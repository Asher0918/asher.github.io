<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/css/main.css?v=7.1.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2"><link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.1.2",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script src="https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts.common.min.js"></script><meta name="description" content="Redis命令Redis 命令用于在 redis 服务上执行操作。要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。语法Redis 客户端的基本语法为：1$ redis-cli实例以下实例讲解了如何启动 redis 客户端：启动 redis 客户端，打开终端并输入命令 redis-cli。该命令会连接本地的 redis 服务"><meta name="keywords" content="Redis命令"><meta property="og:type" content="article"><meta property="og:title" content="Redis命令1"><meta property="og:url" content="https://muhouer.github.io/posts/e45303ba/index.html"><meta property="og:site_name" content="Muhouer"><meta property="og:description" content="Redis命令Redis 命令用于在 redis 服务上执行操作。要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。语法Redis 客户端的基本语法为：1$ redis-cli实例以下实例讲解了如何启动 redis 客户端：启动 redis 客户端，打开终端并输入命令 redis-cli。该命令会连接本地的 redis 服务"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2019-08-02T15:26:55.061Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Redis命令1"><meta name="twitter:description" content="Redis命令Redis 命令用于在 redis 服务上执行操作。要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。语法Redis 客户端的基本语法为：1$ redis-cli实例以下实例讲解了如何启动 redis 客户端：启动 redis 客户端，打开终端并输入命令 redis-cli。该命令会连接本地的 redis 服务"><link rel="alternate" href="/atom.xml" title="Muhouer" type="application/atom+xml"><link rel="canonical" href="https://muhouer.github.io/posts/e45303ba/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>Redis命令1 | Muhouer</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Muhouer</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">就是做个记录，先来5分钟的！</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益 404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://muhouer.github.io/posts/e45303ba/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Muhouer"><meta itemprop="description" content="斯人若彩红，遇上方知有有木有。"><meta itemprop="image" content="/images/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Muhouer"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Redis命令1</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-30 22:29:00" itemprop="dateCreated datePublished" datetime="2019-07-30T22:29:00+08:00">2019-07-30</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-08-02 23:26:55" itemprop="dateModified" datetime="2019-08-02T23:26:55+08:00">2019-08-02</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数： <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">21k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">19 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><p>Redis 命令用于在 redis 服务上执行操作。</p><p>要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Redis 客户端的基本语法为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli</span></span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例讲解了如何启动 redis 客户端：</p><p>启动 redis 客户端，打开终端并输入命令 <strong>redis-cli</strong>。该命令会连接本地的 redis 服务。连接到本地的 redis 服务并执行 <strong>PING</strong> 命令，该命令用于检测 redis 服务是否启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><hr><h2 id="在远程服务上执行命令"><a href="#在远程服务上执行命令" class="headerlink" title="在远程服务上执行命令"></a>在远程服务上执行命令</h2><p>如果需要在远程 <code>Redis</code> 服务上执行命令，同样我们使用的也是 <strong><code>redis-cli</code></strong> 命令。和上面实例类似，上述命令执行的是默认参数，<code>host</code> 为 <code>127.0.0.1</code> ，<code>port</code>为 <code>6379</code>， 无需密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6379 -a <span class="string">"mypass"</span></span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h host -p port -a password</span></span><br></pre></td></tr></table></figure><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6379 -a <span class="string">"mypass"</span></span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h2 id="Redis-键-key-相关命令"><a href="#Redis-键-key-相关命令" class="headerlink" title="Redis 键(key)相关命令"></a>Redis 键(key)相关命令</h2><p>Redis 键命令用于管理 redis 的键。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>Redis 键命令的基本语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># del 是一个命令， name 是一个键。如果键被删除成功，命令执行后输出 (integer) 1，否则将输出 (integer) 0</span></span></span><br><span class="line">127.0.0.1:6379&gt; set name redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; del name  </span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h3 id="Redis键相关的基本命令"><a href="#Redis键相关的基本命令" class="headerlink" title="Redis键相关的基本命令"></a>Redis键相关的基本命令</h3><table><thead><tr><th>命令</th><th>描述</th><th>可用版本</th></tr></thead><tbody><tr><td><code>del key</code></td><td>该命令用于在 key 存在时删除 key。返回被删除 key 的数量</td><td>&gt;= 1.0.0</td></tr><tr><td><code>dump key</code></td><td>该命令用于序列化给定 key 。如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。</td><td>&gt;= 2.6.0</td></tr><tr><td><code>exists key</code></td><td>该命令用于检查给定 key 是否存在。若 key 存在返回 1 ，否则返回 0 。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>expire key seconds</code></td><td>1. 该命令用于设置 key 的过期时间，key 过期后将不再可用。单位以秒计。设置成功返回 1 。 当 key 不存在或者不能为 key 设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的过期时间)返回 0 。在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 <code>key</code> 会导致整个 <code>key</code> 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。<br>2. 在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 <code>key</code> 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>pexpire key milliseconds</code></td><td>该命令和 <code>expire</code> 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间。</td><td>&gt;= 2.6.0</td></tr><tr><td><code>expireat key timestamp</code></td><td>该命令用于以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间，单位以秒计。key 过期后将不再可用。设置成功返回 1 。当 key 不存在或者不能为 key 设置过期时间时返回 0 。</td><td>&gt;= 1.2.0</td></tr><tr><td><code>pexpireat key milliseconds-timestamp</code></td><td>该命令和<code>expireat</code>命令类似，但它以毫秒为单位设置 <code>key</code> 的过期 unix 时间戳。</td><td>&gt;= 2.6.0</td></tr><tr><td><code>keys pattern</code></td><td>1. 该命令用于查找所有符合给定模式 <code>pattern</code> 的 <code>key</code>。时间复杂度：O(N)， <code>N</code> 为数据库中 <code>key</code> 的数量。返回符合给定模式的 <code>key</code> 列表。<br>2. <code>keys</code>的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 <code>key</code> ，你最好还是用 Redis 的集合结构(set)来代替。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>move key db</code></td><td>1. 该命令用于将当前数据库的 <code>key</code> 移动到给定的数据库 <code>db</code> 当中。时间复杂度：O(1)。移动成功返回 1 ，失败则返回 0 。<br>2. 如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 <code>key</code> ，或者 <code>key</code> 不存在于当前数据库，那么 <code>MOVE</code> 没有任何效果。因此，也可以利用这一特性，将 <code>move</code>当作锁(locking)原语(primitive)。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>persist key</code></td><td>该命令用于移除给定 <code>key</code> 的生存时间，将这个 <code>key</code> 从『易失的』(带生存时间 <code>key</code> )转换成『持久的』(一个不带生存时间、永不过期的 <code>key</code> )。时间复杂度：O(1)。当生存时间移除成功时，返回 1 .如果 key 不存在或 key 没有设置生存时间，返回 0 。</td><td>&gt;= 2.2.0</td></tr><tr><td><code>ttl key</code></td><td>1. 该命令以秒为单位返回 key 的剩余过期时间。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。时间复杂度：O(1)<br>2. 在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>pttl key</code></td><td>1. 该命令以毫秒为单位返回 key 的剩余过期时间。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。时间复杂度：O(1)<br>2. 在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</td><td>&gt;= 2.6.0</td></tr><tr><td><code>randomkey</code></td><td>该命令从当前数据库中随机返回(不删除)一个 <code>key</code> 。时间复杂度：O(1)。当数据库不为空时，返回一个 key 。当数据库为空时，返回 nil 。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>rename key newkey</code></td><td>将 <code>key</code> 改名为 <code>newkey</code> 。时间复杂度：O(1)。改名成功时提示 OK ，当 <code>key</code> 和 <code>newkey</code> 相同，或者 <code>key</code> 不存在时，返回一个错误。当 <code>newkey</code> 已经存在时， <code>raname</code>命令将覆盖旧值。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>renamenx key newkey</code></td><td>将 <code>key</code> 改名为 <code>newkey</code> 。时间复杂度：O(1)。当且仅当 <code>newkey</code> 不存在时，将 <code>key</code> 改名为 <code>newkey</code> 。修改成功时，返回 1 。当 <code>newkey</code> 存在时，返回 0 。当 <code>key</code> 不存在时，返回一个错误。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>type key</code></td><td>返回 <code>key</code> 所储存的值的类型。时间复杂度：O(1)。none (key不存在)string (字符串)list (列表)set (集合)zset (有序集)hash (哈希表)</td><td>&gt;= 1.0.0</td></tr></tbody></table><h3 id="Redis键相关的其他命令"><a href="#Redis键相关的其他命令" class="headerlink" title="Redis键相关的其他命令"></a>Redis键相关的其他命令</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><p><code>sort key [by pattern] [limit offset count] [get pattern [get pattern ...]] [asc | desc] [alpha] [store destination]</code></p><p>返回或保存给定列表、集合、有序集合 key 中经过排序的元素。排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</p><h5 id="一般-SORT-用法"><a href="#一般-SORT-用法" class="headerlink" title="一般 SORT 用法"></a>一般 SORT 用法</h5><p>最简单的 SORT 使用方法是 SORT key 和 SORT key DESC ：</p><ol><li><code>sort key</code> 返回键值从小到大排序的结果。</li><li><code>sort key desc</code> 返回键值从大到小排序的结果。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush cost 20 18 35 9.3 18</span><br><span class="line">(integer) 5</span><br><span class="line"># 排序</span><br><span class="line">127.0.0.1:6379&gt; sort cost</span><br><span class="line">1) &quot;9.3&quot;</span><br><span class="line">2) &quot;18&quot;</span><br><span class="line">3) &quot;18&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;35&quot;</span><br><span class="line"># 逆序排序</span><br><span class="line">127.0.0.1:6379&gt; sort cost desc </span><br><span class="line">1) &quot;35&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;18&quot;</span><br><span class="line">4) &quot;18&quot;</span><br><span class="line">5) &quot;9.3&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="使用外部-key-进行排序"><a href="#使用外部-key-进行排序" class="headerlink" title="使用外部 key 进行排序"></a>使用外部 key 进行排序</h5><p>可以使用外部 key 的数据作为权重，代替默认的直接对比键值的方式来进行排序。<br>假设现在有用户数据如下：</p><table><thead><tr><th align="left">uid</th><th align="left">user_name_{uid}</th><th align="left">user_level_{uid}</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">admin</td><td align="left">9999</td></tr><tr><td align="left">2</td><td align="left">jack</td><td align="left">10</td></tr><tr><td align="left">3</td><td align="left">peter</td><td align="left">25</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush uid 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; set user_name_1 admin</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set user_level_1 9999</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lpush uid 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; set user_name_2 jack</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set user_level_2 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lpush uid 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; set user_name_3 peter</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set user_level_3 25</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; sort uid by user_level_*</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>默认情况下， SORT uid 直接按 uid 中的值排序，通过使用 BY 选项，可以让 uid 按其他键的元素来排序。</p><p>user_level_* 是一个占位符， 它先取出 uid 中的值， 然后再用这个值来查找相应的键。</p><p>比如在对 uid 列表进行排序时， 程序就会先取出 uid 的值 1 、 2 、 3 ， 然后使用 user_level_1 、 user_level_2 、 user_level_3的值作为排序 uid 的权重。</p><h5 id="get-选项"><a href="#get-选项" class="headerlink" title="get 选项"></a>get 选项</h5><p>使用<code>get</code>选项， 可以根据排序的结果来取出相应的键值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort uid get user_name_*</span><br><span class="line">1) &quot;admin&quot;</span><br><span class="line">2) &quot;jack&quot;</span><br><span class="line">3) &quot;peter&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="组合使用-by-和-get"><a href="#组合使用-by-和-get" class="headerlink" title="组合使用 by 和 get"></a>组合使用 by 和 get</h5><p>通过组合使用<code>by</code>和<code>get</code>， 可以让排序结果以更直观的方式显示出来。</p><p>比如说， 以下代码先按 user_level_{uid} 来排序 uid 列表， 再取出相应的 user_name_{uid} 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort uid by user_level_* get user_name_*</span><br><span class="line">1) &quot;jack&quot;  </span><br><span class="line">2) &quot;peter&quot; </span><br><span class="line">3) &quot;mary&quot;</span><br></pre></td></tr></table></figure><h5 id="获取多个外部键"><a href="#获取多个外部键" class="headerlink" title="获取多个外部键"></a>获取多个外部键</h5><p>可以同时使用多个<code>get</code>选项， 获取多个外部键的值。<code>get</code>有一个额外的参数规则——可以用 # 获取被排序键的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort uid get # get user_level_* get user_name_*</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;9999&quot;</span><br><span class="line">3) &quot;admin&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;10&quot;</span><br><span class="line">6) &quot;jack&quot;</span><br><span class="line">7) &quot;3&quot;</span><br><span class="line">8) &quot;25&quot;</span><br><span class="line">9) &quot;peter&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="获取外部键，但不进行排序"><a href="#获取外部键，但不进行排序" class="headerlink" title="获取外部键，但不进行排序"></a>获取外部键，但不进行排序</h5><p>通过将一个不存在的键作为参数传给<code>by</code>选项， 可以让<code>sort</code>跳过排序操作， 直接返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort uid by not-exists-key</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;1&quot;</span><br></pre></td></tr></table></figure><p>这种用法在单独使用时，没什么实际用处。<br>不过，通过将这种用法和<code>get</code>选项配合， 就可以在不排序的情况下， 获取多个外部键， 相当于执行一个整合的获取操作（类似于 SQL 数据库的 join 关键字）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort uid by not-exists-key get # get user_level_* get user_name_*</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;25&quot;</span><br><span class="line">3) &quot;peter&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;10&quot;</span><br><span class="line">6) &quot;jack&quot;</span><br><span class="line">7) &quot;1&quot;</span><br><span class="line">8) &quot;9999&quot;</span><br><span class="line">9) &quot;admin&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="保存排序结果"><a href="#保存排序结果" class="headerlink" title="保存排序结果"></a>保存排序结果</h5><p>默认情况下， <code>sort</code>操作只是简单地返回排序结果，并不进行任何保存操作。<br>通过给<code>store</code>选项指定一个 key 参数，可以将排序结果保存到给定的键上。<br>如果被指定的 key 已存在，那么原有的值将被排序结果覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush numbers 1 3 5 7 9</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; rpush numbers 2 4 6 8 10</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line"> 1) &quot;1&quot;</span><br><span class="line"> 2) &quot;3&quot;</span><br><span class="line"> 3) &quot;5&quot;</span><br><span class="line"> 4) &quot;7&quot;</span><br><span class="line"> 5) &quot;9&quot;</span><br><span class="line"> 6) &quot;2&quot;</span><br><span class="line"> 7) &quot;4&quot;</span><br><span class="line"> 8) &quot;6&quot;</span><br><span class="line"> 9) &quot;8&quot;</span><br><span class="line">10) &quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt; sort numbers store sorted-numbers</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; lrange sorted-numbers 0 -1</span><br><span class="line"> 1) &quot;1&quot;</span><br><span class="line"> 2) &quot;2&quot;</span><br><span class="line"> 3) &quot;3&quot;</span><br><span class="line"> 4) &quot;4&quot;</span><br><span class="line"> 5) &quot;5&quot;</span><br><span class="line"> 6) &quot;6&quot;</span><br><span class="line"> 7) &quot;7&quot;</span><br><span class="line"> 8) &quot;8&quot;</span><br><span class="line"> 9) &quot;9&quot;</span><br><span class="line">10) &quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>可以通过将<code>sort</code>命令的执行结果保存，并用<code>expire</code>为结果设置生存时间，以此来产生一个<code>sort</code>操作的结果缓存。</p><p>这样就可以避免对<code>sort</code>操作的频繁调用：只有当结果集过期时，才需要再调用一次<code>sort</code>操作。</p><p>另外，为了正确实现这一用法，你可能<strong>需要加锁以避免多个客户端同时进行缓存重建</strong>(也就是多个客户端，同一时间进行<code>sort</code>操作，并保存为结果集)，具体参见<code>setnx</code>命令。</p><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p><code>object subcommand [arguments [arguments]]</code></p><p><code>object</code>命令允许从内部察看给定<code>key</code>的 Redis 对象。</p><p>它通常用在除错(debugging)或者了解为了节省空间而对 key 使用特殊编码的情况。<br>当将Redis用作缓存程序时，你也可以通过 OBJECT 命令中的信息，决定 key 的驱逐策略(eviction policies)。</p><p>可用版本：&gt;= 2.2.3 ，时间复杂度：O(1)。</p><h5 id="object-命令子命令"><a href="#object-命令子命令" class="headerlink" title="object 命令子命令"></a>object 命令子命令</h5><ol><li><code>object refcount key</code> 返回给定 key 引用所储存的值的次数。此命令主要用于除错。</li><li><code>object encoding key</code> 返回给定 key 锁储存的值所使用的内部表示(representation)。</li><li><code>object idletime key</code> 返回给定 key 自储存以来的空转时间(idle， 没有被读取也没有被写入)，以秒为单位。</li></ol><h5 id="对象编码方式："><a href="#对象编码方式：" class="headerlink" title="对象编码方式："></a>对象编码方式：</h5><ol><li>字符串可以被编码为<code>raw</code>(一般字符串)、<code>embstr</code>或<code>int</code>(用字符串表示64位数字是为了节约空间)。</li><li>列表可以被编码为<code>ziplist</code>或<code>linkedlist</code>。 <code>ziplist</code>是为节约大小较小的列表空间而作的特殊表示。</li><li>集合可以被编码为<code>intset</code>或者<code>hashtable</code>。 <code>intset</code>是只储存数字的小集合的特殊表示。</li><li>哈希表可以编码为<code>zipmap</code>或者<code>hashtable</code> 。 <code>zipmap</code>是小哈希表的特殊表示。<br>有序集合可以被编码为 ziplist 或者 skiplist 格式。 ziplist 用于表示小的有序集合，而 skiplist 则用于表示任何大小的有序集合。</li></ol><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name &quot;redis&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object refcount name </span><br><span class="line">(integer) 1 # 只有一个引用</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; object idletime name</span><br><span class="line">(integer) 104 # 等待一阵，然后查看空转时间</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; object idletime name</span><br><span class="line">(integer) 1 # get之后立即查空转时间</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line">&quot;embstr&quot; # 对象编码方式</span><br><span class="line">127.0.0.1:6379&gt; set phone 17608882643</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding phone</span><br><span class="line">&quot;int&quot;</span><br><span class="line">127.0.0.1:6379&gt; set phone 9223372036854775808</span><br><span class="line">OK # 大于或等于2的64次方，被编码为字符串</span><br><span class="line">127.0.0.1:6379&gt; object encoding phone</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; set phone 111111111111111111111111111111111111111111111</span><br><span class="line">OK  # 超过44位之后以 raw 编码</span><br><span class="line">127.0.0.1:6379&gt; object encoding phone</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure><p>具体为什么是44而不是其他数字，原因可参考<br><a href="https://www.zhihu.com/question/25624589" target="_blank" rel="noopener">为什么redis小等于39字节的字符串是embstr编码，大于39是raw编码？</a> 44和39只是因为版本支持不同，github修改记录可参考<a href="https://github.com/antirez/redis/commit/f15df8ba5db09bdf4be58c53930799d82120cc34#diff-43278b647ec38f9faf284496e22a97d5" target="_blank" rel="noopener">commit</a></p><h4 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h4><p><code>restore key ttl serialized-value</code></p><p>反序列化给定的序列化值，并将它和给定的<code>key</code>关联。与<code>dump</code>相对应。可用版本：&gt;= 2.6.0</p><p>参数<code>ttl</code>以毫秒为单位为<code>key</code>设置生存时间；如果<code>ttl</code>为 0 ，那么不设置生存时间。</p><p><code>restore</code>在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么<code>restore</code>会拒绝进行反序列化，并返回一个错误。</p><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ol><li>查找给定键的复杂度为 O(1) ，对键进行反序列化的复杂度为 O(N*M) ，其中 N 是构成 key 的 Redis 对象的数量，而 M 则是这些对象的平均大小。</li><li>有序集合(sorted set)的反序列化复杂度为 O(N<em>M</em>log(N)) ，因为有序集合每次插入的复杂度为 O(log(N)) 。</li><li>如果反序列化的对象是比较小的字符串，那么复杂度为 O(1) 。</li></ol><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set hi "Hello, World!"</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; dump hi  # 序列化</span><br><span class="line">"\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; restore hi 0 "\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR"  # 反序列化时key已存在</span><br><span class="line">(error) BUSYKEY Target key name already exists.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; restore hi-restore 0 "\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR" # 反序列化</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; restore fake-hi 0 "hello blablabla" # 使用错误的值进行反序列化</span><br><span class="line">(error) ERR DUMP payload version or checksum are wrong</span><br></pre></td></tr></table></figure><h4 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h4><p><code>migrate host port key destination-db timeout [copy] [replace]</code></p><p>将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。可用版本：&gt;= 2.6.0。迁移成功时返回 OK ，否则返回相应的错误。</p><p>这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。</p><h5 id="可选项："><a href="#可选项：" class="headerlink" title="可选项："></a>可选项：</h5><ol><li><code>copy</code> ：不移除源实例上的 key 。</li><li><code>replace</code> ：替换目标实例上已存在的 key 。</li></ol><h5 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h5><p>它在当前实例对给定 key 执行<code>dump</code>命令 ，将它序列化，然后传送到目标实例，目标实例再使用<code>restore</code>对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到<code>restore</code>命令返回 OK ，它就会调用<code>del</code>删除自己数据库上的 key 。</p><p>timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。</p><p><code>migrate</code>命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。</p><p>当 IOERR 出现时，有以下两种可能：</p><ol><li>key 可能存在于两个实例</li><li>key 可能只存在于当前实例<br>唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。</li></ol><p>如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）。</p><h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>这个命令在源实例上实际执行 DUMP 命令和 DEL 命令，在目标实例执行 RESTORE 命令，查看以上命令的文档可以看到详细的复杂度说明。<br>key 数据在两个实例之间传输的复杂度为 O(N) 。</p><h5 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h5><ol><li>启动两个Redis实例，一个默认 6379 端口，一个 9999 接口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-server --port 9999</span><br><span class="line">80619:C 01 Aug 2019 23:21:22.685 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">80619:C 01 Aug 2019 23:21:22.686 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=80619, just started</span><br><span class="line">80619:C 01 Aug 2019 23:21:22.686 # Configuration loaded</span><br><span class="line">80619:M 01 Aug 2019 23:21:22.687 * Increased maximum number of open files to 10032 (it was originally set to 256).</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &apos;&apos;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &apos;&apos;-._           Redis 5.0.5 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &apos;&apos;-._                                   </span><br><span class="line"> (    &apos;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 9999</span><br><span class="line"> |    `-._   `._    /     _.-&apos;    |     PID: 80619</span><br><span class="line">  `-._    `-._  `-./  _.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line">      `-._    `-.__.-&apos;    _.-&apos;                                       </span><br><span class="line">          `-._        _.-&apos;                                           </span><br><span class="line">              `-.__.-&apos;                                               </span><br><span class="line"></span><br><span class="line">80619:M 01 Aug 2019 23:21:22.691 # Server initialized</span><br><span class="line">80619:M 01 Aug 2019 23:21:22.692 * DB loaded from disk: 0.001 seconds</span><br><span class="line">80619:M 01 Aug 2019 23:21:22.692 * Ready to accept connections</span><br></pre></td></tr></table></figure><ol start="2"><li>用客户端连上 6379 端口的实例，设置一个键，然后将它迁移到 7777 端口的实例上</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set hello "Hello from 6379 instance"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 9999 hello 0 1000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; exists hello </span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 迁移成功后 key 被删除</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用另一个客户端，查看 9999 端口上的实例</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli -p 9999</span><br><span class="line">127.0.0.1:9999&gt; get hello</span><br><span class="line">&quot;Hello from 6379 instance&quot;</span><br></pre></td></tr></table></figure><h4 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h4><p><code>scan cursor [MATCH pattern] [COUNT count]</code></p><p><code>scan</code>命令是一个基于游标的迭代器（cursor based iterator）： <code>scan</code>命令每次被调用之后，都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数，以此来延续之前的迭代过程。当<code>scan</code>命令的游标参数被设置为 0 时，服务器将开始一次新的迭代，而当服务器向用户返回值为 0 的游标时，表示迭代已结束。</p><h5 id="MATCH-选项"><a href="#MATCH-选项" class="headerlink" title="MATCH 选项"></a>MATCH 选项</h5><p>和<code>keys</code>命令一样，增量式迭代命令也可以通过提供一个 glob 风格的模式参数，让命令只返回和给定模式相匹配的元素，这一点可以通过在执行增量式迭代命令时，通过给定 MATCH<pattern>参数来实现。</pattern></p><p><strong>TODO 不是很明白，回头继续</strong></p><h2 id="Redis-字符串-String-相关命令"><a href="#Redis-字符串-String-相关命令" class="headerlink" title="Redis 字符串(String)相关命令"></a>Redis 字符串(String)相关命令</h2><p>Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></figure><h3 id="Redis字符串-String-相关的基本命令"><a href="#Redis字符串-String-相关的基本命令" class="headerlink" title="Redis字符串(String)相关的基本命令"></a>Redis字符串(String)相关的基本命令</h3><table><thead><tr><th>命令</th><th>描述</th><th>时间复杂度</th><th>可用版本</th></tr></thead><tbody><tr><td><code>set key value</code></td><td>1. 将字符串值 <code>value</code> 关联到 <code>key</code> 。如果 <code>key</code> 已经持有其他值， <code>set</code>就覆写旧值，无视类型。对于某个原本带有生存时间（TTL）的键来说， 当<code>set</code>命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。<br>2. 在 Redis 2.6.12 以前版本， <code>set</code> 命令总是返回 OK 。从 Redis 2.6.12 版本开始，<code>set</code> 在设置操作成功完成时，才返回 OK 。如果设置了 <code>NX</code> 或者 <code>XX</code> ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。<br>3. 从 Redis 2.6.12 版本开始， <code>set</code>命令的行为可以通过一系列参数来修改：<code>EX</code>、<code>PX</code>、<code>NX</code>、<code>XX</code> 。<a href="http://doc.redisfans.com/string/set.html" target="_blank" rel="noopener">http://doc.redisfans.com/string/set.html</a></td><td>O(1)</td><td>&gt;= 1.0.0</td></tr><tr><td><code>get key</code></td><td>返回 <code>key</code> 所关联的字符串值。如果 <code>key</code> 不存在那么返回特殊值 <code>nil</code> 。假如 <code>key</code> 储存的值不是字符串类型，返回一个错误，因为<code>get</code>只能用于处理字符串值。</td><td>O(1)</td><td>&gt;= 1.0.0</td></tr><tr><td><code>getrange key start end</code></td><td>返回 <code>key</code> 中字符串值的子字符串，字符串的截取范围由 <code>start</code> 和 <code>end</code> 两个偏移量决定(包括 <code>start</code> 和 <code>end</code> 在内)。负数偏移量表示从字符串最后开始计数， <code>-1</code> 表示最后一个字符， <code>-2</code> 表示倒数第二个，以此类推。<code>getrange</code>通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</td><td>O(N)， N 为要返回的字符串的长度。复杂度最终由字符串的返回值长度决定，但因为从已有字符串中取出子字符串的操作非常廉价(cheap)，所以对于长度不大的字符串，该操作的复杂度也可看作O(1)。</td><td>&gt;= 2.4.0</td></tr><tr><td><code>getset key value</code></td><td>将给定 <code>key</code> 的值设为 <code>value</code> ，并返回 <code>key</code> 的旧值(old value)。当 <code>key</code> 存在但不是字符串类型时，返回一个错误。<code>key</code> 不存在时，返回 <code>nil</code>。</td><td>O(1)</td><td>&gt;= 1.0.0</td></tr><tr><td><code>incr key</code></td><td>1. 将 <code>key</code> 中储存的数字值增一。如果 <code>key</code> 不存在，那么 <code>key</code> 的值会先被初始化为 <code>0</code> ，然后再执行<code>incr</code>操作，返回执行命令之后 <code>key</code> 的值。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br>2. 本操作的值限制在 64 位(bit)有符号数字表示之内。这是一个针对字符串的操作，因为 Redis 没有专用的整数类型，所以 key 内储存的字符串被解释为十进制 64 位有符号整数来执行 <code>incr</code> 操作。<br>3. 限速器与计数器的应用。<br>4. <code>incrby key increment</code>、<code>incrbyfloat key increment</code>、<code>decr key</code>、<code>decrby key decrement</code>命令与之类似。<a href="http://doc.redisfans.com/string/incrbyfloat.html" target="_blank" rel="noopener">http://doc.redisfans.com/string/incrbyfloat.html</a></td><td>O(1)</td><td>&gt;= 1.0.0</td></tr><tr><td><code>getbit key offset</code></td><td>对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位(bit)。当 <code>offset</code> 比字符串值的长度大，或者 <code>key</code> 不存在时，返回 <code>0</code> 。</td><td>O(1)</td><td>&gt;= 2.2.0</td></tr><tr><td><code>setbit key offset value</code></td><td>对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。位的设置或清除取决于 <code>value</code> 参数，可以是 <code>0</code> 也可以是 <code>1</code> 。当 <code>key</code> 不存在时，自动生成一个新的字符串值。字符串会进行伸展(grown)以确保它可以将 <code>value</code> 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 <code>0</code> 填充。<br>2. <code>offset</code> 参数必须大于或等于 <code>0</code> ，小于 2^32 (bit 映射被限制在 512 MB 之内)。对使用大的 <code>offset</code> 的 <code>setbit</code>操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考<code>setrange</code>命令，warning(警告)部分。</td><td>O(1)</td><td>&gt;= 2.2.0</td></tr><tr><td><code>strlen key</code></td><td>返回 <code>key</code> 所储存的字符串值的长度。当 <code>key</code> 不存在时，返回 <code>0</code> 。当 <code>key</code> 储存的不是字符串值时，返回一个错误。</td><td>O(1)</td><td>&gt;= 2.2.0</td></tr><tr><td><code>mget key [key ...]</code></td><td>返回所有(一个或多个)给定 <code>key</code> 的值。如果给定的 <code>key</code> 里面，有某个 <code>key</code> 不存在，那么这个 <code>key</code> 返回特殊值 <code>nil</code> 。因此，该命令永不失败。</td><td>O(N) , N 为给定 key 的数量。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>mset key value [key value ...]</code></td><td>1. 同时设置一个或多个 <code>key-value</code> 对。如果某个给定 <code>key</code> 已经存在，那么<code>mset</code>会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用<code>msetnx</code>命令：它只会在所有给定 <code>key</code> 都不存在的情况下进行设置操作。<br>2. <code>mset</code>是一个原子性(atomic)操作，所有给定 <code>key</code> 都会在同一时间内被设置，某些给定 <code>key</code> 被更新而另一些给定 <code>key</code> 没有改变的情况，不可能发生。总是返回 OK (因为 MSET 不可能失败)</td><td>O(N)， N 为要设置的 key 数量。</td><td>&gt;= 1.0.1</td></tr><tr><td><code>msetnx key value [key value ...]</code></td><td>1. 同时设置一个或多个 <code>key-value</code> 对，当且仅当所有给定 <code>key</code> 都不存在。即使只有一个给定 <code>key</code> 已存在， <code>msetnx</code>也会拒绝执行所有给定 <code>key</code> 的设置操作。当所有 key 都成功设置，返回 1 。如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。<br>2. <code>msetnx</code>是原子性的，因此它可以用作设置多个不同 <code>key</code> 表示不同字段(field)的唯一性逻辑对象(unique logic object)，所有字段要么全被设置，要么全不被设置。</td><td>O(N)， N 为要设置的 key 数量。</td><td>&gt;= 1.0.1</td></tr><tr><td><code>append key value</code></td><td>1. 如果 <code>key</code> 已经存在并且是一个字符串， <code>append</code>命令将 <code>value</code> 追加到 <code>key</code> 原来的值的末尾。如果 <code>key</code> 不存在， <code>append</code>就简单地将给定 <code>key</code> 设为 <code>value</code> ，就像执行 <code>set key value</code> 一样。<br>2. 返回追加 value 之后， key 中字符串的长度。</td><td>平摊O(1)</td><td>&gt;= 2.0.0</td></tr></tbody></table><h3 id="Redis字符串-String-相关的其他命令"><a href="#Redis字符串-String-相关的其他命令" class="headerlink" title="Redis字符串(String)相关的其他命令"></a>Redis字符串(String)相关的其他命令</h3><h4 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h4><p><code>bitcount key [start] [end]</code></p><p>计算给定字符串中，被设置为 1 的比特位的数量。</p><p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的<code>start</code>或 <code>end</code>参数，可以让计数只在特定的位上进行。</p><p><code>start</code>和<code>end</code>参数的设置和<code>getrange</code>命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推。</p><p>不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。</p><p>可用版本：&gt;= 2.6.0，时间复杂度：O(N)</p><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount bits</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bits 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bitcount bits</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setbit bits 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bitcount bits</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="使用-bitmap-实现用户上线次数统计"><a href="#使用-bitmap-实现用户上线次数统计" class="headerlink" title="使用 bitmap 实现用户上线次数统计"></a>使用 bitmap 实现用户上线次数统计</h5><p>Bitmap 对于一些特定类型的计算非常有效。</p><p>假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 SETBIT 和 BITCOUNT 来实现。</p><p>比如说，每当用户在某一天上线的时候，我们就使用 SETBIT ，以用户名作为 key ，将那天所代表的网站的上线日作为 offset 参数，并将这个 offset 上的为设置为 1 。</p><p>举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 SETBIT peter 100 1 ；如果明天 peter 也继续阅览网站，那么执行命令 SETBIT peter 101 1 ，以此类推。</p><p>当要计算 peter 总共以来的上线次数时，就使用 BITCOUNT 命令：执行 BITCOUNT peter ，得出的结果就是 peter 上线的总天数。</p><p>更详细的实现可以参考博文(墙外) Fast, easy, realtime metrics using Redis bitmaps 。</p><p>性能<br>前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， BITCOUNT 的处理速度就像 GET 和 INCR 这种 O(1) 复杂度的操作一样快。</p><p>如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：</p><p>将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。<br>使用 BITCOUNT 的 start 和 end 参数，每次只对所需的部分位进行计算，将位的累积工作(accumulating)放到客户端进行，并且对结果进行缓存 (caching)。</p><p>更详细的实现可以参考博文 <a href="https://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/" target="_blank" rel="noopener">REDIS BITMAPS – FAST, EASY, REALTIME METRICS</a></p><h4 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a>bitop</h4><p><code>bitop operation destkey key [key ...]</code></p><p>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p><p>operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：</p><ol><li><code>bitop add destkey key [key ...]</code> ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。</li><li><code>bitop or destkey key [key ...]</code> ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。</li><li><code>bitop xor destkey key [key ...]</code> ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。</li><li><code>bitop not destkey key</code> ，对给定 key 求逻辑非，并将结果保存到 destkey 。<br>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</li></ol><h5 id="处理不同长度的字符串"><a href="#处理不同长度的字符串" class="headerlink" title="处理不同长度的字符串"></a>处理不同长度的字符串</h5><p>当<code>bitop</code>处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。</p><p>可用版本：&gt;= 2.6.0，时间复杂度：O(N)，返回值：保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</p><p><code>bitop</code> 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。</p><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit bits-1 0 1 # 1001</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setbit bits-1 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bits-2 0 1 # 1011</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bits-2 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bits-2 3 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitop and and-result bits-1 bits-2 # 1001</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit and-result 2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit and-result 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="setrange"><a href="#setrange" class="headerlink" title="setrange"></a>setrange</h4><p><code>setrange key offset value</code></p><p>用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。可用版本：&gt;= 2.2.0。返回被<code>setrange</code>修改之后，字符串的长度。</p><p><code>setrange</code>命令会确保字符串足够长以便将 value 设置在指定的偏移量上，不存在的 key 当作空白字符串处理。如果给定 key 原来储存的字符串长度比偏移量小，那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )来填充。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>你能使用的最大偏移量是 2^29-1(536870911) ，因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内。如果你需要使用比这更大的空间，你可以使用多个 key 。</p><h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>对小(small)的字符串，平摊复杂度O(1)(关于什么字符串是”小”的，请参考 <code>append</code>命令)。否则为O(M)， M 为 value 参数的长度。</p><h5 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ # 对非空字符串进行 setrange</span><br><span class="line">127.0.0.1:6379&gt; set hello &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange hello 6 &quot;Redis&quot;</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;hello Redis&quot;</span><br><span class="line"></span><br><span class="line">$ # 对空字符串/不存在的 key 进行 setrange</span><br><span class="line">127.0.0.1:6379&gt; exists empty_string</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setrange empty_string 5 &quot;Redis!&quot;</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get empty_string </span><br><span class="line">&quot;\x00\x00\x00\x00\x00Redis!&quot;</span><br></pre></td></tr></table></figure><h5 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h5><p>因为有了<code>setrange</code>和<code>getrange</code>命令，你可以将 Redis 字符串用作具有O(1)随机访问时间的线性数组，这在很多真实用例中都是非常快速且高效的储存方式，具体请参考<code>append</code>命令的『模式：时间序列』部分。</p><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p><code>append key value</code></p><p><code>append key value</code>之后，返回 key 中字符串的长度。如果 key 已经存在并且是一个字符串，<code>append</code>命令将 value 追加到 key 原来的值的末尾。如果 key 不存在，<code>append</code>就简单地将给定 key 设为 value ，就像执行 <code>set key value</code> 一样。可用版本：&gt;= 2.0.0。时间复杂度：平摊O(1)。</p><h5 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists money</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; append money &quot;five cent&quot;</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; append money &quot;one dollor&quot;</span><br><span class="line">(integer) 19</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="时间序列-Time-series"><a href="#时间序列-Time-series" class="headerlink" title="时间序列(Time series)"></a>时间序列(Time series)</h5><p><code>append</code>可以为一系列<strong>定长(fixed-size)数据(sample)</strong>提供一种紧凑的表示方式，通常称之为时间序列。</p><p>每当一个新数据到达的时候，执行命令：<code>append timeseries &quot;fixed-size sample&quot;</code></p><p>然后可以通过以下的方式访问时间序列的各项属性：</p><ol><li><code>strlen</code> 给出时间序列中数据的数量</li><li>getrange 可以用于随机访问。只要有相关的时间信息的话，我们就可以在 Redis 2.6 中使用 Lua 脚本和 GETRANGE 命令实现二分查找。</li><li><code>setrange</code> 可以用于覆盖或修改已存在的的时间序列。</li></ol><p>这个模式的唯一缺陷是我们只能增长时间序列，而不能对时间序列进行缩短，因为 Redis 目前还没有对字符串进行修剪(tirm)的命令，但是，不管怎么说，这个模式的储存方式还是可以节省下大量的空间。</p><p>可以考虑使用 UNIX 时间戳作为时间序列的键名，这样一来，可以避免单个 key 因为保存过大的时间序列而占用大量内存，另一方面，也可以节省下大量命名空间。</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><code>set key value [EX seconds] [PX milliseconds] [NX|XX]</code></p><ol><li>将字符串值 value 关联到 key 。如果 key 已经持有其他值， SET 就覆写旧值，无视类型。</li><li>对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。</li></ol><h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</p><ol><li><code>EX second</code> ：设置键的过期时间为 second 秒。 <code>set key value EX second</code> 效果等同于 <code>setex key second value</code> 。</li><li><code>PX millisecond</code> ：设置键的过期时间为 millisecond 毫秒。 <code>set key value PX millisecond</code> 效果等同于 <code>psetex key millisecond value</code> 。</li><li><code>NX</code> ：只在键不存在时，才对键进行设置操作。 <code>set key value NX</code> 效果等同于 <code>setnx key value</code> 。</li><li><code>XX</code> ：只在键已经存在时，才对键进行设置操作。</li></ol><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><ol><li>在 Redis 2.6.12 版本以前， SET 命令总是返回 OK 。</li><li>从 Redis 2.6.12 版本开始， SET 在设置操作成功完成时，才返回 OK 。如果设置了 NX 或者 XX ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。</li></ol><h5 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h5><p>命令 <code>set resource-name anystring NX EX max-lock-time</code> 是一种在 Redis 中实现锁的简单方法。</p><p>客户端执行以上的命令：</p><ol><li>如果服务器返回 OK ，那么这个客户端获得锁。<br>如果服务器返回 NIL ，那么客户端获取锁失败，可以在稍后再重试。</li><li>设置的过期时间到达之后，锁将自动释放。</li></ol><p>可以通过以下修改，让这个锁实现更健壮：</p><p>不使用固定的字符串作为键的值，而是设置一个不可猜测（non-guessable）的长随机字符串，作为口令串（token）。<br>不使用 DEL 命令来释放锁，而是发送一个 Lua 脚本，这个脚本只在客户端传入的值和键的口令串相匹配时，才对键进行删除。<br>这两个改动可以防止持有过期锁的客户端误删现有锁的情况出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1]</span><br><span class="line">then</span><br><span class="line">    return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Redis命令/" rel="tag"># Redis命令</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/2c68463d/" rel="next" title="Redis配置与数据类型"><i class="fa fa-chevron-left"></i> Redis配置与数据类型</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/a9bf165e/" rel="prev" title="拾句-现实">拾句-现实 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="Muhouer"><p class="site-author-name" itemprop="name">Muhouer</p><div class="site-description motion-element" itemprop="description">斯人若彩红，遇上方知有有木有。</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a rel="external nofollow" href="/archives/"><span class="site-state-item-count">59</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a rel="external nofollow" href="/categories/"><span class="site-state-item-count">29</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a rel="external nofollow" href="/tags/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a rel="external nofollow" href="/atom.xml"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/muhouer" title="GitHub &rarr; https://github.com/muhouer" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:muhouer@gmail.com" title="E-Mail &rarr; mailto:muhouer@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://bl.ocks.org/mbostock/3711652" title="https://bl.ocks.org/mbostock/3711652" rel="noopener" target="_blank">世界地图投影</a></li><li class="links-of-blogroll-item"><a href="http://www.chuangzaoshi.com/code" title="http://www.chuangzaoshi.com/code" rel="noopener" target="_blank">创造狮导航</a></li><li class="links-of-blogroll-item"><a href="https://hoxis.github.io/" title="https://hoxis.github.io/" rel="noopener" target="_blank">hoxis's blog</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis命令"><span class="nav-number">1.</span> <span class="nav-text">Redis命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法"><span class="nav-number">1.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">1.2.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在远程服务上执行命令"><span class="nav-number">2.</span> <span class="nav-text">在远程服务上执行命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-1"><span class="nav-number">2.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语法-1"><span class="nav-number">2.2.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-2"><span class="nav-number">2.3.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-键-key-相关命令"><span class="nav-number">3.</span> <span class="nav-text">Redis 键(key)相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法-2"><span class="nav-number">3.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-3"><span class="nav-number">3.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis键相关的基本命令"><span class="nav-number">3.3.</span> <span class="nav-text">Redis键相关的基本命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis键相关的其他命令"><span class="nav-number">3.4.</span> <span class="nav-text">Redis键相关的其他命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sort"><span class="nav-number">3.4.1.</span> <span class="nav-text">sort</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#语法-3"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一般-SORT-用法"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">一般 SORT 用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用外部-key-进行排序"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">使用外部 key 进行排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#get-选项"><span class="nav-number">3.4.1.4.</span> <span class="nav-text">get 选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#组合使用-by-和-get"><span class="nav-number">3.4.1.5.</span> <span class="nav-text">组合使用 by 和 get</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取多个外部键"><span class="nav-number">3.4.1.6.</span> <span class="nav-text">获取多个外部键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取外部键，但不进行排序"><span class="nav-number">3.4.1.7.</span> <span class="nav-text">获取外部键，但不进行排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#保存排序结果"><span class="nav-number">3.4.1.8.</span> <span class="nav-text">保存排序结果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#object"><span class="nav-number">3.4.2.</span> <span class="nav-text">object</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#object-命令子命令"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">object 命令子命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对象编码方式："><span class="nav-number">3.4.2.2.</span> <span class="nav-text">对象编码方式：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#示例"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#restore"><span class="nav-number">3.4.3.</span> <span class="nav-text">restore</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#时间复杂度"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#示例-1"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#migrate"><span class="nav-number">3.4.4.</span> <span class="nav-text">migrate</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#可选项："><span class="nav-number">3.4.4.1.</span> <span class="nav-text">可选项：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内部实现"><span class="nav-number">3.4.4.2.</span> <span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#时间复杂度："><span class="nav-number">3.4.4.3.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实例-4"><span class="nav-number">3.4.4.4.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scan"><span class="nav-number">3.4.5.</span> <span class="nav-text">scan</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MATCH-选项"><span class="nav-number">3.4.5.1.</span> <span class="nav-text">MATCH 选项</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-字符串-String-相关命令"><span class="nav-number">4.</span> <span class="nav-text">Redis 字符串(String)相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法-4"><span class="nav-number">4.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-5"><span class="nav-number">4.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis字符串-String-相关的基本命令"><span class="nav-number">4.3.</span> <span class="nav-text">Redis字符串(String)相关的基本命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis字符串-String-相关的其他命令"><span class="nav-number">4.4.</span> <span class="nav-text">Redis字符串(String)相关的其他命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bitcount"><span class="nav-number">4.4.1.</span> <span class="nav-text">bitcount</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#示例-2"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-bitmap-实现用户上线次数统计"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">使用 bitmap 实现用户上线次数统计</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bitop"><span class="nav-number">4.4.2.</span> <span class="nav-text">bitop</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#处理不同长度的字符串"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">处理不同长度的字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#示例-3"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setrange"><span class="nav-number">4.4.3.</span> <span class="nav-text">setrange</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#注意"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#时间复杂度：-1"><span class="nav-number">4.4.3.2.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实例-6"><span class="nav-number">4.4.3.3.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#模式"><span class="nav-number">4.4.3.4.</span> <span class="nav-text">模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#append"><span class="nav-number">4.4.4.</span> <span class="nav-text">append</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实例-7"><span class="nav-number">4.4.4.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#时间序列-Time-series"><span class="nav-number">4.4.4.2.</span> <span class="nav-text">时间序列(Time series)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set"><span class="nav-number">4.4.5.</span> <span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#可选参数"><span class="nav-number">4.4.5.1.</span> <span class="nav-text">可选参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#返回值"><span class="nav-number">4.4.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用模式"><span class="nav-number">4.4.5.3.</span> <span class="nav-text">使用模式</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><span id="sitetime"></span><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),a=o.getMonth()+1,n=o.getDate(),r=o.getHours(),l=o.getMinutes(),s=o.getSeconds(),M=Date.UTC(2019,6,25,9,0,0),g=Date.UTC(i,a,n,r,l,s)-M,m=Math.floor(g/31536e6),T=Math.floor(g/t-365*m),f=Math.floor((g-(365*m+T)*t)/e),h=Math.floor((g-(365*m+T)*t-f*e)/6e4),u=Math.floor((g-(365*m+T)*t-f*e-6e4*h)/1e3);document.getElementById("sitetime").innerHTML=" 嗯，我还在！已安全运行"+m+" 年 "+T+" 天 "+f+" 小时 "+h+" 分钟 "+u+" 秒"}siteTime()</script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Muhouer</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">223k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">3:23</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/reading_progress/reading_progress.js"></script><script src="/js/utils.js?v=7.1.2"></script><script src="/js/motion.js?v=7.1.2"></script><script src="/js/affix.js?v=7.1.2"></script><script src="/js/schemes/pisces.js?v=7.1.2"></script><script src="/js/scrollspy.js?v=7.1.2"></script><script src="/js/post-details.js?v=7.1.2"></script><script src="/js/next-boot.js?v=7.1.2"></script><script>// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script src="/lib/bookmark/bookmark.min.js?v=1.0"></script><script>bookmark.scrollToMark("auto","#更多")</script><script type="text/javascript" src="/js/click.js"></script></body></html>
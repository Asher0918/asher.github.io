<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Muhouer</title>
  
  <subtitle>开始记录只需5分钟!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muhouer.github.io/"/>
  <updated>2019-10-07T15:49:35.747Z</updated>
  <id>https://muhouer.github.io/</id>
  
  <author>
    <name>Muhouer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>睡眠Tips</title>
    <link href="https://muhouer.github.io/posts/5257dc18/"/>
    <id>https://muhouer.github.io/posts/5257dc18/</id>
    <published>2019-10-07T15:47:00.000Z</published>
    <updated>2019-10-07T15:49:35.747Z</updated>
    
    <content type="html"><![CDATA[<p>提升睡眠质量的10个小Tips</p><ol><li><p>睡前7小时内避免摄入咖啡因；3小时内避免抽烟或摄入酒精。</p></li><li><p>养成锻炼身体的习惯，但不要在入睡前运动。</p></li><li><p>睡前选择做自己熟悉和喜爱的事情，如看剧、听歌，避免做容易引发焦虑的事。</p></li><li><p>睡前1小时，调暗卧室灯光。智能手机屏幕的蓝光会抑制褪黑素的自然生成。与其吃褪黑素类药物，不如在睡前收起智能手机，或佩戴隔绝蓝光的眼镜。</p></li><li><p>放松和正念冥想可以帮助我们缓解焦虑，让入睡变得更加容易。</p></li><li><p>通过日记或电子追踪器记录睡眠情况；让伴侣帮你注意是否有睡眠呼吸暂停症等睡眠障碍，并及时就医。</p></li><li><p>睡前沐浴有助于缓解疲劳。保证身体清洁以及裸睡更容易让睡眠质量得到提升。</p></li><li><p>了解自己身体如肩颈、腰椎对于枕头、床垫软硬高低的不同需求，提升睡眠硬件舒适度。</p></li><li><p>慎重对待宵夜，睡前不要过度饮食。但也避免在饥饿状态下入睡。可以吃一些温热、易消化类食物。</p></li><li><p>避免睡前打游戏或聊天，使自己过于兴奋。有意识的暗示自己，你需要充足的睡眠，需要尽快入睡。</p></li></ol><p>睡眠的另一个神奇功效是，它其实是抗抑郁的最佳灵药。</p><p><strong>睡眠不足、疲劳会导致一个人判断力低下、缺乏自控力，创造力也会被削弱。更严重的情况是：当一个人因为长期睡眠不足，消耗自控能力时，很可能让他们变得容易经不起诱惑，而做出不道德的事。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提升睡眠质量的10个小Tips&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;睡前7小时内避免摄入咖啡因；3小时内避免抽烟或摄入酒精。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;养成锻炼身体的习惯，但不要在入睡前运动。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;睡前选择做自己熟悉和喜爱的事情，如看剧、听歌，避免做容
      
    
    </summary>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>蔡崇信关于莫雷事件的公开信</title>
    <link href="https://muhouer.github.io/posts/a8a661c9/"/>
    <id>https://muhouer.github.io/posts/a8a661c9/</id>
    <published>2019-10-07T14:01:00.000Z</published>
    <updated>2019-10-09T16:43:10.116Z</updated>
    
    <content type="html"><![CDATA[<p>致所有NBA球迷：</p><p>当我在9月收购篮网股权成为大老板，是真的没想到第一次对球迷发表公开信，是因为这样的政治事件和误解。</p><p>现在你们也知道了，中国球迷对于火箭总经理达雷尔-莫雷支持香港暴乱的推特有多么反感。</p><p>火箭原本是在中国最受欢迎的NBA球队，但现在，已经在中国市场被彻底封杀，失去了球迷的爱和尊重，失去了转播商和赞助商的支持。</p><p>中国球迷需要一个解释——如果火箭不给他们，他们就会找NBA。</p><p>NBA一向把球迷摆在第一位，现在几亿球迷都因此事而愤怒，那NBA圈内的任何人都应该注意起来。作为董事会成员，以及一位在中国创业的华人，我必须发出自己的声音。</p><p>自由表达观点有什么问题？这是美国和NBA倡导的进步派价值观，但问题在于，在一些国家和社会中，很多事情是处于敏感范畴的。</p><p>支持分离主义，在中国就是敏感问题。不仅政府敏感，人民对此也非常敏感。</p><p>被很多西方媒体误会乃至忽视的，是中国14亿人民对于主权领土完整的重视，这一议题是没有商榷余地的。</p><p>这里需要向你们科普一下中国的历史知识。在19世纪中期，英法侵略者向中国输入鸦片，导致两场战争。清王朝战败，香港就此成为英国殖民地。</p><p>因为国土沦丧的耻辱，19世纪末才爆发了农民领导的义和团运动，结果引来八国联军的侵犯，连清王朝首都所在地北平（现在的北京）都被割据。</p><p>1937年，日本侵略中国，占据北京、上海、南京等地，犯下屠杀罪行。等到美国因珍珠港事件参战时，中国人为了抗击侵略者，已经付出了千万条生命。</p><p>我之所以讲这些历史，是希望你们明白为什么中国人民如此警惕外国分裂势力。对于香港问题，中国人民感受到的情绪，就是多年前被侵略者羞辱而产生的愤怒。</p><p>现在我希望你们西方人能理解为什么莫雷激起了如此大的民愤。我个人并不认识莫雷，我知道他作为总经理能力很强，他说自己对香港问题并不是真的了解，我就算他是在道歉了。但他给中国球迷造成的伤害，是需要很长时间才能弥补的。</p><p>我希望能帮助联盟度过莫雷制造的难关，作为董事，我也会继续就中国问题发表自己的见解。我也请求中国的球迷，给NBA一些信心，篮球一定可以让这个世界更团结。</p><p>蔡崇信</p><blockquote><p>蔡老板文采盎然，一针见血。</p><p>作为在NBA有一定话语权，在美国有一定社会地位的他，能够为祖国球迷发声，本身就顶着压力。</p><p>更难能可贵的是，他的发言，很独到的抓住了美国普通人所困惑的点，用美国的方式，给美国人讲了个可以接受的故事。</p><p>曾经的姚明，也做过想同的事情，在融入美国社会后，用美国的方式，对中国进行了宣传，搭起了中美互相了解的桥梁，效果显著。</p></blockquote><blockquote><ol><li><p>言论自由是没错，但“自由”的言论是有红线的，美国人的红线是种族，宗教，性别，堕胎，控枪，中国的红线就是主权完整。这些背负非常大利益的重要人士，在美国会小心翼翼避开这些话题，那对中国来说也一样，红线就是红线，必须避开。</p></li><li><p>对斯特林的歧视言论，联盟迅速反应，禁赛卖球队，因为斯特林触犯了美国的言论红线。对莫雷的不当言论，模棱两可毫无歉意，这不只是双标，这是长久以来的傲慢。</p></li><li><p>言论自由不代表无需负责，不代表说完了就完了，被冒犯的人也有不接受这言论的自由，相应造成的包括经济在内的各种损失，都必须去承担。这就是莫雷最大的问题，他低估了自己的言论，更忽略了自己的身份。</p></li><li><p>肖华目前对内对外都无法交代，因此证明他所谓的公关是极其失败的。事实上，在这件事情上，已经没有办法两全，必须选边站了，像他声明中这样模棱两可，还天真幻想两头讨好，最终和平解决，已经不可能了。</p></li><li><p>这件事情的损失是双方的，对于中国来说，现在已经站在红线上，身后是悬崖，不可能再后退了，有损失就咽了，我相信参与其中的企业都会接受，这个时候，没人会脱队，一定是共进退。对于NBA来说，是他们做选择的时候，如果选择放弃，那就放弃吧。成年人，做了选择就要承担后果，这很正常。</p></li><li><p>虽然莫雷是一只巨大的黑天鹅，但这件事实际都是必然，因为我们已经是美国无法忽视的大国了。中美之间的对抗会在未来一段时间内，从经济层面很快会转向价值观层面，对抗与合作会共存，并且持续下去。我们应该有底气，有智慧，更有自信。</p></li></ol><footer><strong>直布罗陀岩石</strong><cite><a href="https://www.zhihu.com/question/349698023/answer/850400654" target="_blank" rel="noopener">NBA 总裁亚当·萧华针对莫雷事件再发声明，你有什么想说的？</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;致所有NBA球迷：&lt;/p&gt;&lt;p&gt;当我在9月收购篮网股权成为大老板，是真的没想到第一次对球迷发表公开信，是因为这样的政治事件和误解。&lt;/p&gt;&lt;p&gt;现在你们也知道了，中国球迷对于火箭总经理达雷尔-莫雷支持香港暴乱的推特有多么反感。&lt;/p&gt;&lt;p&gt;火箭原本是在中国最受欢迎的NBA球
      
    
    </summary>
    
      <category term="公开信" scheme="https://muhouer.github.io/categories/%E5%85%AC%E5%BC%80%E4%BF%A1/"/>
    
    
      <category term="蔡崇信" scheme="https://muhouer.github.io/tags/%E8%94%A1%E5%B4%87%E4%BF%A1/"/>
    
      <category term="莫雷事件" scheme="https://muhouer.github.io/tags/%E8%8E%AB%E9%9B%B7%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>小故事</title>
    <link href="https://muhouer.github.io/posts/f7d7eea6/"/>
    <id>https://muhouer.github.io/posts/f7d7eea6/</id>
    <published>2019-10-07T09:01:46.000Z</published>
    <updated>2019-10-12T13:30:26.123Z</updated>
    
    <content type="html"><![CDATA[<h3 id="街机游戏"><a href="#街机游戏" class="headerlink" title="街机游戏"></a>街机游戏</h3><p>我有一段时间住青旅，青旅老板买了一台游戏机，就是小时候游戏厅玩的那种街机。我小时候最喜欢玩的是《恐龙快打》，一般玩到第四关的 BOSS那我就 over了。后面有次在街角遇到一个年长我几岁的大哥，也喜欢玩这个。然后他告诉我技巧，就是每一次玩要总结每一个地方哪里会出现什么敌人，你走到哪个位置先打完多少个新的敌人才会出现，你不能一股脑把他们都引出来。后面我玩的时候都有留意这些技巧，所以每次都能一块币通关。</p><h3 id="有哪些事情你坚持了3年以上？"><a href="#有哪些事情你坚持了3年以上？" class="headerlink" title="有哪些事情你坚持了3年以上？"></a>有哪些事情你坚持了3年以上？</h3><p>“听CNN和BBC，坚持了6年以上”；</p><p>“每天练字20分钟，练了4年”；</p><p>“每天出门擦防晒霜，坚持了7年”；<br>……</p><h3 id="骗子"><a href="#骗子" class="headerlink" title="骗子"></a>骗子</h3><p>为什么连骗子都知道人年纪大了会特别注意头发黑不黑，头发掉不掉，然后“对症下药”，我们做儿女的反而注意不到呢？我这才回忆起帮爸妈代买最多的东西还真就是黑发染膏，可是我本人从来没往这方面想过。</p><h3 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h3><p>停止寻求建议，而专注于建设。获得初始启动所需的时间比您想象的要长得多，因此即使进行不顺利，也要长时间的行进。 长期关注对于取得成果至关重要。MailChimp建立了一个惊人的帝国，但是他们已经有17年了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;街机游戏&quot;&gt;&lt;a href=&quot;#街机游戏&quot; class=&quot;headerlink&quot; title=&quot;街机游戏&quot;&gt;&lt;/a&gt;街机游戏&lt;/h3&gt;&lt;p&gt;我有一段时间住青旅，青旅老板买了一台游戏机，就是小时候游戏厅玩的那种街机。我小时候最喜欢玩的是《恐龙快打》，一般玩到第四关的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Executors解析</title>
    <link href="https://muhouer.github.io/posts/ae1d81ea/"/>
    <id>https://muhouer.github.io/posts/ae1d81ea/</id>
    <published>2019-09-25T17:43:02.000Z</published>
    <updated>2019-09-25T17:43:27.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>Exectors</code> 中定义了 <code>Executor</code>、<code>Executorservice</code>、<code>ScheduledExecutorService</code>、<code>ThreadFactory</code>和<code>Callable</code>类的工厂和实用方法，提供了大量创建连接池的静态方法。<code>Exectors</code> 支持以下方法：</p><ol><li>创建并返回一个带有常用配置设置的 <code>Executorservice</code> 。</li><li>创建并返回一个带有常用配置设置的 <code>ScheduledExecutorService</code> 。</li><li>创建并返回一个包装过的 <code>Executorservice</code> ，通过使实现特定的方法不可访问，来禁用重新配置。</li><li>创建并返回一个 <code>ThreadFactory</code> ，将新创建的线程设置为已知状态。</li><li>从其他类似闭包的窗体中创建并返回 <code>Callable</code> ，因此可以在需要 Callable 的执行方法中使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造器私有化，只能通过类去直接调用静态方法,而不允许创建类的实例对象。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Executors</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p><code>ThreadPoolExecutor</code> 继承自 <code>AbstractExecutorService</code> 抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>corePoolSize：核心线程数</p></li><li><p>maxmumPoolSize：池中允许的最大线程数</p></li><li><p>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止</p></li><li><p>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS; <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS; <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES; <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS; <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS; <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS; <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS; <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure></li><li><p>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue <span class="comment">// 采用数组实现的有界阻塞线程安全队列</span></span><br><span class="line">LinkedBlockingQueue <span class="comment">// 通过单向链表实现的无界缓存阻塞队列</span></span><br><span class="line">SynchronousQueue <span class="comment">// 无缓冲等待队列，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。</span></span><br></pre></td></tr></table></figure></li><li><p>threadFactory：创建新线程的工厂。</p></li><li><p>handler：拒绝策略，当线程池的任务缓存队列已满并且线程池中的线程数目达到 maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy <span class="comment">//丢弃任务并抛出RejectedExecutionException异常。</span></span><br><span class="line">ThreadPoolExecutor.DiscardPolicy <span class="comment">//也是丢弃任务，但是不抛出异常。</span></span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy <span class="comment">//丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span></span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy <span class="comment">//由调用线程处理该任务</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="创建固定大小的线程池"><a href="#创建固定大小的线程池" class="headerlink" title="创建固定大小的线程池"></a>创建固定大小的线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 创建一个固定大小的线程池，以共享的无界队列方式来运行这些线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心池的大小和池中允许的最大线程数均为nThreads</span></span><br><span class="line">    <span class="comment">// 线程没有任务执行时会不会终止</span></span><br><span class="line">    <span class="comment">// 线程排队采用的是LinkedBlockingQueue</span></span><br><span class="line">    <span class="comment">// 使用默认的线程工厂创建新线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建一个固定大小的线程池，以共享的无界队列方式来运行这些线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//和上面相比，需要指定 ThreadFactory，在需要时使用提供的 ThreadFactory 创建新线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建一个单个线程的线程池，以无界队列方式来运行该线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用默认的线程工厂创建新线程</span></span><br><span class="line">    <span class="comment">// 和 Executors.newFixedThreadPool(1) 差不多的效果。</span></span><br><span class="line">    <span class="comment">// 不一样的是newSingleThreadExecutor创建的线程池被一个FinalizableDelegatedExecutorService包装了一下</span></span><br><span class="line">    <span class="comment">// FinalizableDelegatedExecutorService 继承了DelegatedExecutorService类并增加了一个finalize方法，finalize方法会在虚拟机利用垃圾回收清理对象时被调用。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建一个单个线程的线程池，以无界队列方式来运行该线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 和上面相比，需要指定 ThreadFactory，在需要时使用提供的 ThreadFactory 创建新线</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建可按需自动扩容的线程池"><a href="#创建可按需自动扩容的线程池" class="headerlink" title="创建可按需自动扩容的线程池"></a>创建可按需自动扩容的线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 创建一个可按需自动扩容的线程池，但优先重用线程池中空闲可用的线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止并从缓存中移除那些已有 60 秒钟未被使用的线程</span></span><br><span class="line">    <span class="comment">// 采用SynchronousQueue</span></span><br><span class="line">    <span class="comment">// 使用默认的线程工厂创建新线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建一个可按需自动扩容的线程池，但优先重用线程池中空闲可用的线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 和上面相比，需要指定 ThreadFactory，在需要时使用提供的 ThreadFactory 创建新线</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建定延时后执行异步任务或者周期性执行任务的线程池"><a href="#创建定延时后执行异步任务或者周期性执行任务的线程池" class="headerlink" title="创建定延时后执行异步任务或者周期性执行任务的线程池"></a>创建定延时后执行异步任务或者周期性执行任务的线程池</h3><p><code>DelegatedScheduledExecutorService</code> 是 <code>ScheduledExecutorService</code> 的包装类，只向外暴露 <code>ScheduledExecutorService</code> 实现的 “schedule” 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ScheduledThreadPoolExecutor</code> 继承 <code>ThreadPoolExecutor</code> 实现 <code>ScheduledExecutorService</code> 接口，最终调用的还是 <code>ThreadPoolExecutor</code> 的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 创建一个单线程执行程序，它可安排在给定延迟后执行或者定期地执行 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程排队采用的是DelayedWorkQueue</span></span><br><span class="line">    <span class="comment">// 核心线程数为1</span></span><br><span class="line">    <span class="comment">// 池中允许的最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="comment">// 使用默认的线程工厂创建新线程</span></span><br><span class="line">    <span class="comment">// 线程没有任务执行时会不会终止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建一个单线程执行程序，它可安排在给定延迟后执行或者定期地执行 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程排队采用的是DelayedWorkQueue</span></span><br><span class="line">    <span class="comment">// 核心线程数为1</span></span><br><span class="line">    <span class="comment">// 池中允许的最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="comment">// 使用指定的线程工厂创建新线程</span></span><br><span class="line">    <span class="comment">// 线程没有任务执行时会不会终止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService(<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建一个在一定延迟时间后调度命令的线程池，或者周期性执行的线程池 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程排队采用的是DelayedWorkQueue</span></span><br><span class="line">    <span class="comment">// 核心线程数为corePoolSize</span></span><br><span class="line">    <span class="comment">// 池中允许的最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="comment">// 使用默认的线程工厂创建新线程</span></span><br><span class="line">    <span class="comment">// 线程没有任务执行时不会终止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建一个在一定延迟时间后调度命令的线程池，或者周期性执行的线程池 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程排队采用的是DelayedWorkQueue</span></span><br><span class="line">    <span class="comment">// 核心线程数为corePoolSize</span></span><br><span class="line">    <span class="comment">// 池中允许的最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="comment">// 使用指定的线程工厂创建新线程</span></span><br><span class="line">    <span class="comment">// 线程没有任务执行时会不会终止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建工作窃取的线程池"><a href="#创建工作窃取的线程池" class="headerlink" title="创建工作窃取的线程池"></a>创建工作窃取的线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>parallelism：并行度，默认情况下跟我们机器的cpu个数保持一致，使用 <code>Runtime.getRuntime().availableProcessors()</code>可以得到我们机器运行时可用的CPU个数。</li><li>factory：创建新线程的工厂。默认情况下使用 <code>ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory</code>。</li><li>handler：线程异常情况下的处理器，该处理器在线程执行任务时由于某些无法预料到的错误而导致任务线程中断时进行一些处理，默认情况为 null。</li><li>asyncMode：这个参数要注意，在 <code>ForkJoinPool</code> 中，每一个工作线程都有一个独立的任务队列，<strong>asyncMode 表示工作线程内的任务队列是采用何种方式进行调度，可以是先进先出FIFO，也可以是后进先出LIFO。如果为true，则线程池中的工作线程则使用先进先出方式进行任务调度，默认情况下是false。工作线程在处理本地任务时使用 FIFO 顺序</strong>。这种模式下的 <code>ForkJoinPool</code> 更接近于是一个消息队列，而不是用来处理递归式的任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 利用所有运行的处理器数目来创建一个工作窃取的线程池 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 采用默认的 ForkJoinWorkerThreadFactory 来创建新线程</span></span><br><span class="line">    <span class="comment">// 并行度为 Java虚拟机可用的处理器数量。</span></span><br><span class="line">    <span class="comment">// 采用 FIFO_QUEUE</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(Runtime.getRuntime().availableProcessors(),ForkJoinPool.defaultForkJoinWorkerThreadFactory,<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 根据给定的并行等级，创建一个拥有足够的线程数目的工作窃取的线程池 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 采用默认的 ForkJoinWorkerThreadFactory 来创建新线程</span></span><br><span class="line">    <span class="comment">// 并行度为 parallelism</span></span><br><span class="line">    <span class="comment">// 采用 FIFO_QUEUE</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism,ForkJoinPool.defaultForkJoinWorkerThreadFactory,<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建不可配置的线程池"><a href="#创建不可配置的线程池" class="headerlink" title="创建不可配置的线程池"></a>创建不可配置的线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个将所有已定义的ExecutorService方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">unconfigurableExecutorService</span><span class="params">(ExecutorService executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedExecutorService(executor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个将所有已定义的ScheduledExecutorService方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">unconfigurableScheduledExecutorService</span><span class="params">(ScheduledExecutorService executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 类似Executors.newSingleThreadScheduledExecutor()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService(executor);<span class="comment">//ScheduledExecutorService继承了ExecutorService</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="创建线程工厂"><a href="#创建线程工厂" class="headerlink" title="创建线程工厂"></a>创建线程工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 返回用于创建新线程的默认线程工厂 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此工厂创建同一 <code>ThreadGroup</code>中 Executor 使用的所有新线程。如果有 <code>SecurityManager</code>，则它使用 <code>System.getSecurityManager()</code>组来调用此 defaultThreadFactory 方法，其他情况则使用线程组。每个新线程都作为非守护程序而创建，并且具有设置为 Thread.NORM_PRIORITY 中较小者的优先级以及线程组中允许的最大优先级。新线程具有可通过 <em>pool-N-thread-M</em> 的 <code>Thread.getName()</code>来访问的名称，其中 <em>N</em> 是此工厂的序列号， <em>M</em> 是此工厂所创建线程的序列号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">privilegedThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedThreadFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此工厂创建具有与 <code>defaultThreadFactory()</code> 相同设置的线程，新线程的 <code>AccessControlContext</code> 和 <code>contextClassLoader</code> 的其他设置与调用此 privilegedThreadFactory 方法的线程相同，新线程与当前线程具有相同的权限。可以在 <code>AccessController.doPrivileged(java.security.PrivilegedAction )</code>操作中创建一个新 privilegedThreadFactory，设置当前线程的访问控制上下文，以便创建具有该操作中保持的所选权限的线程。</p><h3 id="创建-Callable-对象"><a href="#创建-Callable-对象" class="headerlink" title="创建 Callable 对象"></a>创建 Callable 对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 返回 Callable 对象，调用它时可运行给定的任务并返回 null */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;Object&gt;(task, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedAction&lt;?&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> action.run(); &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedExceptionAction&lt;?&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="keyword">return</span> action.run(); &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">privilegedCallable</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedCallable&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">privilegedCallableUsingCurrentClassLoader</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedCallableUsingCurrentClassLoader&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="Callable相关"><a href="#Callable相关" class="headerlink" title="Callable相关"></a>Callable相关</h3><h4 id="RunnableAdapter"><a href="#RunnableAdapter" class="headerlink" title="RunnableAdapter"></a>RunnableAdapter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现了Callable接口，可运行给定的任务并返回给定的结果</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现了Callable接口定义的call方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task.run();<span class="comment">//运行所定义的Runnable方法</span></span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回 T result</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PrivilegedCallable"><a href="#PrivilegedCallable" class="headerlink" title="PrivilegedCallable"></a>PrivilegedCallable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现了Callable接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegedCallable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;T&gt; task;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    PrivilegedCallable(Callable&lt;T&gt; task) &#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现了Callable接口定义的call方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedExceptionAction&lt;T&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> T <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> task.call();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, acc);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PrivilegedActionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PrivilegedCallableUsingCurrentClassLoader"><a href="#PrivilegedCallableUsingCurrentClassLoader" class="headerlink" title="PrivilegedCallableUsingCurrentClassLoader"></a>PrivilegedCallableUsingCurrentClassLoader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现了Callable接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegedCallableUsingCurrentClassLoader</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;T&gt; task;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader ccl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    PrivilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; task) &#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);            </span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">"setContextClassLoader"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现了Callable接口定义的call方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedExceptionAction&lt;T&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> T <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Thread t = Thread.currentThread();</span><br><span class="line">                        ClassLoader cl = t.getContextClassLoader();</span><br><span class="line">                        <span class="keyword">if</span> (ccl == cl) &#123;</span><br><span class="line">                            <span class="keyword">return</span> task.call();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            t.setContextClassLoader(ccl);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> task.call();</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                t.setContextClassLoader(cl);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, acc);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PrivilegedActionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程工厂类"><a href="#线程工厂类" class="headerlink" title="线程工厂类"></a>线程工厂类</h3><h4 id="DefaultThreadFactory"><a href="#DefaultThreadFactory" class="headerlink" title="DefaultThreadFactory"></a>DefaultThreadFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现ThreadFactory接口（创建默认线程工厂）</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="comment">//线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//线程名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();<span class="comment">//获取安全管理器对象</span></span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();<span class="comment">//得到当前线程组</span></span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> + poolNumber.getAndIncrement() + <span class="string">"-thread-"</span>;<span class="comment">//线程名称初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现ThreadFactory接口：创建新线程的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);<span class="comment">//创建一个新的线程加入到当前线程组(线程名称加1)</span></span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())<span class="comment">//判断是否设置了后台守护标志</span></span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);<span class="comment">//设为后台线程</span></span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<span class="comment">//将线程优先级统统设置为5</span></span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);<span class="comment">//不为5的统统改成5</span></span><br><span class="line">        <span class="keyword">return</span> t;<span class="comment">//返回创建的线程对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PrivilegedThreadFactory"><a href="#PrivilegedThreadFactory" class="headerlink" title="PrivilegedThreadFactory"></a>PrivilegedThreadFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承DefaultThreadFactory，增加成员变量，重写newThread方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegedThreadFactory</span> <span class="keyword">extends</span> <span class="title">DefaultThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader ccl;<span class="comment">//类加载器</span></span><br><span class="line"></span><br><span class="line">    PrivilegedThreadFactory() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">"setContextClassLoader"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写newThread方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.newThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Thread.currentThread().setContextClassLoader(ccl);</span><br><span class="line">                        r.run();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="DelegatedExecutorService"><a href="#DelegatedExecutorService" class="headerlink" title="DelegatedExecutorService"></a>DelegatedExecutorService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承AbstractExecutorService抽象类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123; e.execute(command); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; e.shutdown(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> e.shutdownNow(); &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> e.isShutdown(); &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> e.isTerminated(); &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.awaitTermination(timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.submit(task, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> e.invokeAll(tasks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> e.invokeAll(tasks, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.invokeAny(tasks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体实现依赖于传入的ExecutorService的实现类中定义的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.invokeAny(tasks, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FinalizableDelegatedExecutorService"><a href="#FinalizableDelegatedExecutorService" class="headerlink" title="FinalizableDelegatedExecutorService"></a>FinalizableDelegatedExecutorService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承DelegatedExecutorService类，重写了finalize()回收方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizableDelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">        <span class="keyword">super</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写finalize()回收方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DelegatedScheduledExecutorService"><a href="#DelegatedScheduledExecutorService" class="headerlink" title="DelegatedScheduledExecutorService"></a>DelegatedScheduledExecutorService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在DelegatedExecutorService的基础上，增加了对ScheduledExecutorService接口的实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line">        <span class="keyword">super</span>(executor);</span><br><span class="line">        e = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体实现依赖于ScheduledExecutorService接口的实现</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.schedule(command, delay, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体实现依赖于ScheduledExecutorService接口的实现</span></span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.schedule(callable, delay, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体实现依赖于ScheduledExecutorService接口的实现</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.scheduleAtFixedRate(command, initialDelay, period, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体实现依赖于ScheduledExecutorService接口的实现</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.scheduleWithFixedDelay(command, initialDelay, delay, unit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 <code>Executors</code> 提供四种常用线程池：<code>newFixedThreadPool</code>、<code>newCachedThreadPool</code>、<code>newSingleThreadExecutor</code>、<code>newScheduledThreadPool</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建固定数目线程的线程池。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。</span></span><br><span class="line"><span class="comment">// 如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个单线程化的Executor。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure><p><strong>newFixedThreadPool</strong> 创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，提交的任务则进入队列等待，等着有闲置的线程来执行这些任务。它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。<strong>主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    Runnable syncRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    executorService.execute(syncRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>newCachedThreadPool</strong> 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<strong>主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</strong></p><ul><li>工作线程的创建数量最大为 Interger. MAX_VALUE, 这样可灵活的往线程池中添加线程。</li><li>在创建任务时，若有空闲的线程时则复用空闲的线程，若没有则新建线程。</li><li>如果存在某一线程持续一段时间没有工作(默认为1分钟)，则该线程就会销毁回收。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Runnable syncRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    executorService.execute(syncRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>newSingleThreadExecutor *</em>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。特点：有且仅有一个工作线程执行任务，所有任务按照指定顺序执行，即遵循队列的入队出队规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    Runnable syncRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    executorService.execute(syncRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>newScheduledThreadPool</strong>创建一个定长的线程池，而且支持定时或周期性的任务执行。<strong>主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    Runnable syncRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    executorService.schedule(syncRunnable, <span class="number">5000</span>, TimeUnit.MILLISECONDS);<span class="comment">//延迟5秒执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟3秒后执行任务，从开始执行任务开始计时,每7秒执行一次不管执行任务需要多长的时间</span></span><br><span class="line">executorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable(),<span class="number">3</span>, <span class="number">7</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//延迟3秒后执行任务，从任务完成时开始计时，每7秒执行一次需要等到任务执行完成才开始计时</span></span><br><span class="line">executorService.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable(),<span class="number">3</span>, <span class="number">7</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p><strong>线程池不推荐使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式去创建，这样的处理方式让线程池的创建者更加明确线程池的运行规则，规避资源耗尽的风险。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;Exectors&lt;/code&gt; 中定义了 &lt;code&gt;Executor&lt;/code&gt;、&lt;code&gt;Executorservi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Phaser的使用</title>
    <link href="https://muhouer.github.io/posts/6810aa2c/"/>
    <id>https://muhouer.github.io/posts/6810aa2c/</id>
    <published>2019-09-24T15:45:00.000Z</published>
    <updated>2019-09-24T15:48:54.345Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Phaser</code> 移相器是一个可重用的同步屏障，功能上与 <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 类似，但是支持更灵活的使用，用来解决控制多个线程分阶段共同完成任务的情景问题。</p><h2 id="Phaser类结构"><a href="#Phaser类结构" class="headerlink" title="Phaser类结构"></a>Phaser类结构</h2><img src="/images/Phaser.png" alt="Phaser" style="zoom:80%"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phaser</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要状态, 占用4个字节：</span></span><br><span class="line"><span class="comment"> * unarrived: 还未到达的参与者数目 bits 0-15</span></span><br><span class="line"><span class="comment"> * parties: 当前阶段总的参与者数目 bits 16-31</span></span><br><span class="line"><span class="comment"> * phase: 屏障所处的阶段          bits 32-62</span></span><br><span class="line"><span class="comment"> * terminated: 屏障是否终止       bit  63 / sign)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"><span class="comment">// 最大的参与者数目</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  MAX_PARTIES     = <span class="number">0xffff</span>;</span><br><span class="line"><span class="comment">// 最大的阶段值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  MAX_PHASE       = Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">// 参与者移位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  PARTIES_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 阶段移位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  PHASE_SHIFT     = <span class="number">32</span>;</span><br><span class="line"><span class="comment">// 未到达参与者数掩码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  UNARRIVED_MASK  = <span class="number">0xffff</span>;      <span class="comment">// to mask ints</span></span><br><span class="line"><span class="comment">// 总参与者数掩码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PARTIES_MASK    = <span class="number">0xffff0000L</span>; <span class="comment">// to mask longs</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> COUNTS_MASK     = <span class="number">0xffffffffL</span>;</span><br><span class="line"><span class="comment">// 终止位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TERMINATION_BIT = <span class="number">1L</span> &lt;&lt; <span class="number">63</span>;</span><br><span class="line"><span class="comment">// 一个到达者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  ONE_ARRIVAL     = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 一个参与者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  ONE_PARTY       = <span class="number">1</span> &lt;&lt; PARTIES_SHIFT;</span><br><span class="line"><span class="comment">// 撤销一个参与者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  ONE_DEREGISTER  = ONE_ARRIVAL|ONE_PARTY;</span><br><span class="line"><span class="comment">// 0 个参与者，1 个达到者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  EMPTY           = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** 父 Phaser */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Phaser parent;</span><br><span class="line"><span class="comment">/** Phaser树的root */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Phaser root;</span><br><span class="line"><span class="comment">// 阶段值为偶数时，Treiber 栈节点，阻塞线程驻留在节点上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;QNode&gt; evenQ;</span><br><span class="line"><span class="comment">// 阶段值为奇数时，Treiber 栈节点，阻塞线程驻留在节点上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;QNode&gt; oddQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>创建具有父 Phaser 和参与数的新 Phaser。当给定的父 Phaser 非空且给定的参与数大于零时，该子 Phaser 将注册到其父 Phaser。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent 父Phaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties 需要推到下一阶段的参与数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 假如 parties 小于0或者大于所支持的最大参与数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(Phaser parent, <span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &gt;&gt;&gt; PARTIES_SHIFT != <span class="number">0</span>) <span class="comment">// 校验参与数</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal number of parties"</span>);</span><br><span class="line">    <span class="keyword">int</span> phase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser root = parent.root;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">        <span class="keyword">this</span>.evenQ = root.evenQ;</span><br><span class="line">        <span class="keyword">this</span>.oddQ = root.oddQ;</span><br><span class="line">        <span class="keyword">if</span> (parties != <span class="number">0</span>)</span><br><span class="line">            phase = parent.doRegister(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.evenQ = <span class="keyword">new</span> AtomicReference&lt;QNode&gt;();</span><br><span class="line">        <span class="keyword">this</span>.oddQ = <span class="keyword">new</span> AtomicReference&lt;QNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.state = (parties == <span class="number">0</span>) ? (<span class="keyword">long</span>)EMPTY :</span><br><span class="line">        ((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) |</span><br><span class="line">        ((<span class="keyword">long</span>)parties &lt;&lt; PARTIES_SHIFT) |</span><br><span class="line">        ((<span class="keyword">long</span>)parties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 父 Phaser 为 null，且需要推到下一阶段的参与数为0 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 父 Phaser 为 null */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, parties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 需要推到下一阶段的参与数为0 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(Phaser parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parent, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p><code>Phaser</code> 替代 <code>CyclicBarrier</code> 比较简单，<code>CyclicBarrier</code> 的 <code>await()</code> 方法可以直接用 <code>Phaser</code> 的<code>arriveAndAwaitAdvance()</code> 方法替代。<code>CyclicBarrier</code> 只适用于固定数量的参与者，而 <code>Phaser</code> 适用于可变数目的屏障。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random(<span class="number">10</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(NUM); <span class="comment">// 使用CyclicBarrier</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Task(phaser).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Phaser barrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Phaser barrier)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" 出发！"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * random.nextInt(<span class="number">5</span>));</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 已经上车，等待其他线程上车！"</span>);</span><br><span class="line">        barrier.arriveAndAwaitAdvance(); <span class="comment">// 使用await()</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><code>phaser.getPhase()</code> 初始值为0，如果全部线程执行完则+1，如果 <code>phaser.getPhase()</code> 达到 Integer 的最大值，这重新清空为0。<br><code>phaser.arriveAndDeregister()</code> 表示线程到达后离开。<br><code>phaser.arriveAndAwaitAdvance()</code> 表示线程在等待其他线程。<br><code>phaser.bulkRegister(friendNum)</code> 表示临时加进来几个线程。</p><p>这些方法的具体实现相对复杂，了解这些方法的作用会熟练使用即可。</p><p>有个例子很好的解释了这些方法的作用，更多可以参考 <a href="https://blog.csdn.net/tianshi_kco/article/details/52975468" target="_blank" rel="noopener">java多线程之Phaser</a>。</p><p>假如有这么一个场景，在旅游过程中，有可能很凑巧遇到几个朋友，然后他们听说你们在旅游,所以想要加入一起继续接下来的旅游。也有可能，在旅游过程中，突然其中有某几个人临时有事，想退出这次旅游了。在自由行的旅游，这是很常见的一些事情。如果现在我们使用 CyclicBarrier 这个类来实现，我们发现是实现不了，但是用Phaser就可实现这个功能。<br><strong>旅游类 TourismRunnable</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TourismRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  Phaser phaser;</span><br><span class="line">  Random random;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 每个线程保存一个朋友计数器,比如小红第一次遇到一个朋友,则取名`小红的朋友0号`,</span></span><br><span class="line"><span class="comment">   * 然后旅游到其他景点的时候,如果小红又遇到一个朋友,这取名为`小红的朋友1号`</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  AtomicInteger frientCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TourismRunnable</span><span class="params">(Phaser phaser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">    <span class="keyword">this</span>.random = <span class="keyword">new</span> Random();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tourism();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 旅游过程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tourism</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (phaser.getPhase()) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (!goToStartingPoint()) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> (!goToHotel()) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> (!goToTourismPoint1()) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> (!goToTourismPoint2()) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> (!goToTourismPoint3()) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">if</span> (!goToEndPoint()) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 准备返程</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回true, 说明还要继续旅游, 否则就临时退出了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">goToEndPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> goToPoint(<span class="string">"飞机场,准备登机回家"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 到达旅游点3</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回true, 说明还要继续旅游, 否则就临时退出了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">goToTourismPoint3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> goToPoint(<span class="string">"旅游点3"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 到达旅游点2</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回true, 说明还要继续旅游, 否则就临时退出了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">goToTourismPoint2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> goToPoint(<span class="string">"旅游点2"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 到达旅游点1</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回true, 说明还要继续旅游, 否则就临时退出了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">goToTourismPoint1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> goToPoint(<span class="string">"旅游点1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入住酒店</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回true, 说明还要继续旅游, 否则就临时退出了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">goToHotel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> goToPoint(<span class="string">"酒店"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出发点集合</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回true, 说明还要继续旅游, 否则就临时退出了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">goToStartingPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> goToPoint(<span class="string">"出发点"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRandomTime</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time = random.nextInt(<span class="number">400</span>) + <span class="number">100</span>;</span><br><span class="line">    Thread.sleep(time);</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> point 集合点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回true, 说明还要继续旅游, 否则就临时退出了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">goToPoint</span><span class="params">(String point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!randomEvent()) &#123; <span class="comment">// 到达后有事离开</span></span><br><span class="line">        phaser.arriveAndDeregister();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      String name = Thread.currentThread().getName();</span><br><span class="line">      System.out.println(name + <span class="string">" 花了 "</span> + getRandomTime() + <span class="string">" 时间才到了"</span> + point);</span><br><span class="line">      phaser.arriveAndAwaitAdvance(); <span class="comment">// 等待其他人</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 随机事件</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回true, 说明还要继续旅游, 否则就临时退出了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">randomEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = random.nextInt(<span class="number">100</span>);</span><br><span class="line">    String name = Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> friendNum = <span class="number">1</span>;</span><br><span class="line">      System.out.println(name + <span class="string">":在这里竟然遇到了"</span> + friendNum + <span class="string">"个朋友,他们说要一起去旅游..."</span>);</span><br><span class="line">      phaser.bulkRegister(friendNum); <span class="comment">// 临时加入</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; friendNum; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TourismRunnable(phaser), name + <span class="string">"的朋友"</span> + frientCount.getAndAdd(<span class="number">1</span>) + <span class="string">"号"</span>).start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r &gt; <span class="number">90</span>) &#123;</span><br><span class="line">      System.out.println(name + <span class="string">":突然有事要离开一下,不和他们继续旅游了...."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"明刚红丽黑白"</span>;</span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> SubPhaser(name.length());</span><br><span class="line">    List&lt;Thread&gt; tourismThread = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : name.toCharArray()) &#123;</span><br><span class="line">      tourismThread.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> TourismRunnable(phaser), <span class="string">"小"</span> + ch));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Thread thread : tourismThread) &#123;</span><br><span class="line">      thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SubPhaser</span> <span class="keyword">extends</span> <span class="title">Phaser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubPhaser</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(parties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** onAdvance 可重写，表示是否终止的条件 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">":全部"</span> + getArrivedParties() + <span class="string">"个人都到齐了,现在是第"</span> + (phase + <span class="number">1</span>)</span><br><span class="line">        + <span class="string">"次集合准备去下一个地方..................\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.onAdvance(phase, registeredParties);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">小刚:突然有事要离开一下,不和他们继续旅游了....</span><br><span class="line">小白:在这里竟然遇到了1个朋友,他们说要一起去旅游...</span><br><span class="line">小红:在这里竟然遇到了1个朋友,他们说要一起去旅游...</span><br><span class="line">小红 花了 207 时间才到了出发点</span><br><span class="line">小黑 花了 365 时间才到了出发点</span><br><span class="line">小红的朋友0号 花了 367 时间才到了出发点</span><br><span class="line">小明 花了 371 时间才到了出发点</span><br><span class="line">小白的朋友0号 花了 379 时间才到了出发点</span><br><span class="line">小白 花了 402 时间才到了出发点</span><br><span class="line">小丽 花了 460 时间才到了出发点</span><br><span class="line">小丽:全部7个人都到齐了,现在是第1次集合准备去下一个地方..................</span><br><span class="line"></span><br><span class="line">小红 花了 130 时间才到了酒店</span><br><span class="line">小红的朋友0号 花了 168 时间才到了酒店</span><br><span class="line">小黑 花了 187 时间才到了酒店</span><br><span class="line">小明 花了 328 时间才到了酒店</span><br><span class="line">小白 花了 380 时间才到了酒店</span><br><span class="line">小白的朋友0号 花了 438 时间才到了酒店</span><br><span class="line">小丽 花了 464 时间才到了酒店</span><br><span class="line">小丽:全部7个人都到齐了,现在是第2次集合准备去下一个地方..................</span><br><span class="line"></span><br><span class="line">小丽:在这里竟然遇到了1个朋友,他们说要一起去旅游...</span><br><span class="line">小红:在这里竟然遇到了1个朋友,他们说要一起去旅游...</span><br><span class="line">小黑:突然有事要离开一下,不和他们继续旅游了....</span><br><span class="line">小白:突然有事要离开一下,不和他们继续旅游了....</span><br><span class="line">小明 花了 103 时间才到了旅游点1</span><br><span class="line">小红的朋友1号 花了 241 时间才到了旅游点1</span><br><span class="line">小丽的朋友0号 花了 317 时间才到了旅游点1</span><br><span class="line">小红的朋友0号 花了 365 时间才到了旅游点1</span><br><span class="line">小丽 花了 383 时间才到了旅游点1</span><br><span class="line">小红 花了 433 时间才到了旅游点1</span><br><span class="line">小白的朋友0号 花了 460 时间才到了旅游点1</span><br><span class="line">小白的朋友0号:全部7个人都到齐了,现在是第3次集合准备去下一个地方..................</span><br><span class="line"></span><br><span class="line">小明:在这里竟然遇到了1个朋友,他们说要一起去旅游...</span><br><span class="line">小明 花了 121 时间才到了旅游点2</span><br><span class="line">小白的朋友0号 花了 203 时间才到了旅游点2</span><br><span class="line">小红 花了 261 时间才到了旅游点2</span><br><span class="line">小红的朋友1号 花了 286 时间才到了旅游点2</span><br><span class="line">小丽的朋友0号 花了 306 时间才到了旅游点2</span><br><span class="line">小红的朋友0号 花了 432 时间才到了旅游点2</span><br><span class="line">小明的朋友0号 花了 478 时间才到了旅游点2</span><br><span class="line">小丽 花了 491 时间才到了旅游点2</span><br><span class="line">小丽:全部8个人都到齐了,现在是第4次集合准备去下一个地方..................</span><br><span class="line"></span><br><span class="line">小丽:突然有事要离开一下,不和他们继续旅游了....</span><br><span class="line">小丽的朋友0号:突然有事要离开一下,不和他们继续旅游了....</span><br><span class="line">小红的朋友0号 花了 155 时间才到了旅游点3</span><br><span class="line">小白的朋友0号 花了 216 时间才到了旅游点3</span><br><span class="line">小红 花了 226 时间才到了旅游点3</span><br><span class="line">小明的朋友0号 花了 268 时间才到了旅游点3</span><br><span class="line">小红的朋友1号 花了 364 时间才到了旅游点3</span><br><span class="line">小明 花了 373 时间才到了旅游点3</span><br><span class="line">小明:全部6个人都到齐了,现在是第5次集合准备去下一个地方..................</span><br><span class="line"></span><br><span class="line">小明 花了 189 时间才到了飞机场,准备登机回家</span><br><span class="line">小白的朋友0号 花了 235 时间才到了飞机场,准备登机回家</span><br><span class="line">小红的朋友0号 花了 245 时间才到了飞机场,准备登机回家</span><br><span class="line">小明的朋友0号 花了 323 时间才到了飞机场,准备登机回家</span><br><span class="line">小红的朋友1号 花了 418 时间才到了飞机场,准备登机回家</span><br><span class="line">小红 花了 450 时间才到了飞机场,准备登机回家</span><br><span class="line">小红:全部6个人都到齐了,现在是第6次集合准备去下一个地方..................</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Phas
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Phaser" scheme="https://muhouer.github.io/tags/Phaser/"/>
    
  </entry>
  
  <entry>
    <title>CyclicBarrier解析</title>
    <link href="https://muhouer.github.io/posts/83559382/"/>
    <id>https://muhouer.github.io/posts/83559382/</id>
    <published>2019-09-23T16:23:10.000Z</published>
    <updated>2019-09-23T16:45:59.914Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>CyclicBarrier</code> 字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，<code>CyclicBarrier</code> 可以被重用。</p><h2 id="CyclicBarrier类结构"><a href="#CyclicBarrier类结构" class="headerlink" title="CyclicBarrier类结构"></a>CyclicBarrier类结构</h2><img src="/images/CyclicBarrier.png" width="800px" height="500px" align="center"><p><code>CyclicBarrier</code> 底层使用重写锁和 <code>Generation</code> 实现，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * barrier的每次使用都表示为一个Generation实例。当barrier被释放或重置时，generation会发生变化。 </span></span><br><span class="line"><span class="comment">     * 可以有许多generation实例与使用屏障的线程关联。——因为锁可能被分配给等待的线程的方式是不确定的，</span></span><br><span class="line"><span class="comment">     * 但是一次只能有一个线程处于活动状态（应用&#123;<span class="doctag">@code</span> count&#125;的线程），其余的线程要么被破坏，要么被触发。</span></span><br><span class="line"><span class="comment">     * 如果发生中断，但没有后续重置，则不需要激活generation。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 防护barrier入口的锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** 待跳闸条件 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/** 线程数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* 跳闸时运行的命令 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** 当前 generation */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仍然在等待的线程数量。每当仍然在等待的线程数量到0或崩溃时，CyclicBarrier会重置为每一代的线程数量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>一群学生准备乘车出去玩，约定明天在学校门口集合上车出发。现在陆陆续续的一个一个同学上车了，如果还有学生没到，其它人都必须等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random(<span class="number">10</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Runnable barrierAction =</span><br><span class="line">      () -&gt; &#123; System.out.println(<span class="string">"线程到齐，发车！"</span>); &#125;;</span><br><span class="line">    <span class="keyword">final</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(NUM, barrierAction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Task(barrier).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" 出发！"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * random.nextInt(<span class="number">5</span>));</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 已经上车，等待其他线程上车！"</span>);</span><br><span class="line">        barrier.await();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 出发！</span><br><span class="line">Thread-2 出发！</span><br><span class="line">Thread-1 出发！</span><br><span class="line">Thread-2 已经上车，等待其他线程上车！</span><br><span class="line">Thread-1 已经上车，等待其他线程上车！</span><br><span class="line">Thread-0 已经上车，等待其他线程上车！</span><br><span class="line">线程到齐，发车！</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 创建一个新的CyclicBarrier对象，当给定的线程都到达这个临界点等待(即调用await方法)，则开启barrier。</span></span><br><span class="line"><span class="comment"> * 当开启barrier时，它将执行 barrierAction </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的CyclicBarrier对象，当给定的线程都到达这个临界点等待(即调用await方法)，则开启barrier。</span></span><br><span class="line"><span class="comment"> * 当开启barrier时并没有任何预先定义的action需要执行。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="await-方法"><a href="#await-方法" class="headerlink" title="await 方法"></a>await 方法</h2><p>等待直到在这个 barrier 中有 parties 个线程调用了 await 方法。如果当前线程不是最后一个到达的，则由于线程调度的原因被禁用，sleep 直至以下事情发生：</p><ol><li>最后一个线程的到达;</li><li>其它的线程中断了当前线程;</li><li>其它的线程中断了和一样正在等待的线程;</li><li>其它线程等待barrier超时;</li><li>其它线程在这个barrier处调用了reset方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>); <span class="comment">// 无超时时间</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 指定等待超时时间 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法是本质上是调用 dowait 方法来完成，dowait 方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取重写锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="keyword">if</span> (g.broken) <span class="comment">// broken 则抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">// 线程中断</span></span><br><span class="line">            <span class="comment">// 将 barrier 当前generation 的 broken字段设为 true，并唤醒所有线程。</span></span><br><span class="line">            breakBarrier(); </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 执行barrierCommand</span></span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环直至发生 tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/** 超时设置 */</span></span><br><span class="line">                <span class="keyword">if</span> (!timed) <span class="comment">// 未设置超时时间，则一直等待，直到其它线程唤醒</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">/** 发生中断 */</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="comment">// broken</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// timed out</span></span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>breakBarrier()</code> 和 <code>nextGeneration()</code> 实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置当前的generation状态为broken且唤醒所有正在等待的线程。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新barrier的状态为重复利用做准备并且唤醒所有正在等待的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>CyclicBarrier 是可重用的，CountDownLatch 是不可重用的。</li><li>CyclicBarrier 的用途是让一组线程互相等待，直到到达某个公共屏障点才开始继续工作。</li><li>CyclicBarrier 指定的任务是进入 barrier 最后一个线程来调用的，如果在执行这个任务发生异常时，则会传播到此线程，其它线程不受影响继续正常运行。</li><li>在等待的只要有一个线程发生中断，则其它线程就会被唤醒继续正常运行。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Cycl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PostgreSQL简介</title>
    <link href="https://muhouer.github.io/posts/b81a5cf5/"/>
    <id>https://muhouer.github.io/posts/b81a5cf5/</id>
    <published>2019-09-23T14:19:52.000Z</published>
    <updated>2019-09-23T14:25:52.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>PostgreSQL 是一个功能强大、特性丰富、结构复杂的开源关系型数据库，它的起源可以追溯到1986年，当时它是加州大学伯克利分校 <a href="https://www.postgresql.org/docs/current/history.html" target="_blank" rel="noopener">POSTGRES</a> 项目的一部分。</p><img src="/images/postgresql_elephant.png" width="200px" height="200px" align="center"><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>macOS安装</strong></p><ol><li><p>使用 HomeBrew 安装</p><blockquote><p>默认的版本可能会比较低，可以下载安装包进行安装，参考第二种方式。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew search postgresql</span></span><br><span class="line">==&gt; Formulae</span><br><span class="line">postgresql      postgresql@10   postgresql@9.4  postgresql@9.5  postgresql@9.6</span><br><span class="line"></span><br><span class="line">==&gt; Casks</span><br><span class="line">navicat-for-postgresql                   navicat-for-postgresql</span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install postgresql@10</span></span><br></pre></td></tr></table></figure></li><li><p>下载 Postgres.app 再安装</p><p>参考 <a href="https://postgresapp.com/" target="_blank" rel="noopener">postgresapp 官网</a></p></li></ol><p><strong>Windows安装</strong></p><p>进入 <a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads" target="_blank" rel="noopener">下载地址</a>，选择相应的版本下载安装即可。</p><p><strong>CentOS安装</strong></p><ol><li><p>通过 yum 进行安装</p><blockquote><p>详细可参考 <a href="https://www.postgresql.org/download/linux/redhat/" target="_blank" rel="noopener">Linux下的安装</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install postgresql11</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install postgresql11-server <span class="comment"># 可选</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /usr/pgsql-11/bin/postgresql-11-setup initdb <span class="comment"># 初始化，可选</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> postgresql-11 <span class="comment"># 允许自启动，可选</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl start postgresql-11 <span class="comment"># 启动</span></span></span><br></pre></td></tr></table></figure></li><li><p>下载 rpm 包安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装相应PG版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpm -ivh pgdg-centos-XXX.rpm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum update</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装相应的版本，包括常用的pgadmin工具</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum --enablerepo=pgdgXX install postgresqlXX-server pgadmin3_XX postgresqlXX-contrib</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置PATH环境变量，并使之生效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/profile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>源码安装</strong></p><p>直接从官网 <a href="https://www.postgresql.org/ftp/source/" target="_blank" rel="noopener">PostgreSQL</a> 下载相应版本的源码包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建PG专用的用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> groupadd postgres</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> useradd -g postgres postgres</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -xf postgresql-X.X.X.tar.bz2 &amp;&amp; <span class="built_in">cd</span> postgresql-X.X.X</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/opt/postgre</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译contrib目录下的一些工具</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> contrib &amp;&amp; make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 绑定数据库文件存储目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PGDATA=/home/xxx/Workspace/databases/postgre/data</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /opt/postgre/bin/initdb -D <span class="variable">$PGDATA</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动、停止数据库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /opt/postgre/bin/pg_ctl -D <span class="variable">$PGDATA</span> -l logfile start</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /opt/postgre/bin/pg_ctl -D <span class="variable">$PGDATA</span> -l logfile stop</span></span><br></pre></td></tr></table></figure><h3 id="添加用户和数据库"><a href="#添加用户和数据库" class="headerlink" title="添加用户和数据库"></a>添加用户和数据库</h3><p>初次安装后，默认生成一个名为 postgres 的数据库和一个名为 postgres 的数据库用户，同时还生成了一个名为 postgres 的 Linux 系统用户。</p><h4 id="使用PostgreSQL控制台新增用户"><a href="#使用PostgreSQL控制台新增用户" class="headerlink" title="使用PostgreSQL控制台新增用户"></a>使用PostgreSQL控制台新增用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo adduser newdbuser <span class="comment"># 新建一个Linux新用户</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo su - postgres <span class="comment"># 切换用户</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> psql <span class="comment"># 登录PostgreSQL控制台,相当于系统用户postgres以同名数据库用户的身份，登录数据库，不用输入密码</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 为postgres用户设置一个密码</span></span></span><br><span class="line">postgres=# \password postgres </span><br><span class="line">postgres=# CREATE USER newdbuser WITH PASSWORD 'password'; -- 创建数据库用户newdbuser</span><br><span class="line">postgres=# CREATE DATABASE newdb OWNER newdbuser; -- 创建用户数据库newdb，并指定所有者为newdbuser。</span><br><span class="line">postgres=# GRANT ALL PRIVILEGES ON DATABASE newdb to newdbuser;-- 将newdb数据库的所有权限都赋予newdbuser</span><br><span class="line">postgres=# \q</span><br></pre></td></tr></table></figure><h4 id="使用shell命令行新增用户"><a href="#使用shell命令行新增用户" class="headerlink" title="使用shell命令行新增用户"></a>使用shell命令行新增用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo -u postgres createuser --superuser newdbuser <span class="comment"># 创建数据库用户 newdbuser，并指定其为超级用户</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo -u postgres psql <span class="comment"># 登录数据库控制台</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置 newdbuser 用户的密码，完成后退出控制台</span></span></span><br><span class="line">postgres=# \password newdbuser </span><br><span class="line">postgres=# \q</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo -u postgres createdb -O newdbuser newdb <span class="comment"># 创建数据库 newdb，并指定所有者为 newdbuser</span></span></span><br></pre></td></tr></table></figure><h3 id="控制台常见命令"><a href="#控制台常见命令" class="headerlink" title="控制台常见命令"></a>控制台常见命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\h：查看SQL命令的解释，比如\h select。</span><br><span class="line">\?：查看psql命令列表。</span><br><span class="line">\l：列出所有数据库。</span><br><span class="line">\c [database_name]：连接其他数据库。</span><br><span class="line">\d：列出当前数据库的所有表格。</span><br><span class="line">\d [table_name]：列出某一张表格的结构。</span><br><span class="line">\du：列出所有用户。</span><br><span class="line">\e：打开文本编辑器。</span><br><span class="line">\conninfo：列出当前数据库和连接的信息。</span><br></pre></td></tr></table></figure><h3 id="基本数据库操作"><a href="#基本数据库操作" class="headerlink" title="基本数据库操作"></a>基本数据库操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> xxx_tb(<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>), create_date <span class="built_in">DATE</span>);</span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> xxx_tb(<span class="keyword">name</span>, create_date) <span class="keyword">VALUES</span>(<span class="string">'xxx'</span>, <span class="string">'2019-09-25'</span>);</span><br><span class="line"><span class="comment"># 查询记录</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> xxx_tb;</span><br><span class="line"><span class="comment"># 更新记录</span></span><br><span class="line"><span class="keyword">UPDATE</span> xxx_tb <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'yyy'</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'xxx'</span>;</span><br><span class="line"><span class="comment"># 删除记录</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> xxx_tb <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'yyy'</span> ;</span><br><span class="line"><span class="comment"># 添加表列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> xxx_tb <span class="keyword">ADD</span> mobile_phone <span class="built_in">VARCHAR</span>(<span class="number">11</span>);</span><br><span class="line"><span class="comment"># 更新表结构</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> xxx_tb <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> create_date <span class="keyword">SET</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment"># 更改列名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> xxx_tb <span class="keyword">RENAME</span> <span class="keyword">COLUMN</span> create_date <span class="keyword">TO</span> <span class="keyword">create</span>;</span><br><span class="line"><span class="comment"># 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> xxx_tb <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> mobile_phone;</span><br><span class="line"><span class="comment"># 更改表名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> xxx_tb <span class="keyword">RENAME</span> <span class="keyword">TO</span> backup_xxx_tb;</span><br><span class="line"><span class="comment"># 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> backup_xxx_tb;</span><br></pre></td></tr></table></figure><h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p><strong>PostgreSQL</strong> 日志分为三类，分别是 <code>pg_log</code>、<code>pg_xlog</code> 和 <code>pg_clog</code>，一般保存在 <code>$PGDATA</code> 对应的目录下。</p><ol><li><p><code>pg_log</code> —— 数据库运行日志，默认开启，可以通过配置 <code>$PGDATA/postgresql.conf</code> 。</p><blockquote><p>这个日志一般是记录服务器与DB的状态，比如各种Error信息，定位慢查询SQL，数据库的启动关闭信息，发生checkpoint过于频繁等的告警信息，诸如此类。linux自带的路径一般在 /var/log/postgres 下面。该日志有.csv格式和.log。个人建议用前一种，因为一般会按大小和时间自动切割，毕竟查看一个巨大的日志文件比查看不同时间段的多个日志要难得多。另外这种日志是可以被清理删除，压缩打包或者转移，同时并不影响DB的正常运行。当我们有遇到DB无法启动或者更改参数没有生效时，第一个想到的就是查看这个日志。</p></blockquote></li><li><p><code>pg_xlog</code> —— WAL日志，强制开启。</p><blockquote><p>记录的 PostgreSQL 的 WAL 信息，也就是一些事务日志信息(transaction log)，默认单个大小是16M，源码安装的时候可以更改其大小。这些信息通常名字是类似’000000010000000000000013’这样的文件，这些日志会在定时回滚恢复(PITR)，流复制(Replication Stream)以及归档时能被用到，这些日志是非常重要的，记录着数据库发生的各种事务信息，不得随意删除或者移动这类日志文件，不然你的数据库会有无法恢复的风险</p><p>当你的归档或者流复制发生异常的时候，事务日志会不断地生成，有可能会造成你的磁盘空间被塞满，最终导致DB挂掉或者起不来。遇到这种情况不用慌，可以先关闭归档或者流复制功能，备份 pg_xlog 日志到其他地方，但请不要删除。然后删除较早时间的的 pg_xlog，有一定空间后再试着启动 Postgres。</p></blockquote></li><li><p><code>pg_clog</code> —— 事务提交日志，记录事务的元数据，强制开启。</p><blockquote><p>pg_clog 这个文件也是事务日志文件，但与 pg_xlog 不同的是它记录的是事务的元数据(metadata)，这个日志告诉我们哪些事务完成了，哪些没有完成。这个日志文件一般非常小，但是重要性也是相当高，不得随意删除或者对其更改信息。</p></blockquote></li></ol><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>*<em>pg_hba.conf *</em>—— 客户端访问和认证受到标准的 PostgreSQL 的基于主机的认证文件的控制。其中的认证文件即 是 pg_hba.conf。一般格式是一组记录，每行一个。一个记录由多个被空格或者制表符分隔的域组成。如果域值被加上引号，域可以包含空格。记录不能跨越多行。配置的具体含义可以参考 <a href="https://blog.csdn.net/hmxz2nn/article/details/83717663" target="_blank" rel="noopener">pg_hba.conf文件说明与配置</a>。</p><p><strong>postgresql.conf</strong> —— 配置文件主要影响这服务器实例的基本行为，比如允许的连接数，操作允许占用的最大内存数，指定哪些用户可以用何种方式连接到数据库等等。当然这一切在数据库安装好时都有一个默认值，但是如果你需要对你的数据库进行定制的话，可以对这些数值进行符合需求的修改。配置的具体含义可以参考 <a href="https://blog.csdn.net/syshzbtt/article/details/80953963" target="_blank" rel="noopener">PostgreSQL 配置文件postgresql.conf</a>。</p><h3 id="防火墙、SELinux-设置"><a href="#防火墙、SELinux-设置" class="headerlink" title="防火墙、SELinux 设置"></a>防火墙、SELinux 设置</h3><p><strong>PostgreSQL</strong> 默认使用 <code>5432</code> 端口，也可以在 <code>postgresql.conf</code> 文件中设置，可以使用如下命令开启防火墙端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 暂时有效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --add-port=5432/tcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久生效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --permanent --add-port=5432/tcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在iptables中开启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p tcp --dport 5432 -m state --state NEW,ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>如果开启了 SELinux 服务，可能会在使用中遇到各种各样的权限问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改数据库的存放位置，必须添加一些新上下文来匹配新位置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> semanage fcontext -a -t postgresql_db_t <span class="string">"/new/location(/.*)?"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认端口不起作用，需要匹配postgre的端口类型为你想要的端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> semanage port -a -t postgresql_port_t -p tcp 5433</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果APP需要通过TCP/IP与PG交互，你需要告诉SELinux允许这个操作</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> setsebool -P httpd_can_network_connect_db on</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>PostgreSQL 诞生于学院派，没有局限于当时的一些硬件条件，MySQL 发展自程序员的业余作品，为当时的小内存小外存的硬件条件做了特殊的处理，随着硬件的不断发展，这些处理在现在看来倒成了一个缺点。</p><p>MariaDB 由 MySQL 的创始人 Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司 MySQL AB 卖给了SUN，此后，随着SUN被甲骨文收购，MySQL 的所有权也落入 Oracle 的手中。MariaDB 名称来自 Michael Widenius 的女儿 Maria 的名字。MariaDB 发展势头也很不错，对应版本和 MySQL 也基本兼容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;PostgreSQL 是一个功能强大、特性丰富、结构复杂的开源关系型数据库，它的起源可以追溯到1986年，当时它是加州大学伯克利分校 &lt;a 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DNS协议介绍</title>
    <link href="https://muhouer.github.io/posts/13c9dbc5/"/>
    <id>https://muhouer.github.io/posts/13c9dbc5/</id>
    <published>2019-09-22T17:03:00.000Z</published>
    <updated>2019-09-22T17:03:43.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>DNS 协议</strong>也就是在做 DNS 解析时，客户端与服务端之间的通信协议。<strong>DNS 协议</strong>建立在 UDP 或 TCP 协议之上，默认使用 53 号端口。客户端默认通过 UDP 协议进行通讯，但是由于广域网中不适合传输过大的 UDP 数据包，因此规定当报文长度超过了 512 字节时，应转换为使用 TCP 协议进行数据传输。详见 <a href="https://www.ietf.org/rfc/rfc1035.txt" target="_blank" rel="noopener">RFC1035 4.MESSAGES</a> 部分。</p><ul><li>客户端认为 UDP 响应包长度可能超过 512 字节，主动使用 TCP 协议；</li><li>客户端使用 UDP 协议发送 DNS 请求，服务端发现响应报文超过了 512 字节，在截断的 UDP 响应报文中将 TC 设置为 1 ，以通知客户端该报文已经被截断，客户端收到之后再发起一次 TCP 请求。</li></ul><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>整个报文的格式如下，包括了五部分组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|        Header       | 报文头，定义了报文是请求还是应答、错误码以及其它的一些标志位</span><br><span class="line">+---------------------+</span><br><span class="line">|       Question      | 查询请求，包括查询类型(QTYPE)、查询类(QCLASS) 以及查询的域名(QNAME)</span><br><span class="line">+---------------------+</span><br><span class="line">|        Answer       | 应答资源记录(RRs)</span><br><span class="line">+---------------------+</span><br><span class="line">|      Authority      | 授权资源记录(RRs)</span><br><span class="line">+---------------------+</span><br><span class="line">|      Additional     | 附加信息资源记录(RRs)</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h2 id="报文头"><a href="#报文头" class="headerlink" title="报文头"></a>报文头</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                1  1  1  1  1  1</span><br><span class="line">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                      ID                       |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    QDCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    ANCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    NSCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    ARCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></pre></td></tr></table></figure><p>字段含义如下:</p><table><thead><tr><th align="center">字段</th><th>备注</th></tr></thead><tbody><tr><td align="center">ID</td><td>16Bits ，用于生成任何类型的查询。响应报文会原样带回，用于客户端区分不同的请求应答。</td></tr><tr><td align="center">QR</td><td>1Bits，请求 (0 Question) ，应答 (1 Response)。</td></tr><tr><td align="center">Opcode</td><td>4Bits，设置查询的种类，0 标准查询 QUERY、1 反向查询 IQUERY、2 服务器状态查询 STATUS、3~15 保留。响应报文会原样带回。</td></tr><tr><td align="center">AA</td><td>1Bits，授权应答(AuthoritativeAnswer)，响应报文生效，用于标示服务器响应报文是否为授权服务器返回的结果，可能是在本地 Cache 的缓存。</td></tr><tr><td align="center">TC</td><td>1Bits，截断(TrunCation)，报文因为超过了允许的长度，导致被截断。</td></tr><tr><td align="center">RD</td><td>1Bits，用于请求中，期望使用递归查询。</td></tr><tr><td align="center">RA</td><td>1Bits，用于响应中，如果服务器支持递归查询则设置为 1 ，否则设置为 0 。</td></tr><tr><td align="center">RCODE</td><td>4Bits，应答码(ResponseCode)，会在响应报文中设置。含义如下：<br>0 没有错误；<br>1 报文格式错误(Format Error)，服务器解析请求报文时报错；<br>2 服务器失败(Server Failure)，因为服务器的原因导致没办法处理这个请求；<br>3 名字错误(Name Error)，只对授权域名解析服务器有意义，解析的域名不存在；<br>4 没有实现(Not Implemented)，域名服务器不支持查询类型；<br>5 拒绝(Refused)，由于服务器设置的策略拒绝给出应答，通常是安全的配置；<br>6-15 保留值，暂未使用。</td></tr><tr><td align="center">QDCOUNT</td><td>无符号16位整数，表示报文请求段中的问题记录数。</td></tr><tr><td align="center">ANCOUNT</td><td>无符号16位整数，表示报文回答段中的回答记录数。</td></tr><tr><td align="center">NSCOUNT</td><td>无符号16位整数，表示报文授权段中的授权记录数。</td></tr><tr><td align="center">ARCOUNT</td><td>无符号16位整数，表示报文附加段中的附加记录数。</td></tr></tbody></table><blockquote><p>为加快 DNS 的查询速度，一般会在服务端缓存一段时间，所以有可能 DNS 会返回缓存在 Cache 中的内容，那么此时就会将 AA 响应设置为 0 ，也就是是这里显示的 Non-authoritative answer 。</p></blockquote><h2 id="查询请求"><a href="#查询请求" class="headerlink" title="查询请求"></a>查询请求</h2><p>用来标识，查询的请求参数，同时需要在头中设置 <code>QDCOUNT</code> 这个字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                                1  1  1  1  1  1</span><br><span class="line">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                                               |</span><br><span class="line">/                     QNAME                     /</span><br><span class="line">/                                               /</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                     QTYPE                     |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                     QCLASS                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></pre></td></tr></table></figure><p>字段含义如下:</p><table><thead><tr><th>字段</th><th align="left">注释</th></tr></thead><tbody><tr><td>QNAME</td><td align="left">域名被表示为标签序列，每个标签包含一个字节表示后续字符串长度，以及这个字符串，以0长度和空字符串来表示域名结束。请注意，此字段可能是奇数个字节，不需要进行边界填充对齐。</td></tr><tr><td>QTYPE</td><td align="left">2个字节，表示查询类型，取值可以为任何可用的类型值，以及通配码来表示所有的资源记录。</td></tr><tr><td>QCLASS</td><td align="left">2个字节，表示查询的协议类，比如，IN代表Internet</td></tr></tbody></table><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="递归查询-VS-迭代查询"><a href="#递归查询-VS-迭代查询" class="headerlink" title="递归查询 VS. 迭代查询"></a>递归查询 VS. 迭代查询</h3><p>在递归查询模式下，DNS 服务器在接收到客户机请求时，必须使用一个准确的查询结果回复客户机。也就意味着，如果 DNS 服务器本地没有缓存所查询的 DNS 信息，那么该服务器会询问其它服务器，并将返回的查询结果提交给客户机。</p><p>而在使用迭代查询时，DNS 服务器会向客户机提供其它能够解析查询请求的 DNS 服务器地址。也就是说，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台 DNS 服务器地址，客户机需要再向这台 DNS 服务器提交请求，依次循环直到返回查询的结果为止。</p><p>也就是说，关键的区别是由谁去查询最终的结果。</p><h3 id="DDoS"><a href="#DDoS" class="headerlink" title="DDoS"></a>DDoS</h3><p>发送大量的 DNS 递归查询会消耗服务端的一定资源，所以，只需要将发送的报文设置一个 RD 标志位即可。</p><p>当发送垃圾查询时，例如不存在的域名，必然会导致查询很慢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;DNS 协议&lt;/strong&gt;也就是在做 DNS 解析时，客户端与服务端之间的通信协议。&lt;strong&gt;DNS 协议&lt;/st
      
    
    </summary>
    
      <category term="通信协议" scheme="https://muhouer.github.io/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="DNS" scheme="https://muhouer.github.io/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>为什么数据库设计中要使用long来替换Date类型</title>
    <link href="https://muhouer.github.io/posts/c0f0d722/"/>
    <id>https://muhouer.github.io/posts/c0f0d722/</id>
    <published>2019-09-22T15:38:00.000Z</published>
    <updated>2019-09-22T15:41:06.287Z</updated>
    
    <content type="html"><![CDATA[<p>对数据库中的记录进行操作的时候，牵涉到对时间数据的处理，比如创建时间、修改时间等，一般使用 long 类型代替 <code>Date</code> 、<code>Timestamp</code>。比如 Mybatis 的池连接类 <code>PooledConnection</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> checkoutTimestamp; <span class="comment">// 检查时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> createdTimestamp; <span class="comment">// 创建时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastUsedTimestamp; <span class="comment">// 最后一次使用时间戳</span></span><br></pre></td></tr></table></figure><h2 id="MySQL、SQL-Server中的表示时间的类型"><a href="#MySQL、SQL-Server中的表示时间的类型" class="headerlink" title="MySQL、SQL Server中的表示时间的类型"></a>MySQL、SQL Server中的表示时间的类型</h2><p><strong>Date</strong>——日期。格式：YYYY-MM-DD。占用三个字节。</p><p><strong>Datetime</strong>——日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS。<code>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</code>，占用8个字节。适合用来记录数据的原始的创建时间。</p><p><strong>Timestamp</strong>——日期+时间，使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS。占用4个字节，<code>&#39;1970-01-01 00:00:01&#39; UTC ~ &#39;2038-01-09 03:14:07&#39; UTC</code>，适合用来记录数据的最后修改时间，只要更改记录中其他字段的值，timestamp字段的值都会被自动更新。</p><p><strong>bigint</strong>——表示从-2^63 (-9,223,372,036,854,775,808) 到 2^63-1 (9,223,372,036,854,775,807)，占用8个字节。</p><h2 id="Java-中表示时间的类型"><a href="#Java-中表示时间的类型" class="headerlink" title="Java 中表示时间的类型"></a>Java 中表示时间的类型</h2><p>Java 中对时间处理的类比较混乱，处理时间的类有：<code>java.util.Date</code>、<code>java.sql.Date</code> 、<code>java.sql.Time</code> 、<code>java.sql.Timestamp</code>、<code>java.util.Calendar</code> 、<code>java.util.TimeZone</code>。使用过程中存在以下问题：</p><ol><li>获取当前时间时，各个地区在同一个时间点会有不同的时间表示。</li><li>将 <code>java.util.Date</code> 转为 <code>java.sql.Date</code> 时候，日期的时分秒会被去掉，数据的精度发生了变化。而 JDBC 中定义接口时候，用的是 <code>java.sql.Date</code>，而我们常常用到的 Date 都是 <code>java.util.Date</code>，这往往导致一些转换过程中发生误差。</li><li><code>java.sql.Date</code>在JDBC接口中使用，如果对其进行修改，JDBC 接口规范也要改，那么将引发各个数据库厂商对数据库驱动也要改，这是不可接受的。</li><li><code>java.sql.Timestamp</code> 类，它保持了日期数据原有的精度。可以实现和 <code>java.util.Date</code> 的无损转换。但是 Timestamp 这个类在一些预定义SQL中常常会出问题。</li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>将 Date 类型转换为 long 类型。这样一来：</p><ol><li>有利于计算时间差</li><li>方便 Java 与数据库之间的传输</li><li>通过 <code>long now = System.currentTimeMillis()</code> 获得当前时间的 long 类型 也可以通过 <code>Date date1=new Date()</code> 来获得当前时间，再用 <code>long time = date.getTime()</code> 将其转化为 long类型。然后在数据库中的相应字段设置类型为 bigint 即可，在数据库中取得数据后，可以在转为相应的时间格式。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对数据库中的记录进行操作的时候，牵涉到对时间数据的处理，比如创建时间、修改时间等，一般使用 long 类型代替 &lt;code&gt;Date&lt;/code&gt; 、&lt;code&gt;Timestamp&lt;/code&gt;。比如 Mybatis 的池连接类 &lt;code&gt;PooledConnection
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>抽象队列与阻塞队列解析</title>
    <link href="https://muhouer.github.io/posts/ee5f9e9d/"/>
    <id>https://muhouer.github.io/posts/ee5f9e9d/</id>
    <published>2019-09-17T15:11:19.000Z</published>
    <updated>2019-09-17T15:11:50.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象队列"><a href="#抽象队列" class="headerlink" title="抽象队列"></a>抽象队列</h2><p><code>AbstractQueue</code> 是个抽象类，继承 <code>AbstractCollection</code>，实现 <code>Queue</code> 接口。其中 <code>AbstractCollection</code> 也是个抽象类，实现了 <code>Collection</code> 接口。所以 <code>AbstractQueue</code> 实现了集合的方法，和常用的 <code>ArrayList</code> 等类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 被子类使用的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractQueue</code> 还实现 <code>Queue</code> 接口，<code>Queue</code> 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 将元素 e 插入队列尾部，插入成功返回 true。如果在超出 JVM 限制的时候用 add 方法会抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素 e 插入队列尾部，插入成功返回 true。如果在超出 JVM 限制的时候用 offer 方法会返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检索并移除此队列的头，队列为空则抛出 NoSuchElementException</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检索并移除此队列的头，队列为空则返回 null</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检索但不移除此队列的头，队列为空则抛出 NoSuchElementException</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检索但不移除此队列的头，队列为空则返回 null</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractQueue</code> 在实现 <code>add(E e)</code> 方法时，调用 <code>offer(E e)</code> 添加失败则抛出异常 <code>IllegalStateException(&quot;Queue full&quot;)</code>。实现 <code>remove()</code> 方法时，调用 <code>poll()</code> 方法返回 null 则抛出异常 <code>NoSuchElementException()</code>。实现 <code>element()</code> 方法时，调用 <code>peek()</code> 方法返回 null 则抛出异常 <code>NoSuchElementException()</code>。</p><p>除了以上方法外，<code>AbstractQueue</code> 还实现了 <code>clear()</code> 、<code>addAll(Collection&lt;? extends E&gt; c)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空队列元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (poll() != <span class="keyword">null</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将集合中的元素全部加到队列，全部添加成功则返回 true。</span></span><br><span class="line"><span class="comment">// 如果集合为 null，则抛出空指针异常。如果集合和当前队列是一个，则抛出 IllegalArgumentException 异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>在 JUC 中，<code>BlockingQueue</code> 很好的解决了多线程中如何高效安全“传输”数据的问题，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。</p><p>接口中定义的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 将元素 e 插入队列尾部，参见 `Queue` 接口的 add 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将元素 e 插入队列尾部，参见 `Queue` 接口的 offer 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将指定的元素插队列尾部，当空间不可用时会等待。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将指定的元素插队列尾部，当空间不可用时会等待，直到超时。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 遍历并移除队列头部元素，如果队列为空则阻塞直至有元素可移除。</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// take() 的超时版本</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回此队列在理想情况下（在没有内存或资源约束的情况下）可以不阻塞地接受的元素的数目</span></span><br><span class="line">    <span class="comment">// 如果没有内在限制，则返回&#123;@code integer.max_value&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 检索并移除此队列的头，参见 `Queue` 接口的 remove 方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含，参见 Collection 接口的 contains 方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中移除所有可用元素并将它们添加到给定集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中移除指定数量的可用元素并将它们添加到给定集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;抽象队列&quot;&gt;&lt;a href=&quot;#抽象队列&quot; class=&quot;headerlink&quot; title=&quot;抽象队列&quot;&gt;&lt;/a&gt;抽象队列&lt;/h2&gt;&lt;p&gt;&lt;code&gt;AbstractQueue&lt;/code&gt; 是个抽象类，继承 &lt;code&gt;AbstractCollection&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ArrayBlockingQueue解析</title>
    <link href="https://muhouer.github.io/posts/c7003c14/"/>
    <id>https://muhouer.github.io/posts/c7003c14/</id>
    <published>2019-09-17T15:07:00.000Z</published>
    <updated>2019-09-17T15:12:35.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ArrayBlockingQueue</code> 是采用数组实现的有界阻塞线程安全队列。如果向已满的队列继续塞入元素，将导致当前的线程阻塞。如果向空队列获取元素，那么将导致当前线程阻塞。</p><p><code>ArrayBlockingQueue</code> 继承 <code>AbstractQueue</code> 类，实现 <code>BlockingQueue</code> 和 <code>Serializable</code>接口，关于 <code>AbstractQueue</code> 和 <code>BlockingQueue</code> 的内容可以参考 <a href="/posts/ee5f9e9d/" title="抽象队列与阻塞队列解析">抽象队列与阻塞队列解析</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><img src="/images/ArrayBlockingQueue.png" width="800px" height="300px" align="center"><p><code>ArrayBlockingQueue</code> 有两个内部类，分别为 <code>Itrs</code> 和 <code>Itr</code>。其中 <code>Itrs</code> 内部类 <code>Node</code> 继承 <code>WeakReference</code> 类。<code>Itr</code> 实现了 <code>Iterator</code> 接口</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>实现简单的生产者消费者模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Food&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生产者</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Food food = <span class="keyword">new</span> Food();</span><br><span class="line">      food.setName(<span class="string">"Apple"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        queue.put(food);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" provider : "</span> + food);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消费者</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Food food = queue.take();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" consumer : "</span> + food);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 食物</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Food &#123;name:"</span> + name + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> ArrayBlockingQueueTest().new Producer()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> ArrayBlockingQueueTest().new Consumer()).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> ArrayBlockingQueueTest().new Consumer()).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一次执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">4</span> provider : Food &#123;name:Apple&#125;</span><br><span class="line">Thread-<span class="number">3</span> provider : Food &#123;name:Apple&#125;</span><br><span class="line">Thread-<span class="number">5</span> consumer : Food &#123;name:Apple&#125;</span><br><span class="line">Thread-<span class="number">2</span> provider : Food &#123;name:Apple&#125;</span><br><span class="line">Thread-<span class="number">0</span> provider : Food &#123;name:Apple&#125;</span><br><span class="line">Thread-<span class="number">6</span> consumer : Food &#123;name:Apple&#125;</span><br></pre></td></tr></table></figure><h2 id="类结构源码分析"><a href="#类结构源码分析" class="headerlink" title="类结构源码分析"></a>类结构源码分析</h2><h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>可重入锁的内容可以参考 <a href="/posts/b376c662/" title="ReentrantLock解析">ReentrantLock解析</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 存放队列元素的数组 */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 取元素的下标索引 */</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 存元素的下标索引 */</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列中元素的数量 */</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 数据访问的重入锁 */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 取元素的等待队列条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 存元素的等待队列条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前活动迭代器的共享状态，如果已知不存在，则为空。允许队列操作更新迭代器状态。*/</span></span><br><span class="line"><span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>构造器有三种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化阻塞队列容量，默认是采用不公平重入锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 capacity 初始化阻塞队列容量，fair 初始化重入锁的公平与否</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ArrayBlockingQueue(int capacity, boolean fair) 基础上，将集合中元素加到阻塞队列中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 采用 ArrayBlockingQueue(int capacity, boolean fair) 初始化阻塞队列</span></span><br><span class="line">    <span class="keyword">this</span>(capacity, fair);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 锁仅用于可见性，而不是相互排斥</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                checkNotNull(e); <span class="comment">// 检查非空</span></span><br><span class="line">                items[i++] = e; <span class="comment">// 将元素加入阻塞队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新队列中元素的数量</span></span><br><span class="line">        count = i;</span><br><span class="line">        <span class="comment">// 更新存元素的下标索引，i 和 capacity 相等，则从 0 开始重新计</span></span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类源码分析"><a href="#内部类源码分析" class="headerlink" title="内部类源码分析"></a>内部类源码分析</h2><h3 id="Itrs内部类"><a href="#Itrs内部类" class="headerlink" title="Itrs内部类"></a>Itrs内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Itrs</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 弱迭代器引用的链接列表节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Itr</span>&gt; </span>&#123;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(Itr iterator, Node next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(iterator);</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** takeIndex 环绕到0的次数*/</span></span><br><span class="line">    <span class="keyword">int</span> cycles = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 弱迭代器引用的链接列表头节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/** 用于删除过时的迭代器 */</span></span><br><span class="line">    <span class="keyword">private</span> Node sweeper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 短扫频探头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHORT_SWEEP_PROBES = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 长扫频探头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LONG_SWEEP_PROBES = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    Itrs(Itr initial) &#123;</span><br><span class="line">        register(initial);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 清理迭代器，查找并删除过时的迭代器。仅从迭代线程调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeSweeping</span><span class="params">(<span class="keyword">boolean</span> tryHarder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        <span class="comment">// assert head != null;</span></span><br><span class="line">        <span class="keyword">int</span> probes = tryHarder ? LONG_SWEEP_PROBES : SHORT_SWEEP_PROBES;</span><br><span class="line">        Node o, p;</span><br><span class="line">        <span class="keyword">final</span> Node sweeper = <span class="keyword">this</span>.sweeper;</span><br><span class="line">        <span class="keyword">boolean</span> passedGo;   <span class="comment">// to limit search to one full sweep</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sweeper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            o = <span class="keyword">null</span>;</span><br><span class="line">            p = head;</span><br><span class="line">            passedGo = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = sweeper;</span><br><span class="line">            p = o.next;</span><br><span class="line">            passedGo = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; probes &gt; <span class="number">0</span>; probes--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (passedGo)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                o = <span class="keyword">null</span>;</span><br><span class="line">                p = head;</span><br><span class="line">                passedGo = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Itr it = p.get();</span><br><span class="line">            <span class="keyword">final</span> Node next = p.next;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="keyword">null</span> || it.isDetached()) &#123;</span><br><span class="line">                <span class="comment">// found a discarded/exhausted iterator</span></span><br><span class="line">                probes = LONG_SWEEP_PROBES; <span class="comment">// "try harder"</span></span><br><span class="line">                <span class="comment">// unlink p</span></span><br><span class="line">                p.clear();</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head = next;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// We've run out of iterators to track; retire</span></span><br><span class="line">                        itrs = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    o.next = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                o = p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sweeper = (p == <span class="keyword">null</span>) ? <span class="keyword">null</span> : o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新迭代器添加到跟踪迭代器的链接列表中。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Itr itr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        head = <span class="keyword">new</span> Node(itr, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有迭代器，并删除任何已过时的迭代器。takeIndex 环绕到0时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">takeIndexWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        cycles++;</span><br><span class="line">        <span class="keyword">for</span> (Node o = <span class="keyword">null</span>, p = head; p != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Itr it = p.get();</span><br><span class="line">            <span class="keyword">final</span> Node next = p.next;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="keyword">null</span> || it.takeIndexWrapped()) &#123;</span><br><span class="line">                <span class="comment">// unlink p</span></span><br><span class="line">                <span class="comment">// assert it == null || it.isDetached();</span></span><br><span class="line">                p.clear();</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">                    head = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    o.next = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                o = p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)   <span class="comment">// no more iterators to track</span></span><br><span class="line">            itrs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当迭代器被移除时调用，通知所有迭代器，并删除已过时的迭代器。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removedAt</span><span class="params">(<span class="keyword">int</span> removedIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node o = <span class="keyword">null</span>, p = head; p != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Itr it = p.get();</span><br><span class="line">            <span class="keyword">final</span> Node next = p.next;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="keyword">null</span> || it.removedAt(removedIndex)) &#123;</span><br><span class="line">                <span class="comment">// unlink p</span></span><br><span class="line">                <span class="comment">// assert it == null || it.isDetached();</span></span><br><span class="line">                p.clear();</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">                    head = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    o.next = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                o = p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)   <span class="comment">// no more iterators to track</span></span><br><span class="line">            itrs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列为空时调用，通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">queueIsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        <span class="keyword">for</span> (Node p = head; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">            Itr it = p.get();</span><br><span class="line">            <span class="keyword">if</span> (it != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.clear();</span><br><span class="line">                it.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        itrs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每当元素（在 takeIndex 处）退出队列时调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">elementDequeued</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            queueIsEmpty();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (takeIndex == <span class="number">0</span>)</span><br><span class="line">            takeIndexWrapped();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Itr-内部类"><a href="#Itr-内部类" class="headerlink" title="Itr 内部类"></a>Itr 内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** 游标，下一个next节点对应的下标，到达putIndex结束的位置为NONE */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">        <span class="comment">/** next节点的元素值 */</span></span><br><span class="line">        <span class="keyword">private</span> E nextItem;</span><br><span class="line">        <span class="comment">/** next节点的索引 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">        <span class="comment">/** 上一个节点的元素值 */</span></span><br><span class="line">        <span class="keyword">private</span> E lastItem;</span><br><span class="line">        <span class="comment">/** 上一个节点的索引 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> lastRet;</span><br><span class="line">        <span class="comment">/** 记录 takeIndex */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> prevTakeIndex;</span><br><span class="line">        <span class="comment">/** 记录cycles */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> prevCycles;</span><br><span class="line">        <span class="comment">/** 元素不可用或未定义时的特殊索引值 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NONE = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 元素非调用 this.remove() 被移除元素的索引值 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REMOVED = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/** detached 模式特殊的 prevTakeIndex 值 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DETACHED = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            lastRet = NONE;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// assert itrs == null;</span></span><br><span class="line">                    cursor = NONE;</span><br><span class="line">                    nextIndex = NONE;</span><br><span class="line">                    prevTakeIndex = DETACHED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> takeIndex = ArrayBlockingQueue.<span class="keyword">this</span>.takeIndex;</span><br><span class="line">                    prevTakeIndex = takeIndex;</span><br><span class="line">                    nextItem = itemAt(nextIndex = takeIndex);</span><br><span class="line">                    cursor = incCursor(takeIndex);</span><br><span class="line">                    <span class="keyword">if</span> (itrs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        itrs = <span class="keyword">new</span> Itrs(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 在 itrs 中注册 this</span></span><br><span class="line">                        itrs.register(<span class="keyword">this</span>); <span class="comment">// in this order</span></span><br><span class="line">                        <span class="comment">// 清理迭代器，查找并删除过时的迭代器。</span></span><br><span class="line">                        itrs.doSomeSweeping(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    prevCycles = itrs.cycles;</span><br><span class="line">                    <span class="comment">// assert takeIndex &gt;= 0;</span></span><br><span class="line">                    <span class="comment">// assert prevTakeIndex == takeIndex;</span></span><br><span class="line">                    <span class="comment">// assert nextIndex &gt;= 0;</span></span><br><span class="line">                    <span class="comment">// assert nextItem != null;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否是 detached 模式</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isDetached</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">return</span> prevTakeIndex &lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 游标处理</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incCursor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">if</span> (++index == items.length)</span><br><span class="line">                <span class="comment">// 从 0 开始</span></span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (index == putIndex)</span><br><span class="line">                <span class="comment">// takeIndex == putIndex</span></span><br><span class="line">                index = NONE;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验索引是否有效</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">invalidated</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> prevTakeIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">long</span> dequeues, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> distance = index - prevTakeIndex;</span><br><span class="line">            <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">                distance += length;</span><br><span class="line">            <span class="comment">// 下标距离的prevTakeIndex元素数量 和 出队元素数量 比较</span></span><br><span class="line">            <span class="keyword">return</span> dequeues &gt; distance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整索引，合并自上次对此迭代器执行操作以来的所有出列。</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incorporateDequeues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="comment">// assert itrs != null;</span></span><br><span class="line">            <span class="comment">// assert !isDetached();</span></span><br><span class="line">            <span class="comment">// assert count &gt; 0;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> cycles = itrs.cycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> takeIndex = ArrayBlockingQueue.<span class="keyword">this</span>.takeIndex;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevCycles = <span class="keyword">this</span>.prevCycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevTakeIndex = <span class="keyword">this</span>.prevTakeIndex;</span><br><span class="line">            <span class="comment">// cycles和takeIndex存在不一致，需要修正</span></span><br><span class="line">            <span class="keyword">if</span> (cycles != prevCycles || takeIndex != prevTakeIndex) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> len = items.length;</span><br><span class="line">                <span class="comment">// 计算出队元素的数量</span></span><br><span class="line">                <span class="keyword">long</span> dequeues = (cycles - prevCycles) * len</span><br><span class="line">                    + (takeIndex - prevTakeIndex);</span><br><span class="line">                <span class="comment">// 校验下标合法性</span></span><br><span class="line">                <span class="keyword">if</span> (invalidated(lastRet, prevTakeIndex, dequeues, len))</span><br><span class="line">                    lastRet = REMOVED;</span><br><span class="line">                <span class="keyword">if</span> (invalidated(nextIndex, prevTakeIndex, dequeues, len))</span><br><span class="line">                    nextIndex = REMOVED;</span><br><span class="line">                <span class="keyword">if</span> (invalidated(cursor, prevTakeIndex, dequeues, len))</span><br><span class="line">                    cursor = takeIndex;</span><br><span class="line">                <span class="comment">// 进入detach模式</span></span><br><span class="line">                <span class="keyword">if</span> (cursor &lt; <span class="number">0</span> &amp;&amp; nextIndex &lt; <span class="number">0</span> &amp;&amp; lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                    detach();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.prevCycles = cycles;</span><br><span class="line">                    <span class="keyword">this</span>.prevTakeIndex = takeIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改detach的标志字段，并且启动itrs的清理逻辑。</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Switch to detached mode</span></span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="comment">// assert cursor == NONE;</span></span><br><span class="line">            <span class="comment">// assert nextIndex &lt; 0;</span></span><br><span class="line">            <span class="comment">// assert lastRet &lt; 0 || nextItem == null;</span></span><br><span class="line">            <span class="comment">// assert lastRet &lt; 0 ^ lastItem != null;</span></span><br><span class="line">            <span class="keyword">if</span> (prevTakeIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// assert itrs != null;</span></span><br><span class="line">                prevTakeIndex = DETACHED;</span><br><span class="line">                <span class="comment">// try to unlink from itrs (but not too hard)</span></span><br><span class="line">                itrs.doSomeSweeping(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器的 hasNext 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            <span class="keyword">if</span> (nextItem != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            noNext(); <span class="comment">// 对于没有下一个节点的迭代器，需要修正下标属性并进入detach模式。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修正下标属性并进入detach模式</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">noNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// assert cursor == NONE;</span></span><br><span class="line">                <span class="comment">// assert nextIndex == NONE;</span></span><br><span class="line">                <span class="keyword">if</span> (!isDetached()) &#123;</span><br><span class="line">                    <span class="comment">// assert lastRet &gt;= 0;</span></span><br><span class="line">                    incorporateDequeues(); <span class="comment">// might update lastRet</span></span><br><span class="line">                    <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        lastItem = itemAt(lastRet);</span><br><span class="line">                        <span class="comment">// assert lastItem != null;</span></span><br><span class="line">                        detach();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// assert isDetached();</span></span><br><span class="line">                <span class="comment">// assert lastRet &lt; 0 ^ lastItem != null;</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器的 next() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            <span class="keyword">final</span> E x = nextItem;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isDetached())</span><br><span class="line">                    incorporateDequeues();</span><br><span class="line">                <span class="comment">// assert nextIndex != NONE;</span></span><br><span class="line">                <span class="comment">// assert lastItem == null;</span></span><br><span class="line">                lastRet = nextIndex;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">                <span class="keyword">if</span> (cursor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    nextItem = itemAt(nextIndex = cursor);</span><br><span class="line">                    <span class="comment">// assert nextItem != null;</span></span><br><span class="line">                    <span class="keyword">this</span>.cursor = incCursor(cursor);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextIndex = NONE;</span><br><span class="line">                    nextItem = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器的 remove() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isDetached())</span><br><span class="line">                    incorporateDequeues(); <span class="comment">// might update lastRet or detach</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> lastRet = <span class="keyword">this</span>.lastRet;</span><br><span class="line">                <span class="keyword">this</span>.lastRet = NONE;</span><br><span class="line">                <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isDetached())</span><br><span class="line">                        removeAt(lastRet);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">final</span> E lastItem = <span class="keyword">this</span>.lastItem;</span><br><span class="line">                        <span class="comment">// assert lastItem != null;</span></span><br><span class="line">                        <span class="keyword">this</span>.lastItem = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (itemAt(lastRet) == lastItem)</span><br><span class="line">                            removeAt(lastRet);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastRet == NONE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                <span class="comment">// else lastRet == REMOVED and the last returned element was</span></span><br><span class="line">                <span class="comment">// previously asynchronously removed via an operation other</span></span><br><span class="line">                <span class="comment">// than this.remove(), so nothing to do.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cursor &lt; <span class="number">0</span> &amp;&amp; nextIndex &lt; <span class="number">0</span>)</span><br><span class="line">                    detach();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="comment">// assert lastRet == NONE;</span></span><br><span class="line">                <span class="comment">// assert lastItem == null;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知迭代器队列为空，或队列已无望地落在后面</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            cursor = NONE;</span><br><span class="line">            <span class="keyword">if</span> (nextIndex &gt;= <span class="number">0</span>)</span><br><span class="line">                nextIndex = REMOVED;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                lastRet = REMOVED;</span><br><span class="line">                lastItem = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prevTakeIndex = DETACHED;</span><br><span class="line">            <span class="comment">// Don't set nextItem to null because we must continue to be</span></span><br><span class="line">            <span class="comment">// able to return it on next().</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Caller will unlink from itrs when convenient.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> prevTakeIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> distance = index - prevTakeIndex;</span><br><span class="line">            <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">                distance += length;</span><br><span class="line">            <span class="keyword">return</span> distance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有队列移除takeIndex下标处元素的方法, 都会调用迭代器的removeAt方法，以通知其修正下标索引值。</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">removedAt</span><span class="params">(<span class="keyword">int</span> removedIndex)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">if</span> (isDetached())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> cycles = itrs.cycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> takeIndex = ArrayBlockingQueue.<span class="keyword">this</span>.takeIndex;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevCycles = <span class="keyword">this</span>.prevCycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevTakeIndex = <span class="keyword">this</span>.prevTakeIndex;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> len = items.length;</span><br><span class="line">            <span class="keyword">int</span> cycleDiff = cycles - prevCycles;</span><br><span class="line">            <span class="keyword">if</span> (removedIndex &lt; takeIndex)</span><br><span class="line">                cycleDiff++;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> removedDistance =</span><br><span class="line">                (cycleDiff * len) + (removedIndex - prevTakeIndex);</span><br><span class="line">            <span class="comment">// assert removedDistance &gt;= 0;</span></span><br><span class="line">            <span class="keyword">int</span> cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">            <span class="keyword">if</span> (cursor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = distance(cursor, prevTakeIndex, len);</span><br><span class="line">                <span class="keyword">if</span> (x == removedDistance) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cursor == putIndex)</span><br><span class="line">                        <span class="keyword">this</span>.cursor = cursor = NONE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance) &#123;</span><br><span class="line">                    <span class="comment">// assert cursor != prevTakeIndex;</span></span><br><span class="line">                    <span class="keyword">this</span>.cursor = cursor = dec(cursor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> lastRet = <span class="keyword">this</span>.lastRet;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = distance(lastRet, prevTakeIndex, len);</span><br><span class="line">                <span class="keyword">if</span> (x == removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.lastRet = lastRet = REMOVED;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.lastRet = lastRet = dec(lastRet);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nextIndex = <span class="keyword">this</span>.nextIndex;</span><br><span class="line">            <span class="keyword">if</span> (nextIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = distance(nextIndex, prevTakeIndex, len);</span><br><span class="line">                <span class="keyword">if</span> (x == removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.nextIndex = nextIndex = REMOVED;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.nextIndex = nextIndex = dec(nextIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cursor &lt; <span class="number">0</span> &amp;&amp; nextIndex &lt; <span class="number">0</span> &amp;&amp; lastRet &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.prevTakeIndex = DETACHED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// takeIndex每次循环到0时会调用该方法。</span></span><br><span class="line">        <span class="comment">// cycle计数增加，遍历链表检查并清理过期的无效节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">takeIndexWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">if</span> (isDetached())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (itrs.cycles - prevCycles &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// All the elements that existed at the time of the last</span></span><br><span class="line">                <span class="comment">// operation are gone, so abandon further iteration.</span></span><br><span class="line">                shutdown();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         /** 取消调试注释. */</span></span><br><span class="line"><span class="comment">//         public String toString() &#123;</span></span><br><span class="line"><span class="comment">//             return ("cursor=" + cursor + " " +</span></span><br><span class="line"><span class="comment">//                     "nextIndex=" + nextIndex + " " +</span></span><br><span class="line"><span class="comment">//                     "lastRet=" + lastRet + " " +</span></span><br><span class="line"><span class="comment">//                     "nextItem=" + nextItem + " " +</span></span><br><span class="line"><span class="comment">//                     "lastItem=" + lastItem + " " +</span></span><br><span class="line"><span class="comment">//                     "prevCycles=" + prevCycles + " " +</span></span><br><span class="line"><span class="comment">//                     "prevTakeIndex=" + prevTakeIndex + " " +</span></span><br><span class="line"><span class="comment">//                     "size()=" + size() + " " +</span></span><br><span class="line"><span class="comment">//                     "remainingCapacity()=" + remainingCapacity());</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入detach模式的关键有3种情况：</p><ol><li>cursor == putIndex，这时候 cursor = NONE</li><li>空队列</li><li>cycle - preCycles &gt; 1</li></ol><h2 id="常用操作源码分析"><a href="#常用操作源码分析" class="headerlink" title="常用操作源码分析"></a>常用操作源码分析</h2><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用抽象队列的 add 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素 e 插入队列尾部，不感知中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e); <span class="comment">// 检查元素 e 是否为空</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 加锁，不感知中断</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="comment">// 队列满了，返回 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 入队，返回 true</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素 e 插入队列尾部，如果队列慢了则一直等待，感知中断。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e); <span class="comment">// 检查元素 e 是否为空</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 加锁，感知中断</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">// 队列满了，等待</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// put(E e) 超时版本，如果入队成功，则返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 加锁，感知中断</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// notFull 的超时等待</span></span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历并移除队列头部元素，不感知中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 出队：队列为空则返回 null。</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历并移除队列头部元素，感知中断。如果队列为空则一直等待。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 加锁，感知中断</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 队列为空，等待</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 出队：遍历并移除队列头部元素，并返回头部元素</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take() 的超时版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// notEmpty 的超时等待</span></span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出队：遍历并移除队列头部元素，并返回头部元素</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组中下标索引 takeIndex 对应的元素，不进行弹出。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// 队列为空返回 null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队列中移除元素，不感知中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列非空</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                    <span class="comment">// takeIndex 对应的元素和 o 一致则移除 takeIndex 对应的元素，返回 true</span></span><br><span class="line">                    removeAt(i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    <span class="comment">// ++i 和数组长度相等，i 从 0 开始计</span></span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex); <span class="comment">// i == putIndex 则终止循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = count;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                items[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">            takeIndex = putIndex;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。</span></span><br><span class="line">                itrs.queueIsEmpty();</span><br><span class="line">            <span class="comment">// 查询是否有因为给定条件 notFull 正在等待的线程</span></span><br><span class="line">            <span class="keyword">for</span> (; k &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); k--)</span><br><span class="line">                <span class="comment">// 唤醒因为给定条件 notFull 正在等待的线程</span></span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueIsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="keyword">for</span> (Node p = head; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">        Itr it = p.get();</span><br><span class="line">        <span class="keyword">if</span> (it != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.clear();</span><br><span class="line">            it.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head = <span class="keyword">null</span>;</span><br><span class="line">    itrs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转数组"><a href="#转数组" class="headerlink" title="转数组"></a>转数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将队列转成 Object 数组</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] a;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="keyword">this</span>.count;</span><br><span class="line">        a = <span class="keyword">new</span> Object[count];</span><br><span class="line">        <span class="keyword">int</span> n = items.length - takeIndex;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= n) <span class="comment">// putIndex 大于等于 takeIndex</span></span><br><span class="line">            System.arraycopy(items, takeIndex, a, <span class="number">0</span>, count);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// putIndex 小于 takeIndex</span></span><br><span class="line">            System.arraycopy(items, takeIndex, a, <span class="number">0</span>, n);</span><br><span class="line">            System.arraycopy(items, <span class="number">0</span>, a, n, count - n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列转成泛型数组</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; count)</span><br><span class="line">            <span class="comment">// 泛型数组 a 长度不够，重新创建一个长度为 count 的数组</span></span><br><span class="line">            <span class="comment">// 注意：泛型数组不能通过 T[] a = new T[count] 方式进行创建，只能通过反射进行创建</span></span><br><span class="line">            a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                a.getClass().getComponentType(), count);</span><br><span class="line">        <span class="keyword">int</span> n = items.length - takeIndex;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= n) <span class="comment">// putIndex 大于等于 takeIndex</span></span><br><span class="line">            System.arraycopy(items, takeIndex, a, <span class="number">0</span>, count);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// putIndex 小于 takeIndex</span></span><br><span class="line">            System.arraycopy(items, takeIndex, a, <span class="number">0</span>, n);</span><br><span class="line">            System.arraycopy(items, <span class="number">0</span>, a, n, count - n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; count) <span class="comment">// 泛型数组 a 长度大于阻塞队列元素个数， 则第 count 位清空</span></span><br><span class="line">            a[count] = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取阻塞队列元素数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取阻塞队列剩余容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.length - count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断阻塞队列是否包含元素 o</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">// 处理类似 remove 方法</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(items[i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString 方法，结果类似 [e1.toString(), e2.toString()……]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = count;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = takeIndex; ; ) &#123;</span><br><span class="line">            Object e = items[i];</span><br><span class="line">            sb.append(e == <span class="keyword">this</span> ? <span class="string">"(this Collection)"</span> : e);</span><br><span class="line">            <span class="keyword">if</span> (--k == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> sb.append(<span class="string">']'</span>).toString();</span><br><span class="line">            sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">            <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><h3 id="将队列元素添加到集合"><a href="#将队列元素添加到集合" class="headerlink" title="将队列元素添加到集合"></a>将队列元素添加到集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将队列元素添加到集合 c，最大数量为 Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> drainTo(c, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列元素添加到集合 c，最大数量为 maxElements</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">    checkNotNull(c); <span class="comment">// 检查集合是否非null</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>) <span class="comment">// c 是当前队列本身</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 取 maxElements 和队列元素数量最小值</span></span><br><span class="line">        <span class="keyword">int</span> n = Math.min(maxElements, count);</span><br><span class="line">        <span class="keyword">int</span> take = takeIndex;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">// 从队列中循环取出元素并加入集合 c 中</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                E x = (E) items[take];</span><br><span class="line">                c.add(x);</span><br><span class="line">                items[take] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (++take == items.length)</span><br><span class="line">                    take = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 恢复不变量，即使调用 c.add() 抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count -= i; <span class="comment">// 移除并成功添加到集合后，队列剩余元素数量</span></span><br><span class="line">                takeIndex = take; <span class="comment">// 更新 takeIndex</span></span><br><span class="line">                <span class="keyword">if</span> (itrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                        <span class="comment">// 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。</span></span><br><span class="line">                        itrs.queueIsEmpty();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; take) <span class="comment">// 移除并成功添加到集合的元素个数大于 take</span></span><br><span class="line">                        <span class="comment">// 每当 takeIndex 为0时调用。通知所有迭代器，并删除任何已过时的迭代器。</span></span><br><span class="line">                        itrs.takeIndexWrapped(); <span class="comment">// 参考内部类 Itrs 的 takeIndexWrapped 实现</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 查询是否有因为给定条件 notFull 正在等待的线程</span></span><br><span class="line">                <span class="keyword">for</span> (; i &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); i--)</span><br><span class="line">                    <span class="comment">// 唤醒因为给定条件 notFull 正在等待的线程</span></span><br><span class="line">                    notFull.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队与入队"><a href="#出队与入队" class="headerlink" title="出队与入队"></a>出队与入队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 唤醒因为给定条件 notEmpty 正在等待的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 唤醒因为给定条件 notFull 正在等待的线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elementDequeued</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。</span></span><br><span class="line">        queueIsEmpty();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (takeIndex == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 通知所有迭代器，并删除任何已过时的迭代器。</span></span><br><span class="line">        takeIndexWrapped();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分割迭代器"><a href="#分割迭代器" class="headerlink" title="分割迭代器"></a>分割迭代器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk8新增，可用来并行遍历元素的一个迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有序、非空、线程安全</span></span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator</span><br><span class="line">        (<span class="keyword">this</span>, Spliterator.ORDERED | Spliterator.NONNULL |</span><br><span class="line">         Spliterator.CONCURRENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ArrayBlockingQueue</code> 采用数组实现的有界阻塞线程安全队列，是规定大小的 <code>BlockingQueue</code>，其构造必须指定大小。其所含的对象是 FIFO 顺序排序的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt; 是采用数组实现的有界阻塞线程安全队列。如果向已满的队列继续塞入元素，将导致当
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ArrayBlockingQueue" scheme="https://muhouer.github.io/tags/ArrayBlockingQueue/"/>
    
  </entry>
  
  <entry>
    <title>StampedLock</title>
    <link href="https://muhouer.github.io/posts/ab957bc5/"/>
    <id>https://muhouer.github.io/posts/ab957bc5/</id>
    <published>2019-09-16T13:04:00.000Z</published>
    <updated>2019-09-16T13:12:44.665Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>读写锁如果使用不当，容易出现“饥饿”问题，比如在读线程非常多，写线程非常少的情况下，很容易导致写线程“饥饿”。虽然公平策略在一定程度上可以缓解这个问题，但是鱼与熊掌不可兼得，公平策略是以牺牲系统吞吐量为代价的。</p><p>于是<code>StampedLock</code> 类应运而生，在 JDK1.8 时引入，是对读写锁 <code>ReentrantReadWriteLock</code> 的增强，该类提供了一些功能，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，可以更细粒度控制并发。</p><p>不过该类的设计初衷是作为一个内部工具类，用于辅助开发其它线程安全组件。用得好，该类可以提升系统性能，用不好，容易产生死锁和其它莫名其妙的问题。</p><h2 id="StampedLock-类结构"><a href="#StampedLock-类结构" class="headerlink" title="StampedLock 类结构"></a>StampedLock 类结构</h2><p><code>StampedLock</code> 类结构如下：</p><img src="/images/StampedLock.png" width="800px" height="500px" align="center"><p><code>StampedLock</code> 的内部类包括四个，分别为 <code>WriteLockView</code>、<code>ReadLockView</code>、<code>ReadWriteLockView</code> 以及 <code>WNode</code>。</p><h3 id="StampedLock-底层实现"><a href="#StampedLock-底层实现" class="headerlink" title="StampedLock 底层实现"></a>StampedLock 底层实现</h3><p><code>StampedLock</code> 虽然不像其它锁一样定义了内部类来实现 AQS 框架，但是 <code>StampedLock</code> 的基本实现思路还是利用 CLH 队列进行线程的管理，通过同步状态值来表示锁的状态和类型。</p><p><code>StampedLock</code> 把读分为了悲观读和乐观读，悲观读就等价于 <code>ReadWriteLock</code> 的读，而乐观读在一个线程写共享变量时，不会被阻塞，乐观读是不加锁的。</p><p><code>StampedLock</code> 内部定义了很多常量，定义这些常量的根本目的和 <code>ReentrantReadWriteLock</code> 一样，对同步状态值按位切分，以通过位运算对State进行操作</p><blockquote><p>对于 StampedLock 来说，写锁被占用的标志是第8位为1，读锁使用0-7位，正常情况下读锁数目为1-126，超过126时，使用一个名为的 readerOverflow int整型保存超出数。</p></blockquote><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLock</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6001602636862214147L</span>;</span><br><span class="line">    <span class="comment">/** CPU 核数，用于控制自旋次数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">/** 尝试获取锁失败次数超过该值，则将其加入等待队列 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">6</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 等待队列首节点自旋获取锁失败次数超过该值，会继续阻塞 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">10</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 等待队列首节点再次阻塞之前的最大尝试次数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">16</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 等待自旋锁溢出时的 yield 周期 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OVERFLOW_YIELD_RATE = <span class="number">7</span>; <span class="comment">// must be power 2 - 1</span></span><br><span class="line">    <span class="comment">/** 在读锁数量溢出之前的 bit 位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LG_READERS = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁状态和标记操作的位常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RUNIT = <span class="number">1L</span>; <span class="comment">// 一单位读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WBIT  = <span class="number">1L</span> &lt;&lt; LG_READERS; <span class="comment">// 写状态标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RBITS = WBIT - <span class="number">1L</span>; <span class="comment">// 读状态标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RFULL = RBITS - <span class="number">1L</span>; <span class="comment">// 读锁的最大数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABITS = RBITS | WBIT; <span class="comment">// 用于获取读写状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SBITS = ~RBITS; <span class="comment">// note overlap with ABITS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁状态初始值，避免初始化为失败值 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ORIGIN = WBIT &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消获取方法返回的特殊值，以便调用方可以抛出 InterruptedException</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> INTERRUPTED = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点状态值，和顺序有关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITING   = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的模式，使用 int 而不是 boolean，方便计算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RMODE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WMODE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait nodes */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> WNode prev;</span><br><span class="line">        <span class="keyword">volatile</span> WNode next;</span><br><span class="line">        <span class="keyword">volatile</span> WNode cowait;    <span class="comment">// list of linked readers</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;   <span class="comment">// non-null while possibly parked</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> status;      <span class="comment">// 0, WAITING, or CANCELLED</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode;           <span class="comment">// RMODE or WMODE</span></span><br><span class="line">        WNode(<span class="keyword">int</span> m, WNode p) &#123; mode = m; prev = p; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** CLH 队列的头节点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode whead;</span><br><span class="line">    <span class="comment">/** CLH 队列的尾节点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode wtail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视图</span></span><br><span class="line">    <span class="keyword">transient</span> ReadLockView readLockView;</span><br><span class="line">    <span class="keyword">transient</span> WriteLockView writeLockView;</span><br><span class="line">    <span class="keyword">transient</span> ReadWriteLockView readWriteLockView;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 锁状态 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line">    <span class="comment">/** 读锁饱和时的额外读锁计数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> readerOverflow;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 StampedLock，初始是 unlocked 状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StampedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state = ORIGIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种锁视图"><a href="#三种锁视图" class="headerlink" title="三种锁视图"></a>三种锁视图</h3><p>三种锁视图分别为读锁视图、写锁视图、读写锁(悲观读)视图。这些视图其实是对 <code>StamedLock</code> 方法的封装，便于习惯了 <code>ReentrantReadWriteLock</code> 的用户使用。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读锁视图</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLockView</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非独占获取锁，如果需要会阻塞到可用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; readLock(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        readLockInterruptibly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> tryReadLock() != <span class="number">0L</span>; &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁，带超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryReadLock(time, unit) != <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无标识释放锁 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; unstampedUnlockRead(); &#125;</span><br><span class="line">    <span class="comment">// 不支持 Condition</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写锁视图</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLockView</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; writeLock(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        writeLockInterruptibly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> tryWriteLock() != <span class="number">0L</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryWriteLock(time, unit) != <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; unstampedUnlockWrite(); &#125;</span><br><span class="line">    <span class="comment">// 不支持 Condition</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读写锁(悲观读)视图</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockView</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lock <span class="title">readLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> asReadLock(); &#125;</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> asWriteLock(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReadWriteLock</code> 方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lock <span class="title">asReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReadLockView v;</span><br><span class="line">    <span class="keyword">return</span> ((v = readLockView) != <span class="keyword">null</span> ? v :</span><br><span class="line">            (readLockView = <span class="keyword">new</span> ReadLockView()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回写锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lock <span class="title">asWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WriteLockView v;</span><br><span class="line">    <span class="keyword">return</span> ((v = writeLockView) != <span class="keyword">null</span> ? v :</span><br><span class="line">            (writeLockView = <span class="keyword">new</span> WriteLockView()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>在使用 <code>StampedLock</code> 的时候，建议这样操作：<strong>乐观读时，如果有写操作修改了共享变量则升级乐观读为悲观读锁</strong>，因为这样可用避免乐观读反复的循环等待写锁的释放，造成 CPU 资源的浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// an exclusively locked method</span></span><br><span class="line">    <span class="keyword">long</span> stamp = sl.writeLock();  <span class="comment">//获取写锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      x += deltaX;</span><br><span class="line">      y += deltaY;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      sl.unlockWrite(stamp); <span class="comment">//释放写锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">    <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//乐观读</span></span><br><span class="line">    <span class="keyword">double</span> currentX = x, currentY = y;</span><br><span class="line">    <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">//判断共享变量是否已经被其他线程写过</span></span><br><span class="line">       stamp = sl.readLock();  <span class="comment">//如果被写过则升级为悲观读锁</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         currentX = x;</span><br><span class="line">         currentY = y;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          sl.unlockRead(stamp); <span class="comment">//释放悲观读锁</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">    <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">    <span class="keyword">long</span> stamp = sl.readLock(); <span class="comment">//获取读锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);  <span class="comment">//升级为写锁</span></span><br><span class="line">        <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">          stamp = ws;</span><br><span class="line">          x = newX;</span><br><span class="line">          y = newY;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          sl.unlockRead(stamp);</span><br><span class="line">          stamp = sl.writeLock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      sl.unlock(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StampedLock-获取锁和释放锁的实现"><a href="#StampedLock-获取锁和释放锁的实现" class="headerlink" title="StampedLock 获取锁和释放锁的实现"></a>StampedLock 获取锁和释放锁的实现</h2><p><code>StampedLock</code> 在获取锁和乐观读时，都会返回一个 stamp，解锁时需要传入这个 stamp，在乐观读时是用来验证共享变量是否被其他线程写过。</p><p><code>StampedLock</code> 中，等待队列的结点要比AQS中简单些，仅仅三种状态。</p><ol><li>初始状态</li><li>等待中</li><li>取消</li></ol><h3 id="获取写锁"><a href="#获取写锁" class="headerlink" title="获取写锁"></a>获取写锁</h3><p>写锁(独占锁)，如果获取失败则进入阻塞队列，不响应中断。返回非 0 代表成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, next;  <span class="comment">// bypass acquireWrite in fully unlocked case only</span></span><br><span class="line">    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT)) ?</span><br><span class="line">            next : acquireWrite(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(s = state) &amp; ABITS) == 0L</code> 为 true 代表读锁与写锁均未被使用，<code>compareAndSwapLong</code> 表示通过 CAS 更新同步状态值 state。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, next;</span><br><span class="line">    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT)) ?</span><br><span class="line">            next : <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryWriteLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">long</span> next, deadline;</span><br><span class="line">        <span class="keyword">if</span> ((next = tryWriteLock()) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">if</span> ((deadline = System.nanoTime() + nanos) == <span class="number">0L</span>)</span><br><span class="line">            deadline = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">if</span> ((next = acquireWrite(<span class="keyword">true</span>, deadline)) != INTERRUPTED)</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">writeLockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> next;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted() &amp;&amp;</span><br><span class="line">        (next = acquireWrite(<span class="keyword">true</span>, <span class="number">0L</span>)) != INTERRUPTED)</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取悲观读锁"><a href="#获取悲观读锁" class="headerlink" title="获取悲观读锁"></a>获取悲观读锁</h3><p>悲观读锁(非独占锁)，为获得锁一直处于阻塞状态，直到获得锁为止，不响应中断。返回非 0 代表成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s = state, next;  <span class="comment">// bypass acquireRead on common uncontended case</span></span><br><span class="line">    <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT)) ?</span><br><span class="line">            next : acquireRead(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>whead == wtail</code> 代表队列为空 ，<code>s &amp; ABITS) &lt; RFULL</code> 没有写锁且读锁数小于 126 。<code>compareAndSwapLong</code> 表示通过 CAS 更新同步状态值 state。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> s, m, next;</span><br><span class="line">        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) == WBIT)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((next = tryIncReaderOverflow(s)) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryReadLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, m, next, deadline;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) != WBIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT))</span><br><span class="line">                    <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((next = tryIncReaderOverflow(s)) != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">if</span> ((deadline = System.nanoTime() + nanos) == <span class="number">0L</span>)</span><br><span class="line">            deadline = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">if</span> ((next = acquireRead(<span class="keyword">true</span>, deadline)) != INTERRUPTED)</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> next;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted() &amp;&amp;</span><br><span class="line">        (next = acquireRead(<span class="keyword">true</span>, <span class="number">0L</span>)) != INTERRUPTED)</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取乐观读锁"><a href="#获取乐观读锁" class="headerlink" title="获取乐观读锁"></a>获取乐观读锁</h3><p>相对于悲观读锁来说的，在操作数据前并没有通过 CAS 设置锁的状态，仅仅是通过位运算测试。如果当前没有线程持有写锁，则简单的返回一个非 0 的 stamp 版本信息。由于 <code>tryOptimisticRead</code> 并没有使用 CAS 设置锁状态，所以不需要显示的释放该锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryOptimisticRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s;</span><br><span class="line">    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取该 stamp 后在具体操作数据前还需要调用 <code>validate</code> 验证下该 stamp 是否已经不可用，也就是看当调用 <code>tryOptimisticRead</code> 返回 stamp 后，到当前时间是否有其它线程持有了写锁。如果是那么 <code>validate</code> 会返回 0，否者就可以使用该 stamp 版本的锁对数据进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean validate(long stamp) &#123;</span><br><span class="line">    U.loadFence();</span><br><span class="line">    return (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用乐观读锁还是很容易犯错误的，必须要严谨。需要遵循相应的调用模板(判断共享变量是否已经被其他线程写过，如果被写过则升级为悲观读锁)，防止出现数据不一致的问题。</strong></p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>锁释放需要锁状态和 stamp 匹配，才能释放对应的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果锁状态和 stamp 匹配，则释放写锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    WNode h;</span><br><span class="line">    <span class="keyword">if</span> (state != stamp || (stamp &amp; WBIT) == <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    state = (stamp += WBIT) == <span class="number">0L</span> ? ORIGIN : stamp;</span><br><span class="line">    <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">        release(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果锁状态和 stamp 匹配，则释放读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, m; WNode h;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((s = state) &amp; SBITS) != (stamp &amp; SBITS) ||</span><br><span class="line">            (stamp &amp; ABITS) == <span class="number">0L</span> || (m = s &amp; ABITS) == <span class="number">0L</span> || m == WBIT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                    release(h);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果锁状态和 stamp 匹配，则释放相关模式的锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = stamp &amp; ABITS, m, s; WNode h;</span><br><span class="line">    <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            state = (s += WBIT) == <span class="number">0L</span> ? ORIGIN : s;</span><br><span class="line">            <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                release(h);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0L</span> || a &gt;= WBIT)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                    release(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放读锁、写锁的 “try” 版本，即“一次性”版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryUnlockWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> s; WNode h;</span><br><span class="line">     <span class="keyword">if</span> (((s = state) &amp; WBIT) != <span class="number">0L</span>) &#123;</span><br><span class="line">         state = (s += WBIT) == <span class="number">0L</span> ? ORIGIN : s;</span><br><span class="line">         <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">             release(h);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryUnlockRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> s, m; WNode h;</span><br><span class="line">     <span class="keyword">while</span> ((m = (s = state) &amp; ABITS) != <span class="number">0L</span> &amp;&amp; m &lt; WBIT) &#123;</span><br><span class="line">         <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">             <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                     release(h);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="锁转换"><a href="#锁转换" class="headerlink" title="锁转换"></a>锁转换</h3><p><code>StampedLock</code> 读写锁之间可以互相转换，可以更细粒度控制并发。包括三种转换：</p><ol><li>转换成写锁</li><li>转换成悲观读锁</li><li>转换成乐观读锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试转换成写锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryConvertToWriteLock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = stamp &amp; ABITS, m, s, next;</span><br><span class="line">    <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">return</span> stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == RUNIT &amp;&amp; a != <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                     next = s - RUNIT + WBIT))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试转换成悲观读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryConvertToReadLock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = stamp &amp; ABITS, m, s, next; WNode h;</span><br><span class="line">    <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT))</span><br><span class="line">                    <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((next = tryIncReaderOverflow(s)) != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            state = next = s + (WBIT + RUNIT);</span><br><span class="line">            <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                release(h);</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a != <span class="number">0L</span> &amp;&amp; a &lt; WBIT)</span><br><span class="line">            <span class="keyword">return</span> stamp;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试转换成乐观读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryConvertToOptimisticRead</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = stamp &amp; ABITS, m, s, next; WNode h;</span><br><span class="line">    U.loadFence();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((s = state) &amp; SBITS) != (stamp &amp; SBITS))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            state = next = (s += WBIT) == <span class="number">0L</span> ? ORIGIN : s;</span><br><span class="line">            <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                release(h);</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0L</span> || a &gt;= WBIT)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s - RUNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                    release(h);</span><br><span class="line">                <span class="keyword">return</span> next &amp; SBITS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((next = tryDecReaderOverflow(s)) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> next &amp; SBITS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>和 <code>ReadWritLock</code>相比，在一个线程情况下，是读速度其4倍左右，写是1倍。</p><img src="/images/StampedLock1.png" width="800px" height="500px" align="center"><p>和 <code>ReadWritLock</code>相比，六个线程情况下，读性能是其几十倍，写性能也是近10倍左右。</p><img src="/images/StampedLock2.png" width="800px" height="500px" align="center"><p>和 <code>ReadWritLock</code>相比，吞吐量提高</p><img src="/images/StampedLock3.png" width="800px" height="500px" align="center"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>StampedLock</code> 提供的读写锁与 <code>ReentrantReadWriteLock</code> 类似，前者不支持重入，不支持条件变量，也就是没 <code>Condition</code>。不过前者通过提供乐观读锁在多线程多读的情况下能提供更好的性能，这是因为获取乐观读锁时候不需要进行 CAS 操作设置锁的状态，而只是简单的测试状态。</p><p><strong><code>writeLock()</code> 或者 <code>readLock()</code> 获得锁之后，线程还没执行完就被 <code>interrupt()</code> 的话，会导致 CPU 飙升。</strong></p><p>另外，<code>StampedLock</code> 使用时要特别小心，避免锁重入的操作，在使用乐观读锁时也需要遵循相应的调用模板，防止出现数据不一致的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;读写锁如果使用不当，
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="StampedLock" scheme="https://muhouer.github.io/tags/StampedLock/"/>
    
  </entry>
  
  <entry>
    <title>AtomicInteger解析</title>
    <link href="https://muhouer.github.io/posts/4f6208ca/"/>
    <id>https://muhouer.github.io/posts/4f6208ca/</id>
    <published>2019-09-15T14:29:00.000Z</published>
    <updated>2019-09-15T14:30:52.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文代码基于 JDK 8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>AtomicInteger</code> 是 <code>Integer</code> 类型的线程安全原子类，可以在应用程序中以原子方式更新 int 值，是 atomic 框架中经常使用的原子类。</p><h2 id="AtomicInteger-使用示例"><a href="#AtomicInteger-使用示例" class="headerlink" title="AtomicInteger 使用示例"></a>AtomicInteger 使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger atomicRace = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    atomicRace.incrementAndGet();</span><br><span class="line">    race++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">      threads[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10000</span>; i1++) &#123;</span><br><span class="line">          increase();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">      threads[i].join();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"atomic race: "</span> + atomicRace);</span><br><span class="line">    System.out.println(<span class="string">"       race: "</span> + race);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atomic race: 200000</span><br><span class="line">       race: 114084</span><br></pre></td></tr></table></figure><p>由于自增操作并不能保证原子性，所以并发情况下 race 的值每次不太一样，而使用 <code>AtomicInteger</code> 可以保证自增操作原子性，使得每次结果都是 200000。</p><h2 id="AtomicInteger-底层实现"><a href="#AtomicInteger-底层实现" class="headerlink" title="AtomicInteger 底层实现"></a>AtomicInteger 底层实现</h2><p><code>AtomicInteger</code> 继承 <code>Number</code>，底层是通过 <code>Unsafe</code> 类做 CAS 操作，来原子的更新状态值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line">    <span class="comment">// 使用 Unsafe.compareAndSwapInt 去更新状态值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AtomicIntegerd 的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 根据 initialValue 创建一个新的 AtomicInteger 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个新的 AtomicInteger</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicInteger-常用方法"><a href="#AtomicInteger-常用方法" class="headerlink" title="AtomicInteger 常用方法"></a>AtomicInteger 常用方法</h2><p><code>AtomicInteger</code> 常用方法包括原子的加、减等，类似 i++、++i、i–、–i 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 newValue 设置为当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将旧状态值设置为 newValue 并返回旧状态值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果expect值和当前值相等且原子的设置当前值为 update，则返回 true，否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值加一，返回之前的状态值，先取后增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值减一，返回之前的状态值，先取后减</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值加 delta，返回之前的状态值，先取后增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值减 delta，返回之前的状态值，先增后取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值减一，返回当前的状态值，先减后取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值加 delta，返回当前的状态值，先增后取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicInteger-特殊方法"><a href="#AtomicInteger-特殊方法" class="headerlink" title="AtomicInteger 特殊方法"></a>AtomicInteger 特殊方法</h2><h3 id="lazySet-方法"><a href="#lazySet-方法" class="headerlink" title="lazySet 方法"></a>lazySet 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set() 方法的不可见版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// putOrderedInt 设置值并且马上写入主存，该变量必须是 volatile 类型</span></span><br><span class="line">    unsafe.putOrderedInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lazySet()</code>⽅法是 <code>set()</code> ⽅法的不可⻅版本。通过 <code>volatile</code> 修饰的变量，可以保证在多处理器环境下的<strong>可⻅性</strong>，即当⼀个线程修改⼀个共 享变量时，其它线程能⽴即读到这个修改的值。</p><p><code>volatile</code> 的实现加了内存屏障：</p><ol><li>保证写 <code>volatile</code> 变量时会强制把 CPU 写缓存区的数据刷新到内存。</li><li>读 <code>volatile</code> 变量时，使缓存失效，强制从内存中读取最新的值。</li><li>由于内存屏障的存在，volatile变量还能阻⽌重排序。</li></ol><p><code>lazySet</code> 内部调⽤了 Unsafe 类的 <code>putOrderedInt</code> ⽅法，通过该⽅法对共享变量值的改变，不⼀定能被其他线 程⽴即看到。也就是说以普通变量的操作⽅式来写变量。</p><p>什么情况下需要使⽤ <code>lazySet</code> 呢？ 考虑下⾯这样⼀个场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ai.set(1);</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于锁的存在：</p><ul><li><code>lock()</code> ⽅法获取锁时，和 <code>volatile</code> 变量的读操作⼀样，会强制使 CPU 缓存失效，强制从内存读取变量。</li><li><code>unlock()</code> ⽅法释放锁时，和 <code>volatile</code> 变量的写操作⼀样，会强制刷新 CPU 写缓冲区，把缓存数据写到主内存。</li></ul><p>所以，上述 <code>ai.set(1)</code>可以⽤ <code>ai.lazySet(1)</code> ⽅法替换： <strong>由锁来保证共享变量的可⻅性，以设置普通变量的⽅式来修改共享变量，减少不必要的内存屏障，从⽽提⾼ 程序执⾏的效率。</strong></p><h3 id="weakCompareAndSet-方法"><a href="#weakCompareAndSet-方法" class="headerlink" title="weakCompareAndSet 方法"></a>weakCompareAndSet 方法</h3><p><code>weakCompareAndSet</code> 操作仅保留了 <code>volatile</code>自身变量的特性，而去除了 <strong>happens-before</strong> 规则带来的内存语义。也就是说，<code>weakCompareAndSet</code> 无法保证处理操作目标的 <code>volatile</code> 变量外的其他变量的执行顺序( 编译器和处理器为了优化程序性能而对指令序列进行重新排序 )，同时也无法保证这些变量的可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JDK 8 及之前的版本，<code>weakCompareAndSet</code> 方法并没有被真正意义上的实现，目前该方法所呈现出来的效果与 <code>compareAndSet</code> 方法是一样的。</p><p>在 JDK 9 中 <code>compareAndSet</code> 和 <code>weakCompareAndSet</code> 方法的实现有些许的不同</p><ol><li>底层调用的 native 方法的实现中，<code>cmpxchgb</code> 指令前都会有“<code>lock</code>”前缀，而在 JDK 8 中，程序会根据当前处理器的类型来决定是否为 <code>cmpxchg</code> 指令添加 <code>lock</code> 前缀，只有在 CPU 是多处理器(multi processors)的时候，会添加一个 <code>lock</code> 前缀)。</li><li>新增 <code>@HotSpotIntrinsicCandidate</code> 注解，该注解是特定于 Java 虚拟机的注解。通过该注解表示的方法可能( 但不保证 )通过 HotSpot VM 自己来写汇编或IR编译器来实现该方法以提供性能。</li></ol><h2 id="AtomicInteger-新增方法"><a href="#AtomicInteger-新增方法" class="headerlink" title="AtomicInteger 新增方法"></a>AtomicInteger 新增方法</h2><p>在 JDK 8 中，<code>AtomicInteger</code> 新增了一些方法，使用 JDK 8 的函数式接口。不过这些函数应该是无副作用的，因为当尝试的更新时，如果由于线程争用更新失败，可能会重新应用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子的将给定函数的结果更新当前值，并返回旧值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        <span class="comment">// 将此运算符 applyAsInt 应用于给定的操作数 prev</span></span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子的将函数的结果更新当前值，并返回新值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子的将函数的结果和 x 的计算结果更新当前值，并返回新值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAccumulate</span><span class="params">(<span class="keyword">int</span> x, IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子地根据给定函数的结果和 x 的计算结果更新当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">accumulateAndGet</span><span class="params">(<span class="keyword">int</span> x, IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        <span class="comment">// 将此运算符 applyAsInt 应用于给定的操作数 prev</span></span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicInteger-溢出问题"><a href="#AtomicInteger-溢出问题" class="headerlink" title="AtomicInteger 溢出问题"></a>AtomicInteger 溢出问题</h2><p>使用了 <code>AtomicInteger</code> 的 <code>incrementAndGet</code> 方法不断的增加，如果 <code>AtomicInteger</code> 增加到了2147483647 (即) 再加一，<code>AtomicInteger</code> 的值会变成负数 -2147483648。如果不对其作出处理，当资源数目不断累积超过最大值变成负数的时候。</p><p>比如可以在 <code>AtomicInteger</code> 变量达到最大值的时候，转为零重新开始计数，并保证 <code>AtomicInteger</code> 在多线程环境下的原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> current;</span><br><span class="line">  <span class="keyword">int</span> next;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    current = <span class="keyword">this</span>.i.get();</span><br><span class="line">    next = current &gt;= Integer.MAX_VALUE ? <span class="number">0</span> : current + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!<span class="keyword">this</span>.i.compareAndSet(current, next));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> current;</span><br><span class="line">  <span class="keyword">int</span> next;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    current = <span class="keyword">this</span>.i.get();</span><br><span class="line">    next = current &lt;= <span class="number">0</span> ? Integer.MAX_VALUE : current - <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!<span class="keyword">this</span>.i.compareAndSet(current, next));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>AtomicInteger</code> <strong>使用非阻塞算法实现并发控制</strong>，在一些高并发程序中非常适合，但并不代表每一种场景都适合，不同场景要使用使用不同的数值类。比如 <code>AtomicBoolean</code>、<code>AtomicLong</code> 等。</p><p><code>AtomicIntegerArray</code> 或 <code>AtomicLongArray</code> 操作类似，不过它们对应的数组，操作的是数组中的某个元素，通过索引对值进行操作。</p><h2 id="其他-Atomic-类"><a href="#其他-Atomic-类" class="headerlink" title="其他 Atomic 类"></a>其他 Atomic 类</h2><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><p>可以原子更新的对象引用。和 <code>AtomicInteger</code> 类似，少了一些数字类型的“加”、”减”操作，支持泛型，具体含义和方法名息息相关，具体实现和 <code>AtomicInteger</code> 也类似。<code>AtomicReferenceArray</code> 则和 <code>AtomicIntegerArray</code> 类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1848883965231344442L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 initialValue 创建一个 AtomicReference 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">(V initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicReference with null initial value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 创建一个空 AtomicReference 对象，value 为 null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(V expect, V update)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndUpdate</span><span class="params">(UnaryOperator&lt;V&gt; updateFunction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">updateAndGet</span><span class="params">(UnaryOperator&lt;V&gt; updateFunction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndAccumulate</span><span class="params">(V x, BinaryOperator&lt;V&gt; accumulatorFunction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">accumulateAndGet</span><span class="params">(V x, BinaryOperator&lt;V&gt; accumulatorFunction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h3><p>基于反射的实用工具，可以对指定类的指定 volatile int 字段进行原子更新。此类用于原子数据结构，该结构中同一节点的几个字段都独立受原子更新控制。此类中 <code>compareAndSet</code>方法的保证弱于其他原子类中该方法的保证。因为此类不能确保所有使用的字段都适合于原子访问目的，所以对于相同更新器上的 <code>compareAndSet</code> 和 <code>set</code> 的其他调用，它仅可以保证原子性和可变语义。</p><p>有如下限制：</p><ol><li>操作的 int 字段必须是基本类型数据，用volatile修饰，不能是包装类型，int、long就可以，但是不可以是Integer和Long；</li><li>必须是实例变量，不可以是类变量；</li><li>必须是可变的变量，不能是final修饰的变量。</li></ol><p>示例如下：</p><p>定义一个 Person 类，有一个 id 字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 id 字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指定 Person 对象和 id 字段</span></span><br><span class="line">  AtomicIntegerFieldUpdater&lt;Person&gt; personAtomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Person.class, <span class="string">"id"</span>);</span><br><span class="line">  Person person = <span class="keyword">new</span> Person(<span class="number">99999</span>);</span><br><span class="line">  personAtomicIntegerFieldUpdater.compareAndSet(person, <span class="number">99999</span>, <span class="number">99999</span>);</span><br><span class="line">  System.out.println(<span class="string">"id="</span> + person.getId());</span><br><span class="line">  Person person1 = <span class="keyword">new</span> Person(<span class="number">99999</span>);</span><br><span class="line">  personAtomicIntegerFieldUpdater.incrementAndGet(person1);</span><br><span class="line">  System.out.println(<span class="string">"id="</span> + person1.getId());</span><br><span class="line">  IntBinaryOperator intBinaryOperator = (left, right) -&gt; left+right;</span><br><span class="line">  personAtomicIntegerFieldUpdater.getAndAccumulate(person1, <span class="number">1</span>, intBinaryOperator);</span><br><span class="line">  System.out.println(<span class="string">"id="</span> + person1.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从示例来看，具体操作和 <code>AtomicInteger</code> 操作起来其实和是一样的。只不过操作之前需要指定对哪个对象的哪个字段进行操作。</p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p>在运用 CAS 做锁释放操作中有一个经典的 ABA问题：</p><blockquote><p>在线程1准备用 CAS 将变量的值由A替换为B之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行 CAS 时发现变量的值仍然为A，所以 CAS 成功。但实际上这时的现场已经和最初不同了，尽管 CAS 成功，但可能存在潜藏的问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 内部 Pair 类，一个[reference, stamp]元组 。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="comment">// 版本戳</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据初始 initialRef 和 initialStamp 创建一个 AtomicStampedReference 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;</span><br><span class="line">        pair = Pair.of(initialRef, initialStamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各种乐观锁的实现中通常都会用版本戳 version 来对记录或对象标记，避免并发操作带来的问题，在 Java 中，<code>AtomicStampedReference&lt;V&gt;</code>也实现了这个作用，它通过包装 [E,Integer] 的元组来对对象标记版本戳 stamp，从而避免 ABA 问题。</p><p><code>AtomicMarkableReference</code> 与 <code>AtomicStampedReference</code> ，不过前者版本戳 <code>final int stamp</code> 变成了 <code>final boolean mark</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;本文代码基于 JDK 8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Ato
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="AtomicInteger" scheme="https://muhouer.github.io/tags/AtomicInteger/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal分析</title>
    <link href="https://muhouer.github.io/posts/90bf09a1/"/>
    <id>https://muhouer.github.io/posts/90bf09a1/</id>
    <published>2019-09-13T19:11:00.000Z</published>
    <updated>2019-09-14T17:21:07.555Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ThreadLocal</code> 的官方API解释为：</p><blockquote><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p></blockquote><ol><li><p><code>ThreadLocal</code> 提供了一种访问某个变量的特殊方式：访问到的变量属于当前线程，即保证每个线程的变量不一样，而同一个线程在任何地方拿到的变量都是一致的，这就是所谓的线程隔离。</p></li><li><p>如果要使用 <code>ThreadLocal</code> ，通常定义为 <code>private static</code> 类型，最好是定义为 <code>private static final</code> 类型。</p></li></ol><p>即 <strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</strong></p><h2 id="ThreadLocal-类结构"><a href="#ThreadLocal-类结构" class="headerlink" title="ThreadLocal 类结构"></a>ThreadLocal 类结构</h2><p><code>ThreadLocal</code> 类结构如下：<br><img src="/images/ThreadLocal.png" width="800px" height="500px" align="center"></p><p><code>ThreadLocalMap</code>、<code>SuppliedThreadLocal</code> 是 <code>ThreadLocal</code> 内部类，且 <code>SuppliedThreadLocal</code> 继承自 <code>ThreadLocal</code>， <code>Entry</code> 是 <code>ThreadLocalMap</code> 内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 下一个哈希值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line">    <span class="comment">// 下一个要给出的哈希值，原子更新，从 0 开始。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">// 连续生成的散列码之间的差异：将隐式顺序线程局部id转换为近似最优分布的乘法散列值，以获得两个大小表的幂。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap-实现"><a href="#ThreadLocalMap-实现" class="headerlink" title="ThreadLocalMap 实现"></a>ThreadLocalMap 实现</h2><p><code>ThreadLocalMap</code> 是一个定制的散列映射，仅适用于维护线程本地值。该类是包私有的，允许在 <code>Thread</code> 类中声明字段。在 <code>ThreadLocal</code> 类之外不做任何操作。为了帮助处理占用内存大和存活时间长的用法，哈希表 <code>Entry</code> 使用弱引用作为键。但是，由于不使用引用队列，因此只有当表开始耗尽空间时，才保证删除过时的条目。</p><p><strong>每个线程可能有多个 <code>ThreadLocal</code>，同一线程的各个<code>ThreadLocal</code> 存放于同一个 <code>ThreadLocalMap</code> 中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** 和当前 ThreadLocal 有关 */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code> 具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 哈希表 Entry</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** 该值和当前 ThreadLocal 对象有关 */</span></span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哈希表初始容量，必须是 2 的指数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// Entry表，需要的时候会调整表大小，表大小一定是 2 的指数。</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="comment">// 表中 Entry 数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Entry表大小调整的阈值，默认是 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">    <span class="comment">// 设置阈值为表长度的 2/3</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取下一个 index，i+1&lt;len 则返回 i + 1，否则返回 0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取上一个 index，i - 1 &gt;= 0 则返回 i-1，否则返回 len-1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** ThreadLocalMap 构造函数 */</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">// 创建大小为 INITIAL_CAPACITY 的 Entry表</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="comment">// 根据 firstKey 的哈希值和初始容量获取元素 index</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置表的元素</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置表大小调整阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 根据 parentMap 构造 ThreadLocalMap */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line">                    Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                    <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 根据 key 获取 Entry */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        Entry e = table[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在其直接哈希槽中找不到密钥时使用的GetEntry方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">            e = tab[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** ThreadLocalMap set 方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> sz = ++size;</span><br><span class="line">        <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 从 ThreadLocalMap 中移除 key */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                e.clear();</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用指定 key 的项替换 set 操作期间遇到的过时项</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        Entry e;</span><br><span class="line">        <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = prevIndex(i, len))</span><br><span class="line">            <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line"></span><br><span class="line">                tab[i] = tab[staleSlot];</span><br><span class="line">                tab[staleSlot] = e;</span><br><span class="line">                <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">                <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">        <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过重新清除位于过时槽和下一个空槽之间的任何可能发生冲突的条目来删除过时的条目</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">        Entry e;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    tab[h] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 试探性地扫描一些单元格以查找过时的条目。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">            Entry e = tab[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                n = len;</span><br><span class="line">                removed = <span class="keyword">true</span>;</span><br><span class="line">                i = expungeStaleEntry(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 重新哈希 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        expungeStaleEntries();</span><br><span class="line">        <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">            resize();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 调整 Entry 表大小，大小变为原来的 2 倍 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">        Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">            Entry e = oldTab[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, newLen);</span><br><span class="line">                    newTab[h] = e;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setThreshold(newLen);</span><br><span class="line">        size = count;</span><br><span class="line">        table = newTab;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 删除表中所有过时的项 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = tab[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">                expungeStaleEntry(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SuppliedThreadLocal-实现"><a href="#SuppliedThreadLocal-实现" class="headerlink" title="SuppliedThreadLocal 实现"></a>SuppliedThreadLocal 实现</h2><p><code>SuppliedThreadLocal</code> 是 JDK8 新增的内部类，只是扩展了 <code>ThreadLocal</code> 的初始化值的方法而已，允许使用 JDK8 新增的 Lambda 表达式赋值。需要注意的是，函数式接口 <code>Supplier</code> 不允许为 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppliedThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Supplier容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class="line">    <span class="comment">// SuppliedThreadLocal 构造方法</span></span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">        <span class="comment">// supplier == null 会抛出空指针异常</span></span><br><span class="line">        <span class="keyword">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用get()方法，此时会调用对象的构造方法，即获得到真正对象</span></span><br><span class="line">        <span class="comment">// 每次get都会调用构造方法，即获取的对象不同</span></span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal-的基本方法"><a href="#ThreadLocal-的基本方法" class="headerlink" title="ThreadLocal 的基本方法"></a>ThreadLocal 的基本方法</h2><p><code>ThreadLocal</code> 的基本方法包括取值、设置初始值、赋值、移除等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 根据当前线程获取本地线程 Map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123; <span class="comment">// 本地线程Map不为空</span></span><br><span class="line">        <span class="comment">// 获取当前对象对应的本地线程 Map 的 Entry 对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// Entry 对象不为空</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置初始值后返回初始值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置初始值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 继承 ThreadLocal 后重写，参考 SuppliedThreadLocal</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 本地线程 Map 不存在则创建</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建本地线程 Map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前对象对应的本地线程 Map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 覆盖</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 本地线程 Map 不存在则创建</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建线程局部变量。变量的初始值是通过调用&#123;@code supplier&#125;上的&#123;@code get&#125;方法来确定的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>变量有局部的还有全局的，局部变量没什么好说的，一涉及到全局，那自然就会出现多线程的安全问题，要保证多线程安全访问，不出现脏读脏写，那就要涉及到线程同步了。而 <code>ThreadLocal</code> 相当于提供了介于局部变量与全局变量中间的这样一种线程内部的全局变量。</p><p>当我们只想在本身的线程内使用的变量，可以用 <code>ThreadLocal</code> 来实现，并且这些变量是和线程的生命周期密切相关的，线程结束，变量也就销毁了。 <code>ThreadLocal</code> 不是为了解决线程间的共享变量问题的，如果是多线程都需要访问的数据，那需要用全局变量加同步机制。</p><ol><li>线程中处理一个非常复杂的业务，可能方法有很多，那么，使用 <code>ThreadLocal</code> 可以代替一些参数的显式传递；</li><li>在一些多线程的情况下，如果用线程同步的方式，当并发比较高的时候会影响性能，可以改为 <code>ThreadLocal</code> 的方式，例如高性能序列化框架 Kyro 就要用 <code>ThreadLocal</code> 来保证高性能和线程安全；</li><li>线程内上下文管理器、数据库连接等可以用到 <code>ThreadLocal</code> ;</li><li>用来存储用户 Session。Session 的特性很适合 <code>ThreadLocal</code> ，因为 Session 之前当前会话周期内有效，会话结束便销毁。</li></ol><h2 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h2><p><code>ThreadLocal</code> 的不正确使用会导致内存泄漏。实际上 <code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。JVM 利用调用 remove、get、set 方法的时候，会清除线程 <code>ThreadLocalMap</code> 里所有 key 为 null 的 value，回收弱引用。</p><p>所以如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 <code>ThreadLocalMap</code> 中使用这个 <code>ThreadLocal</code> 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p><p>当使用静态 <code>ThreadLocal</code> 的时候，延长 <code>ThreadLocal</code> 的生命周期，那也可能导致内存泄漏。因为，静态变量在类未加载的时候，它就已经加载，当线程结束的时候，静态变量不一定会回收。</p><p><code>ThreadLocal</code> 出现内存泄漏条件：</p><ol><li><code>ThreadLocal</code> 引用被设置为 null，且后面没有 set、get、remove 操作。</li><li>线程一直运行，不停止。（线程池）</li><li>触发了垃圾回收。（Minor GC或Full GC）</li></ol><p>如何避免内存泄漏：</p><ol><li><code>ThreadLocal</code> 声明为 <code>private final</code>。 <code>private</code> 与 <code>final</code> 尽可能不让他人修改变更引用，最好不要声明为静态的。</li><li><code>ThreadLocal</code> 使用后务必调用 <code>remove</code> 方法。最简单有效的方法是使用后将其移除。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ThreadLocalMap</code> 并不是为了解决线程安全问题，而是提供了一种将实例绑定到当前线程的机制，类似于隔离的效果。每个线程维护一个 <code>ThreadLocalMap</code> 的映射表，映射表的 key 是 <code>ThreadLocal</code> 实例本身，value 是要存储的副本变量。<code>ThreadLocal</code> 实例本身并不存储值，它只是提供一个在当前线程中找到副本值的 key。</p><p><code>ThreadLocal</code> 设计的初衷是为了解决多线程编程中的资源共享问题。对比 <code>synchronized</code>，<code>synchronized</code> 采取的是“以时间换空间”的策略，本质上是对关键资源上锁，让大家排队操作。而 <code>ThreadLocal</code> 采取的是“以空间换时间”的思路，为每个使用该变量的线程提供独立的变量副本，在本线程内部，它相当于一个“全局变量”，可以保证本线程任何时间操纵的都是同一个对象。</p><p><code>ThreadLocal</code> 类最重要的一个概念是，其原理是通过一个 <code>ThreadLocal</code> 的静态内部类 <code>ThreadLocalMap</code> 实现，但是实际中，<code>ThreadLocal</code> 不保存 <code>ThreadLocalMap</code>，而是有每个 Thread 内部维护 <code>ThreadLocal.ThreadLocalMap threadLocals</code> 一份数据结构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Thre
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
      <category term="ThreadLocal" scheme="https://muhouer.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore解析</title>
    <link href="https://muhouer.github.io/posts/e73eaf42/"/>
    <id>https://muhouer.github.io/posts/e73eaf42/</id>
    <published>2019-09-13T04:15:00.000Z</published>
    <updated>2019-09-13T19:14:55.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Semaphore</code> 是JDK1.5的 <code>java.util.concurrent</code> 并发包中提供的一个并发工具类。所谓 <code>Semaphore</code> 即 信号量 的意思。这个叫法并不能很好地表示它的作用，更形象的说法应该是 许可证管理器 。</p><p><code>Semaphore</code> 是一个计数信号量。</p><ul><li>从概念上将，<code>Semaphore</code> 包含一组许可证。</li><li>如果有需要的话，每个 <code>acquire()</code> 方法都会阻塞，直到获取一个可用的许可证。</li><li>每个 <code>release()</code> 方法都会释放持有许可证的线程，并且归还 <code>Semaphore</code> 一个可用的许可证。</li><li>实际上并没有真实的许可证对象供线程使用，<code>Semaphore</code> 只是对可用的数量进行管理维护。</li></ul><h2 id="Semaphore类结构"><a href="#Semaphore类结构" class="headerlink" title="Semaphore类结构"></a>Semaphore类结构</h2><p><code>Semaphore</code> 类结构如下：</p><img src="/images/Semaphore.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code>、<code>FairSync</code>、<code>NonfairSync</code> 是 <code>Semaphore</code> 的内部类。<code>FairSync</code>、<code>NonfairSync</code> 均继承自 <code>Sync</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NonFair version</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 无论当前线程是不是在 CLH 队列的头部，它都会直接获取信号量。</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fair version</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前线程不在 CLH 队列的头部，则排队等候。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="comment">// 判断当前线程是不是在 CLH 队列的头部</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非公平模式共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享式释放同步状态</span></span><br><span class="line">    <span class="comment">// “非公平信号量许可的释放(release)”与“公平信号量许可的释放(release)”是一样的。 </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减少许可数</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取并返回立即可用的所有许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore-构造方法"><a href="#Semaphore-构造方法" class="headerlink" title="Semaphore 构造方法"></a>Semaphore 构造方法</h2><p>构造方法分为两种，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建具有给定的许可数和非公平模式的 Semaphore</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建具有给定的许可数和指定是否公平模式的 Semaphore</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore-获取、释放许可的方法"><a href="#Semaphore-获取、释放许可的方法" class="headerlink" title="Semaphore 获取、释放许可的方法"></a>Semaphore 获取、释放许可的方法</h2><p>获取、释放许可的方法分为两大类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 阻塞方法：</span></span><br><span class="line"><span class="comment"> * 1. 无许可能够获得，则会一直等待，直到获得许可。</span></span><br><span class="line"><span class="comment"> * 2. 在释放许可之前，必须先获获得许可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 获取一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 获取permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>; <span class="comment">// 释放一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span></span>; <span class="comment">// 释放permits个许可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 非阻塞方法：</span></span><br><span class="line"><span class="comment"> * 立即获取执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"><span class="comment">//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span></span>; </span><br><span class="line"><span class="comment">//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><h2 id="Semaphore的其他方法"><a href="#Semaphore的其他方法" class="headerlink" title="Semaphore的其他方法"></a>Semaphore的其他方法</h2><p>其他方法包括获取当前可用许可数、获取队列正在等待许可的线程数目、是否是公平模式等，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回此信号量中当前可用的许可数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回正在等待获取的线程的估计数目。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取并返回立即可用的所有许可。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 查询是否有线程正在等待获取。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 如果此信号量的公平设置为 true，则返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回标识此信号量的字符串，以及信号量的状态。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 collection，包含可能等待获取的线程。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 根据指定的缩减量减小可用许可的数目。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reduction)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Semaphore的使用"><a href="#Semaphore的使用" class="headerlink" title="Semaphore的使用"></a>Semaphore的使用</h2><p><code>Semaphore</code> 经常用于限制获取某种资源的线程数量。</p><p>以请求总数为 6，并发执行的线程数为 2 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求总数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 并发执行的线程数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 随机数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">      executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire(<span class="number">1</span>);</span><br><span class="line">          System.out.println(<span class="string">"处理请求 "</span> + count + <span class="string">" 前，当前许可证数量："</span> + semaphore.availablePermits());</span><br><span class="line">          resolve(count);</span><br><span class="line">          System.out.println(<span class="string">"处理请求 "</span> + count + <span class="string">" 中，正在等待许可证的请求数量："</span> + semaphore.getQueueLength());</span><br><span class="line">          semaphore.release(<span class="number">1</span>);</span><br><span class="line">          System.out.println(<span class="string">"处理请求 "</span> + count + <span class="string">" 后，当前许可证数量："</span> + semaphore.availablePermits());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolve</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"请求 "</span> + i + <span class="string">" 开始处理"</span>);</span><br><span class="line">    <span class="keyword">int</span> r = random.nextInt(i + <span class="number">3</span>) + <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"请求 "</span> + i + <span class="string">"处理"</span> + r + <span class="string">"秒"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span> * r);</span><br><span class="line">    System.out.println(<span class="string">"请求 "</span> + i + <span class="string">" 结束处理"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">处理请求 0 前，当前许可证数量：0</span><br><span class="line">处理请求 1 前，当前许可证数量：0</span><br><span class="line">请求 0 开始处理</span><br><span class="line">请求 1 开始处理</span><br><span class="line">请求 0处理4秒</span><br><span class="line">请求 1处理2秒</span><br><span class="line">请求 1 结束处理</span><br><span class="line">处理请求 1 中，正在等待许可证的请求数量：4</span><br><span class="line">处理请求 1 后，当前许可证数量：1</span><br><span class="line">处理请求 2 前，当前许可证数量：0</span><br><span class="line">请求 2 开始处理</span><br><span class="line">请求 2处理5秒</span><br><span class="line">请求 0 结束处理</span><br><span class="line">处理请求 0 中，正在等待许可证的请求数量：3</span><br><span class="line">处理请求 0 后，当前许可证数量：1</span><br><span class="line">处理请求 3 前，当前许可证数量：0</span><br><span class="line">请求 3 开始处理</span><br><span class="line">请求 3处理6秒</span><br><span class="line">请求 2 结束处理</span><br><span class="line">处理请求 2 中，正在等待许可证的请求数量：2</span><br><span class="line">处理请求 2 后，当前许可证数量：1</span><br><span class="line">处理请求 4 前，当前许可证数量：0</span><br><span class="line">请求 4 开始处理</span><br><span class="line">请求 4处理2秒</span><br><span class="line">请求 4 结束处理</span><br><span class="line">处理请求 4 中，正在等待许可证的请求数量：1</span><br><span class="line">处理请求 4 后，当前许可证数量：1</span><br><span class="line">处理请求 5 前，当前许可证数量：0</span><br><span class="line">请求 5 开始处理</span><br><span class="line">请求 5处理7秒</span><br><span class="line">请求 3 结束处理</span><br><span class="line">处理请求 3 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 3 后，当前许可证数量：1</span><br><span class="line">请求 5 结束处理</span><br><span class="line">处理请求 5 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 5 后，当前许可证数量：2</span><br></pre></td></tr></table></figure><p>当释放许可参数变成 2，即从 <code>semaphore.release(1)</code> 变成 <code>semaphore.release(2)</code>。执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">处理请求 0 前，当前许可证数量：0</span><br><span class="line">请求 0 开始处理</span><br><span class="line">请求 0处理4秒</span><br><span class="line">处理请求 1 前，当前许可证数量：0</span><br><span class="line">请求 1 开始处理</span><br><span class="line">请求 1处理3秒</span><br><span class="line">请求 1 结束处理</span><br><span class="line">处理请求 1 中，正在等待许可证的请求数量：4</span><br><span class="line">处理请求 1 后，当前许可证数量：2</span><br><span class="line">处理请求 2 前，当前许可证数量：1</span><br><span class="line">请求 2 开始处理</span><br><span class="line">处理请求 3 前，当前许可证数量：0</span><br><span class="line">请求 3 开始处理</span><br><span class="line">请求 3处理4秒</span><br><span class="line">请求 2处理5秒</span><br><span class="line">请求 0 结束处理</span><br><span class="line">处理请求 0 中，正在等待许可证的请求数量：2</span><br><span class="line">处理请求 0 后，当前许可证数量：2</span><br><span class="line">处理请求 4 前，当前许可证数量：1</span><br><span class="line">请求 4 开始处理</span><br><span class="line">处理请求 5 前，当前许可证数量：0</span><br><span class="line">请求 5 开始处理</span><br><span class="line">请求 5处理8秒</span><br><span class="line">请求 4处理2秒</span><br><span class="line">请求 4 结束处理</span><br><span class="line">处理请求 4 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 4 后，当前许可证数量：2</span><br><span class="line">请求 3 结束处理</span><br><span class="line">处理请求 3 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 3 后，当前许可证数量：4</span><br><span class="line">请求 2 结束处理</span><br><span class="line">处理请求 2 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 2 后，当前许可证数量：6</span><br><span class="line">请求 5 结束处理</span><br><span class="line">处理请求 5 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 5 后，当前许可证数量：8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Semaphore&lt;/code&gt; 是JDK1.5的 &lt;code&gt;java.util.concurrent&lt;/code&gt; 并发包中
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Semaphore" scheme="https://muhouer.github.io/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantReadWriteLock解析</title>
    <link href="https://muhouer.github.io/posts/cb5cf479/"/>
    <id>https://muhouer.github.io/posts/cb5cf479/</id>
    <published>2019-09-13T04:15:00.000Z</published>
    <updated>2019-09-13T16:52:49.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ReentrantReadWriteLock</code> 是 <code>Lock</code> 的另一种实现方式， <code>ReentrantLock</code> 是一个排他锁，同一时间只允许一个线程访问，而 <code>ReentrantReadWriteLock</code> 允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。</p><p>读写锁内部维护了两个锁，一个用于读操作，一个用于写操作。所有 <code>ReadWriteLock</code> 实现都必须保证 <code>writeLock</code> 操作的内存同步效果也要保持与相关 <code>readLock</code> 的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</p><p><code>ReentrantReadWriteLock</code> 支持以下功能：</p><ul><li>支持公平和非公平的获取锁的方式；</li><li>支持可重入。读线程在获取了读锁后还可以获取读锁，写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</li><li>允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；</li><li>读取锁和写入锁都支持锁获取期间的中断；</li><li>支持 Condition 。<strong>仅写入锁提供了一个 Conditon 实现，读取锁不支持 Conditon</strong> 。<code>readLock().newCondition()</code> 会抛出 <code>UnsupportedOperationException</code>。</li></ul><h2 id="ReentrantReadWriteLock-类结构"><a href="#ReentrantReadWriteLock-类结构" class="headerlink" title="ReentrantReadWriteLock 类结构"></a>ReentrantReadWriteLock 类结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6992448646407690164L</span>;</span><br><span class="line">    <span class="comment">/** 内部类提供读取锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/** 内部类提供写入锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">/** 执行所有同步机制 */</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁默认是非公平模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 支持指导锁公平模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写入锁</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">    <span class="comment">// 获取读取锁</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/ReentrantReadWriteLock.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code> 、<code>FairSync</code>、<code>NonfairSync</code>、<code>ReadLock</code>、<code>WriteLock</code> 是 <code>ReentrantReadWriteLock</code> 的内部类，<code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> ，而 <code>FairSync</code>、<code>NonfairSync</code> 继承 <code>Sync</code>，分别对应公平锁和非公平锁。<code>ThreadLocalHoldCounter</code> 、<code>HoldCounter</code>是 <code>Sync</code>的内部类。</p><h2 id="Sync-锁"><a href="#Sync-锁" class="headerlink" title="Sync 锁"></a>Sync 锁</h2><p><code>Sync</code> 也是一个继承于AQS的抽象类。<code>Sync</code> 也包括公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code>。sync 对象是 <code>FairSync</code> 和 <code>NonfairSync</code> 中的一个，默认是 <code>NonfairSync</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;</span><br><span class="line">    <span class="comment">/** Lock 状态逻辑上分为两个无符号 short 类型：</span></span><br><span class="line"><span class="comment">     * 1. 低位表示独占（writer）锁写入计数</span></span><br><span class="line"><span class="comment">     * 2. 高位表示共享（reader）锁读取次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回共享（reader）锁被持有次数  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    <span class="comment">/** 返回独占（writer）锁被持有次数  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">    <span class="comment">// 持有计数器：每个线程持有锁的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 为了避免垃圾滞留(garbage retention)，使用 id 而不是引用</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 本地线程持有锁的计数器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程持有的可重入读锁数。每当线程的读取保持计数降至0时删除。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">    <span class="comment">// 成功获取读锁的最后一个线程的保持计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">    <span class="comment">// 第一个获取读锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">    Sync() &#123;</span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        setState(getState()); <span class="comment">// 确保读取锁持有次数可见</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前线程尝试获取读锁，且在其他情况下有资格获取该锁，但由于超过其他等待线程的策略而应该阻塞，则返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程尝试获取写锁，且在其他情况下有资格获取该锁，但由于超过其他等待线程的策略而应该阻塞，则返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 释放写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (free)</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">// 获取当前状态</span></span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 获取写的状态</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 读状态不为0，读锁已获取</span></span><br><span class="line">            <span class="comment">// 写状态为 0 或 当前线程不是独占线程</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 增加写状态，写锁获取成功</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读锁未获取</span></span><br><span class="line">        <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">            !compareAndSetState(c, c + acquires))</span><br><span class="line">            <span class="comment">// 当前线程应该阻塞或通过 CAS 更新 state 为 c + acquires 失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 设置当前线程为独占线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 当前线程是第一个成功获取读锁的线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 线程读锁数量为1，那么第一个成功获取读锁的线程置为null</span></span><br><span class="line">                firstReader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 线程读锁数量减一</span></span><br><span class="line">                firstReaderHoldCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从缓存中获取当前线程的读锁数量</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                rh = readHolds.get();</span><br><span class="line">            <span class="keyword">int</span> count = rh.count; <span class="comment">// 当前线程的读锁数量</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 从本地线程移除读锁线程</span></span><br><span class="line">                readHolds.remove();</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 无读锁可以释放</span></span><br><span class="line">                    <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 线程读锁数量减一</span></span><br><span class="line">            --rh.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> nextc = c - SHARED_UNIT; <span class="comment">// state读锁状态减一</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// 如果state为0，表示无锁状态，返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">// 获取当前状态态</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="comment">// 写状态不为 0 且当前线程是独占线程</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c); <span class="comment">// 获取读状态</span></span><br><span class="line">        <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">            r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">            compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">// 读锁线程不阻塞、读取锁的共享计数未超过限制且通过 CAS 获取锁失败</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 读状态为 0</span></span><br><span class="line">                firstReader = current; <span class="comment">//当前线程是第一个成功获取读锁的线程</span></span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程是第一个成功获取读锁的线程</span></span><br><span class="line">                firstReaderHoldCount++; <span class="comment">// 持有读锁数量加一</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从缓存中获取当前线程的读锁数量</span></span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    <span class="comment">// 缓存读锁为 null 或当前线程的 id 不等于缓存线程 id</span></span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 将读锁线程加到本地线程</span></span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++; <span class="comment">// 持有读锁数量加一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读锁线程阻塞等待</span></span><br><span class="line">        <span class="comment">// 读取锁的共享计数超过限制</span></span><br><span class="line">        <span class="comment">// 通过 CAS 获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果读锁线程阻塞等待、读取锁的共享计数超过限制、通过 CAS 获取锁失败，则通过该方法获取读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState(); <span class="comment">// 获取当前状态</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123; <span class="comment">// 写锁已经被获取</span></span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="comment">// 当前线程不是独占线程</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123; <span class="comment">// 读锁线程阻塞等待</span></span><br><span class="line">                <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前线程不是 firstReader</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123; <span class="comment">// 获取缓存读锁数量</span></span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                            <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                readHolds.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果读锁数量超过 MAX_COUNT，则抛出异常。</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// 通过 CAS 获取锁成功</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123; <span class="comment">// 当前读锁数量为 0</span></span><br><span class="line">                    firstReader = current; <span class="comment">// 当前线程设置为 firstReader</span></span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>; <span class="comment">// firstReader 计数初始化</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程是 firstReader</span></span><br><span class="line">                    firstReaderHoldCount++; <span class="comment">// firstReader 计数加一</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 获取缓存读锁数量</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++; <span class="comment">// 读锁数量加一</span></span><br><span class="line">                    cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并返回 Condition 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getReadLockCount() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 当前线程是首次成功获取读锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) </span><br><span class="line">            <span class="keyword">return</span> firstReaderHoldCount;</span><br><span class="line">        <span class="comment">// 获取缓存读锁数量</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh != <span class="keyword">null</span> &amp;&amp; rh.tid == getThreadId(current))</span><br><span class="line">            <span class="keyword">return</span> rh.count;</span><br><span class="line">        <span class="keyword">int</span> count = readHolds.get().count;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) readHolds.remove();</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反序列化方法，将当前 state 重置为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁和非公平锁实现"><a href="#公平锁和非公平锁实现" class="headerlink" title="公平锁和非公平锁实现"></a>公平锁和非公平锁实现</h2><p>和互斥锁 <code>ReentrantLock</code> 一样，读写锁也分为公平锁和非公平锁。公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 总是不阻塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只要该非公平读锁对应的线程不为 null，则返回 true。</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">       (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">       !s.isShared()         &amp;&amp;</span><br><span class="line">       s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。</span></span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。</span></span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">  <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">  <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readerShouldBlock</code> 的本质就是在检测这次获取读锁资源的操作时，<strong>AQS</strong> 的等待队列中是否已经有写锁了。</p><ul><li>如果已经有写锁，那么要判断写锁是不是本线程，是本线程可以做锁降级。不是本线程就执行<code>fullTryAcquireShared</code>；</li><li>如果没有写锁，就可以继续执行，做 <code>r&lt;MAX_COUNT</code> 判断。</li></ul><p>对公平锁而言，<code>!readerShouldBlock()</code> 就是 <code>!hasQueuedPredecessors()</code>， <code>h == t || ((s = h.next)!=null &amp;&amp; s.thread == Thread.currentThread())</code></p><ol><li><code>h==t</code> 说明Node的等待队列为空</li><li><code>(s = h.next)!=null &amp;&amp; s.thread == Thread.currentThread()</code> 说明等待队列中有值且是本线程申请锁资源。</li></ol><p>满足以上2点的任何一个，可以申请读锁，继续执行下面的 <code>r&lt;MAX_COUNT</code> 判断。</p><h2 id="ReadLock-与-WriteLock"><a href="#ReadLock-与-WriteLock" class="headerlink" title="ReadLock 与 WriteLock"></a>ReadLock 与 WriteLock</h2><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><p>读锁是一个可重入的共享锁，获取读锁的思想(即 <code>lock()</code>的步骤)，是先通过 <code>tryAcquireShared()</code> 尝试获取共享锁。尝试成功的话，则直接返回；尝试失败的话，则通过 <code>doAcquireShared()</code> 不断的循环并尝试获取锁，若有需要，则阻塞等待。<code>doAcquireShared()</code> 在循环中每次尝试获取锁时，都是通过 <code>tryAcquireShared()</code> 来进行尝试的。</p><p>释放读锁的思想(即 <code>unlock()</code>的步骤)，是先通过 <code>tryReleaseShared()</code> 尝试释放共享锁。尝试成功的话，则通过<code>doReleaseShared()</code> 唤醒“其他等待获取共享锁的线程”，并返回true；否则的话，返回 flase。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="comment">// 读锁构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁，不感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 获取共享锁方法 acquireShared</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取读锁，感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 获取共享锁方法 acquireSharedInterruptibly</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState(); <span class="comment">//当前状态</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="comment">// 写锁已经被持有且当前线程不是独占线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c); <span class="comment">// 获取读锁数量</span></span><br><span class="line">            <span class="keyword">if</span> (r == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 通过 CAS 获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 写锁未被获取</span></span><br><span class="line">                    firstReader = current; <span class="comment">// 设置当前线程为 firstReader</span></span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>; <span class="comment">// firstReader 计数初始化</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程是 firstReader</span></span><br><span class="line">                    firstReaderHoldCount++; <span class="comment">// firstReader 计数加一</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从缓存获取读锁数量</span></span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取读锁，感知中断且有超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并返回 Condition，读锁不支持该操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>写锁是一个可重入的排它锁。如果当前线程获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="comment">// 写锁构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁，感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁，不感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryWriteLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">//获取当前状态</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 获取写状态</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="comment">// 写状态为0 或 当前线程不是独占线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (w == MAX_COUNT)</span><br><span class="line">                <span class="comment">// 写状态超过 MAX_COUNT</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 CAS 获取锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetState(c, c + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 设置当前线程为独占线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁，感知中断且有超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 的获取排它锁方法 tryAcquireNanos</span></span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放排它锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 的释放排它锁方法 release</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并返回 Condition 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前线程是否是独占线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getWriteHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="利用重入来执行升级缓存后的锁降级"><a href="#利用重入来执行升级缓存后的锁降级" class="headerlink" title="利用重入来执行升级缓存后的锁降级"></a>利用重入来执行升级缓存后的锁降级</h3><p>锁降级指的是写锁降级成为读锁。锁降级是指把持住当前拥有的写锁的同时，再获取到读锁，随后释放写锁的过程。锁降级的意义在于：<strong>在一边读一边写的情况下感知数据变化并提高性能</strong>。</p><blockquote><ol><li><p>首先写锁是独占的，读锁是共享的，然后读写锁是线程间互斥的，锁降级的前提是所有线程都希望对数据变化敏感，但是因为写锁只有一个，所以会发生降级。如果先释放写锁，再获取读锁，可能在获取之前，会有其他线程获取到写锁，阻塞读锁的获取，就无法感知数据变化了。所以需要先hold住写锁，保证数据无变化，获取读锁，然后再释放写锁。</p></li><li><p>如果长时间用写锁独占，对于某些高响应的应用是不允许的。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;    <span class="comment">//缓存是否有效</span></span><br><span class="line">    ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();    <span class="comment">//获取读锁</span></span><br><span class="line">        <span class="comment">//如果缓存无效，更新cache;否则直接使用data</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">//获取写锁前须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();    </span><br><span class="line">            <span class="comment">// Recheck state because another thread might have acquired</span></span><br><span class="line">            <span class="comment">// write lock and changed state before we did.</span></span><br><span class="line">            <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                data = ...</span><br><span class="line">                cacheValid = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">            <span class="comment">// 锁降级，在释放写锁前获取读锁</span></span><br><span class="line">            rwl.readLock().lock();</span><br><span class="line">            rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        use(data);</span><br><span class="line">        rwl.readLock().unlock();    <span class="comment">//释放读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-ReentrantReadWriteLock-来提高-Collection-的并发性"><a href="#使用-ReentrantReadWriteLock-来提高-Collection-的并发性" class="headerlink" title="使用 ReentrantReadWriteLock 来提高 Collection 的并发性"></a>使用 ReentrantReadWriteLock 来提高 Collection 的并发性</h3><p><strong>通常在 collection 数据很多，读线程访问多于写线程并且附带操作的开销高于同步开销时尝试这么做。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock(); <span class="comment">//读锁</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock(); <span class="comment">//写锁</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> m.get(key);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      r.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> m.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      r.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> m.put(key, value);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      m.clear();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相对于排他锁，读写锁提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时 <code>ReentrantReadWriteLock</code> 能够提供比排他锁更好的并发性和吞吐量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Reen
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ReentrantReadWriteLock" scheme="https://muhouer.github.io/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock解析</title>
    <link href="https://muhouer.github.io/posts/b376c662/"/>
    <id>https://muhouer.github.io/posts/b376c662/</id>
    <published>2019-09-13T04:14:00.000Z</published>
    <updated>2019-09-13T04:27:16.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Reentrant 可重入的;重入;可再入的。即再次进入的意思，entrant: 新职员;新生;新会员;新成员。</p></blockquote><p>JDK 中独占锁的实现除了使用关键字 <code>synchronized</code> 外,还可以使用 <code>ReentrantLock</code>。虽然在性能上<code>ReentrantLock</code> 和 <code>synchronized</code> 没有什么区别，但 <code>ReentrantLock</code> 相比 <code>synchronized</code> 而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。即 <code>ReentrantLock</code> 粒度更小。</p><ul><li><code>ReentrantLock</code> 是独占锁且可重入的。</li><li><code>ReentrantLock</code> 可以实现公平锁。</li><li><code>ReentrantLock</code> 可以响应中断。</li><li><code>ReentrantLock</code> 提供了获取锁超时等待。</li><li><code>ReentrantLock</code> 结合 <code>Condition</code> 接口可以实现线程间的等待通知机制。</li></ul><h2 id="ReentrantLock-类结构"><a href="#ReentrantLock-类结构" class="headerlink" title="ReentrantLock 类结构"></a>ReentrantLock 类结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平可重入锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定可重入锁公平模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/ReentrantLock.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code> 、<code>FairSync</code>、<code>NonfairSync</code>是 <code>ReentrantLock</code> 的内部类，<code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> ，而 <code>FairSync</code>、<code>NonfairSync</code> 继承 <code>Sync</code>，分别对应公平锁和非公平锁。</p><h3 id="Sync-内部类"><a href="#Sync-内部类" class="headerlink" title="Sync 内部类"></a>Sync 内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line">    <span class="comment">// 执行锁操作，由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行非公平 tryLock()</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 利用 CAS 来更新 state 的状态</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 设置当前线程拥有独占访问权限</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取拥有独占访问权限的线程和当前线程比较</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="comment">// 溢出</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 设置新状态</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="comment">// 拥有独占访问权限的线程不是当前线程，抛出 IllegalMonitorStateException</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 清空拥有独占访问权限的线程</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置新状态</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程是否拥有独占访问权限</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 Condition 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取拥有独占访问权限的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否锁住</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解序列化，将状态重置为 0，即锁释放状态</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NonfairSync、FairSync-内部类"><a href="#NonfairSync、FairSync-内部类" class="headerlink" title="NonfairSync、FairSync 内部类"></a>NonfairSync、FairSync 内部类</h3><blockquote><p>线程会重复获取锁。如果申请获取锁的线程足够多，那么可能会造成某些线程长时间得不到锁。这就是非公平锁的“饥饿”问题。</p></blockquote><p>公平锁是指当锁可用时，在锁上等待时间最长的线程将获得锁的使用权，而非公平锁则随机分配这种使用权。和<code>synchronized</code> 一样，默认的 <code>ReentrantLock</code> 实现是非公平锁，因为相比公平锁，非公平锁性能更好。当然公平锁能防止饥饿，某些情况下也很有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">    <span class="comment">// 锁实现</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用 CAS 来更新 state 的状态为1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 设置当前线程拥有独占访问权限，随机分配</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// AQS 的 acquire()</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参考上文 Sync 的 nonfairTryAcquire 实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"><span class="comment">// 锁实现</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 的 acquire()</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，和 AQS 的 nonfairTryAcquire 相比，多了判断队列有没有前置节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 队列没有前置节点，且成功利用 CAS 来更新 state 的状态为 acquires </span></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 设置当前线程拥有独占访问权限</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReentrantLock-提供的方法"><a href="#ReentrantLock-提供的方法" class="headerlink" title="ReentrantLock 提供的方法"></a>ReentrantLock 提供的方法</h2><h3 id="ReentrantLock-锁方法"><a href="#ReentrantLock-锁方法" class="headerlink" title="ReentrantLock 锁方法"></a>ReentrantLock 锁方法</h3><p><code>ReentrantLock</code> 和 <code>synchronized</code> 都是独占锁。不同的是 <code>ReentrantLock</code> 需要手动加锁和解锁，且解锁的操作尽量要放在 finally 代码块中，保证线程正确释放锁。<code>ReentrantLock</code> 操作较为复杂，但是因为可以手动控制加锁和解锁过程，在复杂的并发场景中能派上用场。<code>synchronized</code> 加锁解锁的过程是隐式的，用户不用手动操作，优点是操作简单，但显得不够灵活。一般并发场景使用 <code>synchronized</code> 就足够。</p><p><code>ReentrantLock</code> 和 <code>synchronized</code> 都是可重入的。<code>synchronized</code> 因为可重入，所以可以放在被递归执行的方法上，且不用担心线程最后能否正确释放锁。而 <code>ReentrantLock</code> 在重入时要却<strong>确保重复获取锁的次数必须和重复释放锁的次数一样</strong>，否则可能导致其他线程无法获得该锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁，分别调用公平锁和非公平锁的加锁方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断敏感的加锁，参考 AQS 的 acquireInterruptibly 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平模式加锁，参考 Sync 的 nonfairTryAcquire 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁直至超时，参考 AQS 的 tryAcquireNanos 方法</span></span><br><span class="line"><span class="comment">// 使用该方法配合失败重试机制可以用来解决死锁问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Condition-相关方法"><a href="#Condition-相关方法" class="headerlink" title="Condition 相关方法"></a>Condition 相关方法</h3><p><code>Condition</code> 由 <code>ReentrantLock</code> 对象创建，并且可以同时创建多个。<code>Condition</code> 接口在使用前必须先调用<code>ReentrantLock</code> 的 <code>lock()</code> 方法获得锁。之后调用 <code>Condition</code> 接口的 <code>await()</code> 将释放锁，并且在该<code>Condition</code> 上等待，直到有其他线程调用 <code>Condition</code> 的 <code>signal()</code> 方法唤醒线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Condition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询在给定条件下，是否有线程在等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!(condition <span class="keyword">instanceof</span> AbstractQueuedSynchronizer.ConditionObject))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not owner"</span>);</span><br><span class="line">    <span class="keyword">return</span> sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询在给定条件下，等待线程队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!(condition <span class="keyword">instanceof</span> AbstractQueuedSynchronizer.ConditionObject))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not owner"</span>);</span><br><span class="line">    <span class="keyword">return</span> sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询在给定条件下，所有等待线程</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">(Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!(condition <span class="keyword">instanceof</span> AbstractQueuedSynchronizer.ConditionObject))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not owner"</span>);</span><br><span class="line">    <span class="keyword">return</span> sync.getWaitingThreads((AbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了锁方法和 Condition 相关方法外，还有一些判断是否是公平锁、是否加锁、获取阻塞队列长度、当前队列是否独占等方法，比较简单参考源码即可。</p><h2 id="ReentrantLock-使用示例"><a href="#ReentrantLock-使用示例" class="headerlink" title="ReentrantLock 使用示例"></a>ReentrantLock 使用示例</h2><h3 id="基于官方示例"><a href="#基于官方示例" class="headerlink" title="基于官方示例"></a>基于官方示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公平锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadDemo</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"获得锁的线程："</span> + id);</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是公平锁，线程几乎是轮流的获取到了锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：0</span><br><span class="line">获得锁的线程：0</span><br></pre></td></tr></table></figure><p>如果是非公平锁，线程会重复获取锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：0</span><br><span class="line">获得锁的线程：0</span><br></pre></td></tr></table></figure><h3 id="结合-Condition-实现等待通知机制"><a href="#结合-Condition-实现等待通知机制" class="headerlink" title="结合 Condition 实现等待通知机制"></a>结合 Condition 实现等待通知机制</h3><p>使用 <code>synchronized</code> 结合 Object 上的 <code>wait()</code> 和 <code>notify()</code> 方法可以实现线程间的等待通知机制。<code>ReentrantLock</code> 结合 <code>Condition</code> 接口同样可以实现这个功能，而且相比前者使用起来更清晰也更简单。</p><p>使用<code>Condition</code> 实现简单的阻塞队列，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionBlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 阻塞队列最大容量</span></span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// 可重入锁</span></span><br><span class="line">  ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 队列底层实现</span></span><br><span class="line">  LinkedList&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 队列满时的等待条件</span></span><br><span class="line">  Condition notFull = lock.newCondition();</span><br><span class="line">  <span class="comment">// 队列空时的等待条件</span></span><br><span class="line">  Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConditionBlockingQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 队列已满,在 notFull 条件上等待</span></span><br><span class="line">      <span class="keyword">while</span> (list.size() == size) &#123;</span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;</span><br><span class="line">      list.add(e); <span class="comment">// 加入链表末尾</span></span><br><span class="line">      notEmpty.signal(); <span class="comment">// 通知在 notEmpty 条件上等待的线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 队列为空,在 notEmpty 条件上等待</span></span><br><span class="line">      <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      e = list.removeFirst(); <span class="comment">// 移除链表首元素</span></span><br><span class="line">      notFull.signal(); <span class="comment">// 通知在 notFull 条件上等待的线程</span></span><br><span class="line">      <span class="keyword">return</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ReentrantLock</code> 是可重入的独占锁。比 <code>synchronized</code> 功能更加丰富，控制粒度更小，支持公平锁实现，支持中断响应以及超时等待…… <code>ReentrantLock</code> 还可以配合一个或多个 <code>Condition</code> 条件方便的实现等待通知机制。不过需要手动加锁和解锁，且解锁的操作尽量要放在 finally 代码块中，保证线程正确释放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ReentrantLock" scheme="https://muhouer.github.io/tags/ReentrantLock/"/>
    
  </entry>
  
  <entry>
    <title>AQS同步器解析</title>
    <link href="https://muhouer.github.io/posts/cdbd94c4/"/>
    <id>https://muhouer.github.io/posts/cdbd94c4/</id>
    <published>2019-09-13T04:09:00.000Z</published>
    <updated>2019-09-13T04:18:13.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>AQS</strong> (<code>AbstractQueuedSynchronizer</code>) 提供了基于 FIFO 队列机制的模板，可以用来实现阻塞锁以及相关的同步锁 (semaphores, events等)，是构建 Java 同步组件的基础。自定义子类通过继承 <strong>AQS</strong> 类，实现它的抽象方法来管理同步状态。<strong>AQS</strong> 提供了大量的模板方法来实现同步，主要是分为三类：</p><ol><li>独占式获取、释放同步状态。</li><li>共享式获取、释放同步状态</li><li>查询同步队列中的等待线程情况。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>继承关系及 public 方法如下图所示</p><img src="/images/AbstractQueuedSynchronizer.png" width="800px" height="600px" align="center"><h2 id="需要自定义同步组件实现的方法"><a href="#需要自定义同步组件实现的方法" class="headerlink" title="需要自定义同步组件实现的方法"></a>需要自定义同步组件实现的方法</h2><p>基于 <strong>AQS</strong> 实现的自定义同步组件主要有五种</p><ul><li>倒计时器：<code>CountDownLatch.Sync</code>——<a href="/posts/49d01824/" title="CountDownLatch解析">CountDownLatch解析</a></li><li>信号量：<code>Semaphore.Sync</code>——<a href="/posts/e73eaf42/" title="Semaphore解析">Semaphore解析</a></li><li>重入锁：<code>ReentrantLock.Sync</code>——<a href="/posts/b376c662/" title="ReentrantLock解析">ReentrantLock解析</a></li><li>读写锁：<code>ReentrantReadWriteLock.Sync</code> ——<a href="/posts/cb5cf479/" title="ReentrantReadWriteLock解析">ReentrantReadWriteLock解析</a></li><li>线程池执行器：<code>ThreadPoolExecutor.Worker</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占式获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 独占式释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享式获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享式释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前（调用）线程以独占方式持有同步，则返回&#123;@code true&#125;</span></span><br><span class="line"><span class="comment">// 每次调用非等待的方法时都会调用此方法。（等待方法改为调用&#123;@link release&#125;。）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h2><p>独占式，同一时刻仅有一个线程持有同步状态。</p><blockquote><p>在 AQS 中维护着一个 FIFO 的同步队列，当线程获取同步状态失败后，则会加入到这个 CLH 同步队列的对尾并一直保持着自旋。在 CLH 同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出 CLH 同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p></blockquote><h3 id="独占式获取同步状态"><a href="#独占式获取同步状态" class="headerlink" title="独占式获取同步状态"></a>独占式获取同步状态</h3><p><code>acquire(int arg)</code> 方法是 <strong>AQS</strong> 提供的模板方法，该方法为独占式获取同步状态，忽略中断，即线程获取同步状态失败加入到 CLH 同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryAcquire(int arg)</code> 去尝试获取锁，获取成功则设置锁状态并返回 <code>true</code>，否则返回 <code>false</code>。该方法需要自定义同步组件实现，该方法必须要保证线程安全的获取同步状态。</li><li>如果 <code>tryAcquire(int arg)</code> 返回 <code>false</code> 即获取同步状态失败，则调用 <code>addWaiter(Node mode)</code> 将当前线程加入到 CLH 同步队列尾部。</li><li><code>acquireQueued(final Node node, int arg)</code> : 当前线程会根据公平性原则来进行阻塞等待，直到获取锁为止，并且返回当前线程在等待过程中有没有中断过。</li><li><code>selfInterrupt()</code> 会产生一个中断。</li></ul><p><code>acquireQueued(final Node node, int arg)</code> 是一个自旋的过程，也就是说当前线程(Node) 进入同步队列后，当前线程会一直尝试获取同步状态，当前驱节点是头节点并且获取锁成功才会退出。其中只有其前驱节点为头结点才能够尝试获取同步状态，原因有二：1.保持 FIFO 同步队列原则。2.头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 中断标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">               <span class="comment">// 前驱节点是头节点并且获取锁成功</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取失败，线程等待 &amp;&amp; 检查中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 置中断标志位true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">【tryAcquire 获取锁--失败--&gt;【addWaiter 生成 Node 节点并将当前线程加入 CLH 同步队列】</span><br><span class="line">          |                              |&lt;-------------------------------</span><br><span class="line">          |                             ***                              |</span><br><span class="line">          |                              *                               |</span><br><span class="line">          |      【acquireQueued 判断前驱节点是否是头节点】--否--     线程被中断或前驱节点被释放</span><br><span class="line">          |                  |                 |             |</span><br><span class="line">          |                  是      【acquireQueued 线程进入线程等待】</span><br><span class="line">          |                    |                    *</span><br><span class="line">          |                   ***                  ***</span><br><span class="line">          |                              *                    |</span><br><span class="line">          |                  【acquireQueued 获取锁成功】---失败--</span><br><span class="line">          |                            |</span><br><span class="line">          |                           成功 </span><br><span class="line">          |                            |</span><br><span class="line">          |                           ***</span><br><span class="line">          |                            *</span><br><span class="line">         ***                  【设置当前节点为头节点】</span><br><span class="line">          *                               |</span><br><span class="line">          结束&lt;----------------------------</span><br></pre></td></tr></table></figure><h3 id="独占式中断获取同步状态"><a href="#独占式中断获取同步状态" class="headerlink" title="独占式中断获取同步状态"></a>独占式中断获取同步状态</h3><p><strong>AQS</strong> 提供了 <code>acquire(int arg)</code> 以独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于 CLH 同步队列中等待着获取同步状态。为了响应中断，<strong>AQS</strong> 提供了 <code>acquireInterruptibly(int arg)</code> ，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常<code>InterruptedException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 校验该线程是否已经中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">// 抛出InterruptedException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg)) <span class="comment">// 获取同步状态</span></span><br><span class="line">        <span class="comment">// 获取失败，执行doAcquireInterruptibly(arg)</span></span><br><span class="line">        <span class="comment">// 如果获取失败，线程等待 &amp;&amp; 检查有中断则抛出InterruptedException，和 acquireQueued 置中断标志位true不一样</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h3><p><strong>AQS</strong> 除了提供上面两个方法外，还提供了 <code>tryAcquireNanos(int arg,long nanos)</code>。该方法除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回 false，否则返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 获取到直接返回，否则执行 doAcquireNanos(arg, nanosTimeout)</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时获取同步状态最终是在 <code>doAcquireNanos(int arg, long nanosTimeout)</code>中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 生成 Node节点并当前线程加入 CLH 同步队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 前驱节点是头节点获取同步状态成功</span></span><br><span class="line">                setHead(node); <span class="comment">// 设置当前节点为头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 剩余时间计算</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 超时</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">// 获取失败，线程等待并且剩余时间大于 1000 纳秒</span></span><br><span class="line">                <span class="comment">// 等待 nanosTimeout 纳秒，线程会直接从LockSupport.parkNanos中返回</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 超时非常短nanosTimeout&lt;=spinForTimeoutThreshold，AQS会进行无条件的快速自旋。</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独占式释放同步状态"><a href="#独占式释放同步状态" class="headerlink" title="独占式释放同步状态"></a>独占式释放同步状态</h3><p>当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。<strong>AQS</strong> 提供了 <code>release(int arg)</code> 来释放同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用自定义同步器自定义的 tryRelease(int arg) 方法来释放同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h2><p>共享式与独占式的最主要区别在于独占式同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。</p><h3 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="共享式同步状态获取"></a>共享式同步状态获取</h3><p><strong>AQS</strong> 提供 <code>acquireShared(int arg)</code> 共享式获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试获取同步状态，需要自定义同步组件实现</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 自旋方式获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doAcquireShared(int arg)</code> 自旋方式获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建共享式节点并将当前线程加入 CLH 同步队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 前驱节点为头节点</span></span><br><span class="line">                <span class="comment">// 尝试获取同步</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 获取成功</span></span><br><span class="line">                  <span class="comment">// 设置当前节点为头节点并检查后续进程是否可以在共享模式下等待</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取失败线程等待并检查中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireShared(int arg)</code> 不响应中断，与独占式类似，<strong>AQS</strong> 也提供了响应中断、超时的方法，分别是：<code>acquireSharedInterruptibly(int arg)</code>、<code>tryAcquireSharedNanos(int arg,long nanos)</code>，与独占式类似。</p><h3 id="共享式释放同步状态"><a href="#共享式释放同步状态" class="headerlink" title="共享式释放同步状态"></a>共享式释放同步状态</h3><p>获取同步状态后，需要调用 <code>releaseShared(int arg)</code> 释放同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放同步状态，需要自定义同步组件实现</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 自旋释放同步状态</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doReleaseShared()</code> 自旋释放同步状态。因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过 CAS (Conmpare And Swap) 和循环来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;AQ
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="AQS" scheme="https://muhouer.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch解析</title>
    <link href="https://muhouer.github.io/posts/49d01824/"/>
    <id>https://muhouer.github.io/posts/49d01824/</id>
    <published>2019-09-13T04:05:00.000Z</published>
    <updated>2019-09-13T04:08:59.144Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>CountDownLatch</code> ，英文翻译为倒计时锁存器，是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。也是基于 <strong>AQS</strong>，它是 <strong>AQS</strong> 的共享功能的一个实现。</p><p>它主要用来保证完成某个任务的先决条件满足，是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</p><ul><li>确保某个计算在其需要的所有资源都被初始化之后才继续执行;</li><li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动;</li><li>等待直到某个操作所有参与者都准备就绪再继续执行。</li></ul><p><code>CountDownLatch</code> 有一个正数计数器，<code>countDown()</code> 方法对计数器做减操作，<code>await()</code> 方法等待计数器达到0。所有 await 的线程都会阻塞直到计数器为0或者等待线程中断或者超时。</p><h2 id="CountDownLatch-类结构"><a href="#CountDownLatch-类结构" class="headerlink" title="CountDownLatch 类结构"></a>CountDownLatch 类结构</h2><img src="/images/CountDownLatch.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code> 是 <code>CountDownLatch</code> 的内部类，<code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> 。使用 <strong>AQS</strong> state 表示 count 计数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"><span class="comment">// 设置初始计数</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取当前计数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 AQS 的 tryAcquireShared 方法，-1 表示 count&gt;0，可以获取。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="comment">// // count-1，如果 count 变为0，则唤醒所有。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前状态，为0表示未锁，不用释放。</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 利用 CAS 来更新 state 的状态，这里可能有并发，所以这也是用死循环更新的原因</span></span><br><span class="line">            <span class="comment">// c为期望值，nextc为更新值。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch-构造方法"><a href="#CountDownLatch-构造方法" class="headerlink" title="CountDownLatch 构造方法"></a>CountDownLatch 构造方法</h2><p>使用给定的 count 构造 <code>CountDownLatch</code>，count 表示线程通过 await 前必须要执行的次数，count 不能小于0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当<code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><h2 id="CountDownLatch-线程等待方法"><a href="#CountDownLatch-线程等待方法" class="headerlink" title="CountDownLatch 线程等待方法"></a>CountDownLatch 线程等待方法</h2><p><code>await()</code> 是通过轮询 state 的状态来判断所有的任务是否都完成。</p><h3 id="无限等待"><a href="#无限等待" class="headerlink" title="无限等待"></a>无限等待</h3><p>让当前线程等待直到 count 减数为0，除非线程被中断。如果 count 为0，线程将立即返回，不再阻塞等待。<br>如果当前计数大于零，则出于线程调度目的，当前线程将禁用，并处于休眠状态，直到发生以下两种情况之一：</p><ol><li><code>countDown()</code> 方法调用使得 count 减数为0；</li><li>当前线程被中断 (如果被中断将会抛出 InterruptedException 异常)。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 AQS 的 acquireSharedInterruptibly() 方法</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h3><p>使当前线程处理等待状态直到 count 减为0或者等待超时。如果当前count是0，则线程立即返回true。<br>如果当前计数大于零，则出于线程调度目的，当前线程将禁用，并处于休眠状态，直到发生以下三种情况之一：</p><ol><li><code>countDown()</code> 方法调用使得 count 减数为0；</li><li>当前线程被中断 (如果被中断将会抛出 InterruptedException 异常)；</li><li>等待超时。</li></ol><p><strong>如果等待超时但是 <code>count&gt;0</code>，则返回 false。如果超时时间小于或等于零，方法将不会等待。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 AQS 的 tryAcquireSharedNanos() 方法</span></span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch-其他方法"><a href="#CountDownLatch-其他方法" class="headerlink" title="CountDownLatch 其他方法"></a>CountDownLatch 其他方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒计时，将会将count-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 AQS 的 releaseShared() 方法</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 的 releaseShared() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 Sync 重写的 tryReleaseShared(int releases) 方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒主线程，因为如果 state 不等于0的话，主线程一直是阻塞的。</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前计数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.getCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回标识锁及其状态的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"[Count = "</span> + sync.getCount() + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AQS-的-doReleaseShared-方法"><a href="#AQS-的-doReleaseShared-方法" class="headerlink" title="AQS 的 doReleaseShared() 方法"></a>AQS 的 doReleaseShared() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123; <span class="comment">// 至少有两个节点</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 后继节点需要唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line">        doSomethingElse();            <span class="comment">// don't let run yet</span></span><br><span class="line">        <span class="comment">// 所有worker线程继续执行</span></span><br><span class="line">        startSignal.countDown();      <span class="comment">// let all threads proceed</span></span><br><span class="line">        doSomethingElse();</span><br><span class="line">        <span class="comment">// 允许driver等待直到所有的worker都完成</span></span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">  Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">    <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      startSignal.await(); <span class="comment">// 开始信号阻止任何worker直到driver准备好</span></span><br><span class="line">      doWork();</span><br><span class="line">      doneSignal.countDown(); <span class="comment">// 完成信号，计数减一</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="火箭发射示例"><a href="#火箭发射示例" class="headerlink" title="火箭发射示例"></a>火箭发射示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatchDemo demo = <span class="keyword">new</span> CountDownLatchDemo();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟检查任务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) * <span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"check complete"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//计数减一</span></span><br><span class="line">            <span class="comment">//放在finally避免任务执行过程出现异常，导致countDown()不能被执行</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            exec.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待检查</span></span><br><span class="line">        latch.await();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发射火箭</span></span><br><span class="line">        System.out.println(<span class="string">"Fire!"</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>CountDownLatch</code> 主要用来保证完成某个任务的先决条件满足，是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Coun
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="CountDownLatch" scheme="https://muhouer.github.io/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>人类愚蠢辞典</title>
    <link href="https://muhouer.github.io/posts/c6491e95/"/>
    <id>https://muhouer.github.io/posts/c6491e95/</id>
    <published>2019-09-08T15:28:00.000Z</published>
    <updated>2019-09-23T14:27:05.834Z</updated>
    
    <content type="html"><![CDATA[<ol><li>习惯的力量与其愚蠢度成正比。我们在个人与社会生活中，总会用同样的方式思考以及做同样的事。</li><li>对于银行来说，25% 就已经是高利贷的标准了。而一些酒吧、饭店来说，它们宣称出于对”卫生问题“的重视不提供直饮水，转而以高达10倍价格向它们愚蠢的顾客推销瓶装水。</li><li>人类的不忠行为远比我们愚蠢地自认为的要多。实际上，男性会偏向于夸大性伴侣的数量，而女性则会倾向于隐藏。不忠行为是对反自然的一夫一妻制进行的自然修正过程。</li><li>往生世界，相信死后我们会有跟活着时一样的烦恼。</li><li>”保护地球“是很愚蠢的：充其量是我们自己有点儿危险罢了。早在25亿年前，光合作用就已经对地球环境的构成造成了更甚于今日的剧烈变化，即所谓的”大氧化事件“。然而，我们地球通过一项调整成功挽救了自己：消灭厌氧生物，并养育需氧生物，也就是人类本身。</li><li>通常，人们愚蠢地认为爱动物就是喜欢小猫小狗，不忍观看斗牛或海豹被屠杀的画面。极少人意识到，真正的问题存在于动物被用于饮食和实验造成的权益侵害。</li><li>愚蠢的种族主义者虽然目标常常变化，但本质永远是不变的。</li><li>斯特金定律：90%的东西都是无意义的废物。</li><li>愚蠢的人有两种截然相反的行事方式，却总能殊途同归，制造麻烦。要么让那些明智的人生活难以为继，无法施展抱负；要么为害群之马铺平道路，帮助他们达成危害大业。</li><li>同样的习惯，于自身都很正常，到了别人那里就怎么看怎么别扭。</li><li>我们愚蠢无知的程度，恰如我们自以为的智慧狡黠一般。</li><li>在任意一群人里，蠢人的比例是固定的，即使是在诺贝尔奖获得者中。</li><li>翡翠行业根本没有赌石这种说法，一堆一堆的专业人士用专业的设备一轮一轮的筛选，根本不需要赌，因为石头的出身是透明的。</li><li>一旦我们陷于嫉妒的情绪，我们往往只看到对方的长处，忽略了自己的优势。也无法看到自己拥有的资源。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;&lt;li&gt;习惯的力量与其愚蠢度成正比。我们在个人与社会生活中，总会用同样的方式思考以及做同样的事。&lt;/li&gt;&lt;li&gt;对于银行来说，25% 就已经是高利贷的标准了。而一些酒吧、饭店来说，它们宣称出于对”卫生问题“的重视不提供直饮水，转而以高达10倍价格向它们愚蠢的顾客推销瓶装
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://muhouer.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="愚蠢" scheme="https://muhouer.github.io/tags/%E6%84%9A%E8%A0%A2/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Muhouer</title>
  
  <subtitle>就是做个记录，先来5分钟的！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muhouer.github.io/"/>
  <updated>2019-08-05T17:33:59.175Z</updated>
  <id>https://muhouer.github.io/</id>
  
  <author>
    <name>Muhouer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis进阶教程</title>
    <link href="https://muhouer.github.io/posts/c275b75f/"/>
    <id>https://muhouer.github.io/posts/c275b75f/</id>
    <published>2019-08-05T16:29:00.000Z</published>
    <updated>2019-08-05T17:33:59.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-数据备份与恢复"><a href="#Redis-数据备份与恢复" class="headerlink" title="Redis 数据备份与恢复"></a>Redis 数据备份与恢复</h2><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p>Redis <code>save</code> 命令用于创建当前数据库的备份。该命令将在 redis 安装目录中创建dump.rdb文件。</p><p>创建 redis 备份文件也可以使用命令 <code>bgsave</code>，该命令在后台执行。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>save</code></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; save </span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用<code>config</code>命令，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) &quot;dir&quot;</span><br><span class="line">2) &quot;/usr/local/redis-5.0.5/src&quot;</span><br></pre></td></tr></table></figure><h2 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h2><p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。</p><p>默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><code>auth password</code></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; config set requirepass &quot;redis&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h2 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h2><p>Redis 性能测试是通过同时执行多个命令实现的。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p><code>redis-benchmark [option] [option value]</code></p><p>注意：该命令是在 redis 的目录下执行的，而不是 redis<br>客户端的内部指令。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>同时执行 10000 个请求来检测性能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-benchmark -n 10000 -q</span><br><span class="line">PING_INLINE: 104166.66 requests per second</span><br><span class="line">PING_BULK: 106382.98 requests per second</span><br><span class="line">SET: 105263.16 requests per second</span><br><span class="line">GET: 105263.16 requests per second</span><br><span class="line">INCR: 103092.78 requests per second</span><br><span class="line">LPUSH: 106382.98 requests per second</span><br><span class="line">RPUSH: 105263.16 requests per second</span><br><span class="line">LPOP: 108695.65 requests per second</span><br><span class="line">RPOP: 102040.82 requests per second</span><br><span class="line">SADD: 106382.98 requests per second</span><br><span class="line">HSET: 107526.88 requests per second</span><br><span class="line">SPOP: 97087.38 requests per second</span><br><span class="line">LPUSH (needed to benchmark LRANGE): 101010.10 requests per second</span><br><span class="line">LRANGE_100 (first 100 elements): 106382.98 requests per second</span><br><span class="line">LRANGE_300 (first 300 elements): 109890.11 requests per second</span><br><span class="line">LRANGE_500 (first 450 elements): 107526.88 requests per second</span><br><span class="line">LRANGE_600 (first 600 elements): 99009.90 requests per second</span><br><span class="line">MSET (10 keys): 101010.10 requests per second</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">序号</th><th align="left">选项</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>-h</strong></td><td align="left">指定服务器主机名</td><td align="left">127.0.0.1</td></tr><tr><td align="left">2</td><td align="left"><strong>-p</strong></td><td align="left">指定服务器端口</td><td align="left">6379</td></tr><tr><td align="left">3</td><td align="left"><strong>-s</strong></td><td align="left">指定服务器 socket</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"><strong>-c</strong></td><td align="left">指定并发连接数</td><td align="left">50</td></tr><tr><td align="left">5</td><td align="left"><strong>-n</strong></td><td align="left">指定请求数</td><td align="left">10000</td></tr><tr><td align="left">6</td><td align="left"><strong>-d</strong></td><td align="left">以字节的形式指定 SET/GET 值的数据大小</td><td align="left">2</td></tr><tr><td align="left">7</td><td align="left"><strong>-k</strong></td><td align="left">1=keep alive 0=reconnect</td><td align="left">1</td></tr><tr><td align="left">8</td><td align="left"><strong>-r</strong></td><td align="left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left"><strong>-P</strong></td><td align="left">通过管道传输<code>&lt;numreq&gt;</code>请求</td><td align="left">1</td></tr><tr><td align="left">10</td><td align="left"><strong>-q</strong></td><td align="left">强制退出 redis。仅显示 query/sec 值</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left"><strong>–csv</strong></td><td align="left">以 CSV 格式输出</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left"><strong>-l</strong></td><td align="left">生成循环，永久执行测试</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left"><strong>-t</strong></td><td align="left">仅运行以逗号分隔的测试命令列表。</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left"><strong>-I</strong></td><td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td><td align="left"></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q</span><br><span class="line">SET: 104166.66 requests per second</span><br><span class="line">LPUSH: 105263.16 requests per second</span><br></pre></td></tr></table></figure><p>以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。</p><h2 id="Redis-客户端连接"><a href="#Redis-客户端连接" class="headerlink" title="Redis 客户端连接"></a>Redis 客户端连接</h2><p>Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：</p><ol><li>首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。</li><li>然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法</li><li>然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送</li></ol><p>Socket编程中，TCP_NODELAY选项是用来控制是否开启Nagle算法，该算法是为了提高较慢的广域网传输效率，减小小分组的报文个数，完整描述：</p><blockquote><p>该算法要求一个TCP连接上最多只能有一个未被确认的小分组，在该小分组的确认到来之前，不能发送其他小分组。</p></blockquote><h3 id="最大连接数"><a href="#最大连接数" class="headerlink" title="最大连接数"></a>最大连接数</h3><p>在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。</p><p>maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxclients</span><br><span class="line">1) "maxclients"</span><br><span class="line">2) "10000"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-server --maxclients 100000 <span class="comment"># 在服务启动时设置最大连接数为 100000</span></span></span><br></pre></td></tr></table></figure><h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h3><table><thead><tr><th align="left">序号</th><th align="left">命令</th><th align="left">描述</th><th>可用版本</th><th>时间复杂度</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>client list</strong></td><td align="left">以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据。返回的信息含义参见</td><td>&gt;=2.4.0</td><td>O(N)， N 为连接到服务器的客户端数量。</td></tr><tr><td align="left">2</td><td align="left"><strong>client setname</strong></td><td align="left">1. 为当前连接分配一个名字。这个名字会显示在<code>client list</code>命令的结果中， 用于识别当前正在与服务器进行连接的客户端。获取通过<code>client setname</code> 命令设置的服务名称。<br>2. 名字使用 Redis 的字符串类型来保存， 最大可以占用 512 MB 。<br>3. 另外， 为了避免和<code>client list</code>命令的输出格式发生冲突， 名字里不允许使用空格。<br>4. 要移除一个连接的名字， 可以将连接的名字设为空字符串 <code>&quot;&quot;</code> 。<br>5. 新创建的连接默认是没有名字的。在 Redis 应用程序发生连接泄漏时，为连接设置名字是一种很好的 debug 手段。</td><td>&gt;=2.6.9</td><td>O(1)</td></tr><tr><td align="left">3</td><td align="left"><strong>client getname</strong></td><td align="left">返回<code>client getname</code>命令为连接设置的名字。因为新创建的连接默认是没有名字的， 对于没有名字的连接， <code>client getname</code>返回空白回复。</td><td>&gt;=2.6.9</td><td>O(1)</td></tr><tr><td align="left">4</td><td align="left"><strong>client pause</strong></td><td align="left">挂起客户端连接，指定挂起的时间以毫秒计</td><td>&gt;=2.9.5</td><td>O(1)</td></tr><tr><td align="left">5</td><td align="left"><strong>client kill</strong></td><td align="left">当指定的客户端存在，且被成功关闭时，返回 OK 。关闭地址为 <code>ip:port</code> 的客户端。<code>ip:port</code> 应该和<code>client-list)</code>命令输出的其中一行匹配。因为 Redis 使用单线程设计，所以当 Redis 正在执行命令的时候，不会有客户端被断开连接。</td><td>&gt;=2.4.0</td><td>O(N) ， N 为已连接的客户端数量。</td></tr><tr><td align="left">6</td><td align="left"><strong>client id</strong></td><td align="left">返回当前连接的id</td><td>&gt;=5.0.0</td><td>O(1)</td></tr></tbody></table><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client getname</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; client setname freya-connection</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; client getname</span><br><span class="line">"freya-connection"</span><br><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=7 addr=127.0.0.1:56661 fd=8 name= age=265815 idle=261969 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribe</span><br><span class="line">id=1012 addr=127.0.0.1:51537 fd=9 name=freya-connection age=647 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client setname    # 只用空格是不行的！</span><br><span class="line">(error) ERR Unknown subcommand or wrong number of arguments for 'setname'. Try CLIENT HELP</span><br><span class="line">127.0.0.1:6379&gt; client setname ""  # 必须双引号显示包围</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; client getname</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=7 addr=127.0.0.1:56661 fd=8 name= age=265951 idle=262105 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribe</span><br><span class="line">id=1012 addr=127.0.0.1:51537 fd=9 name= age=783 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="Redis-client-list-命令返回值"><a href="#Redis-client-list-命令返回值" class="headerlink" title="Redis client list 命令返回值"></a>Redis <code>client list</code> 命令返回值</h4><p>命令返回多行字符串，这些字符串按以下形式被格式化：</p><ol><li>每个已连接客户端对应一行（以 LF 分割）</li><li>每行字符串由一系列 <strong>属性=值</strong> 形式的域组成，每个域之间以空格分开</li></ol><p>以下是域的含义：</p><table><thead><tr><th>域</th><th>含义</th></tr></thead><tbody><tr><td><code>addr</code></td><td>客户端的地址和端口</td></tr><tr><td><code>fd</code></td><td>套接字所使用的文件描述符</td></tr><tr><td><code>age</code></td><td>以秒计算的已连接时长</td></tr><tr><td><code>idle</code></td><td>以秒计算的空闲时长</td></tr><tr><td><code>flags</code></td><td>客户端flag(见下表)</td></tr><tr><td><code>db</code></td><td>该客户端正在使用的数据库ID</td></tr><tr><td><code>sub</code></td><td>已订阅频道的数量</td></tr><tr><td><code>psub</code></td><td>已订阅模式的数量</td></tr><tr><td><code>multi</code></td><td>在事务中被执行的命令数量</td></tr><tr><td><code>qbuf</code></td><td>查询缓存的长度(0 表示没有查询在等待)</td></tr><tr><td><code>qbuf-free</code></td><td>查询缓存的剩余空间(0 表示没有剩余空间)</td></tr><tr><td><code>obl</code></td><td>输出缓存的长度</td></tr><tr><td><code>oll</code></td><td>输出列表的长度(当输出缓存没有剩余空间时，回复被入队到这个队列里)</td></tr><tr><td><code>omem</code></td><td>输出缓存的内存占用量</td></tr><tr><td><code>events</code></td><td>文件描述符事件(见下文)</td></tr><tr><td><code>cmd</code></td><td>最近一次执行的命令</td></tr></tbody></table><p>客户端 flag 可以由以下部分组成：</p><table><thead><tr><th>域</th><th>含义</th></tr></thead><tbody><tr><td><code>O</code></td><td>客户端是 monitor 模式下的附属节点 (slave)</td></tr><tr><td><code>S</code></td><td>客户端是一般模式下 (normal) 的附属节点</td></tr><tr><td><code>M</code></td><td>客户端是主节点 (master)</td></tr><tr><td><code>x</code></td><td>小写<code>x</code>，客户端正在执行事务</td></tr><tr><td><code>b</code></td><td>客户端正在等待阻塞事件</td></tr><tr><td><code>i</code></td><td>客户端正在等待 VM I/O 操作 (已废弃)</td></tr><tr><td><code>d</code></td><td>一个受监控 (watched) 的键已被修改， <code>exec</code>命令将失败</td></tr><tr><td><code>c</code></td><td>在将回复完整写出来之后，关闭连接</td></tr><tr><td><code>u</code></td><td>客户端未被阻塞 (unblocked)</td></tr><tr><td><code>A</code></td><td>尽可能快地关闭连接</td></tr><tr><td><code>N</code></td><td>未设置任何 flag</td></tr></tbody></table><p>文件描述符事件</p><table><thead><tr><th>文件描述符事件</th><th>含义</th></tr></thead><tbody><tr><td><code>r</code></td><td>客户端套接字（在事件 loop 中）是可读的（readable）</td></tr><tr><td><code>w</code></td><td>客户端套接字（在事件 loop 中）是可写的（writeable）</td></tr></tbody></table><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>为了 debug 的需要，经常会对域进行添加和删除，一个安全的 Redis 客户端应该可以对 CLIENT LIST 的输出进行相应的处理（parse），比如忽略不存在的域，跳过未知域，诸如此类。</p><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=7 addr=127.0.0.1:56661 fd=8 name= age=150289 idle=146443 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribe</span><br><span class="line">id=10 addr=127.0.0.1:64043 fd=9 name= age=525 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client</span><br></pre></td></tr></table></figure><h2 id="Redis-管道技术"><a href="#Redis-管道技术" class="headerlink" title="Redis 管道技术"></a>Redis 管道技术</h2><p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：</p><ol><li>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。</li><li>服务端处理命令，并将结果返回给客户端。</li></ol><p>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ (echo -en &quot;auth pwd\r\n PING\r\n SET freya redis\r\nGET freya\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n&quot;; sleep 10) | nc localhost 6379</span><br><span class="line">+OK</span><br><span class="line">+PONG</span><br><span class="line">+OK</span><br><span class="line">$5</span><br><span class="line">redis</span><br><span class="line">:1</span><br><span class="line">:2</span><br><span class="line">:3</span><br></pre></td></tr></table></figure><p>以上命令采用<code>auth pwd</code>授权，采用<code>PING</code>命令查看redis服务是否可用， 之后我们设置了 freya 的值为 redis，然后我们获取 freya 的值并使得 visitor 自增 3 次。</p><h3 id="管道技术的优势"><a href="#管道技术的优势" class="headerlink" title="管道技术的优势"></a>管道技术的优势</h3><p>管道技术最显著的优势是提高了 redis 服务的性能。</p><h2 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis 分区"></a>Redis 分区</h2><p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p><h3 id="分区的优势"><a href="#分区的优势" class="headerlink" title="分区的优势"></a>分区的优势</h3><ol><li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li><li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。<h3 id="分区的不足"><a href="#分区的不足" class="headerlink" title="分区的不足"></a>分区的不足</h3></li><li>涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li><li>涉及多个key的redis事务不能使用。</li><li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li><li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。</li></ol><h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><p>Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。</p><h4 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h4><p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。<br>比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。<br>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各种对象的映射表，通常对Redis来说并非是好的方法。</p><h4 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h4><p>另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：</p><ol><li>用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。</li><li>对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</li></ol><h2 id="Java-使用-Redis"><a href="#Java-使用-Redis" class="headerlink" title="Java 使用 Redis"></a>Java 使用 Redis</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>开始在 Java 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 Java redis 驱动，且你的机器上能正常使用 Java。</p><h3 id="连接到-redis-服务"><a href="#连接到-redis-服务" class="headerlink" title="连接到 redis 服务"></a>连接到 redis 服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">public class RedisTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 连接本地的 Redis 服务</span><br><span class="line">        Jedis jedis = new Jedis(&quot;localhost&quot;)；</span><br><span class="line">        //验证密码</span><br><span class="line">        jedis.auth(&quot;redis&quot;);</span><br><span class="line">        // 查看服务是否运行</span><br><span class="line">        System.out.println(&quot;服务正在运行: &quot; + jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-数据备份与恢复&quot;&gt;&lt;a href=&quot;#Redis-数据备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;Redis 数据备份与恢复&quot;&gt;&lt;/a&gt;Redis 数据备份与恢复&lt;/h2&gt;&lt;h3 id=&quot;数据备份&quot;&gt;&lt;a href=&quot;#数据备份&quot;
      
    
    </summary>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/Redis/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Redis/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="进阶教程" scheme="https://muhouer.github.io/tags/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令5</title>
    <link href="https://muhouer.github.io/posts/e33ec7a3/"/>
    <id>https://muhouer.github.io/posts/e33ec7a3/</id>
    <published>2019-08-04T08:49:00.000Z</published>
    <updated>2019-08-05T17:17:13.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-服务器命令"><a href="#Redis-服务器命令" class="headerlink" title="Redis 服务器命令"></a>Redis 服务器命令</h2><p>Redis 服务器命令主要是用于管理 redis 服务。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>如何获取 redis 服务器的统计信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"># Server</span><br><span class="line">redis_version:5.0.5</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:6d3bf9e511543b78</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Darwin 18.6.0 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:kqueue</span><br><span class="line">atomicvar_api:atomic-builtin</span><br><span class="line">gcc_version:4.2.1</span><br><span class="line">process_id:65254</span><br><span class="line">run_id:3d46ae00173412623b99d81100173246db224357</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:497757</span><br><span class="line">uptime_in_days:5</span><br><span class="line">hz:10</span><br><span class="line">configured_hz:10</span><br><span class="line">lru_clock:4627403</span><br><span class="line">executable:/Users/asher/Desktop/redis-5.0.5/src/./redis-server</span><br><span class="line">config_file:</span><br><span class="line"></span><br><span class="line"># Clients</span><br><span class="line">connected_clients:2</span><br><span class="line">client_recent_max_input_buffer:2</span><br><span class="line">client_recent_max_output_buffer:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">used_memory:1070656</span><br><span class="line">used_memory_human:1.02M</span><br><span class="line">used_memory_rss:1712128</span><br><span class="line">used_memory_rss_human:1.63M</span><br><span class="line">used_memory_peak:1070656</span><br><span class="line">used_memory_peak_human:1.02M</span><br><span class="line">used_memory_peak_perc:100.03%</span><br><span class="line">used_memory_overhead:1054744</span><br><span class="line">used_memory_startup:987824</span><br><span class="line">used_memory_dataset:15912</span><br><span class="line">used_memory_dataset_perc:19.21%</span><br><span class="line">allocator_allocated:1024592</span><br><span class="line">allocator_active:1674240</span><br><span class="line">allocator_resident:1674240</span><br><span class="line">total_system_memory:8589934592</span><br><span class="line">total_system_memory_human:8.00G</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line">used_memory_scripts:0</span><br><span class="line">used_memory_scripts_human:0B</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line">allocator_frag_ratio:1.63</span><br><span class="line">allocator_frag_bytes:649648</span><br><span class="line">allocator_rss_ratio:1.00</span><br><span class="line">allocator_rss_bytes:0</span><br><span class="line">rss_overhead_ratio:1.02</span><br><span class="line">rss_overhead_bytes:37888</span><br><span class="line">mem_fragmentation_ratio:1.67</span><br><span class="line">mem_fragmentation_bytes:687536</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:66616</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line">mem_allocator:libc</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br><span class="line"></span><br><span class="line"># Persistence</span><br><span class="line">loading:0</span><br><span class="line">rdb_changes_since_last_save:0</span><br><span class="line">rdb_bgsave_in_progress:0</span><br><span class="line">rdb_last_save_time:1564893311</span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:0</span><br><span class="line">rdb_current_bgsave_time_sec:-1</span><br><span class="line">rdb_last_cow_size:0</span><br><span class="line">aof_enabled:0</span><br><span class="line">aof_rewrite_in_progress:0</span><br><span class="line">aof_rewrite_scheduled:0</span><br><span class="line">aof_last_rewrite_time_sec:-1</span><br><span class="line">aof_current_rewrite_time_sec:-1</span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line">aof_last_cow_size:0</span><br><span class="line"></span><br><span class="line"># Stats</span><br><span class="line">total_connections_received:8</span><br><span class="line">total_commands_processed:214</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">total_net_input_bytes:9198</span><br><span class="line">total_net_output_bytes:101508</span><br><span class="line">instantaneous_input_kbps:0.00</span><br><span class="line">instantaneous_output_kbps:0.00</span><br><span class="line">rejected_connections:0</span><br><span class="line">sync_full:0</span><br><span class="line">sync_partial_ok:0</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:0</span><br><span class="line">expired_stale_perc:0.00</span><br><span class="line">expired_time_cap_reached_count:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:66</span><br><span class="line">keyspace_misses:7</span><br><span class="line">pubsub_channels:1</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:966</span><br><span class="line">migrate_cached_sockets:0</span><br><span class="line">slave_expires_tracked_keys:0</span><br><span class="line">active_defrag_hits:0</span><br><span class="line">active_defrag_misses:0</span><br><span class="line">active_defrag_key_hits:0</span><br><span class="line">active_defrag_key_misses:0</span><br><span class="line"></span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:b65a8be1272fab6dfd7b73b0c51e75d06e370c79</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line"># CPU</span><br><span class="line">used_cpu_sys:36.666434</span><br><span class="line">used_cpu_user:23.420130</span><br><span class="line">used_cpu_sys_children:0.044782</span><br><span class="line">used_cpu_user_children:0.009325</span><br><span class="line"></span><br><span class="line"># Cluster</span><br><span class="line">cluster_enabled:0</span><br><span class="line"></span><br><span class="line"># Keyspace</span><br><span class="line">db0:keys=6,expires=0,avg_ttl=0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-time-命令"><a href="#Redis-time-命令" class="headerlink" title="Redis time 命令"></a>Redis <code>time</code> 命令</h3><p>用于返回当前服务器时间。可用版本 &gt;= 2.6.0</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>time</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒数。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; time </span><br><span class="line">1) &quot;1564908791&quot;</span><br><span class="line">2) &quot;483839&quot;</span><br></pre></td></tr></table></figure><h3 id="Redis-lastsave-命令"><a href="#Redis-lastsave-命令" class="headerlink" title="Redis lastsave 命令"></a>Redis <code>lastsave</code> 命令</h3><p>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。可用版本 &gt;= 1.0.0</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>lastsave</code></p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>一个 UNIX 时间戳。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lastsave </span><br><span class="line">(integer) 1564893311</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-服务器命令&quot;&gt;&lt;a href=&quot;#Redis-服务器命令&quot; class=&quot;headerlink&quot; title=&quot;Redis 服务器命令&quot;&gt;&lt;/a&gt;Redis 服务器命令&lt;/h2&gt;&lt;p&gt;Redis 服务器命令主要是用于管理 redis 服务。&lt;/p&gt;&lt;h
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
      <category term="Redis命令" scheme="https://muhouer.github.io/tags/Redis%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>奇闻异事</title>
    <link href="https://muhouer.github.io/posts/a0f75295/"/>
    <id>https://muhouer.github.io/posts/a0f75295/</id>
    <published>2019-08-02T17:15:00.000Z</published>
    <updated>2019-08-04T04:21:15.792Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>为什么饮料瓶上要写「此瓶仅用于灌装本产品，请勿重复使用」？</strong></li></ol><blockquote><p>这些都是有人用血泪证明出来的。<br>举个栗子，知道现在为什么沐浴露上面标注:请勿吞食吗？<br>因为以前在美国，有一个人，专门钻法律空子的那种，有一天忽然想到，这个沐浴露上面没有标注不能吞食，发财的机会来了，然后就喝了，送到医院洗了胃，告了卖沐浴露的公司，他们公司赔了几个亿。。。。所以以后的沐浴露标的都有请勿吞食。不过刚才我看了海飞丝没有备注，请勿模仿，因为在我国，食品安全只赔十倍。也就几百块。不要模仿。</p><footer><strong>知乎仙授</strong><cite><a href="https://www.zhihu.com/question/325657727/answer/694367466" target="_blank" rel="noopener">为什么饮料瓶上要写「此瓶仅用于灌装本产品，请勿重复使用」？</a></cite></footer></blockquote><ol start="2"><li><strong>为什么录取通知书要用EMS？</strong></li></ol><blockquote><p>国内快递只有邮政EMS可以全国范围内无差别覆盖的投送，用顺风的话，你家住在江浙沪好办，你家住在祖国某个边疆偏远山区，顺风就傻眼了。并且邮政可以去一些别的快递送不到的地方（部队等）。</p><footer><strong>知乎夏东</strong><cite><a href="https://www.zhihu.com/question/33891578/answer/62693462" target="_blank" rel="noopener">为什么录取通知书要用EMS？</a></cite></footer></blockquote><ol start="3"><li><strong>排位为什么要选不一样的英雄</strong></li></ol><blockquote><p>相同的英雄，相同的技能，如果一旦出现经济等级差，那逆转几乎是不可能的。不仅如此，即便是相同水平的玩家，在使用相同英雄博弈的时候也会因为种种原因失误，一旦被单杀，这种耻辱是很难让己方队友接受的，会有种“你看人家的李白”这种冷嘲热讽，被单杀的队友也会很沮丧，甚至怄气，进而产生消极游戏心理。这可能造成初级玩家对游戏的热忱程度大打折扣。</p><footer><strong>佚名</strong><cite><a href="https://pvp.qq.com" target="_blank" rel="noopener">排位为什么要选不一样的英雄</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;&lt;li&gt;&lt;strong&gt;为什么饮料瓶上要写「此瓶仅用于灌装本产品，请勿重复使用」？&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;这些都是有人用血泪证明出来的。&lt;br&gt;举个栗子，知道现在为什么沐浴露上面标注:请勿吞食吗？&lt;br&gt;因为以前在美国，有一个人
      
    
    </summary>
    
      <category term="记录" scheme="https://muhouer.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="角度" scheme="https://muhouer.github.io/categories/%E8%AE%B0%E5%BD%95/%E8%A7%92%E5%BA%A6/"/>
    
    
      <category term="另类观点" scheme="https://muhouer.github.io/tags/%E5%8F%A6%E7%B1%BB%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令3</title>
    <link href="https://muhouer.github.io/posts/a5d6296/"/>
    <id>https://muhouer.github.io/posts/a5d6296/</id>
    <published>2019-08-02T16:10:00.000Z</published>
    <updated>2019-08-04T14:54:45.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-集合-Set-命令"><a href="#Redis-集合-Set-命令" class="headerlink" title="Redis 集合(Set)命令"></a>Redis 集合(Set)命令</h2><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<br>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。<br>集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set mysql</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd redis</span><br><span class="line">(error) ERR wrong number of arguments for &apos;sadd&apos; command</span><br><span class="line">127.0.0.1:6379&gt; smembers set</span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-Sadd-命令"><a href="#Redis-Sadd-命令" class="headerlink" title="Redis Sadd 命令"></a>Redis Sadd 命令</h3><p>将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。<br>假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。可用版本 &gt;= 1.0.0</p><ol><li>当集合 key 不是集合类型时，返回一个错误。</li><li>在Redis2.4版本以前， SADD 只接受单个成员值。</li></ol><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>sadd key value1... valuen</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>被添加到集合中的新元素的数量，不包括被忽略的元素。</p><h3 id="srandmember-key-count-命令"><a href="#srandmember-key-count-命令" class="headerlink" title="srandmember key [count] 命令"></a><code>srandmember key [count]</code> 命令</h3><p>如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。该操作和<code>spop</code>相似，但<code>spop</code>将随机元素从集合中移除并返回，而 <code>srandmember</code>则仅仅返回随机元素，而不对集合进行任何改动。可用版本 &gt;= 1.0.0</p><p>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</p><ol><li>如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。</li><li>如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h4><p>只提供 key 参数时为 O(1)。如果提供了 count 参数，那么为 O(N)，N 为返回数组的元素个数。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>只提供 key 参数时，返回一个元素；如果集合为空，返回 nil 。如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><table><thead><tr><th>命令</th><th>含义</th><th>可用版本</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>scard key</code></td><td>返回集合 <code>key</code> 的基数(集合中元素的数量)。当 <code>key</code> 不存在时，返回 <code>0</code> 。</td><td>&gt;=1.0.0</td><td>O(1)</td></tr><tr><td><code>sdiff key [key...]</code></td><td>返回一个集合的全部成员，该集合是所有给定集合之间的差集。不存在的 <code>key</code> 被视为空集。差集的结果来自前面的 FIRST_KEY ,而不是后面的 OTHER_KEY1，也不是整个 FIRST_KEY OTHER_KEY1..OTHER_KEYN 的差集。</td><td>&gt;=1.0.0</td><td>O(N)， N 是所有给定集合的成员数量之和。</td></tr><tr><td><code>sdiffstore destination key [key...]</code></td><td>这个命令的作用和<code>sdiff</code>类似，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 <code>destination</code> 集合已经存在，则将其覆盖。<code>destination</code> 可以是 <code>key</code> 本身。</td><td>&gt;=1.0.0</td><td>O(N)， N 是所有给定集合的成员数量之和。</td></tr><tr><td><code>sinter key [key ...]</code></td><td>返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 <code>key</code> 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</td><td>&gt;=1.0.0</td><td>O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</td></tr><tr><td><code>sinterstore destination key [key ...]</code></td><td>这个命令的作用和<code>sinter</code>类似，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 <code>destination</code> 集合已经存在，则将其覆盖。<code>destination</code> 可以是 <code>key</code> 本身。</td><td>&gt;=1.0.0</td><td>O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</td></tr><tr><td><code>sismember key member</code></td><td>判断 <code>member</code> 元素是否集合 <code>key</code> 的成员。如果 <code>member</code> 元素是集合的成员，返回 <code>1</code> 。如果 <code>member</code> 元素不是集合的成员，或 <code>key</code> 不存在，返回 <code>0</code> 。</td><td>&gt;= 1.0.0</td><td>O(1)</td></tr><tr><td><code>smembers key</code></td><td>返回集合 <code>key</code> 中的所有成员。不存在的 <code>key</code> 被视为空集合。</td><td>&gt;= 1.0.0</td><td>O(N)，N 为集合的基数</td></tr><tr><td><code>smove source destination member</code></td><td>将 <code>member</code> 元素从 <code>source</code> 集合移动到 <code>destination</code> 集合。原子性操作。如果 <code>source</code> 集合不存在或不包含指定的 <code>member</code> 元素，则 <code>smove</code>命令不执行任何操作，仅返回 <code>0</code> 。否则， <code>member</code> 元素从 <code>source</code> 集合中被移除，并添加到 <code>destination</code> 集合中去。</td><td>&gt;= 1.0.0</td><td>O(1)</td></tr><tr><td><code>spop key</code></td><td>移除并返回集合中的一个随机元素。当 <code>key</code> 不存在或 <code>key</code> 是空集时，返回 <code>nil</code> 。如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 <code>srandmember</code>命令。</td><td>&gt;= 1.0.0</td><td>O(1)</td></tr><tr><td><code>srem key member [member...]</code></td><td>移除集合 <code>key</code> 中的一个或多个 <code>member</code> 元素，不存在的 <code>member</code> 元素会被忽略。当 <code>key</code> 不是集合类型，返回一个错误。在 Redis 2.4 版本以前，<code>srem</code>只接受单个 <code>member</code> 值。</td><td>&gt;= 1.0.0</td><td>O(n)，n为给定member元素的数量</td></tr><tr><td><code>sunion key [key ...]</code></td><td>返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 <code>key</code> 被视为空集。</td><td>&gt;= 1.0.0</td><td>O(N)， N 是所有给定集合的成员数量之和。</td></tr><tr><td><code>sunionstore dest key [key ...]</code></td><td>这个命令的作用和<code>sinter</code>类似，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 <code>destination</code> 集合已经存在，则将其覆盖。<code>destination</code> 可以是 <code>key</code> 本身。</td><td>&gt;=1.0.0</td><td>O(N * M)， <code>N</code> 是所有给定集合的成员数量之和。</td></tr><tr><td><code>sscan key cursor [MATCH pattern] [COUNT count]</code></td><td>和 <code>scan</code> 、<code>hscan</code>、<code>zscan</code>一样，看不太明白。回头用到再看。</td><td></td><td></td></tr></tbody></table><h2 id="Redis-有序集合-sorted-set-命令"><a href="#Redis-有序集合-sorted-set-命令" class="headerlink" title="Redis 有序集合(sorted set)命令"></a>Redis 有序集合(sorted set)命令</h2><p>Redis 有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd sset 1 redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd sset 2 mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd sset 3 mysql</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd sset 3 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zadd sset 4 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange sset 0 10 withscores</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;mongodb&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;mysql&quot;</span><br></pre></td></tr></table></figure><h3 id="zadd-命令"><a href="#zadd-命令" class="headerlink" title="zadd 命令"></a><code>zadd</code> 命令</h3><p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p><p>如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。</p><ol><li><p>score 值可以是整数值或双精度浮点数。</p></li><li><p>如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</p></li><li><p>当 key 存在但不是有序集类型时，返回一个错误。</p></li></ol><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>zadd key score member [[score member] [score member] ...]</code></p><h4 id="可用版本："><a href="#可用版本：" class="headerlink" title="可用版本："></a>可用版本：</h4><p>可用版本&gt;= 1.2.0 。在 Redis 2.4 版本以前， <code>zadd</code>每次只能添加一个元素。</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h4><p>O(M*log(N))，N 是有序集的基数，M 为成功添加的新成员的数量。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值:"></a>返回值:</h4><p>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p><h3 id="zrange-命令"><a href="#zrange-命令" class="headerlink" title="zrange 命令"></a><code>zrange</code> 命令</h3><p>返回有序集 key 中，指定区间内的成员。可用版本 &gt;= 1.2.0</p><p>其中成员的位置按 score 值递增(从小到大)来排序。</p><p>具有相同 score 值的成员按字典序(lexicographical order )来排列。</p><p>如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE 命令。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p><code>zrange key start stop [WITHSCORES]</code></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。</li><li>你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</li><li>超出范围的下标并不会引起错误。比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。</li><li>另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</li><li>可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。</li><li>客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</li></ol><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</p><h3 id="zrangebyscore-命令"><a href="#zrangebyscore-命令" class="headerlink" title="zrangebyscore 命令"></a><code>zrangebyscore</code> 命令</h3><p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。可用版本 &gt;= 1.0.5</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p><code>zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</code></p><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。</p><p>可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</p><p>可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。该选项自 Redis 2.0 版本起可用。</p><h4 id="区间及无限"><a href="#区间及无限" class="headerlink" title="区间及无限"></a>区间及无限</h4><p>min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。</p><p>默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。<br>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore zset (1 5</span><br></pre></td></tr></table></figure><p>返回所有符合条件 1 &lt; score &lt;= 5 的成员，而</p><p><code>zrangebyscore zset (5 (10</code><br>则返回所有符合条件 5 &lt; score &lt; 10 的成员。</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。</p><h3 id="zremrangebyrank-命令"><a href="#zremrangebyrank-命令" class="headerlink" title="zremrangebyrank 命令"></a><code>zremrangebyrank</code> 命令</h3><p>移除有序集 key 中，指定排名(rank)区间内的所有成员。返回被移除成员的数量。</p><p>区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。</p><p>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。<br>你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><p><code>zremrangebyrank key start stop</code></p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><h3 id="zremrangebyscore-命令"><a href="#zremrangebyscore-命令" class="headerlink" title="zremrangebyscore 命令"></a><code>zremrangebyscore</code> 命令</h3><p>移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。返回被移除成员的数量。可用版本 &gt;= 1.2.0</p><p>自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 <code>zrangebyscore</code> 命令。</p><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><p><code>zremrangebyscore key min max</code></p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><h3 id="zrevrange-命令"><a href="#zrevrange-命令" class="headerlink" title="zrevrange 命令"></a><code>zrevrange</code> 命令</h3><p>返回有序集 key 中，指定区间内的成员。可用版本 &gt;= 1.2.0</p><p>其中成员的位置按 score 值递减(从大到小)来排列。<br>具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。</p><p>除了成员按 score 值递减的次序排列这一点外， <code>zrevrange</code>命令的其他方面和<code>zrange</code>命令一样。</p><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><p><code>zrevrange key start stop [WITHSCORES]</code></p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</p><h3 id="zunionstore-命令"><a href="#zunionstore-命令" class="headerlink" title="zunionstore 命令"></a><code>zunionstore</code> 命令</h3><p>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。返回保存到 destination 的结果集的基数。可用版本 &gt;= 2.0.0</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和 。</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><p><code>zunionstore destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></p><h4 id="WEIGHTS-选项"><a href="#WEIGHTS-选项" class="headerlink" title="WEIGHTS 选项"></a>WEIGHTS 选项</h4><p>使用 WEIGHTS 选项，你可以为 每个给定有序集分别指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。</p><p>如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</p><h4 id="AGGREGATE-选项"><a href="#AGGREGATE-选项" class="headerlink" title="AGGREGATE 选项"></a>AGGREGATE 选项</h4><p>使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。</p><p>默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之和作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。</p><h3 id="zinterstore-命令"><a href="#zinterstore-命令" class="headerlink" title="zinterstore 命令"></a><code>zinterstore</code> 命令</h3><p>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。返回保存到 destination 的结果集的基数。可用版本 &gt;= 2.0.0</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.</p><p>关于 WEIGHTS 和 AGGREGATE 选项的描述，参见<code>zinterstore</code>命令。</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N<em>K)+O(M</em>log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。</p><h3 id="其他命令-1"><a href="#其他命令-1" class="headerlink" title="其他命令"></a>其他命令</h3><table><thead><tr><th>命令</th><th>含义</th><th>可用版本</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>zcard key</code></td><td>返回有序集 <code>key</code> 的基数。当 <code>key</code> 存在且是有序集类型时，返回有序集的基数。当 <code>key</code> 不存在时，返回 <code>0</code> 。</td><td>&gt;=1.2.0</td><td>O(1)</td></tr><tr><td><code>zcount key min max</code></td><td>返回有序集 <code>key</code> 中， <code>score</code> 值在 <code>min</code> 和 <code>max</code> 之间(默认包括 <code>score</code> 值等于 <code>min</code> 或 <code>max</code> )的成员的数量。</td><td>&gt;=2.0.0</td><td>O(log(N)+M)， N 为有序集的基数， M 为值在 min 和 max 之间的元素的数量。</td></tr><tr><td><code>zincrby key increment member</code></td><td>为有序集 <code>key</code> 的成员 <code>member</code> 的 <code>score</code> 值加上增量 <code>increment</code> 。可以通过传递一个负数值 <code>increment</code> ，让 <code>score</code> 减去相应的值。当 <code>key</code> 不存在，或 <code>member</code> 不是 <code>key</code> 的成员时， <code>zincrby key increment member</code> 等同于 <code>zadd key increment member</code> 。当 <code>key</code> 不是有序集类型时，返回一个错误。<code>score</code> 值可以是整数值或双精度浮点数。</td><td>&gt;=1.2.0</td><td>O(log(N))</td></tr><tr><td><code>zrank key member</code></td><td>返回有序集 <code>key</code> 中成员 <code>member</code> 的排名。如果 <code>member</code> 不是有序集 <code>key</code> 的成员，返回 <code>nil</code> 。其中有序集成员按 <code>score</code> 值递增(从小到大)顺序排列。排名以 <code>0</code> 为底，也就是说， <code>score</code> 值最小的成员排名为 <code>0</code> 。</td><td>&gt;=2.0.0</td><td>O(log(N))</td></tr><tr><td><code>zrem key member [member ...]</code></td><td>移除有序集 <code>key</code> 中的一个或多个成员，不存在的成员将被忽略。f返回被成功移除的成员的数量，不包括被忽略的成员。当 <code>key</code> 存在但不是有序集类型时，返回一个错误。在 Redis 2.4 版本以前，<code>zrem</code>每次只能删除一个元素。</td><td>&gt;=1.2.0</td><td>O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。</td></tr><tr><td><code>zrevrank key member</code></td><td>返回有序集 <code>key</code> 中成员 <code>member</code> 的排名。其中有序集成员按 <code>score</code> 值递减(从大到小)排序。排名以 <code>0</code> 为底，也就是说， <code>score</code> 值最大的成员排名为 <code>0</code> 。</td><td>&gt;=2.0.0</td><td>O(log(N))</td></tr><tr><td><code>zscore key member</code></td><td>返回有序集 <code>key</code> 中，成员 <code>member</code> 的 <code>score</code> 值，以字符串形式表示。如果 <code>member</code> 元素不是有序集 <code>key</code> 的成员，或 <code>key</code> 不存在，返回 <code>nil</code> 。</td><td>&gt;=1.2.0</td><td>O(1)</td></tr><tr><td><code>zrevrangebyscore key max min [withscores] [limit offset count]</code></td><td>返回有序集 <code>key</code> 中， <code>score</code> 值介于 <code>max</code> 和 <code>min</code> 之间(默认包括等于 <code>max</code> 或 <code>min</code> )的所有的成员。有序集成员按 <code>score</code> 值递减(从大到小)的次序排列。具有相同 <code>score</code> 值的成员按字典序的逆序(<a href="http://en.wikipedia.org/wiki/Lexicographical_order" target="_blank" rel="noopener">reverse lexicographical order</a> )排列。除了成员按 <code>score</code> 值递减的次序排列这一点外，<code>zrevrangebyscore</code> 命令的其他方面和 <code>zrangebyscore</code>命令一样。</td><td>&gt;=2.2.0</td><td>O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-集合-Set-命令&quot;&gt;&lt;a href=&quot;#Redis-集合-Set-命令&quot; class=&quot;headerlink&quot; title=&quot;Redis 集合(Set)命令&quot;&gt;&lt;/a&gt;Redis 集合(Set)命令&lt;/h2&gt;&lt;p&gt;Redis 的 Set 是 Stri
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
      <category term="Redis命令" scheme="https://muhouer.github.io/tags/Redis%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令4</title>
    <link href="https://muhouer.github.io/posts/9439f735/"/>
    <id>https://muhouer.github.io/posts/9439f735/</id>
    <published>2019-08-02T16:10:00.000Z</published>
    <updated>2019-08-02T17:12:57.594Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍 Redis 发布订阅、事务、脚本、连接四个方面的命令。</p><h2 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。一个频道也可以被多个客户端订阅。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>创建了订阅频道名为 redisChat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe redisChat</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure><p>重新开启个 redis 客户端，然后在同一个频道 redisChat 发布消息，订阅者就能接收到消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish redisChat &quot;Redis is a great caching technique&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe redisChat</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) &quot;Redis is a great caching technique&quot;</span><br></pre></td></tr></table></figure><h3 id="Redis-psubscribe命令"><a href="#Redis-psubscribe命令" class="headerlink" title="Redis psubscribe命令"></a>Redis <code>psubscribe</code>命令</h3><p>订阅一个或多个符合给定模式的频道。可用版本 &gt;= 2.0.0</p><p>每个模式以 * 作为匹配符，比如 redis* 匹配所有以 redis 开头的频道( redis.news 、 redis.blog等等)。</p><p><code>punsubscribe</code> 命令用于退订所有给定模式的频道。与 <code>psubscribe</code> 类似。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>psubscribe pattern [pattern ...]</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>接收到的信息。</p><h3 id="Redis-subscribe命令"><a href="#Redis-subscribe命令" class="headerlink" title="Redis subscribe命令"></a>Redis <code>subscribe</code>命令</h3><p>用于订阅给定的一个或多个频道的信息。可用版本 &gt;= 2.0.0</p><p><code>unsubscribe</code> 命令用于退订所有给定模式的频道。与 <code>subscribe</code> 类似。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>subscribe channel [channel ...]</code></p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>接收到的信息</p><h3 id="Redis-publish命令"><a href="#Redis-publish命令" class="headerlink" title="Redis publish命令"></a>Redis <code>publish</code>命令</h3><p>用于将信息发送到指定的频道。可用版本 &gt;= 2.0.0</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p><code>publish channel message</code></p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>接收到信息的订阅者数量。</p><h3 id="Redis-pubsub命令"><a href="#Redis-pubsub命令" class="headerlink" title="Redis pubsub命令"></a>Redis <code>pubsub</code>命令</h3><p><code>pubsub</code>是一个查看订阅与发布系统状态的内省命令，它由数个不同格式的子命令组成。可用版本 &gt;= 2.8.0</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p><code>pubsub &lt;subcommand&gt; [argument [argument ...]]</code></p><h4 id="channels-子命令"><a href="#channels-子命令" class="headerlink" title="channels 子命令"></a><code>channels</code> 子命令</h4><p>列出当前的活跃频道。活跃频道指的是那些至少有一个订阅者的频道，订阅模式的客户端不计算在内。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><p><code>pubsub channels [pattern]</code></p><p>pattern 参数是可选的，如果不给出 pattern 参数，那么列出订阅与发布系统中的所有活跃频道。如果给出 pattern 参数，那么只列出和给定模式 pattern 相匹配的那些活跃频道。</p><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>O(N) ， N 为活跃频道的数量（对于长度较短的频道和模式来说，将进行模式匹配的复杂度视为常数）。</p><h5 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h5><p>一个由活跃频道组成的列表。</p><h4 id="numsub-子命令"><a href="#numsub-子命令" class="headerlink" title="numsub 子命令"></a><code>numsub</code> 子命令</h4><p>返回给定频道的订阅者数量， 订阅模式的客户端不计算在内。</p><h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><p><code>pubsub numsub [channel-1 ... channel-N]</code></p><h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>O(N)， N 为给定频道的数量。</p><h5 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h5><p>一个多条批量回复(Multi-bulk reply)，回复中包含给定的频道，以及频道的订阅者数量。 格式为：频道 channel-1，channel-1 的订阅者数量，频道 channel-2，channel-2 的订阅者数量，诸如此类。 回复中频道的排列顺序和执行命令时给定频道的排列顺序一致。不给定任何频道而直接调用这个命令也是可以的，在这种情况下，命令只返回一个空列表。</p><h4 id="numpat-子命令"><a href="#numpat-子命令" class="headerlink" title="numpat 子命令"></a><code>numpat</code> 子命令</h4><p>返回订阅模式的数量。这个命令返回的不是订阅模式的客户端的数量，而是客户端订阅的所有模式的数量总和。当有多个客户端订阅相同的模式时，相同的订阅也被计算在内</p><h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><p><code>pubsub numpat</code></p><h5 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h5><p>O(1) 。</p><h5 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h5><p>一个整数回复（Integer reply）。</p><h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ol><li>批量操作在发送<code>exec</code>命令前被放入队列缓存。</li><li>收到<code>exec</code>命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ol><p>一个事务从开始到执行会经历三个阶段：开始事务-&gt;命令入队。-&gt;执行事务。</p><h3 id="Redis-multi与exec命令"><a href="#Redis-multi与exec命令" class="headerlink" title="Redis multi与exec命令"></a>Redis <code>multi</code>与<code>exec</code>命令</h3><p>用于标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由<code>exec</code>命令原子性(atomic)地执行。可用版本 &gt;= 1.2.0</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><p><code>multi</code></p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr user_id</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr user_id</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr user_id</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 2</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) PONG</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-discard命令"><a href="#Redis-discard命令" class="headerlink" title="Redis discard命令"></a>Redis <code>discard</code>命令</h3><p>用于取消事务，放弃执行事务块内的所有命令。可用版本 &gt;= 2.0.0</p><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><p><code>discard</code></p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr user_id</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr user_id</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(error) ERR EXEC without MULTI</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-watch命令"><a href="#Redis-watch命令" class="headerlink" title="Redis watch命令"></a>Redis <code>watch</code>命令</h3><p>用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。可用版本 &gt;= 2.2.0</p><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><p><code>watch key [key ...]</code></p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h3 id="Redis-unwatch-命令"><a href="#Redis-unwatch-命令" class="headerlink" title="Redis unwatch 命令"></a>Redis <code>unwatch</code> 命令</h3><p>用于取消<code>watch</code>命令对所有 key 的监视。可用版本 &gt;= 2.2.0</p><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><p>redis Unwatch 命令基本语法如下：<br>redis 127.0.0.1:6379&gt; UNWATCH</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h2 id="Redis-脚本"><a href="#Redis-脚本" class="headerlink" title="Redis 脚本"></a>Redis 脚本</h2><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p><h3 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h3><p><code>EVAL script numkeys key [key ...] arg [arg ...]</code></p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EVAL &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;first&quot;</span><br><span class="line">4) &quot;second&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-eval-命令"><a href="#Redis-eval-命令" class="headerlink" title="Redis eval 命令"></a>Redis <code>eval</code> 命令</h3><p>使用 Lua 解释器执行脚本。可用版本 &gt;= 2.6.0</p><h4 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h4><p><code>EVAL script numkeys key [key ...] arg [arg ...]</code></p><h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h4><p>script： 参数是一段 Lua 5.1 脚本程序。脚本不必(也不应该)定义为一个 Lua 函数。</p><p>numkeys： 用于指定键名参数的个数。</p><p>key [key …]： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p><p>arg [arg …]： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p><h3 id="Redis-evalsha-命令"><a href="#Redis-evalsha-命令" class="headerlink" title="Redis evalsha 命令"></a>Redis <code>evalsha</code> 命令</h3><p>根据给定的 sha1 校验码，执行缓存在服务器中的脚本。可用版本 &gt;= 2.6.0</p><p>将脚本缓存到服务器的操作可以通过<code>SCRIPT LOAD</code>命令进行。<br>这个命令的其他地方，比如参数的传入方式，都和 <code>EVAL</code> 命令一样。</p><h4 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h4><p><code>EVALSHA sha1 numkeys key [key ...] arg [arg ...]</code></p><h4 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h4><p>sha1 ： 通过<code>SCRIPT LOAD</code>生成的 sha1 校验码。</p><p>numkeys： 用于指定键名参数的个数。</p><p>key [key …]： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p><p>arg [arg …]： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCRIPT LOAD &quot;return &apos;hello freya&apos;&quot;</span><br><span class="line">&quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;</span><br><span class="line">127.0.0.1:6379&gt; evalsha &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot; 0</span><br><span class="line">&quot;hello freya&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-script-exists-命令"><a href="#Redis-script-exists-命令" class="headerlink" title="Redis script exists 命令"></a>Redis <code>script exists</code> 命令</h3><p>用于校验指定的脚本是否已经被保存在缓存当中。可用版本 &gt;= 2.6.0</p><h4 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h4><p><code>SCRIPT EXISTS sha1 [sha1 ...]</code></p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>一个列表，包含 0 和 1 ，前者表示脚本不存在于缓存，后者表示脚本已经在缓存里面了。</p><p>列表中的元素和给定的 SHA1 校验和保持对应关系，比如列表的第三个元素的值就表示第三个 SHA1 校验和所指定的脚本在缓存中的状态。</p><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCRIPT LOAD &quot;return &apos;hello freya&apos;&quot;</span><br><span class="line">&quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;</span><br><span class="line">127.0.0.1:6379&gt; script exists &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;</span><br><span class="line">1) (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; script flush</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; script exists &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;</span><br><span class="line">1) (integer) 0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-script-kill-命令"><a href="#Redis-script-kill-命令" class="headerlink" title="Redis script kill 命令"></a>Redis <code>script kill</code> 命令</h3><p>用于杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。可用版本 &gt;= 2.6.0</p><p>这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限循环的脚本。</p><p><code>script kill</code>执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从<code>EVAL</code>命令的阻塞当中退出，并收到一个错误作为返回值。</p><h4 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h4><p><code>script kill</code></p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK</p><h2 id="Redis-连接"><a href="#Redis-连接" class="headerlink" title="Redis 连接"></a>Redis 连接</h2><p>Redis 连接命令主要是用于连接 redis 服务。</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth &quot;password&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="Redis-auth-命令"><a href="#Redis-auth-命令" class="headerlink" title="Redis auth 命令"></a>Redis <code>auth</code> 命令</h3><p>用于检测给定的密码和配置文件中的密码是否相符。可用版本 &gt;= 1.0.0</p><h4 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h4><p><code>auth pwd</code></p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>密码匹配时返回 OK ，否则返回一个错误。</p><h3 id="Redis-echo-命令"><a href="#Redis-echo-命令" class="headerlink" title="Redis echo 命令"></a>Redis <code>echo</code> 命令</h3><p>用于打印给定的字符串。可用版本 &gt;= 1.0.0</p><h4 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h4><p><code>echo message</code></p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>返回字符串本身。</p><h3 id="Redis-Quit-命令"><a href="#Redis-Quit-命令" class="headerlink" title="Redis Quit 命令"></a>Redis Quit 命令</h3><p>用于关闭与当前客户端与redis服务的连接。可用版本 &gt;= 1.0.0</p><p>一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; quit</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="Redis-select-命令"><a href="#Redis-select-命令" class="headerlink" title="Redis select 命令"></a>Redis <code>select</code> 命令</h3><p>用于切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。可用版本 &gt;= 1.0.0</p><h4 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h4><p><code>select index</code></p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要介绍 Redis 发布订阅、事务、脚本、连接四个方面的命令。&lt;/p&gt;&lt;h2 id=&quot;Redis-发布订阅&quot;&gt;&lt;a href=&quot;#Redis-发布订阅&quot; class=&quot;headerlink&quot; title=&quot;Redis 发布订阅&quot;&gt;&lt;/a&gt;Redis 发布订阅&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/Redis/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Redis/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis命令" scheme="https://muhouer.github.io/tags/Redis%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令2</title>
    <link href="https://muhouer.github.io/posts/7d5a5200/"/>
    <id>https://muhouer.github.io/posts/7d5a5200/</id>
    <published>2019-08-02T15:28:38.000Z</published>
    <updated>2019-08-04T03:51:58.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-哈希-Hash-相关命令"><a href="#Redis-哈希-Hash-相关命令" class="headerlink" title="Redis 哈希(Hash)相关命令"></a>Redis 哈希(Hash)相关命令</h2><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p><h3 id="Redis-hset命令"><a href="#Redis-hset命令" class="headerlink" title="Redis hset命令"></a>Redis <code>hset</code>命令</h3><p>用于为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，旧值将被覆盖。可用版本&gt;= 2.0.0</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>hset key field1 value1 [field2 value2 ]</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 。</p><h3 id="Redis-hsetnx命令"><a href="#Redis-hsetnx命令" class="headerlink" title="Redis hsetnx命令"></a>Redis <code>hsetnx</code>命令</h3><p>用于为哈希表中不存在的的字段赋值。如果哈希表不存在，一个新的哈希表被创建并进行<code>hset</code>操作。如果字段已经存在于哈希表中，操作无效。如果 key 不存在，一个新哈希表被创建并执行<code>hsetnx</code>命令。可用版本 &gt;= 2.0.0</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>hsetnx key field value</code></p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0 。</p><h3 id="Redis-hget命令"><a href="#Redis-hget命令" class="headerlink" title="Redis hget命令"></a>Redis <code>hget</code>命令</h3><p>用于返回哈希表中指定字段的值。可用版本&gt;= 2.0.0</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p><code>hget key field</code></p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>返回给定字段的值。如果给定的字段或 key 不存在时，返回 nil 。</p><h3 id="Redis-hgetall命令"><a href="#Redis-hgetall命令" class="headerlink" title="Redis hgetall命令"></a>Redis <code>hgetall</code>命令</h3><p>用于返回哈希表中，所有的字段和值。在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍。可用版本 &gt;= 2.0.0</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p><code>hgetall key</code></p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>以列表形式返回哈希表的字段及字段值。若 key 不存在，返回空列表。</p><h3 id="Redis-hmget命令"><a href="#Redis-hmget命令" class="headerlink" title="Redis hmget命令"></a>Redis <code>hmget</code>命令</h3><p>用于返回哈希表中，一个或多个给定字段的值。如果指定的字段不存在于哈希表，那么返回一个 nil 值。可用版本 &gt;= 2.0.0</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><p><code>hmget key field1...fieldn</code></p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含多个给定字段关联值的表，表值的排列顺序和指定字段的请求顺序一样。如果对应的 field 不存在则返回 nil。</p><h3 id="Redis-hlen命令"><a href="#Redis-hlen命令" class="headerlink" title="Redis hlen命令"></a>Redis <code>hlen</code>命令</h3><p>用于获取哈希表中字段的数量。可用版本 &gt;= 2.0.0</p><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><p><code>hlen key</code></p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>哈希表中字段的数量。当 key 不存在时，返回 0 。</p><h3 id="Redis-hkeys命令"><a href="#Redis-hkeys命令" class="headerlink" title="Redis hkeys命令"></a>Redis <code>hkeys</code>命令</h3><p>用于获取哈希表中的所有域（field）。可用版本 &gt;= 2.0.0</p><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><p><code>hkeys key</code></p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>包含哈希表中所有域（field）列表。 当 key 不存在时，返回一个空列表。</p><h3 id="Redis-hvals命令"><a href="#Redis-hvals命令" class="headerlink" title="Redis hvals命令"></a>Redis <code>hvals</code>命令</h3><p>返回哈希表所有域(field)的值。可用版本 &gt;= 2.0.0</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><p><code>hvals key</code></p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含哈希表中所有域(field)值的列表。 当 key 不存在时，返回一个空表。</p><h3 id="Redis-hexists命令"><a href="#Redis-hexists命令" class="headerlink" title="Redis hexists命令"></a>Redis <code>hexists</code>命令</h3><p>用于查看哈希表的指定字段是否存在。</p><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><p><code>hexists key field</code></p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>如果哈希表含有给定字段，返回 1 。 如果哈希表不含有给定字段，或 key 不存在，返回 0 。</p><h3 id="Redis-hdel命令"><a href="#Redis-hdel命令" class="headerlink" title="Redis hdel命令"></a>Redis <code>hdel</code>命令</h3><p>用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略。可用版本 &gt;= 2.0.0</p><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><p><code>hdel key field.. fieldn</code></p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>被成功删除字段的数量，不包括被忽略的字段。</p><h3 id="Redis-hincrby命令"><a href="#Redis-hincrby命令" class="headerlink" title="Redis hincrby命令"></a>Redis <code>hincrby</code>命令</h3><p>用于为哈希表中的字段值加上指定增量值 increment。增量也可以为负数，相当于对指定字段进行减法操作。可用版本 &gt;= 2.0.0</p><p>如果哈希表的 key 不存在，一个新的哈希表被创建并执行<code>hincrby</code>命令。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。</p><p>对一个储存字符串值的字段执行<code>hincrby</code>命令将造成一个错误。本操作的值被限制在 64 位(bit)有符号数字表示之内。</p><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><p><code>hincrby key field increment</code></p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>执行 HINCRBY 命令之后，哈希表中字段的值。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset freya age 17</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby freya age 1</span><br><span class="line">(integer) 18</span><br><span class="line">127.0.0.1:6379&gt; hincrby freya age -1</span><br><span class="line">(integer) 17</span><br><span class="line">127.0.0.1:6379&gt; exists asher</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hexists asher age</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hincrby asher age 19</span><br><span class="line">(integer) 19</span><br><span class="line">127.0.0.1:6379&gt; hgetall asher</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;19&quot;</span><br></pre></td></tr></table></figure><h3 id="Redis-hincrbyfloat命令"><a href="#Redis-hincrbyfloat命令" class="headerlink" title="Redis hincrbyfloat命令"></a>Redis <code>hincrbyfloat</code>命令</h3><p>用于为哈希表中的字段值加上指定浮点数增量值 increment。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。可用版本 &gt;= 2.6.0</p><h4 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h4><p><code>hincrbyfloat key field increment</code></p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>执行 Hincrbyfloat 命令之后，哈希表中字段的值。</p><h3 id="Redis-hscan命令"><a href="#Redis-hscan命令" class="headerlink" title="Redis hscan命令"></a>Redis <code>hscan</code>命令</h3><p><code>hscan key cursor [MATCH pattern] [COUNT count]</code></p><p>迭代哈希表中的键值对。与<code>scan</code>类似，看不太懂，回头再战。</p><h2 id="Redis-列表-List-相关命令"><a href="#Redis-列表-List-相关命令" class="headerlink" title="Redis 列表(List)相关命令"></a>Redis 列表(List)相关命令</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p><h3 id="Redis-lpush命令"><a href="#Redis-lpush命令" class="headerlink" title="Redis lpush命令"></a>Redis <code>lpush</code>命令</h3><p>将一个或多个值插入到列表头部。如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误。可用版本&gt;= 1.0.0 。<strong>在Redis 2.4版本以前的<code>lpush</code>命令，都只接受单个 value 值。</strong> <code>rpush</code> 与之类似，只不过在列表尾部添加。</p><h4 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h4><p><code>lpush key value1.. valuen</code></p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>执行<code>lpush</code>命令后，列表的长度。</p><h3 id="Redis-lpushx命令"><a href="#Redis-lpushx命令" class="headerlink" title="Redis lpushx命令"></a>Redis <code>lpushx</code>命令</h3><p>将一个值插入到已存在的列表头部，列表不存在时操作无效。可用版本 &gt;= 2.2.0 。<code>rpushx</code>与之类似，只不过在列表尾部添加。</p><h4 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h4><p><code>lpushx key value1.. valuen</code></p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p><code>lpush</code>命令执行之后，列表的长度。</p><h3 id="Redis-lindex命令"><a href="#Redis-lindex命令" class="headerlink" title="Redis lindex命令"></a>Redis <code>lindex</code>命令</h3><p>用于通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。可用版本 &gt;= 1.0.0</p><h4 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h4><p><code>lindex key index</code></p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>列表中下标为指定索引值的元素。如果指定索引值不在列表的区间范围内，返回 nil。</p><h3 id="Redis-llen命令"><a href="#Redis-llen命令" class="headerlink" title="Redis llen命令"></a>Redis <code>llen</code>命令</h3><p>用于返回列表的长度。如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 。 如果 key 不是列表类型，返回一个错误。可用版本 &gt;= 1.0.0</p><h4 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h4><p><code>llen key</code></p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>列表的长度。</p><h3 id="Redis-linsert命令"><a href="#Redis-linsert命令" class="headerlink" title="Redis linsert命令"></a>Redis <code>linsert</code>命令</h3><p>用于在列表的元素前或者后插入元素。当指定元素不存在于列表中时，不执行任何操作。可用版本 &gt;= 1.0.0</p><ol><li>当列表不存在时，被视为空列表，不执行任何操作。</li><li>如果 key 不是列表类型，返回一个错误。</li></ol><h4 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h4><p><code>linsert key BEFORE|AFTER pivot value</code></p><p>将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</p><h4 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h4><p>如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到指定元素 ，返回 -1 。 如果 key 不存在或为空列表，返回 0 。</p><h3 id="Redis-lpop命令"><a href="#Redis-lpop命令" class="headerlink" title="Redis lpop命令"></a>Redis <code>lpop</code>命令</h3><p>用于移除并返回列表的第一个元素。可用版本 &gt;= 1.0.0</p><h4 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h4><p><code>lpop key</code></p><h4 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h4><p>列表的第一个元素。当列表 key 不存在时，返回 nil 。</p><h3 id="Redis-rpop命令"><a href="#Redis-rpop命令" class="headerlink" title="Redis rpop命令"></a>Redis <code>rpop</code>命令</h3><p>用于移除列表的最后一个元素，返回值为移除的元素。可用版本 &gt;= 1.0.0</p><h4 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h4><p><code>rpop key</code></p><h4 id="返回值-18"><a href="#返回值-18" class="headerlink" title="返回值"></a>返回值</h4><p>被移除的元素。当列表不存在时，返回 nil 。</p><h3 id="Redis-lrange命令"><a href="#Redis-lrange命令" class="headerlink" title="Redis lrange命令"></a>Redis <code>lrange</code>命令</h3><p>返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。可用版本 &gt;= 1.0.0</p><h4 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h4><p><code>lrange key start end</code></p><h4 id="返回值-19"><a href="#返回值-19" class="headerlink" title="返回值"></a>返回值</h4><p>一个列表，包含指定区间内的元素。</p><h3 id="Redis-lrem命令"><a href="#Redis-lrem命令" class="headerlink" title="Redis lrem命令"></a>Redis <code>lrem</code>命令</h3><p>根据参数 count 的值，移除列表中与参数 value 相等的元素。可用版本 &gt;= 1.0.0</p><p>count 的值可以是以下几种：</p><ol><li>count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。</li><li>count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。</li><li>count = 0 : 移除表中所有与 value 相等的值。</li></ol><h4 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h4><p><code>lrem key count value</code></p><h4 id="返回值-20"><a href="#返回值-20" class="headerlink" title="返回值"></a>返回值</h4><p>被移除元素的数量。列表不存在时返回 0 。</p><h3 id="Redis-lset命令"><a href="#Redis-lset命令" class="headerlink" title="Redis lset命令"></a>Redis <code>lset</code>命令</h3><p>通过索引来设置元素的值。当索引参数超出范围，或对一个空列表进行<code>lset</code>时，返回一个错误。可用版本 &gt;= 1.0.0</p><h4 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h4><p><code>lset key index value</code></p><h4 id="返回值-21"><a href="#返回值-21" class="headerlink" title="返回值"></a>返回值</h4><p>操作成功返回 ok ，否则返回错误信息。</p><h3 id="Redis-ltrim命令"><a href="#Redis-ltrim命令" class="headerlink" title="Redis ltrim命令"></a>Redis <code>ltrim</code>命令</h3><p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。可用版本 &gt;= 1.0.0</p><p>下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><h4 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h4><p><code>ltrim key start end</code></p><h4 id="返回值-22"><a href="#返回值-22" class="headerlink" title="返回值"></a>返回值</h4><p>命令执行成功时，返回 ok 。</p><h3 id="Redis-blpop命令"><a href="#Redis-blpop命令" class="headerlink" title="Redis blpop命令"></a>Redis <code>blpop</code>命令</h3><p>移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。可用版本 &gt;= 2.0.0 。<code>brpop</code>与之类似，只不过在列表尾部移除。</p><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p><p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</p><h4 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h4><p><code>blpop list[list...] timeout</code></p><p>返回值<br>如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。可用版本 &gt;= 1.0.0</p><h3 id="Redis-rpoplpush命令"><a href="#Redis-rpoplpush命令" class="headerlink" title="Redis rpoplpush命令"></a>Redis <code>rpoplpush</code>命令</h3><p>用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</p><p>在一个原子时间内，执行以下两个动作：</p><ol><li>将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。</li><li>将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。</li></ol><h4 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h4><p><code>rpoplpush source_key dest_key</code></p><h4 id="返回值-23"><a href="#返回值-23" class="headerlink" title="返回值"></a>返回值</h4><p>被弹出的元素。</p><h3 id="Redis-brpoplpush命令"><a href="#Redis-brpoplpush命令" class="headerlink" title="Redis brpoplpush命令"></a>Redis <code>brpoplpush</code>命令</h3><p><code>brpoplpush</code>是<code>rpoplpush</code>的阻塞版本，当给定列表 source 不为空时，<code>brpoplpush</code>的表现和<code>rpoplpush</code>一样。可用版本 &gt;= 2.2.0</p><p>当列表 source 为空时，<code>brpoplpush</code>命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行<code>lpush</code>或<code>rpush</code>命令为止。</p><p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</p><h4 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h4><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。<br>反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-哈希-Hash-相关命令&quot;&gt;&lt;a href=&quot;#Redis-哈希-Hash-相关命令&quot; class=&quot;headerlink&quot; title=&quot;Redis 哈希(Hash)相关命令&quot;&gt;&lt;/a&gt;Redis 哈希(Hash)相关命令&lt;/h2&gt;&lt;p&gt;Redis 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>拾句-现实</title>
    <link href="https://muhouer.github.io/posts/a9bf165e/"/>
    <id>https://muhouer.github.io/posts/a9bf165e/</id>
    <published>2019-07-30T16:54:00.000Z</published>
    <updated>2019-08-04T15:15:16.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="001"><a href="#001" class="headerlink" title="001"></a>001</h3><hr><blockquote><p>我们现在的现代生活里，在忙碌之后，真正夜半三更的时候，更多的体会还是孤独，所以这个时候就特别渴望有一个相伴，所以爱情在这个地方，跟我们这个部分就有高度的契合。所以孤独本身有时候会让人滑向爱情，好像爱情可以填补这个孤独，但是这是一个特别大的误区，因为两个人真正在一起，它有时候释放出来的孤独，比你原来一个人承担的孤独还要大，因为它伴随着一个特别大的失望，生存生命是要靠自己去承担的，而不是躲到那种所谓的爱情里面去，就像柏拉图讲，人要在洞穴阶段，在一片黑暗里面，获得反思，获得认识，获得沉淀。所以我们人生有时候不要回避，一孤独就觉得为什么我孤独了，就忙着逃避，有的人觉得为什么我还不谈恋爱，我的女朋友、男朋友怎么还不出现，然后我一个人还单着，很多人在恋爱里面，爱人变成对自己的一个弥补，根本的爱的来源是创伤，我们要意识到为什么一个人特别需要，在现代生活里面，需要独立地去成长一段时间，因为在这个过程里面要把自己内心的创伤，要给它认识到，要给它愈合。生命要打开新的叶子，生长出新的枝叶来，来获得一个比较完整的生命，然后去爱人。因为我们今天的社会里面，特别容易有创伤，尤其是我们今天的的独生子女一代，他没有任何经验，也没有任何以前我们传统社会里面的兄弟姐妹，我们的要求太多了，渴望得到的东西也太多了，所以在这种情况下，我们的爱情里面就承担了太多的东西，所以一旦结婚的话，互相的需求度太大了，造成沉重的压力，然后每一个都没有什么输出的能力，互相都是枯竭的，所以就是巨大的失望，所以这些，潜在的需要，我们要有一种自我清理，其实你要珍惜你的这一段孤独，你一旦在这个孤独里面获得了自己的这种独立的生存，获得了自己的内容，获得了自己生命的坚实，这个时候你才真正地变成了一个在这个世界能承担爱情的人，你一生里面如何获得几年的孤独时间，这还真是挺值得去好好地努力的东西，实际上从另外一个意义上说，你的成长就在孤独里面，所以我觉得这个是一个我们原来很容易被扭曲的东西，在天黑以后，往热闹地方躲，可心里头，有定时的闹钟，提醒你有多寂寞。</p><footer><strong>一席|万象|孤独</strong><cite><a href="https://yixi.tv/wanxiang/2/10" target="_blank" rel="noopener">yixi.tv/wanxiang/2/10</a></cite></footer></blockquote><ol><li><strong>在我们国家在出轨这件事上，对小三和对出轨丈夫的接受程度简直天差地别。对小三的态度是绝对的零容忍，但对出轨的男人来说会相对宽容。</strong></li><li><strong>人生最好的三个词——久别重逢、失而复得、虚惊一场。但却没有「和好如初」。只因和好容易，如初太难。</strong></li><li><strong>打太极——踢皮球</strong></li><li><strong>曾经那些如胶似漆的，终有一天会因激情燃尽厌弃对方后而渐行渐远。人，总以缘分来作为了却情义的假词。人活着注定是要孤独的，以前不懂的，现在也应该懂了。</strong></li><li><strong>你觉得电流只走耗电少的那一条。事实上并不是。电流其实走了所有的路。因为电路中电流的产生是要靠电场的。电场会迅速找到阻抗最小的路。期间是一个局部场强不断重新分布的过程，只不过电场很快，你感受不到它的分布。</strong></li><li><strong>简单地说，电流是由电场建立的，电场的建立依据波动方程，你所看到的现象只是电路达到平衡后的稳态，而稳态建立前的瞬间，电流是向四面八方传播的。</strong></li><li><strong>其实很多女生都很好，只是少数女生被那些有毒公众号洗脑了。</strong></li><li><strong>「好人若不团结，必被坏人一一消灭」，这条基本原则不仅适用于以个人为单位，也适用于以国家为单位。</strong>——饭否</li><li><strong>所谓政治，就是老年人谈话、年轻人流血。</strong></li></ol><hr><h3 id="002"><a href="#002" class="headerlink" title="002"></a>002</h3><hr><blockquote><p>你和我玩就不许和我讨厌的人玩，你是我爸妈就是这么多年只想着对我这个小孩付出，你是我朋友不能对我有一丝抱怨和吐槽，你是我的恋人该永远忠贞不能有一丝一毫别的念头。<br>后来发现，绝不是这样的…因为人实在是一种太复杂的生物了太多时候，一些行为并不代表对方不爱你或者不在乎你。<br>如果非要纠结，就会发现世界本就是不纯粹的迈入成年人阶段的过程中，你的三观是无限摧毁建立的。<br>到最后你发现，很多你认定错或者对的事情，到最后只是你以为了而已…你会发现每个人都不是你想象那般好，也不是你想象那般差。<br>你会发现，前一刻的自己的想法如此幼稚，看法过于绝对慢慢宽容一切之后发现，其实是解放了自己。</p><p>——博主:为什么不去问问神奇的阿UU呢</p><footer><strong>知乎无闻</strong><cite><a href="https://www.zhihu.com/question/328988589/answer/742934290" target="_blank" rel="noopener">www.zhihu.com/question/328988589/answer/742934290</a></cite></footer></blockquote><ol><li><strong>只有观念才能战胜观念，学者的使命是纠正错误观念。</strong>——哈耶克</li><li><strong>战争年代，由于存在战争这种强力的淘汰工具，能够迅速证明一个军官的能力和判断，从而保证这个体系掌握在有能力的人手里。而和平时期，这样一个体系没有了这种最终验证的机制，很容易在内部文化上形成上级对下级的粗暴干涉，层层相压，带有强烈的威权色彩。一旦主官的意志形成绝对，那么天然就是官僚威权体系的温床，甚至比普通的官僚体系还要差。</strong></li><li><strong>人们总以为在某个特定时刻，一切错误将被纠正，所有伤痕将会痊愈，但这样的时刻并不存在。</strong></li><li><strong>虽然老话常说，己所不欲，勿施于人。但这就是大道理罢了，很多人都是把自己受的气，又原封不动地撒到比自己更弱小的人身上去。这世界上，越是弱小越是容易遭遇令人讨厌的事情。</strong></li><li><strong>于荣光在《给爸爸的信》里差点把李连杰打死，论个头块头功夫真打起来，除了职业散打选手谁都打不过他，中国人不爱看体格压制的电影，就喜欢以小博大。</strong></li><li><strong>给个淘宝链接，加个微信，百度一下，已经成了很正常的语义，品牌代表品类，这才是基础设施最恐怖的地方。</strong>——半佛仙人</li><li><strong>人类文明史就像一场永不退场的牌局，只是出牌的人变了又变。人类是一个进化飞快的民族，很多问题只要被发现，就离解决不远了。</strong>——半佛仙人</li><li><strong>对一部作品解读最差的可能就是作者本人了。</strong>——苏格拉底</li><li><strong>咸吃萝卜淡操心往往不是太闲，是太坏。</strong></li></ol><hr><h3 id="003"><a href="#003" class="headerlink" title="003"></a>003</h3><hr><ol><li><strong>A10攻击机的第一视角。电视剧主角在这样的扫射下一路狂奔是不可能的，炮弹比音速还快，正确的拍法是主角什么都没听到呢，没有任何反应，突然人就没了……</strong></li><li><strong>100多年前，当大型企业首次出现时，它们能够模仿的唯一组织就是军队。</strong>——彼得·德鲁克</li><li><strong>不要说美团卧虎藏龙？因为是有太多的强者向生活低了头。</strong></li><li><strong>怀孕的时候，老公说我陪你一起胖，生过孩子我再陪你一起减肥！</strong></li><li><strong>越伪装越可悲，越伪装越没有机会。年轻时一定要把这点当成纪律遵守。并不是说中年人老年人不要遵守这纪律，只是年轻时违反这纪律，中老年在财务与人格上双重破产，一点也不重要了，随他们去吧。</strong>——连叔</li><li><strong>那种最庞大的金融机器一旦开动起来就几乎不可能平稳停下来，不管是基于战争的金融，还是基于土地的金融。</strong>——饭否</li><li><strong>中国有一句话，徒弟找师傅，师傅也找徒弟，找一个好徒弟很难的。</strong></li><li><strong>之所以大家觉得天气预报“特别不准”，很大程度上是心理原因，天气预报准的时候，大家并不会惊呼。可一旦不准就立马成为谈资，这才留下“特别不准”的偏见。</strong></li><li><strong>著名的哲学家阿甘他妈曾说过，生活就像一盒巧克力，你永远不知道下一颗的味道。生活也用一次次无情耳光告诉我们：天有不测风云，人有祸福旦夕。</strong></li></ol><hr><h3 id="004"><a href="#004" class="headerlink" title="004"></a>004</h3><ol><li><strong>斯蒂格勒定律，又名“名字来由法则”，是美国统计学家史蒂芬·斯蒂格勒提出的定律，指出科学发现或定律的命名最终大多归功于后来更有名望的科学家，而非其原发现者或创始人。</strong></li><li><strong>礼貌最大的作用，就是营造这种距离感。</strong></li><li><strong>有余力的话还能继续装，没有余力了就会原形毕露。</strong></li><li><strong>与人深交的成本是很高的。</strong></li><li><strong>她对你没有好奇，你说的，她就听，没说的，她也不会追着问；你问的，她就答，没问到的，也不多解释。没有特别想要了解你，或被你了解，就不必走太近。</strong></li><li><strong>待人友善是教养，独来独往是性格。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;001&quot;&gt;&lt;a href=&quot;#001&quot; class=&quot;headerlink&quot; title=&quot;001&quot;&gt;&lt;/a&gt;001&lt;/h3&gt;&lt;hr&gt;&lt;blockquote&gt;&lt;p&gt;我们现在的现代生活里，在忙碌之后，真正夜半三更的时候，更多的体会还是孤独，所以这个时候就特别渴望有一
      
    
    </summary>
    
      <category term="拾句" scheme="https://muhouer.github.io/categories/%E6%8B%BE%E5%8F%A5/"/>
    
    
      <category term="现实" scheme="https://muhouer.github.io/tags/%E7%8E%B0%E5%AE%9E/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令1</title>
    <link href="https://muhouer.github.io/posts/e45303ba/"/>
    <id>https://muhouer.github.io/posts/e45303ba/</id>
    <published>2019-07-30T14:29:00.000Z</published>
    <updated>2019-08-02T15:26:55.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><p>Redis 命令用于在 redis 服务上执行操作。</p><p>要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Redis 客户端的基本语法为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli</span></span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例讲解了如何启动 redis 客户端：</p><p>启动 redis 客户端，打开终端并输入命令 <strong>redis-cli</strong>。该命令会连接本地的 redis 服务。连接到本地的 redis 服务并执行 <strong>PING</strong> 命令，该命令用于检测 redis 服务是否启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><hr><h2 id="在远程服务上执行命令"><a href="#在远程服务上执行命令" class="headerlink" title="在远程服务上执行命令"></a>在远程服务上执行命令</h2><p>如果需要在远程 <code>Redis</code> 服务上执行命令，同样我们使用的也是 <strong><code>redis-cli</code></strong> 命令。和上面实例类似，上述命令执行的是默认参数，<code>host</code> 为 <code>127.0.0.1</code> ，<code>port</code>为 <code>6379</code>， 无需密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6379 -a <span class="string">"mypass"</span></span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h host -p port -a password</span></span><br></pre></td></tr></table></figure><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6379 -a <span class="string">"mypass"</span></span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h2 id="Redis-键-key-相关命令"><a href="#Redis-键-key-相关命令" class="headerlink" title="Redis 键(key)相关命令"></a>Redis 键(key)相关命令</h2><p>Redis 键命令用于管理 redis 的键。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>Redis 键命令的基本语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># del 是一个命令， name 是一个键。如果键被删除成功，命令执行后输出 (integer) 1，否则将输出 (integer) 0</span></span></span><br><span class="line">127.0.0.1:6379&gt; set name redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; del name  </span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h3 id="Redis键相关的基本命令"><a href="#Redis键相关的基本命令" class="headerlink" title="Redis键相关的基本命令"></a>Redis键相关的基本命令</h3><table><thead><tr><th>命令</th><th>描述</th><th>可用版本</th></tr></thead><tbody><tr><td><code>del key</code></td><td>该命令用于在 key 存在时删除 key。返回被删除 key 的数量</td><td>&gt;= 1.0.0</td></tr><tr><td><code>dump key</code></td><td>该命令用于序列化给定 key 。如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。</td><td>&gt;= 2.6.0</td></tr><tr><td><code>exists key</code></td><td>该命令用于检查给定 key 是否存在。若 key 存在返回 1 ，否则返回 0 。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>expire key seconds</code></td><td>1. 该命令用于设置 key 的过期时间，key 过期后将不再可用。单位以秒计。设置成功返回 1 。 当 key 不存在或者不能为 key 设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的过期时间)返回 0 。在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 <code>key</code> 会导致整个 <code>key</code> 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。<br>2. 在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 <code>key</code> 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>pexpire key milliseconds</code></td><td>该命令和 <code>expire</code> 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间。</td><td>&gt;= 2.6.0</td></tr><tr><td><code>expireat key timestamp</code></td><td>该命令用于以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间，单位以秒计。key 过期后将不再可用。设置成功返回 1 。当 key 不存在或者不能为 key 设置过期时间时返回 0 。</td><td>&gt;= 1.2.0</td></tr><tr><td><code>pexpireat key milliseconds-timestamp</code></td><td>该命令和<code>expireat</code>命令类似，但它以毫秒为单位设置 <code>key</code> 的过期 unix 时间戳。</td><td>&gt;= 2.6.0</td></tr><tr><td><code>keys pattern</code></td><td>1. 该命令用于查找所有符合给定模式 <code>pattern</code> 的 <code>key</code>。时间复杂度：O(N)， <code>N</code> 为数据库中 <code>key</code> 的数量。返回符合给定模式的 <code>key</code> 列表。<br>2. <code>keys</code>的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 <code>key</code> ，你最好还是用 Redis 的集合结构(set)来代替。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>move key db</code></td><td>1. 该命令用于将当前数据库的 <code>key</code> 移动到给定的数据库 <code>db</code> 当中。时间复杂度：O(1)。移动成功返回 1 ，失败则返回 0 。<br>2. 如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 <code>key</code> ，或者 <code>key</code> 不存在于当前数据库，那么 <code>MOVE</code> 没有任何效果。因此，也可以利用这一特性，将 <code>move</code>当作锁(locking)原语(primitive)。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>persist key</code></td><td>该命令用于移除给定 <code>key</code> 的生存时间，将这个 <code>key</code> 从『易失的』(带生存时间 <code>key</code> )转换成『持久的』(一个不带生存时间、永不过期的 <code>key</code> )。时间复杂度：O(1)。当生存时间移除成功时，返回 1 .如果 key 不存在或 key 没有设置生存时间，返回 0 。</td><td>&gt;= 2.2.0</td></tr><tr><td><code>ttl key</code></td><td>1. 该命令以秒为单位返回 key 的剩余过期时间。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。时间复杂度：O(1)<br>2. 在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>pttl key</code></td><td>1. 该命令以毫秒为单位返回 key 的剩余过期时间。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。时间复杂度：O(1)<br>2. 在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</td><td>&gt;= 2.6.0</td></tr><tr><td><code>randomkey</code></td><td>该命令从当前数据库中随机返回(不删除)一个 <code>key</code> 。时间复杂度：O(1)。当数据库不为空时，返回一个 key 。当数据库为空时，返回 nil 。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>rename key newkey</code></td><td>将 <code>key</code> 改名为 <code>newkey</code> 。时间复杂度：O(1)。改名成功时提示 OK ，当 <code>key</code> 和 <code>newkey</code> 相同，或者 <code>key</code> 不存在时，返回一个错误。当 <code>newkey</code> 已经存在时， <code>raname</code>命令将覆盖旧值。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>renamenx key newkey</code></td><td>将 <code>key</code> 改名为 <code>newkey</code> 。时间复杂度：O(1)。当且仅当 <code>newkey</code> 不存在时，将 <code>key</code> 改名为 <code>newkey</code> 。修改成功时，返回 1 。当 <code>newkey</code> 存在时，返回 0 。当 <code>key</code> 不存在时，返回一个错误。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>type key</code></td><td>返回 <code>key</code> 所储存的值的类型。时间复杂度：O(1)。none (key不存在)string (字符串)list (列表)set (集合)zset (有序集)hash (哈希表)</td><td>&gt;= 1.0.0</td></tr></tbody></table><h3 id="Redis键相关的其他命令"><a href="#Redis键相关的其他命令" class="headerlink" title="Redis键相关的其他命令"></a>Redis键相关的其他命令</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><p><code>sort key [by pattern] [limit offset count] [get pattern [get pattern ...]] [asc | desc] [alpha] [store destination]</code></p><p>返回或保存给定列表、集合、有序集合 key 中经过排序的元素。排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</p><h5 id="一般-SORT-用法"><a href="#一般-SORT-用法" class="headerlink" title="一般 SORT 用法"></a>一般 SORT 用法</h5><p>最简单的 SORT 使用方法是 SORT key 和 SORT key DESC ：</p><ol><li><code>sort key</code> 返回键值从小到大排序的结果。</li><li><code>sort key desc</code> 返回键值从大到小排序的结果。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush cost 20 18 35 9.3 18</span><br><span class="line">(integer) 5</span><br><span class="line"># 排序</span><br><span class="line">127.0.0.1:6379&gt; sort cost</span><br><span class="line">1) &quot;9.3&quot;</span><br><span class="line">2) &quot;18&quot;</span><br><span class="line">3) &quot;18&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;35&quot;</span><br><span class="line"># 逆序排序</span><br><span class="line">127.0.0.1:6379&gt; sort cost desc </span><br><span class="line">1) &quot;35&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;18&quot;</span><br><span class="line">4) &quot;18&quot;</span><br><span class="line">5) &quot;9.3&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="使用外部-key-进行排序"><a href="#使用外部-key-进行排序" class="headerlink" title="使用外部 key 进行排序"></a>使用外部 key 进行排序</h5><p>可以使用外部 key 的数据作为权重，代替默认的直接对比键值的方式来进行排序。<br>假设现在有用户数据如下：</p><table><thead><tr><th align="left">uid</th><th align="left">user_name_{uid}</th><th align="left">user_level_{uid}</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">admin</td><td align="left">9999</td></tr><tr><td align="left">2</td><td align="left">jack</td><td align="left">10</td></tr><tr><td align="left">3</td><td align="left">peter</td><td align="left">25</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush uid 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; set user_name_1 admin</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set user_level_1 9999</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lpush uid 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; set user_name_2 jack</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set user_level_2 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lpush uid 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; set user_name_3 peter</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set user_level_3 25</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; sort uid by user_level_*</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>默认情况下， SORT uid 直接按 uid 中的值排序，通过使用 BY 选项，可以让 uid 按其他键的元素来排序。</p><p>user_level_* 是一个占位符， 它先取出 uid 中的值， 然后再用这个值来查找相应的键。</p><p>比如在对 uid 列表进行排序时， 程序就会先取出 uid 的值 1 、 2 、 3 ， 然后使用 user_level_1 、 user_level_2 、 user_level_3的值作为排序 uid 的权重。</p><h5 id="get-选项"><a href="#get-选项" class="headerlink" title="get 选项"></a>get 选项</h5><p>使用<code>get</code>选项， 可以根据排序的结果来取出相应的键值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort uid get user_name_*</span><br><span class="line">1) &quot;admin&quot;</span><br><span class="line">2) &quot;jack&quot;</span><br><span class="line">3) &quot;peter&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="组合使用-by-和-get"><a href="#组合使用-by-和-get" class="headerlink" title="组合使用 by 和 get"></a>组合使用 by 和 get</h5><p>通过组合使用<code>by</code>和<code>get</code>， 可以让排序结果以更直观的方式显示出来。</p><p>比如说， 以下代码先按 user_level_{uid} 来排序 uid 列表， 再取出相应的 user_name_{uid} 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort uid by user_level_* get user_name_*</span><br><span class="line">1) &quot;jack&quot;  </span><br><span class="line">2) &quot;peter&quot; </span><br><span class="line">3) &quot;mary&quot;</span><br></pre></td></tr></table></figure><h5 id="获取多个外部键"><a href="#获取多个外部键" class="headerlink" title="获取多个外部键"></a>获取多个外部键</h5><p>可以同时使用多个<code>get</code>选项， 获取多个外部键的值。<code>get</code>有一个额外的参数规则——可以用 # 获取被排序键的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort uid get # get user_level_* get user_name_*</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;9999&quot;</span><br><span class="line">3) &quot;admin&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;10&quot;</span><br><span class="line">6) &quot;jack&quot;</span><br><span class="line">7) &quot;3&quot;</span><br><span class="line">8) &quot;25&quot;</span><br><span class="line">9) &quot;peter&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="获取外部键，但不进行排序"><a href="#获取外部键，但不进行排序" class="headerlink" title="获取外部键，但不进行排序"></a>获取外部键，但不进行排序</h5><p>通过将一个不存在的键作为参数传给<code>by</code>选项， 可以让<code>sort</code>跳过排序操作， 直接返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort uid by not-exists-key</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;1&quot;</span><br></pre></td></tr></table></figure><p>这种用法在单独使用时，没什么实际用处。<br>不过，通过将这种用法和<code>get</code>选项配合， 就可以在不排序的情况下， 获取多个外部键， 相当于执行一个整合的获取操作（类似于 SQL 数据库的 join 关键字）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort uid by not-exists-key get # get user_level_* get user_name_*</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;25&quot;</span><br><span class="line">3) &quot;peter&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;10&quot;</span><br><span class="line">6) &quot;jack&quot;</span><br><span class="line">7) &quot;1&quot;</span><br><span class="line">8) &quot;9999&quot;</span><br><span class="line">9) &quot;admin&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="保存排序结果"><a href="#保存排序结果" class="headerlink" title="保存排序结果"></a>保存排序结果</h5><p>默认情况下， <code>sort</code>操作只是简单地返回排序结果，并不进行任何保存操作。<br>通过给<code>store</code>选项指定一个 key 参数，可以将排序结果保存到给定的键上。<br>如果被指定的 key 已存在，那么原有的值将被排序结果覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush numbers 1 3 5 7 9</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; rpush numbers 2 4 6 8 10</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line"> 1) &quot;1&quot;</span><br><span class="line"> 2) &quot;3&quot;</span><br><span class="line"> 3) &quot;5&quot;</span><br><span class="line"> 4) &quot;7&quot;</span><br><span class="line"> 5) &quot;9&quot;</span><br><span class="line"> 6) &quot;2&quot;</span><br><span class="line"> 7) &quot;4&quot;</span><br><span class="line"> 8) &quot;6&quot;</span><br><span class="line"> 9) &quot;8&quot;</span><br><span class="line">10) &quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt; sort numbers store sorted-numbers</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; lrange sorted-numbers 0 -1</span><br><span class="line"> 1) &quot;1&quot;</span><br><span class="line"> 2) &quot;2&quot;</span><br><span class="line"> 3) &quot;3&quot;</span><br><span class="line"> 4) &quot;4&quot;</span><br><span class="line"> 5) &quot;5&quot;</span><br><span class="line"> 6) &quot;6&quot;</span><br><span class="line"> 7) &quot;7&quot;</span><br><span class="line"> 8) &quot;8&quot;</span><br><span class="line"> 9) &quot;9&quot;</span><br><span class="line">10) &quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>可以通过将<code>sort</code>命令的执行结果保存，并用<code>expire</code>为结果设置生存时间，以此来产生一个<code>sort</code>操作的结果缓存。</p><p>这样就可以避免对<code>sort</code>操作的频繁调用：只有当结果集过期时，才需要再调用一次<code>sort</code>操作。</p><p>另外，为了正确实现这一用法，你可能<strong>需要加锁以避免多个客户端同时进行缓存重建</strong>(也就是多个客户端，同一时间进行<code>sort</code>操作，并保存为结果集)，具体参见<code>setnx</code>命令。</p><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p><code>object subcommand [arguments [arguments]]</code></p><p><code>object</code>命令允许从内部察看给定<code>key</code>的 Redis 对象。</p><p>它通常用在除错(debugging)或者了解为了节省空间而对 key 使用特殊编码的情况。<br>当将Redis用作缓存程序时，你也可以通过 OBJECT 命令中的信息，决定 key 的驱逐策略(eviction policies)。</p><p>可用版本：&gt;= 2.2.3 ，时间复杂度：O(1)。</p><h5 id="object-命令子命令"><a href="#object-命令子命令" class="headerlink" title="object 命令子命令"></a>object 命令子命令</h5><ol><li><code>object refcount key</code> 返回给定 key 引用所储存的值的次数。此命令主要用于除错。</li><li><code>object encoding key</code> 返回给定 key 锁储存的值所使用的内部表示(representation)。</li><li><code>object idletime key</code> 返回给定 key 自储存以来的空转时间(idle， 没有被读取也没有被写入)，以秒为单位。</li></ol><h5 id="对象编码方式："><a href="#对象编码方式：" class="headerlink" title="对象编码方式："></a>对象编码方式：</h5><ol><li>字符串可以被编码为<code>raw</code>(一般字符串)、<code>embstr</code>或<code>int</code>(用字符串表示64位数字是为了节约空间)。</li><li>列表可以被编码为<code>ziplist</code>或<code>linkedlist</code>。 <code>ziplist</code>是为节约大小较小的列表空间而作的特殊表示。</li><li>集合可以被编码为<code>intset</code>或者<code>hashtable</code>。 <code>intset</code>是只储存数字的小集合的特殊表示。</li><li>哈希表可以编码为<code>zipmap</code>或者<code>hashtable</code> 。 <code>zipmap</code>是小哈希表的特殊表示。<br>有序集合可以被编码为 ziplist 或者 skiplist 格式。 ziplist 用于表示小的有序集合，而 skiplist 则用于表示任何大小的有序集合。</li></ol><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name &quot;redis&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object refcount name </span><br><span class="line">(integer) 1 # 只有一个引用</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; object idletime name</span><br><span class="line">(integer) 104 # 等待一阵，然后查看空转时间</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; object idletime name</span><br><span class="line">(integer) 1 # get之后立即查空转时间</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line">&quot;embstr&quot; # 对象编码方式</span><br><span class="line">127.0.0.1:6379&gt; set phone 17608882643</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding phone</span><br><span class="line">&quot;int&quot;</span><br><span class="line">127.0.0.1:6379&gt; set phone 9223372036854775808</span><br><span class="line">OK # 大于或等于2的64次方，被编码为字符串</span><br><span class="line">127.0.0.1:6379&gt; object encoding phone</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; set phone 111111111111111111111111111111111111111111111</span><br><span class="line">OK  # 超过44位之后以 raw 编码</span><br><span class="line">127.0.0.1:6379&gt; object encoding phone</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure><p>具体为什么是44而不是其他数字，原因可参考<br><a href="https://www.zhihu.com/question/25624589" target="_blank" rel="noopener">为什么redis小等于39字节的字符串是embstr编码，大于39是raw编码？</a> 44和39只是因为版本支持不同，github修改记录可参考<a href="https://github.com/antirez/redis/commit/f15df8ba5db09bdf4be58c53930799d82120cc34#diff-43278b647ec38f9faf284496e22a97d5" target="_blank" rel="noopener">commit</a></p><h4 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h4><p><code>restore key ttl serialized-value</code></p><p>反序列化给定的序列化值，并将它和给定的<code>key</code>关联。与<code>dump</code>相对应。可用版本：&gt;= 2.6.0</p><p>参数<code>ttl</code>以毫秒为单位为<code>key</code>设置生存时间；如果<code>ttl</code>为 0 ，那么不设置生存时间。</p><p><code>restore</code>在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么<code>restore</code>会拒绝进行反序列化，并返回一个错误。</p><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ol><li>查找给定键的复杂度为 O(1) ，对键进行反序列化的复杂度为 O(N*M) ，其中 N 是构成 key 的 Redis 对象的数量，而 M 则是这些对象的平均大小。</li><li>有序集合(sorted set)的反序列化复杂度为 O(N<em>M</em>log(N)) ，因为有序集合每次插入的复杂度为 O(log(N)) 。</li><li>如果反序列化的对象是比较小的字符串，那么复杂度为 O(1) 。</li></ol><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set hi "Hello, World!"</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; dump hi  # 序列化</span><br><span class="line">"\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; restore hi 0 "\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR"  # 反序列化时key已存在</span><br><span class="line">(error) BUSYKEY Target key name already exists.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; restore hi-restore 0 "\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR" # 反序列化</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; restore fake-hi 0 "hello blablabla" # 使用错误的值进行反序列化</span><br><span class="line">(error) ERR DUMP payload version or checksum are wrong</span><br></pre></td></tr></table></figure><h4 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h4><p><code>migrate host port key destination-db timeout [copy] [replace]</code></p><p>将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。可用版本：&gt;= 2.6.0。迁移成功时返回 OK ，否则返回相应的错误。</p><p>这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。</p><h5 id="可选项："><a href="#可选项：" class="headerlink" title="可选项："></a>可选项：</h5><ol><li><code>copy</code> ：不移除源实例上的 key 。</li><li><code>replace</code> ：替换目标实例上已存在的 key 。</li></ol><h5 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h5><p>它在当前实例对给定 key 执行<code>dump</code>命令 ，将它序列化，然后传送到目标实例，目标实例再使用<code>restore</code>对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到<code>restore</code>命令返回 OK ，它就会调用<code>del</code>删除自己数据库上的 key 。</p><p>timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。</p><p><code>migrate</code>命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。</p><p>当 IOERR 出现时，有以下两种可能：</p><ol><li>key 可能存在于两个实例</li><li>key 可能只存在于当前实例<br>唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。</li></ol><p>如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）。</p><h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>这个命令在源实例上实际执行 DUMP 命令和 DEL 命令，在目标实例执行 RESTORE 命令，查看以上命令的文档可以看到详细的复杂度说明。<br>key 数据在两个实例之间传输的复杂度为 O(N) 。</p><h5 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h5><ol><li>启动两个Redis实例，一个默认 6379 端口，一个 9999 接口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-server --port 9999</span><br><span class="line">80619:C 01 Aug 2019 23:21:22.685 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">80619:C 01 Aug 2019 23:21:22.686 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=80619, just started</span><br><span class="line">80619:C 01 Aug 2019 23:21:22.686 # Configuration loaded</span><br><span class="line">80619:M 01 Aug 2019 23:21:22.687 * Increased maximum number of open files to 10032 (it was originally set to 256).</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &apos;&apos;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &apos;&apos;-._           Redis 5.0.5 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &apos;&apos;-._                                   </span><br><span class="line"> (    &apos;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 9999</span><br><span class="line"> |    `-._   `._    /     _.-&apos;    |     PID: 80619</span><br><span class="line">  `-._    `-._  `-./  _.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line">      `-._    `-.__.-&apos;    _.-&apos;                                       </span><br><span class="line">          `-._        _.-&apos;                                           </span><br><span class="line">              `-.__.-&apos;                                               </span><br><span class="line"></span><br><span class="line">80619:M 01 Aug 2019 23:21:22.691 # Server initialized</span><br><span class="line">80619:M 01 Aug 2019 23:21:22.692 * DB loaded from disk: 0.001 seconds</span><br><span class="line">80619:M 01 Aug 2019 23:21:22.692 * Ready to accept connections</span><br></pre></td></tr></table></figure><ol start="2"><li>用客户端连上 6379 端口的实例，设置一个键，然后将它迁移到 7777 端口的实例上</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set hello "Hello from 6379 instance"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 9999 hello 0 1000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; exists hello </span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 迁移成功后 key 被删除</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用另一个客户端，查看 9999 端口上的实例</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli -p 9999</span><br><span class="line">127.0.0.1:9999&gt; get hello</span><br><span class="line">&quot;Hello from 6379 instance&quot;</span><br></pre></td></tr></table></figure><h4 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h4><p><code>scan cursor [MATCH pattern] [COUNT count]</code></p><p><code>scan</code>命令是一个基于游标的迭代器（cursor based iterator）： <code>scan</code>命令每次被调用之后，都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数，以此来延续之前的迭代过程。当<code>scan</code>命令的游标参数被设置为 0 时，服务器将开始一次新的迭代，而当服务器向用户返回值为 0 的游标时，表示迭代已结束。</p><h5 id="MATCH-选项"><a href="#MATCH-选项" class="headerlink" title="MATCH 选项"></a>MATCH 选项</h5><p>和<code>keys</code>命令一样，增量式迭代命令也可以通过提供一个 glob 风格的模式参数，让命令只返回和给定模式相匹配的元素，这一点可以通过在执行增量式迭代命令时，通过给定 MATCH<pattern>参数来实现。</pattern></p><p><strong>TODO 不是很明白，回头继续</strong></p><h2 id="Redis-字符串-String-相关命令"><a href="#Redis-字符串-String-相关命令" class="headerlink" title="Redis 字符串(String)相关命令"></a>Redis 字符串(String)相关命令</h2><p>Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></figure><h3 id="Redis字符串-String-相关的基本命令"><a href="#Redis字符串-String-相关的基本命令" class="headerlink" title="Redis字符串(String)相关的基本命令"></a>Redis字符串(String)相关的基本命令</h3><table><thead><tr><th>命令</th><th>描述</th><th>时间复杂度</th><th>可用版本</th></tr></thead><tbody><tr><td><code>set key value</code></td><td>1. 将字符串值 <code>value</code> 关联到 <code>key</code> 。如果 <code>key</code> 已经持有其他值， <code>set</code>就覆写旧值，无视类型。对于某个原本带有生存时间（TTL）的键来说， 当<code>set</code>命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。<br>2. 在 Redis 2.6.12 以前版本， <code>set</code> 命令总是返回 OK 。从 Redis 2.6.12 版本开始，<code>set</code> 在设置操作成功完成时，才返回 OK 。如果设置了 <code>NX</code> 或者 <code>XX</code> ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。<br>3. 从 Redis 2.6.12 版本开始， <code>set</code>命令的行为可以通过一系列参数来修改：<code>EX</code>、<code>PX</code>、<code>NX</code>、<code>XX</code> 。<a href="http://doc.redisfans.com/string/set.html" target="_blank" rel="noopener">http://doc.redisfans.com/string/set.html</a></td><td>O(1)</td><td>&gt;= 1.0.0</td></tr><tr><td><code>get key</code></td><td>返回 <code>key</code> 所关联的字符串值。如果 <code>key</code> 不存在那么返回特殊值 <code>nil</code> 。假如 <code>key</code> 储存的值不是字符串类型，返回一个错误，因为<code>get</code>只能用于处理字符串值。</td><td>O(1)</td><td>&gt;= 1.0.0</td></tr><tr><td><code>getrange key start end</code></td><td>返回 <code>key</code> 中字符串值的子字符串，字符串的截取范围由 <code>start</code> 和 <code>end</code> 两个偏移量决定(包括 <code>start</code> 和 <code>end</code> 在内)。负数偏移量表示从字符串最后开始计数， <code>-1</code> 表示最后一个字符， <code>-2</code> 表示倒数第二个，以此类推。<code>getrange</code>通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</td><td>O(N)， N 为要返回的字符串的长度。复杂度最终由字符串的返回值长度决定，但因为从已有字符串中取出子字符串的操作非常廉价(cheap)，所以对于长度不大的字符串，该操作的复杂度也可看作O(1)。</td><td>&gt;= 2.4.0</td></tr><tr><td><code>getset key value</code></td><td>将给定 <code>key</code> 的值设为 <code>value</code> ，并返回 <code>key</code> 的旧值(old value)。当 <code>key</code> 存在但不是字符串类型时，返回一个错误。<code>key</code> 不存在时，返回 <code>nil</code>。</td><td>O(1)</td><td>&gt;= 1.0.0</td></tr><tr><td><code>incr key</code></td><td>1. 将 <code>key</code> 中储存的数字值增一。如果 <code>key</code> 不存在，那么 <code>key</code> 的值会先被初始化为 <code>0</code> ，然后再执行<code>incr</code>操作，返回执行命令之后 <code>key</code> 的值。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br>2. 本操作的值限制在 64 位(bit)有符号数字表示之内。这是一个针对字符串的操作，因为 Redis 没有专用的整数类型，所以 key 内储存的字符串被解释为十进制 64 位有符号整数来执行 <code>incr</code> 操作。<br>3. 限速器与计数器的应用。<br>4. <code>incrby key increment</code>、<code>incrbyfloat key increment</code>、<code>decr key</code>、<code>decrby key decrement</code>命令与之类似。<a href="http://doc.redisfans.com/string/incrbyfloat.html" target="_blank" rel="noopener">http://doc.redisfans.com/string/incrbyfloat.html</a></td><td>O(1)</td><td>&gt;= 1.0.0</td></tr><tr><td><code>getbit key offset</code></td><td>对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位(bit)。当 <code>offset</code> 比字符串值的长度大，或者 <code>key</code> 不存在时，返回 <code>0</code> 。</td><td>O(1)</td><td>&gt;= 2.2.0</td></tr><tr><td><code>setbit key offset value</code></td><td>对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。位的设置或清除取决于 <code>value</code> 参数，可以是 <code>0</code> 也可以是 <code>1</code> 。当 <code>key</code> 不存在时，自动生成一个新的字符串值。字符串会进行伸展(grown)以确保它可以将 <code>value</code> 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 <code>0</code> 填充。<br>2. <code>offset</code> 参数必须大于或等于 <code>0</code> ，小于 2^32 (bit 映射被限制在 512 MB 之内)。对使用大的 <code>offset</code> 的 <code>setbit</code>操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考<code>setrange</code>命令，warning(警告)部分。</td><td>O(1)</td><td>&gt;= 2.2.0</td></tr><tr><td><code>strlen key</code></td><td>返回 <code>key</code> 所储存的字符串值的长度。当 <code>key</code> 不存在时，返回 <code>0</code> 。当 <code>key</code> 储存的不是字符串值时，返回一个错误。</td><td>O(1)</td><td>&gt;= 2.2.0</td></tr><tr><td><code>mget key [key ...]</code></td><td>返回所有(一个或多个)给定 <code>key</code> 的值。如果给定的 <code>key</code> 里面，有某个 <code>key</code> 不存在，那么这个 <code>key</code> 返回特殊值 <code>nil</code> 。因此，该命令永不失败。</td><td>O(N) , N 为给定 key 的数量。</td><td>&gt;= 1.0.0</td></tr><tr><td><code>mset key value [key value ...]</code></td><td>1. 同时设置一个或多个 <code>key-value</code> 对。如果某个给定 <code>key</code> 已经存在，那么<code>mset</code>会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用<code>msetnx</code>命令：它只会在所有给定 <code>key</code> 都不存在的情况下进行设置操作。<br>2. <code>mset</code>是一个原子性(atomic)操作，所有给定 <code>key</code> 都会在同一时间内被设置，某些给定 <code>key</code> 被更新而另一些给定 <code>key</code> 没有改变的情况，不可能发生。总是返回 OK (因为 MSET 不可能失败)</td><td>O(N)， N 为要设置的 key 数量。</td><td>&gt;= 1.0.1</td></tr><tr><td><code>msetnx key value [key value ...]</code></td><td>1. 同时设置一个或多个 <code>key-value</code> 对，当且仅当所有给定 <code>key</code> 都不存在。即使只有一个给定 <code>key</code> 已存在， <code>msetnx</code>也会拒绝执行所有给定 <code>key</code> 的设置操作。当所有 key 都成功设置，返回 1 。如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。<br>2. <code>msetnx</code>是原子性的，因此它可以用作设置多个不同 <code>key</code> 表示不同字段(field)的唯一性逻辑对象(unique logic object)，所有字段要么全被设置，要么全不被设置。</td><td>O(N)， N 为要设置的 key 数量。</td><td>&gt;= 1.0.1</td></tr><tr><td><code>append key value</code></td><td>1. 如果 <code>key</code> 已经存在并且是一个字符串， <code>append</code>命令将 <code>value</code> 追加到 <code>key</code> 原来的值的末尾。如果 <code>key</code> 不存在， <code>append</code>就简单地将给定 <code>key</code> 设为 <code>value</code> ，就像执行 <code>set key value</code> 一样。<br>2. 返回追加 value 之后， key 中字符串的长度。</td><td>平摊O(1)</td><td>&gt;= 2.0.0</td></tr></tbody></table><h3 id="Redis字符串-String-相关的其他命令"><a href="#Redis字符串-String-相关的其他命令" class="headerlink" title="Redis字符串(String)相关的其他命令"></a>Redis字符串(String)相关的其他命令</h3><h4 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h4><p><code>bitcount key [start] [end]</code></p><p>计算给定字符串中，被设置为 1 的比特位的数量。</p><p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的<code>start</code>或 <code>end</code>参数，可以让计数只在特定的位上进行。</p><p><code>start</code>和<code>end</code>参数的设置和<code>getrange</code>命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推。</p><p>不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。</p><p>可用版本：&gt;= 2.6.0，时间复杂度：O(N)</p><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount bits</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bits 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bitcount bits</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setbit bits 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bitcount bits</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="使用-bitmap-实现用户上线次数统计"><a href="#使用-bitmap-实现用户上线次数统计" class="headerlink" title="使用 bitmap 实现用户上线次数统计"></a>使用 bitmap 实现用户上线次数统计</h5><p>Bitmap 对于一些特定类型的计算非常有效。</p><p>假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 SETBIT 和 BITCOUNT 来实现。</p><p>比如说，每当用户在某一天上线的时候，我们就使用 SETBIT ，以用户名作为 key ，将那天所代表的网站的上线日作为 offset 参数，并将这个 offset 上的为设置为 1 。</p><p>举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 SETBIT peter 100 1 ；如果明天 peter 也继续阅览网站，那么执行命令 SETBIT peter 101 1 ，以此类推。</p><p>当要计算 peter 总共以来的上线次数时，就使用 BITCOUNT 命令：执行 BITCOUNT peter ，得出的结果就是 peter 上线的总天数。</p><p>更详细的实现可以参考博文(墙外) Fast, easy, realtime metrics using Redis bitmaps 。</p><p>性能<br>前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， BITCOUNT 的处理速度就像 GET 和 INCR 这种 O(1) 复杂度的操作一样快。</p><p>如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：</p><p>将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。<br>使用 BITCOUNT 的 start 和 end 参数，每次只对所需的部分位进行计算，将位的累积工作(accumulating)放到客户端进行，并且对结果进行缓存 (caching)。</p><p>更详细的实现可以参考博文 <a href="https://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/" target="_blank" rel="noopener">REDIS BITMAPS – FAST, EASY, REALTIME METRICS</a></p><h4 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a>bitop</h4><p><code>bitop operation destkey key [key ...]</code></p><p>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p><p>operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：</p><ol><li><code>bitop add destkey key [key ...]</code> ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。</li><li><code>bitop or destkey key [key ...]</code> ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。</li><li><code>bitop xor destkey key [key ...]</code> ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。</li><li><code>bitop not destkey key</code> ，对给定 key 求逻辑非，并将结果保存到 destkey 。<br>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</li></ol><h5 id="处理不同长度的字符串"><a href="#处理不同长度的字符串" class="headerlink" title="处理不同长度的字符串"></a>处理不同长度的字符串</h5><p>当<code>bitop</code>处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。</p><p>可用版本：&gt;= 2.6.0，时间复杂度：O(N)，返回值：保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</p><p><code>bitop</code> 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。</p><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit bits-1 0 1 # 1001</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setbit bits-1 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bits-2 0 1 # 1011</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bits-2 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bits-2 3 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitop and and-result bits-1 bits-2 # 1001</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit and-result 2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit and-result 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="setrange"><a href="#setrange" class="headerlink" title="setrange"></a>setrange</h4><p><code>setrange key offset value</code></p><p>用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。可用版本：&gt;= 2.2.0。返回被<code>setrange</code>修改之后，字符串的长度。</p><p><code>setrange</code>命令会确保字符串足够长以便将 value 设置在指定的偏移量上，不存在的 key 当作空白字符串处理。如果给定 key 原来储存的字符串长度比偏移量小，那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )来填充。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>你能使用的最大偏移量是 2^29-1(536870911) ，因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内。如果你需要使用比这更大的空间，你可以使用多个 key 。</p><h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>对小(small)的字符串，平摊复杂度O(1)(关于什么字符串是”小”的，请参考 <code>append</code>命令)。否则为O(M)， M 为 value 参数的长度。</p><h5 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ # 对非空字符串进行 setrange</span><br><span class="line">127.0.0.1:6379&gt; set hello &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange hello 6 &quot;Redis&quot;</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;hello Redis&quot;</span><br><span class="line"></span><br><span class="line">$ # 对空字符串/不存在的 key 进行 setrange</span><br><span class="line">127.0.0.1:6379&gt; exists empty_string</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setrange empty_string 5 &quot;Redis!&quot;</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get empty_string </span><br><span class="line">&quot;\x00\x00\x00\x00\x00Redis!&quot;</span><br></pre></td></tr></table></figure><h5 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h5><p>因为有了<code>setrange</code>和<code>getrange</code>命令，你可以将 Redis 字符串用作具有O(1)随机访问时间的线性数组，这在很多真实用例中都是非常快速且高效的储存方式，具体请参考<code>append</code>命令的『模式：时间序列』部分。</p><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p><code>append key value</code></p><p><code>append key value</code>之后，返回 key 中字符串的长度。如果 key 已经存在并且是一个字符串，<code>append</code>命令将 value 追加到 key 原来的值的末尾。如果 key 不存在，<code>append</code>就简单地将给定 key 设为 value ，就像执行 <code>set key value</code> 一样。可用版本：&gt;= 2.0.0。时间复杂度：平摊O(1)。</p><h5 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists money</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; append money &quot;five cent&quot;</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; append money &quot;one dollor&quot;</span><br><span class="line">(integer) 19</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="时间序列-Time-series"><a href="#时间序列-Time-series" class="headerlink" title="时间序列(Time series)"></a>时间序列(Time series)</h5><p><code>append</code>可以为一系列<strong>定长(fixed-size)数据(sample)</strong>提供一种紧凑的表示方式，通常称之为时间序列。</p><p>每当一个新数据到达的时候，执行命令：<code>append timeseries &quot;fixed-size sample&quot;</code></p><p>然后可以通过以下的方式访问时间序列的各项属性：</p><ol><li><code>strlen</code> 给出时间序列中数据的数量</li><li>getrange 可以用于随机访问。只要有相关的时间信息的话，我们就可以在 Redis 2.6 中使用 Lua 脚本和 GETRANGE 命令实现二分查找。</li><li><code>setrange</code> 可以用于覆盖或修改已存在的的时间序列。</li></ol><p>这个模式的唯一缺陷是我们只能增长时间序列，而不能对时间序列进行缩短，因为 Redis 目前还没有对字符串进行修剪(tirm)的命令，但是，不管怎么说，这个模式的储存方式还是可以节省下大量的空间。</p><p>可以考虑使用 UNIX 时间戳作为时间序列的键名，这样一来，可以避免单个 key 因为保存过大的时间序列而占用大量内存，另一方面，也可以节省下大量命名空间。</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><code>set key value [EX seconds] [PX milliseconds] [NX|XX]</code></p><ol><li>将字符串值 value 关联到 key 。如果 key 已经持有其他值， SET 就覆写旧值，无视类型。</li><li>对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。</li></ol><h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</p><ol><li><code>EX second</code> ：设置键的过期时间为 second 秒。 <code>set key value EX second</code> 效果等同于 <code>setex key second value</code> 。</li><li><code>PX millisecond</code> ：设置键的过期时间为 millisecond 毫秒。 <code>set key value PX millisecond</code> 效果等同于 <code>psetex key millisecond value</code> 。</li><li><code>NX</code> ：只在键不存在时，才对键进行设置操作。 <code>set key value NX</code> 效果等同于 <code>setnx key value</code> 。</li><li><code>XX</code> ：只在键已经存在时，才对键进行设置操作。</li></ol><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><ol><li>在 Redis 2.6.12 版本以前， SET 命令总是返回 OK 。</li><li>从 Redis 2.6.12 版本开始， SET 在设置操作成功完成时，才返回 OK 。如果设置了 NX 或者 XX ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。</li></ol><h5 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h5><p>命令 <code>set resource-name anystring NX EX max-lock-time</code> 是一种在 Redis 中实现锁的简单方法。</p><p>客户端执行以上的命令：</p><ol><li>如果服务器返回 OK ，那么这个客户端获得锁。<br>如果服务器返回 NIL ，那么客户端获取锁失败，可以在稍后再重试。</li><li>设置的过期时间到达之后，锁将自动释放。</li></ol><p>可以通过以下修改，让这个锁实现更健壮：</p><p>不使用固定的字符串作为键的值，而是设置一个不可猜测（non-guessable）的长随机字符串，作为口令串（token）。<br>不使用 DEL 命令来释放锁，而是发送一个 Lua 脚本，这个脚本只在客户端传入的值和键的口令串相匹配时，才对键进行删除。<br>这两个改动可以防止持有过期锁的客户端误删现有锁的情况出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1]</span><br><span class="line">then</span><br><span class="line">    return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis命令&quot;&gt;&lt;a href=&quot;#Redis命令&quot; class=&quot;headerlink&quot; title=&quot;Redis命令&quot;&gt;&lt;/a&gt;Redis命令&lt;/h2&gt;&lt;p&gt;Redis 命令用于在 redis 服务上执行操作。&lt;/p&gt;&lt;p&gt;要在 redis 服务上执行命令需
      
    
    </summary>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/Redis/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Redis/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis命令" scheme="https://muhouer.github.io/tags/Redis%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Redis配置与数据类型</title>
    <link href="https://muhouer.github.io/posts/2c68463d/"/>
    <id>https://muhouer.github.io/posts/2c68463d/</id>
    <published>2019-07-29T14:34:00.000Z</published>
    <updated>2019-07-29T16:21:37.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h2><p><code>Redis</code>的配置文件位于<code>Redis</code>安装目录下，文件名为 <code>redis.conf</code>(Windows 名为<code>redis.windows.conf</code>)。你可以通过<code>config</code>命令查看或设置配置项。</p><p><strong>⚠️不推荐对原始的redis.conf文件进行修改，推荐重新建一个配置文件进行修改，然后运行自己创建的配置文件</strong></p><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dbfilename #获取某个配置项</span><br><span class="line">1) "dbfilename"</span><br><span class="line">2) "dump.rdb"</span><br><span class="line">127.0.0.1:6379&gt; config get *  # 获取所有配置项</span><br><span class="line">  1) "dbfilename"</span><br><span class="line">  2) "dump.rdb"</span><br><span class="line">  3) "requirepass"</span><br><span class="line">  4) ""</span><br><span class="line">  5) "masterauth"</span><br><span class="line">  6) ""</span><br><span class="line">  7) "cluster-announce-ip"</span><br><span class="line">  8) ""</span><br><span class="line">  9) "unixsocket"</span><br><span class="line"> 10) ""</span><br><span class="line"> 11) "logfile"</span><br><span class="line"> 12) ""</span><br><span class="line"> 13) "pidfile"</span><br><span class="line"> 14) ""</span><br><span class="line"> 15) "slave-announce-ip"</span><br><span class="line"> 16) ""</span><br><span class="line"> 17) "replica-announce-ip"</span><br><span class="line"> 18) ""</span><br><span class="line"> 19) "maxmemory"</span><br><span class="line"> 20) "0"</span><br><span class="line">……</span><br><span class="line">208) "0"</span><br><span class="line">209) "slaveof"</span><br><span class="line">210) ""</span><br><span class="line">211) "notify-keyspace-events"</span><br><span class="line">212) ""</span><br><span class="line">213) "bind"</span><br><span class="line">214) ""</span><br></pre></td></tr></table></figure><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>你可以通过修改<code>redis.conf</code>文件或使用<code>config set</code>命令来修改配置。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set loglevel "notice"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get loglevel</span><br><span class="line">1) "loglevel"</span><br><span class="line">2) "notice"</span><br></pre></td></tr></table></figure><hr><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>redis.conf 配置项说明如下：</p><table><thead><tr><th>类型</th><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>基本</td><td><code>daemonize no</code></td><td>是否以守护进程的方式运行，默认为 no，使用yes启用守护进程</td></tr><tr><td>基本</td><td><code>databases 16</code></td><td>设置数据库的数量，默认数据库为0，可以使用SELECT<dbid>命令在连接上指定数据库id</dbid></td></tr><tr><td>基本</td><td><code>stop-writes-on-bgsave-error yes</code></td><td>后台存储错误停止写，默认为 yes</td></tr><tr><td>基本</td><td><code>save &lt;seconds&gt; &lt;changes&gt;</code></td><td>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合。Redis默认配置文件中提供了三个条件：<code>save 900 1</code> 、 <code>save 300 10</code>、<code>save 60 10000</code></td></tr><tr><td>基本</td><td><code>rdbcompression yes</code></td><td>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大。</td></tr><tr><td>基本</td><td><code>rdbchecksum yes</code></td><td>存储和加载rdb文件时校验，默认为 yes</td></tr><tr><td>基本</td><td><code>dbfilename dump.rdb</code></td><td>指定本地数据库文件名，默认值为dump.rdb</td></tr><tr><td>基本</td><td><code>dir ./</code></td><td>指定本地数据库存放目录，默认为当前安装目录</td></tr><tr><td>主从</td><td><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td><td>设置当本机为slave服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</td></tr><tr><td>主从</td><td><code>masterauth &lt;master-password&gt;</code></td><td>当master服务设置了密码保护时，slav服务连接master的密码</td></tr><tr><td>主从</td><td><code>slave-serve-stale-data yes</code></td><td>当主从断开或正在复制中，从服务器是否应答，默认为 yes</td></tr><tr><td>主从</td><td><code>repl-disable-tcp-nodelay no</code></td><td>主端是否合并数据,大块发送给slave</td></tr><tr><td>主从</td><td><code>slave-priority 100</code></td><td>如果master不能再正常工作，那么会在多个slave中，选择优先值最小的一个slave提升为master，优先值为0表示不能提升为master。</td></tr><tr><td>主从</td><td><code>slave-read-only yes</code></td><td>从服务器只读，默认为 yes</td></tr><tr><td>主从</td><td><code>repl-ping-slave-period 10</code></td><td>从ping主的时间间隔，秒为单位</td></tr><tr><td>主从</td><td><code>repl-timeout 60</code></td><td>主从超时时间(超时认为断线了)，要比period大</td></tr><tr><td>安全</td><td><code>requirepass foobared</code></td><td>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH<password>命令提供密码，默认关闭</password></td></tr><tr><td>安全</td><td><code>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</code></td><td>如果公共环境，可以重命名部分敏感命令，如config</td></tr><tr><td>限制</td><td><code>maxclients 128</code></td><td>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回<code>max number of clients reached</code>错误信息</td></tr><tr><td>限制</td><td><code>maxmemory &lt;bytes&gt;</code></td><td>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</td></tr><tr><td>限制</td><td><code>maxmemory-policy volatile-lru</code></td><td>内存到极限后的处理<br>1. volatile-lru -&gt; LRU 算法删除过期key<br>2. allkeys-lru -&gt; LRU算法删除key(不区分过不过期)<br>3. volatile-random -&gt; 随机删除过期key<br>4. allkeys-random -&gt; 随机删除key(不区分过不过期)<br>5. volatile-ttl -&gt; 删除快过期的key<br>6. noeviction -&gt; 不删除,返回错误信息</td></tr><tr><td>日志模式</td><td><code>appendonly no</code></td><td>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</td></tr><tr><td>日志模式</td><td><code>appendfilename appendonly.aof</code></td><td>指定更新日志文件名，默认为appendonly.aof</td></tr><tr><td>日志模式</td><td><code>appendfsync everysec</code></td><td>指定更新日志条件，共有3个可选值：<br><strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<br><strong>always</strong>：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br><strong>everysec</strong>：表示每秒同步一次（折衷，默认值）</td></tr><tr><td>日志模式</td><td><code>no-appendfsync-on-rewrite no</code></td><td>为yes，则其他线程的数据放内存里,合并写入(速度快，容易丢失的多)</td></tr><tr><td>日志模式</td><td><code>auto-AOF-rewrite-percentage 100</code></td><td>aof文件增长比例，指当前aof文件比上次重写的增长比例大小。aof重写即在aof文件在一定大小之后，重新将整个内存写到aof文件当中，以反映最新的状态(相当于bgsave)。这样就避免了，aof文件过大而实际内存数据小的问题(频繁修改数据问题)。</td></tr><tr><td>日志模式</td><td><code>auto-AOF-rewrite-min-size 64mb</code></td><td>aof文件重写最小的文件大小，即最开始aof文件必须要达到这个文件时才触发，后面的每次重写就不会根据这个变量了(根据上一次重写完成之后的大小)，此变量仅初始化启动redis有效。如果是redis恢复时，则lastSize等于初始aof文件大小。</td></tr><tr><td>日志模式</td><td><code>aof-load-truncated yes</code></td><td>指redis在恢复时，会忽略最后一条可能存在问题的指令。默认值yes。即在aof写入时，可能存在指令写错的问题(突然断电，写了一半)，这种情况下，yes会log并继续，而no会直接恢复失败。</td></tr><tr><td>日志</td><td><code>loglevel verbose</code></td><td>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</td></tr><tr><td>日志</td><td><code>logfile stdout</code></td><td>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</td></tr><tr><td>连接</td><td><code>auth 密码</code></td><td>密码登陆(如果有密码)</td></tr><tr><td>连接</td><td><code>ping</code></td><td>测试服务器是否可用</td></tr><tr><td>连接</td><td><code>echo &quot;some content&quot;</code></td><td>测试服务器是否正常交互</td></tr><tr><td>连接</td><td><code>select 0/1/2…</code></td><td>选择数据库</td></tr><tr><td>连接</td><td><code>quit</code></td><td>退出连接</td></tr><tr><td>服务端</td><td><code>shutdown [save/nosave]</code></td><td>关闭服务器，保存数据，修改AOF(如果设置)</td></tr><tr><td>服务端</td><td><code>flushdb</code></td><td>清空当前数据库的所有数据</td></tr><tr><td>服务端</td><td><code>flushall</code></td><td>清空所有数据库的所有数据(误用了怎么办?)</td></tr><tr><td>服务端</td><td><code>config get 选项(支持*通配)</code><br><code>config set 选项 值</code><br><code>config rewrite</code><br><code>config restart</code></td><td>获取配置项<br>修改配置项<br>把值写到配置文件<br>更新info命令的信息</td></tr><tr><td>服务端</td><td><code>time</code><br><code>dbsize</code><br><code>bgrewriteaof</code><br><code>bgsave</code><br><code>save</code><br><code>lastsave</code></td><td>1. 返回时间戳+微秒<br>2. 返回key的数量<br>3.重写aof<br>4. 在后台异步保存当前数据库的数据到磁盘<br>5. 执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘<br>6.返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示</td></tr><tr><td>服务端</td><td><code>monitor</code></td><td>打开控制台,观察命令(调试用)</td></tr><tr><td>服务端</td><td><code>client list</code><br><code>client kill</code><br><code>client getname</code><br><code>client setname &quot;名称&quot;</code><br></td><td>1. 列出所有连接<br>2. 杀死某个连接 CLIENT KILL 127.0.0.1:43501<br>3. 获取连接的名称 默认nil<br>4. 设置连接名称,便于调试</td></tr><tr><td>慢查询</td><td><code>slowlog get</code></td><td>获取慢查询日志</td></tr><tr><td>慢查询</td><td><code>slowlog len</code></td><td>获取慢查询日志条数</td></tr><tr><td>慢查询</td><td><code>slowlog reset</code></td><td>清空慢查询</td></tr><tr><td>慢查询</td><td><code>slowlog-log-slower-than 10000</code></td><td>记录响应时间大于10000微秒的慢查询。</td></tr><tr><td>慢查询</td><td><code>slowlog-max-len 128</code></td><td>最多记录128条</td></tr></tbody></table><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p>Redis支持五种数据类型：string(字符串)，hash(哈希)，list(列表)，set(集合)及zset(sorted set：有序集合)。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ol><li>string 是<code>Redis</code>最基本的类型，你可以理解成与<code>Memcached</code>一模一样的类型，一个 key 对应一个 value。</li><li>string 类型是二进制安全的。意思是<code>Redis</code>的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</li><li>string 类型是<code>Redis</code>最基本的数据类型，string 类型的值最大能存储 512MB。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name &quot;redis&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><ol><li>Redis hash 是一个键值(key=&gt;value)对集合。</li><li>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</li><li>每个 hash 可以存储 2^32-1 键值对（40多亿）</li><li>存储、读取、修改用户属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del name # 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; hmset name field1 &quot;Hello&quot; field2 &quot;World&quot;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget name field1</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget name field2</span><br><span class="line">&quot;World&quot;</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ol><li>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</li><li>列表最多可存储 2^32-1 元素 (4294967295, 每个列表可存储40多亿)。</li></ol><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del name</span><br><span class="line">127.0.0.1:6379&gt; lpush name redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush name mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush name mysql</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange name 0 10</span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ol><li><code>Redis</code>的Set是string类型的无序集合，提供了求交集、并集、差集等操作。</li><li>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</li><li>集合中最大的成员数为 2^32-1(4294967295, 每个集合可存储40多亿个成员)。</li><li>sadd 命令:添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</li><li>共同好友、利用唯一性，统计访问网站的所有独立ip、好友推荐时，根据tag求交集，大于某个阈值就可以推荐<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del name</span><br><span class="line">127.0.0.1:6379&gt; sadd name redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd name mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd name mongodb</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; sadd name mysql</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers name</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;rabitmq&quot;</span><br><span class="line">3) &quot;mongodb&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><ol><li><code>Redis</code> zset 和 set 一样也是string类型元素的集合，且不允许重复的成员。</li><li>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</li><li>zset的成员是唯一的，但分数(score)却可以重复。</li><li>zadd 命令：添加元素到集合，元素在集合中存在则更新对应score</li><li>排行榜、带权重的消息队列</li></ol><p>格式：<code>zadd key score member</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del name</span><br><span class="line">127.0.0.1:6379&gt; zadd name 0 redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd name 0 mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd name 0 mysql</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd name 0 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; &gt; zrangebyscore name 0 1000</span><br><span class="line">1) &quot;mongodb&quot;</span><br><span class="line">2) &quot;mysql&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis配置&quot;&gt;&lt;a href=&quot;#Redis配置&quot; class=&quot;headerlink&quot; title=&quot;Redis配置&quot;&gt;&lt;/a&gt;Redis配置&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;的配置文件位于&lt;code&gt;Redis&lt;/code&gt;安装目录下，文
      
    
    </summary>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/Redis/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Redis/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis配置与数据类型" scheme="https://muhouer.github.io/tags/Redis%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis问题记录</title>
    <link href="https://muhouer.github.io/posts/9f25d6e0/"/>
    <id>https://muhouer.github.io/posts/9f25d6e0/</id>
    <published>2019-07-28T03:10:00.000Z</published>
    <updated>2019-08-05T17:37:53.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="强制把redis快照关闭了导致不能持久化的问题"><a href="#强制把redis快照关闭了导致不能持久化的问题" class="headerlink" title="强制把redis快照关闭了导致不能持久化的问题"></a>强制把redis快照关闭了导致不能持久化的问题</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">(error) MISCONF Redis is configured to save RDB snapshots, </span><br><span class="line">but it is currently not able to persist on disk. Commands </span><br><span class="line">that may modify the data set are disabled, because this </span><br><span class="line">instance is configured to report errors during writes if </span><br><span class="line">RDB snapshotting fails (stop-writes-on-bgsave-error option). </span><br><span class="line">Please check the Redis logs for details about the RDB error.</span><br></pre></td></tr></table></figure><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>通过stop-writes-on-bgsave-error值设置为no即可避免这种问题。</p><p>有两种修改方法，一种是通过redis命令行修改，另一种是直接修改redis.conf配置文件。</p><p>redis命令行修改示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set stop-writes-on-bgsave-error no</span><br></pre></td></tr></table></figure><h3 id="使用-redis-cli-过程中出现中文乱码"><a href="#使用-redis-cli-过程中出现中文乱码" class="headerlink" title="使用 redis-cli 过程中出现中文乱码"></a>使用 redis-cli 过程中出现中文乱码</h3><p>使用<code>redis-cli</code>时后面加上<code>--raw</code>就可以避免中文乱码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli --raw -h host -p port -a password</span></span><br></pre></td></tr></table></figure><h3 id="NOAUTH-Authentication-required"><a href="#NOAUTH-Authentication-required" class="headerlink" title="NOAUTH Authentication required."></a>NOAUTH Authentication required.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; redis.clients.jedis.exceptions.JedisDataException: NOAUTH Authentication required.</span><br><span class="line">at redis.clients.jedis.Protocol.processError(Protocol.java:127)</span><br><span class="line">at redis.clients.jedis.Protocol.process(Protocol.java:161)</span><br><span class="line">at redis.clients.jedis.Protocol.read(Protocol.java:215)</span><br><span class="line">at redis.clients.jedis.Connection.readProtocolWithCheckingBroken(Connection.java:340)</span><br><span class="line">at redis.clients.jedis.Connection.getStatusCodeReply(Connection.java:239)</span><br><span class="line">at redis.clients.jedis.BinaryJedis.ping(BinaryJedis.java:196)</span><br><span class="line">at org.sang.RedisTest.main(RedisTest.java:12)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p>进行密码验证或者把密码置空。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;强制把redis快照关闭了导致不能持久化的问题&quot;&gt;&lt;a href=&quot;#强制把redis快照关闭了导致不能持久化的问题&quot; class=&quot;headerlink&quot; title=&quot;强制把redis快照关闭了导致不能持久化的问题&quot;&gt;&lt;/a&gt;强制把redis快照关闭了导致不能
      
    
    </summary>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://muhouer.github.io/tags/Redis/"/>
    
      <category term="问题记录" scheme="https://muhouer.github.io/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis简单介绍与安装</title>
    <link href="https://muhouer.github.io/posts/985fe3fe/"/>
    <id>https://muhouer.github.io/posts/985fe3fe/</id>
    <published>2019-07-28T02:11:00.000Z</published>
    <updated>2019-07-28T03:07:40.716Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/redis.png" width="800px" height="500px" align="center"><h2 id="Redis-简单介绍"><a href="#Redis-简单介绍" class="headerlink" title="Redis 简单介绍"></a>Redis 简单介绍</h2><p><code>REmote DIctionary Server(Redis)</code> 是一个由<strong>Salvatore Sanfilippo</strong>写的<code>key-value</code>存储系统。</p><p>Redis是一个开源的使用<code>ANSI C</code>语言编写、遵守<code>BSD</code>协议、支持网络、可基于内存亦可持久化的日志型、高性能的<code>key-value</code>数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值(value)可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets) 和有序集合(sorted sets)等类型。</p><h2 id="Redis-特点"><a href="#Redis-特点" class="headerlink" title="Redis 特点"></a>Redis 特点</h2><p><code>key-value</code>缓存产品的三个特点：</p><ul><li>支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>支持简单的key-value类型的数据。</li><li>支持数据的备份，即master-slave模式的数据备份。</li></ul><p><code>Redis</code>的优势：</p><ul><li>性能极高——<code>Redis</code>能读的速度是<strong>110000次/s</strong>，写的速度是<strong>81000次/s</strong> 。</li><li>丰富的数据类型——<code>Redis</code>支持list、set、zset、hash等数据结构的操作。</li><li>原子性——<code>Redis</code>的所有操作都是原子性的：单个操作是原子性的，多个操作也支持事务(通过MULTI和EXEC指令包起来)。</li><li>丰富的特性——<code>Redis</code>还支持<code>publish/subscribe</code>，通知，key 过期等等特性。</li></ul><h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><h3 id="Window-下安装"><a href="#Window-下安装" class="headerlink" title="Window 下安装"></a>Window 下安装</h3><p><strong>下载地址：</strong><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases</a>。</p><p>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 <strong>Redis-x64-xxx.zip</strong>压缩包到 C 盘，解压后，将文件夹重新命名为 <strong>redis</strong>。</p><p>如果下载<a href="https://github.com/microsoftarchive/redis/releases/download/win-3.2.100/Redis-x64-3.2.100.msi" target="_blank" rel="noopener">Redis-x64-3.2.100.msi</a>，双击执行安装即可。如果下载<a href="https://github.com/microsoftarchive/redis/releases/download/win-3.2.100/Redis-x64-3.2.100.zip" target="_blank" rel="noopener">Redis-x64-3.2.100.zip</a>，解压到指定目录即可使用。</p><p>进入安装目录执行以下命令，如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><h3 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h3><p><strong>下载地址：</strong><a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a>，下载最新稳定版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-5.0.5.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-5.0.5</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p><code>make</code>完后<code>redis-5.0.5</code>目录下会出现编译后的<code>redis</code>服务程序<strong>redis-server</strong>，还有用于测试的客户端程序<strong>redis-cli</strong>，两个程序位于安装目录 src 目录下：</p><p>下面启动redis服务.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd src</span><br><span class="line">$ ./redis-server # 使用默认配置</span><br><span class="line">$ ./redis-server ../redis.conf # redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件</span><br></pre></td></tr></table></figure><p>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务进行交互。</p><hr><h3 id="Ubuntu-下安装"><a href="#Ubuntu-下安装" class="headerlink" title="Ubuntu 下安装"></a>Ubuntu 下安装</h3><p>在 <code>Ubuntu</code> 系统安装 <code>Redis</code> 可以使用以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo apt-get update</span><br><span class="line">$sudo apt-get install redis-server</span><br></pre></td></tr></table></figure><h3 id="启动-Redis"><a href="#启动-Redis" class="headerlink" title="启动 Redis"></a>启动 Redis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server</span><br></pre></td></tr></table></figure><h3 id="Mac-下安装"><a href="#Mac-下安装" class="headerlink" title="Mac 下安装"></a>Mac 下安装</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>官网<a href="http://redis.io/" target="_blank" rel="noopener">http://redis.io/</a> 下载最新的稳定版本,这里是5.0.5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mv redis-5.0.5.tar.gz  /usr/<span class="built_in">local</span>/  <span class="comment"># 移至 /usr/local/</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo tar xzf redis-5.0.5.tar.gz          <span class="comment"># 解压文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-5.0.5                           <span class="comment"># 进入解压目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make <span class="built_in">test</span>                           <span class="comment"># 测试编译</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make install                        <span class="comment"># 安装</span></span></span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>使用 <a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">homebrew</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew search redis <span class="comment"># 查找可用的redis包</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install redis <span class="comment">#安装redis，可加@版本号安装指定版本，eg: brew install redis@4.0</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 只能安装可用的redis包，可能不是官网最新版本，比如此次支持最高的是redis@4.0，redis官网是Stable (5.0)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew services start redis <span class="comment"># 或者直接启动：redis-server /usr/local/etc/redis.conf</span></span></span><br></pre></td></tr></table></figure><h2 id="安装后的简单操作"><a href="#安装后的简单操作" class="headerlink" title="安装后的简单操作"></a>安装后的简单操作</h2><h3 id="启动Redis-server"><a href="#启动Redis-server" class="headerlink" title="启动Redis server"></a>启动Redis server</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-5.0.5/src</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-server ../redis.conf</span></span><br><span class="line">60379:C 28 Jul 2019 09:46:36.625 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">60379:C 28 Jul 2019 09:46:36.625 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=60379, just started</span><br><span class="line">60379:C 28 Jul 2019 09:46:36.625 # Configuration loaded</span><br><span class="line">60379:M 28 Jul 2019 09:46:36.627 * Increased maximum number of open files to 10032 (it was originally set to 256).</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ ''-._                                             </span><br><span class="line">      _.-``    `.  `_.  ''-._           Redis 5.0.5 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ ''-._                                   </span><br><span class="line"> (    '      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-'    |     PID: 60379</span><br><span class="line">  `-._    `-._  `-./  _.-'    _.-'                                   </span><br><span class="line"> |`-._`-._    `-.__.-'    _.-'_.-'|                                  </span><br><span class="line"> |    `-._`-._        _.-'_.-'    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-'_.-'    _.-'                                   </span><br><span class="line"> |`-._`-._    `-.__.-'    _.-'_.-'|                                  </span><br><span class="line"> |    `-._`-._        _.-'_.-'    |                                  </span><br><span class="line">  `-._    `-._`-.__.-'_.-'    _.-'                                   </span><br><span class="line">      `-._    `-.__.-'    _.-'                                       </span><br><span class="line">          `-._        _.-'                                           </span><br><span class="line">              `-.__.-'                                               </span><br><span class="line"></span><br><span class="line">60379:M 28 Jul 2019 09:46:36.631 # Server initialized</span><br><span class="line">60379:M 28 Jul 2019 09:46:36.631 * Ready to accept connections</span><br></pre></td></tr></table></figure><h3 id="测试-Redis-是否启动"><a href="#测试-Redis-是否启动" class="headerlink" title="测试 Redis 是否启动"></a>测试 Redis 是否启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-cli <span class="comment"># 不知道IP和端口127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令</span></span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br><span class="line">redis 127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line"><span class="meta">#</span><span class="bash"> 已经成功安装了redis。</span></span><br></pre></td></tr></table></figure><h3 id="Redis-的简单-set-和-get"><a href="#Redis-的简单-set-和-get" class="headerlink" title="Redis 的简单 set 和 get"></a>Redis 的简单 set 和 get</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-cli -h 127.0.0.1 -p 6379 <span class="comment">#指定ip和端口</span></span></span><br><span class="line">127.0.0.1:6379&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">"world"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="退出-Redis-客户端"><a href="#退出-Redis-客户端" class="headerlink" title="退出 Redis 客户端"></a>退出 Redis 客户端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exit</span><br></pre></td></tr></table></figure><h3 id="退出-Redis-服务"><a href="#退出-Redis-服务" class="headerlink" title="退出 Redis 服务"></a>退出 Redis 服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-cli shutdown</span></span><br></pre></td></tr></table></figure><h3 id="检测-Redis-服务"><a href="#检测-Redis-服务" class="headerlink" title="检测 Redis 服务"></a>检测 Redis 服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">检测后台进程是否存在</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -ef |grep redis</span></span><br><span class="line"><span class="meta">#</span><span class="bash">检测6379端口是否在监听</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> netstat -tln | grep 6379</span></span><br><span class="line"><span class="meta">#</span><span class="bash">因为Redis可以妥善处理SIGTERM信号，所以直接 <span class="built_in">kill</span> -9 进程id 也是可以关闭redis的</span></span><br><span class="line">kill -9 PID</span><br></pre></td></tr></table></figure><h3 id="卸载-Redis"><a href="#卸载-Redis" class="headerlink" title="卸载 Redis"></a>卸载 Redis</h3><p>先关闭 Redis 服务，检测以确定关闭。</p><p>删除 make 的时候产生的几个 redis 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf /usr/<span class="built_in">local</span>/bin/redis*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-benchmark</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-check-aof</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-check-rdb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-cli</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-sentinel</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-server</span></span><br></pre></td></tr></table></figure><p>删除解压后的文件目录和所有文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf redis-5.0.5</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf redis-5.0.5.tar.gz</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/redis.png&quot; width=&quot;800px&quot; height=&quot;500px&quot; align=&quot;center&quot;&gt;&lt;h2 id=&quot;Redis-简单介绍&quot;&gt;&lt;a href=&quot;#Redis-简单介绍&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
      <category term="Redis安装" scheme="https://muhouer.github.io/tags/Redis%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>开源软件协议对比</title>
    <link href="https://muhouer.github.io/posts/6821cef2/"/>
    <id>https://muhouer.github.io/posts/6821cef2/</id>
    <published>2019-07-27T23:40:00.000Z</published>
    <updated>2019-07-28T00:09:21.169Z</updated>
    
    <content type="html"><![CDATA[<p><strong>开源不等于免费，开源也不等于没有约束。</strong></p><p>License就是版权许可证，里面详尽表述了你获得代码后拥有的权利，可以对别人的作品进行何种操作，何种操作又是被禁止的。</p><p>世界上的开源许可证(Open Source License)大概有上百种，我们常用的开源软件协议大致有<code>GPL</code>、<code>BSD</code>、<code>MIT</code>、<code>Mozilla</code>、<code>Apache</code>和<code>LGPL</code>。</p><img src="/images/open_source_lincense.png" width="1000px" height="500px" align="center"><h2 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h2><h3 id="Apache-License"><a href="#Apache-License" class="headerlink" title="Apache License"></a>Apache License</h3><p>Apache License（Apache许可证），是Apache软件基金会发布的一个自由软件许可证。</p><p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件：</p><ol><li>需要给代码的用户一份Apache Licence。</li><li>如果修改了代码，需要再被修改的文件中说明。</li><li>在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。</li><li>Apache Licence也是对商业应用又好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。</li></ol><p>使用这个协议的好处是:</p><ol><li>永久权利：一旦被授权，永久拥有。</li><li>全球范围的权利：在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li><li>授权免费：无版税， 前期、后期均无任何费用。</li><li>授权无排他性：任何人都可以获得授权。</li><li>授权不可撤消：一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码。</li></ol><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p>BSD是”Berkeley Software Distribution”的缩写，意思是”伯克利软件发行版”。</p><p>BSD开源协议：是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p><ol><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li></ol><p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GPL （GNU General Public License） ：GNU通用公共许可协议。<br>Linux 采用了 GPL。</p><p>GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>MIT是和BSD一样宽范的许可协议,源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p><p>MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p><h3 id="MPL-Mozilla-Public-License-1-1"><a href="#MPL-Mozilla-Public-License-1-1" class="headerlink" title="MPL (Mozilla Public License 1.1)"></a>MPL (Mozilla Public License 1.1)</h3><p>MPL协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。</p><h3 id="EPL-Eclipse-Public-License-1-0"><a href="#EPL-Eclipse-Public-License-1-0" class="headerlink" title="EPL (Eclipse Public License 1.0)"></a>EPL (Eclipse Public License 1.0)</h3><p>EPL允许Recipients任意使用、复制、分发、传播、展示、修改以及改后闭源的二次商业发布。</p><p>使用EPL协议，需要遵守以下规则：</p><ol><li>当一个Contributors将源码的整体或部分再次开源发布的时候,必须继续遵循EPL开源协议来发布,而不能改用其他协议发布.除非你得到了原”源码”Owner 的授权；</li><li>EPL协议下,你可以将源码不做任何修改来商业发布.但如果你要发布修改后的源码,或者当你再发布的是Object Code的时候,你必须声明它的Source Code是可以获取的,而且要告知获取方法；</li><li>当你需要将EPL下的源码作为一部分跟其他私有的源码混和着成为一个Project发布的时候,你可以将整个Project/Product以私人的协议发布,但要声明哪一部分代码是EPL下的,而且声明那部分代码继续遵循EPL；</li><li>独立的模块(Separate Module),不需要开源。</li></ol><h3 id="Creative-Commons-知识共享协议"><a href="#Creative-Commons-知识共享协议" class="headerlink" title="Creative Commons 知识共享协议"></a>Creative Commons 知识共享协议</h3><p>Creative Commons (CC) 许可协议并不能说是真正的开源协议，它们大多是被使用于设计类的工程上。 CC 协议种类繁多，每一种都授权特定的权利。 一个 CC 许可协议具有四个基本部分，这几个部分可以单独起作用，也可以组合起来。下面是这几部分的简介：</p><ol><li>署名：作品上必须附有作品的归属。如此之后，作品可以被修改，分发，复制和其它用途。</li><li>相同方式共享：作品可以被修改、分发或其它操作，但所有的衍生品都要置于CC许可协议下。</li><li>非商业用途：作品可以被修改、分发等等，但不能用于商业目的。但语言上对什么是”商业”的说明十分含糊不清 (没有提供精确的定义)，所以你可以在你的工程里对其进行说明。例如，有些人简单的解释”非商业”为不能出售这个作品。而另外一些人认为你甚至不能在有广告的网站上使用它们。 还有些人认为”商业”仅仅指你用它获取利益。</li><li>禁止衍生作品</li></ol><p>CC 许可协议的这些条款可以自由组合使用。大多数的比较严格的CC协议会声明 “署名权，非商业用途，禁止衍生”条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且必须声明作品的归属。这个许可协议非常的有用，它可以让你的作品传播出去，但又可以对作品的使用保留部分或完全的控制。最少限制的CC协议类型当属 “署名”协议，这意味着只要人们能维护你的名誉，他们对你的作品怎么使用都行。</p><p>CC 许可协议更多的是在设计类工程中使用，而不是开发类，但没有人或妨碍你将之使用与后者。只是你必须要清楚各部分条款能覆盖到的和不能覆盖到的权利。</p><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><h3 id="简洁版"><a href="#简洁版" class="headerlink" title="简洁版"></a>简洁版</h3><img src="/images/how_to_pick_one.png" width="1000px" height="500px" align="center"><h3 id="稍微复杂版"><a href="#稍微复杂版" class="headerlink" title="稍微复杂版"></a>稍微复杂版</h3><img src="/images/how2pick_by_language.png" width="1000px" height="1000px" align="center"><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.runoob.com/w3cnote/open-source-license.html" target="_blank" rel="noopener">各种开源协议介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;开源不等于免费，开源也不等于没有约束。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;License就是版权许可证，里面详尽表述了你获得代码后拥有的权利，可以对别人的作品进行何种操作，何种操作又是被禁止的。&lt;/p&gt;&lt;p&gt;世界上的开源许可证(Open Source Licen
      
    
    </summary>
    
      <category term="介绍" scheme="https://muhouer.github.io/categories/%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="开源协议" scheme="https://muhouer.github.io/tags/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>拾句-乐评</title>
    <link href="https://muhouer.github.io/posts/70b9f430/"/>
    <id>https://muhouer.github.io/posts/70b9f430/</id>
    <published>2019-07-26T16:33:00.000Z</published>
    <updated>2019-08-04T04:04:27.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="001"><a href="#001" class="headerlink" title="001"></a>001</h3><hr><ol><li><strong>后来再想，你哪点值得我义无反顾？</strong>——《那女孩对我说》</li><li><strong>你回头看一眼我好不好，我就要放弃你了。</strong>——《不找了》</li><li><strong>写歌的人假正经，听歌的人最无情，人要是矫情起来，听什么都像在说自己。</strong>——《不找了》</li><li><strong>每天都在找饭卡：“我觉得这首歌对我的ID有莫大的恶意。”</strong>——《不找了》</li><li><strong>多年以后一场大雨惊醒沉睡的我。</strong>——《星星点灯》</li><li><strong>嗯，我不会慌张，爱在我心上❤️</strong>——《给未来》</li><li><strong>希望我们冰释前嫌，再也不相见。</strong>——《消愁》</li><li><strong>没有正儿八经谈过恋爱，特别喜欢听情歌😌</strong>——《情歌》</li><li><strong>孤岛——仙人掌——铁树</strong></li></ol><hr><h3 id="002"><a href="#002" class="headerlink" title="002"></a>002</h3><hr><ol><li><strong>我仍然认为向人诉苦不过是徒劳，与其如此，不如默默承受。</strong>——《标签》</li><li><strong>我一直都不敢承认自己是个抑郁患者。</strong>——《标签》</li><li><strong>人们真的会因为嘴硬失去很多东西，就像我一样，失去了那个爱我的她</strong>——《标签》</li><li><strong>你爱的人原本也是凡人，是你的注视让他镀上金身。</strong></li><li><strong>做一个俗人，贪君子之财，好美景之色，一身正气，行正义之事，了前生之怨，爱此生之爱人。</strong>——《Skin》</li><li><strong>有人说：二十年的太子，一天的皇上，十个月的奴才，一辈子的提款机，这就是男人的一生；可有人又说：二十年的公主，一天的皇后，十个月的宠妃，一辈子的保姆，这就是女人的一生。我觉得，应该是：二十年的追寻，一天的仪式，十个月的呵护，换来一辈子的相濡以沫。</strong>——《What Makes You Beautiful》</li><li><strong>沈腾的角色很丧，还要被随时准备打脸，偷车架，卖唱，卖炒饭，做一切不可谓卑微的事情。可是都没忘了，那一千多个弯道。我们会被逗笑，这人真背，可是想想自己，是否用尽过全力去追求热爱的事？全力到，尊严和生命都可以牺牲，就是想，在别人眼里当傻子一样的想。我们有那么多故事，是否欠一个结局？</strong>——《奉献》</li><li><strong>小学时，想和喜欢的人同桌；初中时，想和喜欢的人同班；高中时，想和喜欢的人同校；工作时，想和喜欢的人同城；年老时，想和喜欢的人同一个世界。</strong></li><li><strong>起初我们揣着糊涂装明白，后来我们揣着明白装糊涂。并不是我们愿意活得不明不白，只是好多事情一用力就会拆穿，拆穿就会失去。长大以后的世界总是这么脆弱！</strong>——《那女孩对我说》</li></ol><hr><h3 id="003"><a href="#003" class="headerlink" title="003"></a>003</h3><hr><ol><li><strong>人的一生，要死去三次。第一次，当你的心跳停止，呼吸消逝，你在生物学上被宣告了死亡；第二次，当你下葬，人们穿着黑衣出席你的葬礼，他们宣告，你在这个社会上不复存在，你悄然离去；而第三次死亡，是这个世界上最后一个记得你的人，把你忘记，于是，你就真正地死去。整个宇宙都将不再和你有关。</strong>——《the sound of silence》</li><li><strong>人之所以遭受各种各样的伤害大多源于：眼睛看到不该看的东西；嘴巴说出伤人的话语；耳朵听到他人的秘密。</strong>——《耳朵》</li><li><strong>你说一个人自杀，是想通了还是想不通了。</strong>——《遗书》</li><li><strong>看看老电影，听听老调子，对新的人与事物慵懒懈怠。如果那一日的天比较倦，余晖也打着哈欠，我就和一些旧人，谈笑风生。然后等我变老，红酒也够老，就趁着微醺伴着爵士乐沉沉睡去，直到落日的余晖完全融在突如其来的雨里。</strong>——《未妨惆怅是清狂》</li><li><strong>毛不易创作手记：“这个世界上，还有很多不被认可的梦想，不被祝福的感情，不被眷顾的孩子，他们不曾犯错，却只能颤颤巍巍，单薄地行走在路上。这首歌送给他们，借天地万物，不求终将到达某处，只求路上少些阻碍，让他们同样平凡。”</strong>——《借》</li><li><strong>我所有自负都来自我的自卑，所有的英雄气概都来自于我内心的软弱，所有的振振有词都因为心中满是怀疑。我假装无情，其实是痛恨自己的深情。我以为人生的意义在于四处游荡流亡，其实只是掩饰至今没有找到愿意驻足的地方。</strong>——《词不达意》</li><li><strong>我觉得我就像集市上的鱼，水分蒸发得差不多了。我时常觉得自己就要撑不下去，而你总是适时又吝啬地洒点水给我，我便要再提着一口气蹦哒两下，作出生龙活虎的样子给你看。我在前途未卜的痛苦里周而复始，你是不要我死的，又偏不肯温柔豢养我。</strong>——《鱼》</li><li><strong>但凡死缠烂打的人，大都不是真的深爱你，那只是在跟自己赛跑。真正爱你的人，做不到死缠烂打。因为自尊不允许。我们一直深信，爱就是把最好的一切给予对方，包括尊严。多少浅浅淡淡的转身，是旁人看不懂的情深。即使遗憾，那也就遗憾吧。</strong>——《献世》</li><li><strong>任何感情问题都不要冷处理，无论是和家人还是恋人。你有疑惑的时候就要去询问，你有错误的时候就要去承认，你想他就要告诉他。很多事情忍着忍着就变得模糊了，明明不是误会也变成了误会。别以为那些问题会在忍耐的时间中被化解，它只会在日积月累中爆发，给你一个承受不了的结果。</strong>——《玩笑》</li></ol><hr><h3 id="004"><a href="#004" class="headerlink" title="004"></a>004</h3><hr><ol><li><strong>我觉得这样的距离很好，就隔着一片海互不打扰，谁能够决定谁 怎样最好，我疏离得很舒服 不想治疗，这种距离对大家都好，就隔着一片海互相远眺，懂的人懂得就好，我是座小小岛 心满意足的小岛，我爱的人爱我就好。</strong> ——《离岛》</li><li><strong>慢慢大家会明白的，无法跟喜欢的人在一起，其实是人生的常态。忘记一个人可以有两种方式一种是时间，另一种是新欢，而你却选择了时间。</strong>——《爱了很久的朋友》</li><li><strong>某天，你无端想起了一个人，他曾让你对明天有所期许，但是却完全没有出现在你的明天里。</strong>——《再见金华站》</li><li><strong>爱与被爱是世界上最重要的事。</strong>——《再见金华站》</li><li><strong>有时候会喜欢听奇奇怪怪的歌 吃奇奇怪怪的东西 做奇奇怪怪的事 爱奇奇怪怪的人</strong>——《桂花巷》</li><li><hr></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;001&quot;&gt;&lt;a href=&quot;#001&quot; class=&quot;headerlink&quot; title=&quot;001&quot;&gt;&lt;/a&gt;001&lt;/h3&gt;&lt;hr&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;后来再想，你哪点值得我义无反顾？&lt;/strong&gt;——《那女孩对我说》&lt;/li&gt;&lt;li&gt;&lt;stro
      
    
    </summary>
    
      <category term="拾句" scheme="https://muhouer.github.io/categories/%E6%8B%BE%E5%8F%A5/"/>
    
    
      <category term="乐评" scheme="https://muhouer.github.io/tags/%E4%B9%90%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记</title>
    <link href="https://muhouer.github.io/posts/8eda3648/"/>
    <id>https://muhouer.github.io/posts/8eda3648/</id>
    <published>2019-07-25T18:22:00.000Z</published>
    <updated>2019-08-05T17:35:00.969Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理论篇"><a href="#理论篇" class="headerlink" title="理论篇"></a>理论篇</h3><ol><li><a href="/posts/985fe3fe/" title="Redis简单介绍与安装">Redis简单介绍与安装</a></li><li><a href="/posts/9f25d6e0/" title="Redis问题记录">Redis问题记录</a></li><li><a href="/posts/2c68463d/" title="Redis配置与数据类型">Redis配置与数据类型</a></li><li><a href="/posts/e45303ba/" title="Redis命令1">Redis命令1</a></li><li><a href="/posts/7d5a5200/" title="Redis命令2">Redis命令2</a></li><li><a href="/posts/a5d6296/" title="Redis命令3">Redis命令3</a></li><li><a href="/posts/9439f735/" title="Redis命令4">Redis命令4</a></li><li><a href="/posts/e33ec7a3/" title="Redis命令5">Redis命令5</a></li><li><a href="/posts/c275b75f/" title="Redis进阶教程">Redis进阶教程</a></li></ol><h3 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理论篇&quot;&gt;&lt;a href=&quot;#理论篇&quot; class=&quot;headerlink&quot; title=&quot;理论篇&quot;&gt;&lt;/a&gt;理论篇&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;/posts/985fe3fe/&quot; title=&quot;Redis简单介绍与安装&quot;&gt;Redis简单介绍与安装&lt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis" scheme="https://muhouer.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>拾句-开解自己</title>
    <link href="https://muhouer.github.io/posts/4be8e193/"/>
    <id>https://muhouer.github.io/posts/4be8e193/</id>
    <published>2019-07-25T18:06:00.000Z</published>
    <updated>2019-08-04T14:59:29.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="001"><a href="#001" class="headerlink" title="001"></a>001</h3><hr><ol><li><strong>尝试着，放下已有的知识，让自己像孩子一样，慢慢的重新认识这个世界。即便暂时没有什么突破也不要紧，保持那个节奏，允许自己暂时没有突破。</strong></li><li><strong>为什么不要作弊，不是因为“作弊会对别的学生不公平”，也不是因为“作弊会败坏学校的风气”，而是作弊最终会把你困在一个自己不擅长也不喜欢的职业，困住你真正的人生追求…</strong>——加州大学伯克利分校的教授 BrianHarvey</li><li><strong>好人的皮囊穿久了，都快忘记了怎么做坏人。</strong></li><li><strong>不强求是美德，更是好方法。</strong></li><li><strong>清汤一定要清。看起来清澈见底，入口却滋味丰富，这才是一碗好清汤。</strong></li><li><strong>科学是在黑暗中探索，人性就是黑暗中的蜡烛，照亮我们走过的道路以及前方的危险。失去人性，我们将迎来一个可怕的世界。</strong>——迪姆·库克</li><li><strong>赌性更坚强：光拼是不够的，那是体力活；赌才是脑力活。</strong>——曾毓群</li><li><strong>但愿日子清静，抬头遇见的都是柔情。</strong></li><li><strong>上天很有意思，猫喜欢吃鱼，猫却不能下水，鱼喜欢吃蚯蚓，鱼却不能上岸。人生，就是一边拥有，一边失去，一边选择，一边放弃。人生，哪有事事如意，生活，哪有样样顺心。所以，不和别人较真，因为不值得，不和自己较真，因为伤不起，不和往事较真，因为回不去。</strong></li></ol><hr><h3 id="002"><a href="#002" class="headerlink" title="002"></a>002</h3><hr><ol><li><strong>地球这么大，世界这么宽阔，如果找不到相似的灵魂也不要太难过，遇到了也不一定能合拍，合拍也不一定能长久，人生也不过如此。</strong></li><li><strong>人生天地间，忽如远行客。</strong></li><li><strong>笑看人间沉浮事，闲坐摇扇一壶茶。</strong></li><li><strong>春有百花秋有月，夏有凉风冬有雪。</strong></li><li><strong>三生有幸遇见你，纵然悲凉也是情。</strong></li><li><strong>我与春分皆过客，你携秋水揽星河。</strong></li><li><strong>我爱你，不光是因为你的样子；还因为和你在一起时，我的样子。</strong></li><li><strong>欲买桂花同载酒，终不似，少年游。</strong></li><li><strong>岂能尽如人意，但求无愧我心。</strong></li></ol><hr><h3 id="003"><a href="#003" class="headerlink" title="003"></a>003</h3><hr><ol><li><strong>吾貌虽丑，其心温柔。</strong></li><li><strong>忙着工作懒得吃饭的时候会想，人为什么要会饿呢？享受美食的时候会想，人为什么要会饱呢？还有，人为什么要会胖呢？</strong></li><li><strong>没有人愿意成为一个孤岛，也没有人愿意成为被人群淹没的一员。要处理好自己害怕被抛弃的感觉。</strong></li><li><strong>你们搞心理学的，想法的确跟别人不一样。</strong></li><li><strong>相信快，是相信奇迹；相信慢，是相信明天。快，意味着更多的荷尔蒙；慢，意味着耐得住寂寞，以及持续的投入。</strong></li><li><strong>「因为看见，所以相信。」 VS 「因为相信，所以看见。」</strong></li><li><strong>你看见的未来，你相信的那个未来，你主观上的那个未来，和实际上要发生的未来未必是一样的。</strong></li><li><strong>错了就是错了，挨打要立正。</strong></li><li><strong>大(多)和小(少)是最基础的不对称。</strong>——饭否</li></ol><hr><h3 id="004"><a href="#004" class="headerlink" title="004"></a>004</h3><hr><ol><li><strong>重大决策常常是既显然又困难。</strong>——饭否</li><li><strong>爱情和友情一样，都存在很好的人但不合适，于是就没法产生交集，也没法产生共鸣，即使产生了，最终也会消失，因为不对的人，成不了对的事。</strong></li><li><strong>不要因为寂寞而去谈感情，这样就会因为错的感情更加寂寞。</strong></li><li><strong>下了决心要做的事要保持不动声色却满心澎湃。</strong></li><li><strong>读书多了，容颜自然的改变，他们在气质上，在谈吐上，在胸襟上的无涯。</strong>——三毛</li><li><strong>真正骂人的最高境界是面带微笑，云淡风轻。表面看起来很犀利，却掩盖不住内心的色厉内荏，实际上是无能狂怒。</strong></li><li><strong>生活一地鸡毛，理想得竖起来。</strong></li><li><strong>贪财惜命，有所为，有所不为。</strong></li><li><strong>到底有没人在下一盘很大的棋？这是个世界观问题。</strong>——饭否</li></ol><hr><h3 id="005"><a href="#005" class="headerlink" title="005"></a>005</h3><hr><ol><li><strong>人获得财富、才能、地位，第一步都是储蓄。你的所得比你的花费多，积攒可使用的能量，雪球由小滚大。</strong></li><li><strong>人生最大的痛苦莫过于，坚持了不该坚持的，放弃了不该放弃的。</strong></li><li><strong>毕竟几人真得鹿，不知终日梦为鱼。</strong>——黄庭坚《杂诗七首》</li><li><strong>姚明的思维模式，是用自己的冷静把对方的“火”扑灭；而孙杨的思维模式，则是用更大的“火”去冲击对方的“火”，至于这把“火”会波及到谁，孙杨可能并没想过。</strong></li><li><strong>相比于「技工贸」，柳传志老先生当年主张的「贸工技」路线并没有错。事实上，华为正是沿着这条路线发展起来的，从早期代理程控交换机到自己造程控交换机再逐步深入各方面的研发乃至于自己做芯片和操作系统。也就是说，关键是从贸到工之后没有停，真的搞了技。</strong></li><li><strong>当没什么事可做的时候，你在做什么？</strong></li><li><strong>世界上之所以需要鞋匠，是因为有人需要鞋，而不是因为鞋匠需要钱。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;001&quot;&gt;&lt;a href=&quot;#001&quot; class=&quot;headerlink&quot; title=&quot;001&quot;&gt;&lt;/a&gt;001&lt;/h3&gt;&lt;hr&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;尝试着，放下已有的知识，让自己像孩子一样，慢慢的重新认识这个世界。即便暂时没有什么突破也不要紧，保
      
    
    </summary>
    
      <category term="拾句" scheme="https://muhouer.github.io/categories/%E6%8B%BE%E5%8F%A5/"/>
    
    
      <category term="开解自己" scheme="https://muhouer.github.io/tags/%E5%BC%80%E8%A7%A3%E8%87%AA%E5%B7%B1/"/>
    
  </entry>
  
  <entry>
    <title>JVM是如何执行方法调用的?</title>
    <link href="https://muhouer.github.io/posts/f090e573/"/>
    <id>https://muhouer.github.io/posts/f090e573/</id>
    <published>2019-07-25T16:08:00.000Z</published>
    <updated>2019-07-25T16:08:24.333Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java虚拟机" scheme="https://muhouer.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="方法调用" scheme="https://muhouer.github.io/tags/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机是如何加载Java类的？</title>
    <link href="https://muhouer.github.io/posts/2ce44cf1/"/>
    <id>https://muhouer.github.io/posts/2ce44cf1/</id>
    <published>2019-07-23T18:04:00.000Z</published>
    <updated>2019-07-25T17:56:02.602Z</updated>
    
    <content type="html"><![CDATA[<p>从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。</p><p>Java 语言的类型分为两大类——基本类型(primitive types)和引用类型(reference types)，其中引用类型分为4种：类、接口、数组类和泛型参数。由于泛型参数会在编译过程中被擦除，因此 Java 虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。</p><p>字节流最常见的形式要属由 Java 编译器生成的 class 文件。除此之外，我们也可以在程序内部直接生成，或者从网格中获取(例如网页中内嵌的小程序 Java applet)字节流。这些不同形式的字节流，都会被加载到 Java虚拟机中，成为类或接口。为了叙述方便，接下来统一使用“类”来称呼。</p><p>无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载，是指查找字节流，并且据此创建类的过程。对于非 Java 虚拟机直接生成的类来说，Java 虚拟机需要借助类加载器来完成查找字节流的过程。</p><p>类加载器的“祖师爷”叫启动类加载器(bootstrap class loader)，它是由 c++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。</p><p>除了启动类加载器之外，其他的类加载器都是<code>java.lang.ClassLoader</code>的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。</p><p>双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给<code>父 类加载器</code>。在<code>父 类加载器</code>没有找到所请求的情况下，该类加载器才会尝试去加载。</p><p>在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包的类以及由虚拟机参数<code>-Xbootclasspath</code>指定的类。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器(extension class loader)和应用类加载器(application class loader)，均由 Java 核心类库提供。</p><p>扩展类加载器的<code>父 类加载器</code>是启动类加载器。它负责加载相对次要的、但又通用的类，比如存放在 JRE 的 <code>lib/ext</code>目录下 jar 包中的类(以及由系统变量 <code>java.ext.dirs</code>指定的类)。</p><p>应用类加载器的<code>父 类加载器</code>是扩展类加载器。它负责加载应用程序路径下的类。即虚拟机参数 <code>-cp/-classpath</code>、系统变量<code>java.class.path</code>或环境变量 <code>CLASSPATH</code>所指定的路径。默认情况下，应用程序所包含的类便是应用类加载器加载的。</p><p>Java 9 引入了模块系统，并且略微更改了上述的类加载。扩展类加载器改名为平台类加载器(platform class loader)。Java SE 中除了少数几个关键模块之外，其他模块均由平台类加载器所加载。</p><p>除了由 Java 核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊的加载方式。例如：我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其进行解密。</p><p>除了加载功能外，类加载器还提供了命名空间的作用。在 Java 虚拟机中，类的唯一性是由类加载器实现以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们会借助这一特性，来运行同一个类的不同版本。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接，是指将创建的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。</p><p>验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。准备阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则在稍后的初始化阶段进行。除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。</p><p>在 class 文件被加载到 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址。甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能无歧义地定位到具体目标上。</p><p>解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或未被加载类的字段或方法，那么解析将触发这个类的加载(未必触发这个类的链接以及初始化)。</p><p>Java虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。</p><p>如果直接赋值的静态字段被<code>final</code>所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值(ConstantValue)，其初始化直接由 Java 虚拟机完成。除此之外，直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为<code>&lt;clinit&gt;</code>，即 <code>class init</code>。</p><p>类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行<code>&lt;clinit&gt;</code>方法的过程。 Java 虚拟机会通过加锁来确保类的<code>&lt;clinit&gt;</code>方法仅被执行一次。只有初始化完成之后，类才正式成为可执行的状态。</p><p>类的初始化触发情况：</p><ol><li>当虚拟机启动时，初始化用户指定的主类；</li><li>当遇到用以创建模板类实例的 new 指令时，初始化 new 指令的目标类；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了<code>default</code>方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li><li>使用反射 API 对某个类进行反射调用时，初始化这个类；</li><li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Java中所有的非私有实例方法，都算是虚方法。调用这些方法的指令，也区分直接调用和虚调用。</p><p>被<code>final</code>修饰的静态成员变量，如果不是基本类型或字符串，也会放在<code>clinit</code>来做。</p><p>链接时取得的不是被加载类的地址，而是被加载类所调用的其他方法的地址。</p><p>在加载阶段就已经生成了 class 结构，已经写入方法区，只是被标记为未链接而暂时不能使用，如果验证失败会报错退出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。&lt;/p&gt;&lt;p&gt;Java 语言的类型分为两大类——基本类型(primitive types)和引用类型(reference
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="https://muhouer.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java类加载" scheme="https://muhouer.github.io/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java的基本类型</title>
    <link href="https://muhouer.github.io/posts/12a97f14/"/>
    <id>https://muhouer.github.io/posts/12a97f14/</id>
    <published>2019-07-23T18:02:00.000Z</published>
    <updated>2019-07-24T17:59:26.246Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://baike.baidu.com/item/smalltalk/1379989?fr=aladdin]" target="_blank" rel="noopener">Smalltalk</a> 中，所有的值都是对象。因此，许多人认为它是一门纯粹的面向对象语言。Java 则不同，它引进了八个基本类型，用来支撑数值计算。Java 这么做主要是出于工程上的考虑，使用基本类型能够在执行效率以及内存使用两方面提升软件性能。</p><h2 id="Java-虚拟机的-boolean-类型"><a href="#Java-虚拟机的-boolean-类型" class="headerlink" title="Java 虚拟机的 boolean 类型"></a>Java 虚拟机的 boolean 类型</h2><p>在 Java 语言规范中，<code>boolean</code>类型的值只有两种可能，分别使用符合<code>true</code>和<code>false</code>来表示。</p><p>在 Java 虚拟机规范中， <code>boolean</code>类型则被映射成<code>int</code>类型，具体来说，<code>true</code>被映射为整数1，<code>false</code>被映射为整数0。这个编码规则约束了 Java 字节码的具体实现。</p><p>Java 虚拟机规范同时也要求 Java 编译器遵守这个编码规则，并且使用整数相关的字节码来实现逻辑运算。当然，这个约束很容易绕开，除了汇编工具 <code>AsmTools</code>外，还有许多可以修改字节码的 Java 库，比如<a href="https://asm.ow2.io" target="_blank" rel="noopener">ASM</a></p><h2 id="Java-的基本类型"><a href="#Java-的基本类型" class="headerlink" title="Java 的基本类型"></a>Java 的基本类型</h2><table><thead><tr><th><strong>类型</strong></th><th><strong>值域</strong></th><th><strong>默认值</strong></th><th><strong>虚拟机内部符号</strong></th></tr></thead><tbody><tr><td>boolean</td><td>{false, true}</td><td>false</td><td>Z</td></tr><tr><td>byte</td><td>[-128, 127]</td><td>0</td><td>B</td></tr><tr><td>short</td><td>[-32768, 32767]</td><td>0</td><td>S</td></tr><tr><td>char</td><td>[0, 65535]</td><td>‘\u000’</td><td>C</td></tr><tr><td>int</td><td>[-2^31, 2^31-1]</td><td>0</td><td>I</td></tr><tr><td>long</td><td>[-2^63, 2^63-1]</td><td>0L</td><td>J</td></tr><tr><td>float</td><td>~[-3.4E38, 3.4E38]</td><td>+0.0F</td><td>F</td></tr><tr><td>double</td><td>~[-1.8E308, 1.8E308]</td><td>+0.0D</td><td>D</td></tr></tbody></table><ol><li><code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>以及<code>double</code>的值域依次扩大，而且前面的值被后面的值域所包含。因此从前面的基本类型转换至后面的基本类型，无需强制转换。</li><li>它们的默认值看起来都不一样，但在内存中都是0。</li><li>这些基本类型中，<code>boolean</code>和<code>char</code>是唯二的无符号类型。</li><li>声明为<code>byte</code>、<code>char</code>以及<code>short</code>的局部变量，能够存储它们取值范围的数值，但在正常使用 Java 编译器的情况下，生成的字节码会遵守 Java 虚拟机规范对编译器的约束。</li></ol><h2 id="Java-浮点数"><a href="#Java-浮点数" class="headerlink" title="Java 浮点数"></a>Java 浮点数</h2><p>Java 的浮点数采用 IEEE 754 浮点数格式。以 <code>float</code> 为例，浮点数类型通常有两个0，+0.0F以及-0.0F。前者在 Java 里是0，后者是符号位为1、其它位均为0的浮点数，在内存中等同于十六进制整数0x8000000。尽管它们的内存数值不同，但是在 Java 中+0.0F==-0.0F 会返回真。</p><p>浮点数中的正无穷：任意正浮点数除以 +0.0F 得到的值，在内存中等同于0x7F800000;<br>浮点数中的负无穷：任意正浮点数除以 -0.0F 得到的值，在内存中等同于0xFF800000。</p><p>标准 NaN(Not-a-Number)：通过+0.0F/+0.0F 计算得到，在内存中为0x7FC00000；<br>非标准 NaN(Not-a-Number)：0x7F800001、0x7FFFFFF、0xFF800001、0xFFFFFFFF等</p><p>NaN 和其它浮点数相比较，除了<code>!=</code>始终返回<code>true</code>外，所有其它比较结果均会返回<code>false</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(Float.floatToIntBits(0.0F)); //0</span><br><span class="line">    System.out.println(Float.floatToIntBits(-0.0F)); //-2147483648</span><br><span class="line">    System.out.println(Float.floatToIntBits(0.0F/0.0F)); //2143289344</span><br><span class="line">    System.out.println(0x7FC00000); //2143289344</span><br><span class="line">    System.out.println(Float.intBitsToFloat(0x7F800001)); //NaN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-基本类型的大小"><a href="#Java-基本类型的大小" class="headerlink" title="Java 基本类型的大小"></a>Java 基本类型的大小</h2><p>Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。为了方便解释，这里只讨论供解释器使用的解释栈帧(Interpreted frame)。该栈帧有两个主要组成部分，分别是局部变量区以及字节码的操作数栈。这里的局部变量是广义的，除了普通意义下的局部变量外，它还包含实例方法的”this指针”以及方法所接收的参数。</p><p>在 Java 虚拟机规范中，局部变量等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储外，其他基本类型以及引用类型的值均占用一个数组单元。即 boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 一样，和引用类型也一样。因此，在32位的HotSpot 中，这些类型将占用4个字节，而在64位的 HotSpot 中，他们将占用8个字节。(int 所包含的数据是4字节，由于 JVM 栈的实现方式，它们实际使用的内存可能占用得更多)</p><p>当然这种情况仅仅存在于局部变量，并不会出现在存储于堆上的字段或者数组元素。对于 byte、char以及 short 这三种类型的字段或数组单元，它们在堆上占用的空间分别为1字节、2字节以及2字节。(变长数组不好控制，所以选择浪费一些空间，以便访问时直接通过下标来计算地址)</p><p>当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把0xFFFFFFFF(-1)存储到一个声明为 char 类型的字段里时，由于该字段仅占用1字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”。</p><p>boolean 和 boolean 数组比较特殊，在 HotSpot 中，boolean 字段占用一字节，而boolean 数组直接使用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式进行掩码操作，即只取最后一位的值存入 boolean 字段或数组中。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成int类型来运算。</p><p>对于 boolean、char这两类无符号类型来说，加载伴随着零扩展，例如：在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节会用0来填充。</p><p>对于byte、short这两个类型来说，加载伴随着符号扩展，例如：在加载时，short 值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为0，那么该 int 类型的值的高二字节会用0来填充，否则用1来填充。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>ASM 是字节码工程包，它提供了字节码抽象的工具，允许用 Java 代码来生成或更改字节码。JDK里也会使用 ASM 来生成一些适配器什么的。</p><p>Unsafe 就是一些不被虚拟机控制的内存操作的合集，需要根据 API 来了解。</p><p>CAS 可以理解为原子性的写操作，概念来自于底层 CPU 指令。Unsafe 提供了一些 cas 的 Java 接口，在即时编译器中我们会将对这些接口的调用替换成具体的 CPU 指令</p><p>测试 NaN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    float nan1 = 0.0f/0.0f;</span><br><span class="line">    float f =  0.0f;</span><br><span class="line">    float nan2 = f/f;</span><br><span class="line">    double d = 0.0;</span><br><span class="line">    System.out.println(&quot;nan1 raw: &quot; + Integer.toHexString(Float.floatToRawIntBits(nan1)));</span><br><span class="line">    System.out.println(&quot;nan1: &quot; + Integer.toHexString(Float.floatToIntBits(nan1)));</span><br><span class="line">    System.out.println(&quot;nan2 raw: &quot; + Integer.toHexString(Float.floatToRawIntBits(nan2)));</span><br><span class="line">    System.out.println(&quot;nan2: &quot; + Integer.toHexString(Float.floatToIntBits(nan2)));</span><br><span class="line">    System.out.println(&quot;nan3 raw: &quot; + Long.toHexString(Double.doubleToRawLongBits(0.0/0.0)));</span><br><span class="line">    System.out.println(&quot;nan3: &quot; + Long.toHexString(Double.doubleToLongBits(0.0/0.0)));</span><br><span class="line">    System.out.println(&quot;nan4 raw: &quot; + Long.toHexString(Double.doubleToRawLongBits(d/d)));</span><br><span class="line">    System.out.println(&quot;nan4: &quot; + Long.toHexString(Double.doubleToLongBits(d/d)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nan1 raw: 7fc00000</span><br><span class="line">nan1: 7fc00000</span><br><span class="line">nan2 raw: ffc00000</span><br><span class="line">nan2: 7fc00000</span><br><span class="line">nan3 raw: 7ff8000000000000</span><br><span class="line">nan3: 7ff8000000000000</span><br><span class="line">nan4 raw: fff8000000000000</span><br><span class="line">nan4: 7ff8000000000000</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>如果不使用 raw 方法进行 NaN 的转换，采用 <code>0.0f/0.0f</code> 或 先定义变量<code>f = 0.0f</code>再进行<code>f/f</code>的计算，最终结果是一样的，但是如果使用 raw 方法进行转换，结果会有所不同，如:<code>nan1 raw: 7fc00000</code>和<code>nan2 raw: ffc00000</code>，原因是前者是 Java编译器给出的，后者是 CPU 用 DIVSS 指令计算出来的，跟具体的 CPU 实现有关系。由于都是 NaN，理论上哪个值都是正确的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;a href=&quot;https://baike.baidu.com/item/smalltalk/1379989?fr=aladdin]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Smalltalk&lt;/a&gt; 中，所有的值都是对象。因此，许多人认为它是
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="https://muhouer.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java基本类型" scheme="https://muhouer.github.io/tags/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java代码是怎么运行的？</title>
    <link href="https://muhouer.github.io/posts/6e9f02ed/"/>
    <id>https://muhouer.github.io/posts/6e9f02ed/</id>
    <published>2019-07-23T16:24:00.000Z</published>
    <updated>2019-07-23T18:03:16.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><code>Java</code>代码有很多种不同的运行方式，比如在开发工具中运行、双击<code>jar</code>文件运行、在命令行中运行、在网页中运行等，不过这些执行方式都离不开<code>JRE</code>，即Java运行时环境(Java Runtime Environment)。</p><p>实际上，<code>JRE</code>仅包含Java程序的必需组件，包括<code>Java</code>虚拟机以及<code>Java</code>核心类库等。我们通常接触的<code>JDK</code>(Java开发工具包)同样包含了<code>JRE</code>，并且还附带了一系列开发、诊断工具。</p><h2 id="为什么-Java-要在虚拟机里运行？"><a href="#为什么-Java-要在虚拟机里运行？" class="headerlink" title="为什么 Java 要在虚拟机里运行？"></a>为什么 Java 要在虚拟机里运行？</h2><p>Java作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此直接在硬件上运行这种复杂的程序不太现实。所以，在运行 Java 程序之前需要对其进行一番转换。（C++ 的策略是直接编译成目标架构的机器码，Java的策略是编译成一个虚拟架构的机器码。）</p><p>这个转换操作是怎么操作的呢？当前主流思路是这样：设计一个面向Java语言特性的虚拟机，并通过编译器将 Java 程序转换成该虚拟机能识别的指令序列，即 Java 字节码(Java字节码指令的操作码被固定为一个字节)。</p><p>Java虚拟机可以由硬件(Java procesor)实现，但更为常见的是在各个现有平台(如Windows ——x64、Linux_aarch64)上提供软件实现。这样一来，一旦一个程序被转换成 Java 字节码，它就可以在不同平台实现的虚拟机实现里运行，即“一次编译，到处运行。”</p><p>除此之外，虚拟机还提供了一个托管环境(Managed Runtime)。这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。比如：自动内存管理与垃圾回收、数据越界、动态类型、安全权限等等动态监测。</p><h2 id="Java-虚拟机具体怎样运行-Java-字节码的？"><a href="#Java-虚拟机具体怎样运行-Java-字节码的？" class="headerlink" title="Java 虚拟机具体怎样运行 Java 字节码的？"></a>Java 虚拟机具体怎样运行 Java 字节码的？</h2><h3 id="虚拟机角度"><a href="#虚拟机角度" class="headerlink" title="虚拟机角度"></a>虚拟机角度</h3><p>执行 Java 代码首先需要将它编译成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区(Method Area)中，实际运行时，虚拟机会执行方法区内的代码。</p><p>Java虚拟机会将内存划分为堆和栈来存储运行时数据。Java 虚拟机将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法(用C++写的 native 方法)的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。</p><img src="/images/jvm_memory_partition.png" width="700px" height="400px" align="center"><p>在运行过程中，每当调用进入一个 Java 方法，Java虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。</p><p>当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。</p><h3 id="硬件角度"><a href="#硬件角度" class="headerlink" title="硬件角度"></a>硬件角度</h3><p>Java 字节码无法直接执行，需要 Java 虚拟机将字节码翻译成机器码。</p><p>在HotSpot中，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时翻译(Just-In-Time compilation, JIT)，即将一个方法中包含的所有字节码翻译成机器码后再执行。</p><img src="/images/jvm_compilation.png" width="500px" height="500px" align="center"><p>前者优势是无需等待编译，后者优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合解释执行和即时编译的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。</p><h2 id="Java-虚拟机的运行效率是怎么样的？"><a href="#Java-虚拟机的运行效率是怎么样的？" class="headerlink" title="Java 虚拟机的运行效率是怎么样的？"></a>Java 虚拟机的运行效率是怎么样的？</h2><p>HotSpot 采用了多种技术来提升启动性能以及峰值性能。</p><p>即时编译建立在程序符合二八定律的假设之上，即百分之二十的代码占用了百分之八十的计算资源。对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。</p><p>理论上讲，即时编译后的 Java 程序的执行效率是可能超过 C++ 程序的。这是因为与静态编译相比，即时编译拥有程序的运行时信息，并且可以根据这个信息作出相应优化。比如：一个虚方法的调用，尽管它有很多个目标方法，但是在实际运行过程中它可能只调用其中的一个。这个信息就可以被即时编译器所利用，来规避虚方法调用的开销，从而达到比静态编译的 C++ 程序更高的性能。</p><p>为了满足不同用户场景的需要，HotSpot 内置了多个即时编译器：C1、C2 和 Graal。其中 Graal 是Java 10正式引入的实验性即时编译器。这样以来就可以在编译时间和生成代码的执行效率上进行取舍。</p><p>C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。</p><p>C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。</p><p>从 Java 7 开始，HotSpot 的即时编译是放在额外的编译栈程中进行的。HotSpot 会根据 CPU 的数量设置编译线程的数目，并且按 1:2 的比例配置还给 C1 和 C2编译器。</p><p>在资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Java 语言和 Java 虚拟机看待<code>boolean</code>类型的方式是否不同？<br>Java 虚拟机将 boolean 类型看成 int 型 0 和 1 进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Foo.java</span><br><span class="line">public class Foo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">boolean flag = true;</span><br><span class="line">if (flag) &#123;</span><br><span class="line">        System.out.println(&quot;Hello, Java!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">if (flag == true) &#123; </span><br><span class="line">        System.out.println(&quot;Hello, JVM!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ # linux环境</span><br><span class="line">$ javac Foo.java</span><br><span class="line">$ java Foo</span><br><span class="line">$ # 两个都打印</span><br><span class="line">$ # 反汇编器与汇编器 将flag对应的值iconst_1改成了iconst_2</span><br><span class="line">$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &gt; Foo.jasm.1</span><br><span class="line">$ awk &apos;NR==1,/iconst_1/&#123;sub(/iconst_1/, &quot;iconst_2&quot;)&#125; 1&apos; Foo.jasm.1 &gt; Foo.jasm  </span><br><span class="line">$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm</span><br><span class="line">$ java Foo</span><br><span class="line">$ # 第二个不打印</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="热点代码探测"><a href="#热点代码探测" class="headerlink" title="热点代码探测"></a>热点代码探测</h3><p>热点代码探测有两种算法——基于采样的热点探测和基于计数器的热点探测。</p><p>一般采样的是基于计数器的热点探测，这种算法有两个计数器，方法调用计数器和回边计数器，它们在 C1 和 C2 中有不同的阈值。</p><h3 id="对于性能要求高的-web-应用为什么不直接使用即时编译器在启动时全部编译成机器码呢？"><a href="#对于性能要求高的-web-应用为什么不直接使用即时编译器在启动时全部编译成机器码呢？" class="headerlink" title="对于性能要求高的 web 应用为什么不直接使用即时编译器在启动时全部编译成机器码呢？"></a>对于性能要求高的 web 应用为什么不直接使用即时编译器在启动时全部编译成机器码呢？</h3><p>对于长时间运行的程序来说，大部分编译就发生在前几个小时。再之后的即时编译主要是一些非热点代码，以及即时编译器中的 bug 造成的反复去优化重新编译。JVM 这么做主要也是看中字节码的可移植性，从而牺牲了启动性能。JVM 也引入了 AOT 编译，在线下将 Java 代码编译成可链接库。</p><h3 id="为什么理论上比-C-快？"><a href="#为什么理论上比-C-快？" class="headerlink" title="为什么理论上比 C++ 快？"></a>为什么理论上比 C++ 快？</h3><p>实际上会插入一些虚拟机相关的代码。现代编译器一般都分为平台无关的前端和平台相关的后端。如果要生成某个平台的代码，编译器会选择相应的后端。因此，无论是 C 编译器还是 JIT 编译器，都是基于目标 CPU 的指令集来做优化的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;代码有很多种不同的运行方式，比如在开发工具中运行、双击&lt;code&gt;jar&lt;/code&gt;文件
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="https://muhouer.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="代码运行" scheme="https://muhouer.github.io/tags/%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入拆解Java虚拟机</title>
    <link href="https://muhouer.github.io/posts/ec055895/"/>
    <id>https://muhouer.github.io/posts/ec055895/</id>
    <published>2019-07-23T15:48:00.000Z</published>
    <updated>2019-07-25T16:10:07.704Z</updated>
    
    <content type="html"><![CDATA[<p><strong>极客时间《深入拆解Java虚拟机》 | 郑雨迪 | Oracle高级研究员</strong></p><p>好记性不如烂笔头，做下笔记顺便加强一下记忆，之前了解虚拟机笔记零散，准备借此机会梳理一下。</p><h2 id="为什么我们要学习Java虚拟机？"><a href="#为什么我们要学习Java虚拟机？" class="headerlink" title="为什么我们要学习Java虚拟机？"></a>为什么我们要学习Java虚拟机？</h2><p>“知其然”也要“知其所以然”，学习Java虚拟机的本质，更多是了解Java程序是如何被执行且优化的。这样一来，你才可以从内部入手，达到高效编程的目的。与此同时，你也可以为学习更深层级、更为核心的Java技术打好基础。</p><p>了解Java虚拟机有如下好处：</p><ol><li><p>优化：Java虚拟机提供了很多配置参数，用于满足不同应用场景下，对程序性能的需求。学习Java虚拟机，你可以针对自己的应用，最优化匹配运行参数。</p></li><li><p>避险：Java虚拟机本身是一种工程产品，在实现过程中自然存在不少局限性。学习Java虚拟机，可以更好地规避它在使用过程中的bug，也可以更快地识别出Java虚拟机中的错误。</p></li><li><p>触类旁通：Java虚拟机拥有当前最前沿、最成熟的垃圾回收算法，以及即时编译器实现。学习Java虚拟机，我们可以了解其背后的设计决策，今后再遇到其他代码托管技术也能触类旁通。</p></li><li><p>百发齐放：Java虚拟机发展到今天，已经脱离Java语言，形成一套相对独立的、高性能的执行方案。除了Java以外，Scala、Clojure、Groovy，以及时下热门的Kotlin，这些语言都可以运行在Java虚拟机上。学习Java虚拟机，便可以了解这些语言的通用机制，甚至于让这些语言共享生态系统。</p></li></ol><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>剖析Java虚拟机的运行机制，逐一介绍Java虚拟机的设计决策以及工程实现。</p><ol><li><a href="/posts/6e9f02ed/" title="Java代码是怎么运行的？">Java代码是怎么运行的？</a></li><li><a href="/posts/12a97f14/" title="Java的基本类型">Java的基本类型</a></li><li><a href="/posts/2ce44cf1/" title="Java虚拟机是如何加载Java类的？">Java虚拟机是如何加载Java类的？</a></li><li></li><li></li></ol><h2 id="高效实现"><a href="#高效实现" class="headerlink" title="高效实现"></a>高效实现</h2><p>探索Java编译器，以及内嵌于Java虚拟机中的即时编译器，帮助你更好地理解Java语言特性，继而写出简洁高效的代码。</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>介绍如何利用工具定位并解决代码中的问题，以及在已有工具不适用的情况下，打造专属轮子。</p><h2 id="虚拟机黑科技"><a href="#虚拟机黑科技" class="headerlink" title="虚拟机黑科技"></a>虚拟机黑科技</h2><p>介绍甲骨文实验室近年来的前沿工作之——GraalVM。包括如何在JVM上高效运行其他语言；如何混搭这些编程语言，实现Polyglot；如何将这些语言事前编译(Ahead-Of-Time, AOT)成机器指令，单独运行甚至嵌入数据库中运行。</p><img src="/images/jvm_201907231215.png" width="1000px" height="1000px" align="center">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;极客时间《深入拆解Java虚拟机》 | 郑雨迪 | Oracle高级研究员&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;好记性不如烂笔头，做下笔记顺便加强一下记忆，之前了解虚拟机笔记零散，准备借此机会梳理一下。&lt;/p&gt;&lt;h2 id=&quot;为什么我们要学习Java虚拟机？&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="https://muhouer.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java虚拟机" scheme="https://muhouer.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
</feed>

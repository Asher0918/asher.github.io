<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Muhouer</title>
  
  <subtitle>就是做个记录，先来5分钟的！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muhouer.github.io/"/>
  <updated>2019-08-21T17:02:40.008Z</updated>
  <id>https://muhouer.github.io/</id>
  
  <author>
    <name>Muhouer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java的一些基本概念</title>
    <link href="https://muhouer.github.io/posts/d7d0bf4a/"/>
    <id>https://muhouer.github.io/posts/d7d0bf4a/</id>
    <published>2019-08-21T16:39:00.000Z</published>
    <updated>2019-08-21T17:02:40.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h2><h3 id="什么是面向过程？"><a href="#什么是面向过程？" class="headerlink" title="什么是面向过程？"></a>什么是面向过程？</h3><p>自顶而下的编程模式。占用资源相对低，速度相对快。</p><p>把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。</p><p>最典型的用法就是实现一个简单的算法，比如实现冒泡排序。</p><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p>将事务高度抽象化的编程模式。占用资源相对高，速度相对慢。</p><p>将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p><p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。</p><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h3><p>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><h3 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h3><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p><h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态(Polymorphism)"></a>多态(Polymorphism)</h3><p>所谓多态就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><p>最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p><h2 id="重载-amp-重写"><a href="#重载-amp-重写" class="headerlink" title="重载 &amp; 重写"></a>重载 &amp; 重写</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>重载是一个编译期概念，重写是一个运行期间概念。</li><li>重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。</li><li>重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法</li><li>因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）</li></ol><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数，是一种特殊的方法。 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。</p><p>构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。构造器的函数名称必须和它所属的类的名称相同。 它承担着初始化对象数据成员的任务。</p><p>如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数一般会把成员变量的值初始化为默认值，如int -&gt; 0，Integer -&gt; null。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java中共有三种变量，分别是类变量、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author Hollis</span><br><span class="line"> */</span><br><span class="line">public class Variables &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 类变量</span><br><span class="line">     */</span><br><span class="line">    private static int a;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 成员变量</span><br><span class="line">     */</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 局部变量</span><br><span class="line">     * @param c</span><br><span class="line">     */</span><br><span class="line">    public void test(int c)&#123;</span><br><span class="line">        int d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义的三个变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="public"><a href="#public" class="headerlink" title="public"></a><code>public</code></h3><p>表明该成员变量或者方法是对所有类或者对象都是可见的，所有类或者对象都可以直接访问。</p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a><code>protected</code></h3><p>表明成员变量或者方法对类自身以及同在一个包中的其他类可见，其他包下的类不可访问，除非是他的子类。</p><h3 id="default"><a href="#default" class="headerlink" title="default"></a><code>default</code></h3><p>表明该成员变量或者方法只有自己和其位于同一个包的内可见，其他包内的类不能访问，即便是它的子类。</p><h3 id="private"><a href="#private" class="headerlink" title="private"></a><code>private</code></h3><p>表明该成员变量或者方法是私有的，只有当前类对其具有访问权限，除此之外其他类或者对象都没有访问权限，子类也没有访问权限。</p><h2 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h2><p>5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”</p><h3 id="单一职责原则（Single-Resposibility-Principle）"><a href="#单一职责原则（Single-Resposibility-Principle）" class="headerlink" title="单一职责原则（Single-Resposibility Principle）"></a>单一职责原则（Single-Resposibility Principle）</h3><p>其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。</p><h3 id="开放封闭原则（Open-Closed-principle）"><a href="#开放封闭原则（Open-Closed-principle）" class="headerlink" title="开放封闭原则（Open-Closed principle）"></a>开放封闭原则（Open-Closed principle）</h3><p>其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。开放封闭原则主要体现在两个方面：</p><ol><li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li><li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。</li></ol><p>实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。</p><h3 id="里式替换原则（Liskov-Substitution-Principle）"><a href="#里式替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里式替换原则（Liskov-Substitution Principle）"></a>里式替换原则（Liskov-Substitution Principle）</h3><p>其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 里式替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了里式替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 里式替换原则是关于继承机制的设计原则，违反了里式替换原则就必然导致违反开放封闭原则。 里式替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。</p><h3 id="依赖倒置原则（Dependecy-Inversion-Principle）"><a href="#依赖倒置原则（Dependecy-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependecy-Inversion Principle）"></a>依赖倒置原则（Dependecy-Inversion Principle）</h3><p>其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。</p><h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface-Segregation Principle）"></a>接口隔离原则（Interface-Segregation Principle）</h3><p>其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象与面向过程&quot;&gt;&lt;a href=&quot;#面向对象与面向过程&quot; class=&quot;headerlink&quot; title=&quot;面向对象与面向过程&quot;&gt;&lt;/a&gt;面向对象与面向过程&lt;/h2&gt;&lt;h3 id=&quot;什么是面向过程？&quot;&gt;&lt;a href=&quot;#什么是面向过程？&quot; class=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基本概念" scheme="https://muhouer.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>理财杂记</title>
    <link href="https://muhouer.github.io/posts/847d5b8e/"/>
    <id>https://muhouer.github.io/posts/847d5b8e/</id>
    <published>2019-08-21T16:27:00.000Z</published>
    <updated>2019-08-21T17:05:02.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一盆冷水"><a href="#一盆冷水" class="headerlink" title="一盆冷水"></a>一盆冷水</h2><h3 id="年轻人收入少，最好的投资是投资自己。"><a href="#年轻人收入少，最好的投资是投资自己。" class="headerlink" title="年轻人收入少，最好的投资是投资自己。"></a>年轻人收入少，最好的投资是投资自己。</h3><p>什么叫投资自己？什么叫让自己变得值钱？投资是一件带有明确目的性的东西，如果做事情没有目的性，那么不如不做。</p><p>如果做了没有达到目的，那就说明在浪费时间和金钱。变得值钱这件事情，更要有目的性，要有明确的KPI。</p><p>回过头来再看，各种让你学习烘焙旅游化妆穿衣的东西，能算是投资自己吗？<br>即使是所谓的考证，健身，读书，也得考虑一个回报率和执行力的问题。大多数人对于长期坚持考证这种事情，是坚持不下来的，人和人就是不一样的。办了健身房年卡，一年能去几次？去闲鱼看看那些便宜出的年卡就知道了。</p><p><strong>在没有足够数量的有效信息前，各种所谓的投资都是抓瞎。</strong></p><h3 id="依靠理财实现财务自由"><a href="#依靠理财实现财务自由" class="headerlink" title="依靠理财实现财务自由"></a>依靠理财实现财务自由</h3><p>如果说投资自己是欺负年轻人的话，那么依靠理财财务自由则是针对职场人士的春秋大梦。那些靠吃利息的人，绝大多数也都是通过其他行业完成了自己的资本积累，例如1000万。</p><p>理财这件事情说穿了就是把你已有的资金做一个增量，这显然是受限于你的本金的，人家1000万本金一年赚3%都有30万，你5万块钱一年15%也就7千5.</p><p><strong>很多人的问题不在于3%或者15%，而是在于1000万还是5万。</strong></p><p>而且投资其实一个技能，这个技能需要大量的时间积累和实战的，就和你做医生，程序员，工程师，老师一样，不是一蹴而就的，你一个普普通通在自己行业冒头都费劲的人，突然就靠理财财务自由了，这东西有点魔幻。</p><p>一开始就要把目的定下来，让自己舒服一点，但不求大富大贵。大富大贵的东西不要学理财，建议去学刑法。</p><h3 id="投资一定要跟着高手进行操作"><a href="#投资一定要跟着高手进行操作" class="headerlink" title="投资一定要跟着高手进行操作"></a>投资一定要跟着高手进行操作</h3><p>认真想想，你和高手的风险承受能力，信息获取能力，资金量级，心态，时间成本都是完全不一样的，你去学高手的操作模式是得有多么想不通。</p><p>人家高手加杠杆的同时还有另一批资金做风险对冲，你自己傻乎乎地跟着人家加杠杆进场一波就把自己玩儿炸掉。人家高手投资某个标的的时候往往有数据支撑或者内幕消息，你傻乎乎跟着投进去最后就是给高手接盘的。</p><p>高手的操作模式和普通人的操作根本不是一种东西，二者从目的性上就有本质的区别。</p><ol><li>开F1和骑自行车都是交通技术，但能一样么？</li><li>十以内加减法和微积分都是数学，你让小学生学微积分试试？</li></ol><p>不同的人，要有不同的投资模式，强行并线很容易出事故的。而且吧，专业人士操作的时效性要求很高，哪里有空和你比比？</p><p>我自己玩高频交易的时候，根本没空和人家废话，各种公式等着我配平，各种市场风险要在指标变化的第一时间做对冲，时刻要盯着自己的平仓线和保证金，哪里有心思还教人怎么玩儿？</p><p>有的人就是想赚点小钱，学什么杠杆，找死么。有的人心理承受能力就是差，那就去买银行理财，搞什么P2P。有的人天生就是只想投自己懂的公司，那就买股票，死也是个明白鬼。</p><p>普通人应该是有普通人的玩法。非得跟着高手操作的结果，很有可能是人家车都开到下一站了，你还在天上飘着呢。</p><h3 id="大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。"><a href="#大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。" class="headerlink" title="大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。"></a>大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。</h3><p>这话本身没错，但是要看对谁说。</p><p>对于已经挺有钱的人而言是对的，因为他们的时间本身就挺值钱，没有必要在细节上浪费。但是对于绝大多数时间不能直接变成钱的普通人而言，这句话是最毒的鸡汤。</p><p>对于普通人而言，买房买车买包买表这种大钱，大家都会本能性的谨慎，去收集信息，去权衡利弊，其实用不着和人讲谨慎，大家都知道要谨慎。反而是打车，是大量奶茶零食，是大量9块9包邮，是各种拼单凑单，才是普通人资金流血的最大问题所在。</p><p>电子支付的快速发展更加剧了这一问题，过去有一堆堆的现金摆在面前还会让人警醒一点，而现在年轻人手机一刷，感知上就弱了很多。甚至负债类消费已经流行到不需要感知的程度，二维码背后就是信用卡和透支产品，很多人都是一到要还卡的时候才傻了眼，平时根本没什么感觉。</p><p>而投资理财这件事情，我上面第二点说了，最重要的是先要有本金，哪怕是不多的本金，然后才是收益率。</p><p>如果不控制住这种弱感知的消费，管理不好自己的资金流，那么永远也没有本金可言，所谓的投资理财在一开始就完犊子了。</p><p><strong>资金流管理，是我觉得每个人都应该学的第一步。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一盆冷水&quot;&gt;&lt;a href=&quot;#一盆冷水&quot; class=&quot;headerlink&quot; title=&quot;一盆冷水&quot;&gt;&lt;/a&gt;一盆冷水&lt;/h2&gt;&lt;h3 id=&quot;年轻人收入少，最好的投资是投资自己。&quot;&gt;&lt;a href=&quot;#年轻人收入少，最好的投资是投资自己。&quot; class=&quot;
      
    
    </summary>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>CodeReview最佳实践</title>
    <link href="https://muhouer.github.io/posts/eb547231/"/>
    <id>https://muhouer.github.io/posts/eb547231/</id>
    <published>2019-08-21T16:15:06.000Z</published>
    <updated>2019-08-21T16:25:18.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：宝玉<br>原文：<a href="https://www.cnblogs.com/dotey/p/11216430.html" target="_blank" rel="noopener">https://www.cnblogs.com/dotey/p/11216430.html</a></p></blockquote><p>我一直认为Code Review（代码审查）是软件开发中的最佳实践之一，可以有效提高整体代码质量，及时发现代码中可能存在的问题。包括像Google、微软这些公司，Code Review都是基本要求，代码合并之前必须要有人审查通过才行。</p><p>然而对于我观察到的大部分软件开发团队来说，认真做Code Review的很少，有的流于形式，有的可能根本就没有Code Review的环节，代码质量只依赖于事后的测试。也有些团队想做好代码审查，但不知道怎么做比较好。</p><p>网上关于如何做Code Review的文章已经有很多了，这里我结合自己的一些经验，也总结整理了一下Code Review的最佳实践，希望能对大家做好Code Review有所帮助。</p><h2 id="Code-Review有什么好处？"><a href="#Code-Review有什么好处？" class="headerlink" title="Code Review有什么好处？"></a>Code Review有什么好处？</h2><p>很多团队或个人不做Code Review，根源还是不觉得这是一件有意义的事情，不觉得有什么好处。这个问题要从几个角度来看。</p><h3 id="团队知识共享的角度"><a href="#团队知识共享的角度" class="headerlink" title="团队知识共享的角度"></a>团队知识共享的角度</h3><p>一个开发团队中，水平有高有低，每个人侧重的领域也有不同。怎么让高水平的帮助新人成长？怎么让大家都对自己侧重领域之外的知识保持了解？怎么能有人离职后其他人能快速接手？这些都是团队管理者关心的问题。</p><p>而代码审查，就是一个很好的知识共享的方式。通过代码审查，高手可以直接指出新手代码中的问题，新手可以马上从高手的反馈中学习到好的实践，得到更快的成长；通过代码审查，前端也可以去学习后端的代码，做功能模块A的可以去了解功能模块B的。</p><p>可能有些高手觉得给新手代码审查浪费时间，自己也没收获。其实不然，新人成长了，就可以更多的帮高手分担繁重的任务；代码审查中花时间，就少一些帮新人填坑擦屁股的时间；良好的沟通能力、发现问题的能力、帮助其他人成长，都是技术转管理或技术上更上一层楼必不可少的能力，而通过代码审查可以有效的去练习这些方面的能力。</p><h3 id="代码质量的角度"><a href="#代码质量的角度" class="headerlink" title="代码质量的角度"></a>代码质量的角度</h3><p>现实中的项目总是人手缺进度紧，所以被压缩的往往就是自动化测试和代码审查，结果影响代码质量，欠下技术债务，最后还是要加倍偿还。</p><p>也有人寄希望于开发后的人工测试，然而对于代码质量来说，很多问题通过测试是测试不出来的，只能通过代码审查。比如说代码的可读性可维护性，比如代码的结构，比如一些特定条件才触发的死循环、逻辑算法错误，还有一些安全上的漏洞也更容易通过代码审查发现和预防。</p><p>也有人觉得自己水平高就不需要代码审查了。对于高手来说，让别人审查自己的代码，可以让其他人学习到好的实践；在让其他人审查的同时，在给别人说明自己代码的时候，也等于自己对自己的代码进行了一次审查。这其实就跟我们上学时做数学题一样，真正能拿高分的往往是那些做完后还会认真检查的。</p><h3 id="团队规范的角度"><a href="#团队规范的角度" class="headerlink" title="团队规范的角度"></a>团队规范的角度</h3><p>每个团队都有自己的代码规范，有自己的基于架构设计的开发规范，然而时间一长，就会发现代码中出现很多不遵守代码规范的情况，有很多绕过架构设计的代码。比如难以理解和不规范的命名，比如三层架构里面UI层绕过业务逻辑层直接调用数据访问层代码。</p><p>如果这些违反规范的代码被纠正的晚了，后面再要修改就成本很高了，而且团队的规范也会慢慢的形同虚设。</p><p>通过代码审查，就可以及时的去发现和纠正这些问题，保证团队规范的执行。</p><p>关于代码审查的好处，还有很多，也不一一列举。还是希望能认识到Code Review和写自动化测试一样，都是属于磨刀不误砍柴工的工作，在上面投入一点点时间，未来会收获代码质量，会节约整体的开发时间。</p><h2 id="该怎么做？"><a href="#该怎么做？" class="headerlink" title="该怎么做？"></a>该怎么做？</h2><p>现在很多人都已经有意识到Code Review的重要性了，只是苦于不知道如何去实践，不知道怎么样算是好的Code Review实践。</p><h3 id="把Code-Review作为开发流程的必选项而不是可选项"><a href="#把Code-Review作为开发流程的必选项而不是可选项" class="headerlink" title="把Code Review作为开发流程的必选项而不是可选项"></a>把Code Review作为开发流程的必选项而不是可选项</h3><p>在很早以前，我就尝试过将代码审查作为代码流程的一部分，但只是一个可选项，没有Code Review也可以把代码合并到master。这样的结果就是想起来才会去做Code Review，去检查的时候已经有了太多的代码变更，审查起来非常困难，另外就算审查出问题，也很难得以修改。</p><p>我们现在对代码的审查则是作为开发流程的一个必选项，每次开发新功能或者修复Bug，开一个新的分支，分支要合并到master有两个必要条件：</p><ol><li>所有的自动化测试通过</li><li>有至少一个人Code Review通过，如果是新手的PR，还必须有资深程序员Code Review通过。</li></ol><p>这样把Code Review作为开发流程的一个必选项后，就很好的保证了代码在合并之前有过Code Review。而且这样合并前要求代码审查的流程，好处也很明显：</p><ol><li>由于每一次合并前都要做代码审查，这样一般一次审查的代码量也不会太大，对于审查者来说压力也不会太大。</li><li>如果在Code Review时发现问题，被审查者希望代码能尽快合并，也会积极的对审查出来的问题进行修改，不至于对审查结果太过抵触。</li></ol><p>如果你觉得Code Review难以推行，不妨先尝试着把Code Review变成你开发流程的一个必选项。</p><h3 id="把Code-Review变成一种开发文化而不仅仅是一种制度"><a href="#把Code-Review变成一种开发文化而不仅仅是一种制度" class="headerlink" title="把Code Review变成一种开发文化而不仅仅是一种制度"></a>把Code Review变成一种开发文化而不仅仅是一种制度</h3><p>把Code Review 作为开发流程的必选项后，不代表Code Review这件事就可以执行的很好，因为Code Review 的执行，很大部分程度上依赖于审查者的认真审查，以及被审查者的积极配合，两者缺一不可！</p><p>如果仅仅只是当作一个流程制度，那么就可能会流于形式。最终结果就是看起来有Code Review，但没有人认真审查，随便看下就通过了，或者发现问题也不愿意修改。</p><p>真要把Code Review这件事做好，必须让Code Review变成团队的一种文化，开发人员从心底接受这件事，并认真执行这件事。</p><p>要形成这样的文化，不那么容易，也没有想象的那么难，比如这些方面可以参考：</p><ol><li>首先，得让开发人员认识到Code Review这件事为自己、为团队带来的好处。</li><li>然后，得要有几个人做好表率作用，榜样的力量很重要。</li><li>还有，对于管理者来说，你激励什么，往往就会得到什么。</li><li>最后，像写自动化测试一样，把Code Review要作为开发任务的一部分，给审查者和被审查者都留出专门的时间去做这件事，不能光想着马儿跑得快又舍不得给马儿吃草。</li></ol><p>如何形成这样的文化，有心的话，还有很多方法可以尝试。只有真正让大家都认同和践行，才可能去做好Code Review这件事。</p><h2 id="一些Code-Review的经验技巧"><a href="#一些Code-Review的经验技巧" class="headerlink" title="一些Code Review的经验技巧"></a>一些Code Review的经验技巧</h2><p>在做好Code Review这件事上，还有一些经验技巧可以参考。</p><h3 id="选什么工具辅助做CODE-REVIEW？"><a href="#选什么工具辅助做CODE-REVIEW？" class="headerlink" title="选什么工具辅助做CODE REVIEW？"></a>选什么工具辅助做CODE REVIEW？</h3><p>现在很多源代码管理工具都自带Code Review工具，典型的像Github、Gitlab、微软的Azure DevOps，尤其是像Gitlab，还可以自己在本地搭建环境，根据自己的需要灵活配置。</p><h3 id="配合什么样的开发流程比较好？"><a href="#配合什么样的开发流程比较好？" class="headerlink" title="配合什么样的开发流程比较好？"></a>配合什么样的开发流程比较好？</h3><p>像Github Flow[1]这样基于分支开发的流程是特别适合搭配Code Review的。其实不管什么样的开发流程，关键点在于代码合并到master（主干）之前，要先做Code Review。</p><h3 id="真遇到紧急情况，来不及代码审查怎么办？"><a href="#真遇到紧急情况，来不及代码审查怎么办？" class="headerlink" title="真遇到紧急情况，来不及代码审查怎么办？"></a>真遇到紧急情况，来不及代码审查怎么办？</h3><p>虽然原则上，必须要Code Review才能合并，但有时候确实会存在一些紧急情况，比如说线上故障补丁，而又没有其他人在线，那么这种情况下，最好是在任务管理系统中，创建一个Ticket，用来后续跟踪，确保后续补上Code Review，并对Code Review结果有后续的代码更新。</p><h3 id="先设计再编码"><a href="#先设计再编码" class="headerlink" title="先设计再编码"></a>先设计再编码</h3><p>有些新人发现自己的代码提交PR（Pull Request）后，会收到一堆的Code Review意见，必须要做大量的改动。这多半是因为在开始做之前，没有做好设计，做出来后才发现问题很多。</p><p>建议在做一个新功能之前，写一个简单的设计文档，表达清楚自己的设计思路，找资深的先帮你做一下设计的审查，发现设计上的问题。设计上没问题了，再着手开发，那么到Review的时候，相对问题就会少很多。</p><h3 id="代码在提交CODE-REVIEW之前，作者要自己先REVIEW和测试一遍"><a href="#代码在提交CODE-REVIEW之前，作者要自己先REVIEW和测试一遍" class="headerlink" title="代码在提交CODE REVIEW之前，作者要自己先REVIEW和测试一遍"></a>代码在提交CODE REVIEW之前，作者要自己先REVIEW和测试一遍</h3><p>我在做代码审查的时候，有时候会发现一些非常明显的问题，有些甚至自己都没有测试过，就等着别人Code Review和测试帮助发现问题。这种依赖心理无论是对自己还是对团队都是很不负责任的。</p><p>一个好的开发人员，代码在提交Code Review之前，肯定是要自己先Review一遍，把该写的自动化测试代码写上，自己把基本的测试用例跑一遍的。</p><p>我对于团队提交的PR，有个要求就是要在PR的描述中增加截图或者录屏，就是为了通过截图或者录屏，确保提交PR的人自己是先测试过的。这也是一个有效的辅助手段。</p><h3 id="PR要小"><a href="#PR要小" class="headerlink" title="PR要小"></a>PR要小</h3><p>在做Code Review的时候，如果有大量的文件修改，那么Review起来是很困难的，但如果PR比较小，相对就比较容易Review，也容易发现代码中可能存在的问题。</p><p>所以在提交PR时，PR要小，如果是比较大的改动，那么最好分批提交，以减轻审查者的压力。</p><h3 id="对评论进行分级"><a href="#对评论进行分级" class="headerlink" title="对评论进行分级"></a>对评论进行分级</h3><p>在做Code Review时，需要针对审查出有问题的代码行添加评论，如果只是评论，有时候对于被审查者比较难甄别评论所代表的含义，是不是必须要修改。</p><p>建议可以对Review的评论进行分级，不同级别的结果可以打上不同的Tag，比如说：</p><ol><li>[blocker]: 在评论前面加上一个blocker标记，表示这个代码行的问题必须要修改</li><li>[optional]：在评论前面加上一个[optional]标记，表示这个代码行的问题可改可不改</li><li>[question]：在评论前面加上一个[question]标记，表示对这个代码行不理解，有问题需要问，被审查者需要针对问题进行回复澄清<br>类似这样的分级可以帮助被审查者直观了解Review结果，提高Review效率。</li></ol><p>评论要友好，避免负面词汇；有说不清楚的问题当面沟通</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Code Review是一种非常好的开发实践，如果你还没开始，不妨逐步实践起来；如果已经做了效果不好，不妨对照一下，看有没有把Code Review作为开发流程的必选项而不是可选项？有没有把Code Review变成一种开发文化而不仅仅是一种制度？</p><p>虽然评论是主要的Code Review沟通方式，但也不要过于依赖，有时候面对面的沟通效率更高，也容易消除误解。</p><p>另外文明用语，不要用一些负面的词汇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者：宝玉&lt;br&gt;原文：&lt;a href=&quot;https://www.cnblogs.com/dotey/p/11216430.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/do
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>杂记-数学概念</title>
    <link href="https://muhouer.github.io/posts/a12aac50/"/>
    <id>https://muhouer.github.io/posts/a12aac50/</id>
    <published>2019-08-21T15:37:00.000Z</published>
    <updated>2019-08-22T15:29:12.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欧拉常数与圆周率"><a href="#欧拉常数与圆周率" class="headerlink" title="欧拉常数与圆周率"></a>欧拉常数与圆周率</h2><p><code>e</code> 是一个不可思议且特别的定数。在这层意义上，欧拉常数 <code>e</code> 与圆周率 <code>π</code> 是两个至关重要的数学定数，就算说成是神赐予人类的数字也不为过。吹爆炸！！！</p><h2 id="m-n-x-y-mx-my-nx-ny"><a href="#m-n-x-y-mx-my-nx-ny" class="headerlink" title="(m+n)(x+y) = mx + my + nx + ny"></a>(m+n)(x+y) = mx + my + nx + ny</h2><img src="/images/201908211139.png" width="800px" height="400px" align="center"><h2 id="除法的两个意义"><a href="#除法的两个意义" class="headerlink" title="除法的两个意义"></a>除法的两个意义</h2><p>a÷n=p</p><h3 id="等分除"><a href="#等分除" class="headerlink" title="等分除"></a>等分除</h3><p>将a分成n等份，则每份有p个。不同单位的比例为等分除。</p><h3 id="包含除"><a href="#包含除" class="headerlink" title="包含除"></a>包含除</h3><p>将a按照每份有n个等分，则可以分成p份（a有p份的n个）。相同单位的比例为包含除。</p><h2 id="图表的特点"><a href="#图表的特点" class="headerlink" title="图表的特点"></a>图表的特点</h2><ol><li>柱状图：表示大小</li><li>折线图：表示变化</li><li>饼图：表示比例</li><li>带状图：比较比例</li></ol><h2 id="频数分布表"><a href="#频数分布表" class="headerlink" title="频数分布表"></a>频数分布表</h2><p>频数分布表就是将每组中的频数、相对频数、累计相对频数等做成一张表。</p><ol><li>组：将数据以相同间隔分开的区间。</li><li>组中值：各组上下限中间的数值。</li><li>频数：各组中包含数值的数量。</li><li>相对频数：各组数据频数在总频数中的占比。</li><li>累计相对频数：逐级相对频数相加的和。</li></ol><h2 id="分组取组段值"><a href="#分组取组段值" class="headerlink" title="分组取组段值"></a>分组取组段值</h2><p>分组取组段值时，可以参照下面的JIS（日本工业标准的简称）标准：</p><blockquote><p>将包含最大值与最小值在内的数据，分成5～20组时，用最大值与最小值之差（R）除以1、2、5（或者是10、20、50;0.1、0.2、0.5）等各备选范围，选择结果在5～20范围内的数。如果有两个不同的结果，那么，最大值与最小值之差大于100则取小，反之则取大。</p></blockquote><h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><p>将数据由大到小排列时，位于最中间的数值。</p><p>中位数的求法</p><ol><li>将数据按大小排列。</li><li>“当数据个数为奇数时”:中位数=正中间的数值。</li><li>“当数据个数为偶数时”:中位数=正中间两个数值的平均值。</li></ol><h2 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h2><p>一组数据中出现次数最多的数值。即频数最高的数据的值。</p><h2 id="偏差"><a href="#偏差" class="headerlink" title="偏差"></a>偏差</h2><p>偏差 = 50 + (指定的值-平均值)/标准差 * 10</p><h2 id="四分位数"><a href="#四分位数" class="headerlink" title="四分位数"></a>四分位数</h2><p>四分位数是指，将数据从小到大排列并分成4等份后，处于3个分割点上的数。这3个四分位数按照从小到大的顺序分别被称为第一四分位数、第二四分位数和第三四分位数。</p><p>第二四分位数和数据的中位数是一致的。</p><p>四分位数的求法</p><ol><li>找出数据的最大值与最小值。</li><li>找出数据的中位数→第二四分位数。</li><li>求出中位数前半部分数据的中位数→第一四分位数。</li><li>求出中位数后半部分数据的中位数→第三四分位数。</li></ol><h2 id="倍数的辨别方法"><a href="#倍数的辨别方法" class="headerlink" title="倍数的辨别方法"></a>倍数的辨别方法</h2><p>2的倍数：尾数为偶数。</p><p>3的倍数：各位数相加的和为3的倍数。</p><p>4的倍数：末尾两位数为4的倍数或整百数。</p><p>5的倍数：尾数为0或5。</p><p>6的倍数：尾数为偶数，且各位数的和为3的倍数。</p><p>7的倍数：将个位数字去掉之后的数 - 个位数字的两倍 = 7的倍数。</p><h3 id="证明判断3的倍数方法"><a href="#证明判断3的倍数方法" class="headerlink" title="证明判断3的倍数方法"></a>证明判断3的倍数方法</h3><p>首先，拿一个3位数举个栗子，a，b，c 是一个小于10的正整数，则 <code>100a + 10b + c</code>可以表示一个三位数，从而可以得到 <code>100a + 10b + c = 99a + 9b + (a + b + c)</code>，从而只需要<strong>各位数相加的和为3的倍数</strong>即可。更多位数同理可证。</p><h3 id="证明判断7的倍数方法"><a href="#证明判断7的倍数方法" class="headerlink" title="证明判断7的倍数方法"></a>证明判断7的倍数方法</h3><p>如果把一个数记作 10x + y，则<code>10x + y = 7(x + y) + 3x - 6y = 7(x + y) + 3(x - 2y)</code>，即<strong>将个位数字去掉之后的数 - 个位数字的两倍=7的倍数</strong>。</p><h2 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h2><p>一般来说，成功概率为p的实验，独立重复n次后的成功次数为X的概率分布，被称为关于发生概率为p、次数为n的二项分布。</p><h2 id="和事件与积事件"><a href="#和事件与积事件" class="headerlink" title="和事件与积事件"></a>和事件与积事件</h2><p>一般来说，如果一个试验中有A与B两个事件，“A与B至少有一个事件发生”的事件被称为A与B的和事件，写作A∪B；而“A与B同时发生”的事件被称为积事件，写作A∩B。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;欧拉常数与圆周率&quot;&gt;&lt;a href=&quot;#欧拉常数与圆周率&quot; class=&quot;headerlink&quot; title=&quot;欧拉常数与圆周率&quot;&gt;&lt;/a&gt;欧拉常数与圆周率&lt;/h2&gt;&lt;p&gt;&lt;code&gt;e&lt;/code&gt; 是一个不可思议且特别的定数。在这层意义上，欧拉常数 &lt;code
      
    
    </summary>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="数学概念" scheme="https://muhouer.github.io/tags/%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>枚举类型</title>
    <link href="https://muhouer.github.io/posts/4502a76f/"/>
    <id>https://muhouer.github.io/posts/4502a76f/</id>
    <published>2019-08-20T16:44:00.000Z</published>
    <updated>2019-08-20T16:52:25.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>枚举类型（<code>enum type</code>）是指由一组固定的常量组成合法的类型。<code>Java</code> 中由关键字 <code>enum</code> 来定义一个枚举类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">    SPRING, SUMMER, AUTUMN, WINER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句定义：</p><ol><li>使用关键字 <code>enum</code></li><li>类型名称，比如这里的<code>Season</code></li><li>枚举中的属性必须放在最前面，一般使用大写字母表示</li><li>枚举可以单独定义在一个文件中，也可以嵌在其它<code>Java</code>类中</li><li>枚举可以实现一个或多个接口（Interface）</li><li>可以和 java 类一样定义方法 ，枚举中的构造方法必须是私有的。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 <code>javap</code> 进行反编译可以看到 <code>public final class Season extends Enum</code>，也就是说当我们使用 <code>enum</code> 来定义一个枚举类型的时候，编译器会自动帮我们创建一个 <code>final</code> 类型且继承自 <code>Enum</code> 的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Season</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Season</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season SPRING;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season SUMMER;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season AUTUMN;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season WINER;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.muhouer.algorithm.Season[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.muhouer.algorithm.<span class="function">Season <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些特殊方法"><a href="#一些特殊方法" class="headerlink" title="一些特殊方法"></a>一些特殊方法</h2><ol><li><p>Java 枚举值比较用 <code>==</code> 和 <code>equals()</code> 方法效果是一样的。因为枚举 Enum 类的 <code>equals()</code> 方法的实现就是使用 <code>==</code> ；</p></li><li><p>Enum 的 <code>compareTo()</code>方法实际上比较的是 Enum 的 ordinal 顺序大小；</p></li><li><p>Enum 在 <code>switch</code> 中比较的是 Enum 的 ordinal 值；</p></li><li><p>Enum 的 <code>name()</code>方法和 <code>toString()</code> 方法效果一样，返回的都是 Enum 的 name 值。</p></li></ol><h2 id="序列化及线程安全"><a href="#序列化及线程安全" class="headerlink" title="序列化及线程安全"></a>序列化及线程安全</h2><p>为了保证枚举类型像 Java 规范中规定的那样，每一个枚举类型极其定义的枚举变量在 JVM 中都是唯一的，在枚举类型的序列化和反序列化上，Java 做了特殊的规定:</p><blockquote><p>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.</p></blockquote><p>大概意思就是说，在序列化的时候 Java 仅仅是将枚举对象的 name 属性输出到结果中，反序列化的时候则是通过java.lang.Enum 的 <code>valueOf()</code> 方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了 <code>writeObject</code>、<code>readObject</code>、<code>readObjectNoData</code>、<code>writeReplace</code> 和 <code>readResolve</code> 等方法。 我们看一下这个<code>valueOf()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String name)</span> </span>&#123;</span><br><span class="line">    T result = enumType.enumConstantDirectory().get(name); <span class="comment">// 获取枚举类型的枚举常量字典</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 找到即返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) <span class="comment">// 否则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Map&lt;String, T&gt; enumConstantDirectory = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a map from simple name to enum constant.  This package-private</span></span><br><span class="line"><span class="comment"> * method is used internally by Enum to implement</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)&#125;</span></span><br><span class="line"><span class="comment"> * efficiently.  Note that the map is returned by this method is</span></span><br><span class="line"><span class="comment"> * created lazily on first use.  Typically it won't ever get created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Map&lt;String, T&gt; <span class="title">enumConstantDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enumConstantDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        T[] universe = getEnumConstantsShared();  <span class="comment">// 反射的方式调用枚举类型的 values() 静态方法</span></span><br><span class="line">        <span class="keyword">if</span> (universe == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                getName() + <span class="string">" is not an enum type"</span>);</span><br><span class="line">        Map&lt;String, T&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span> * universe.length);</span><br><span class="line">        <span class="keyword">for</span> (T constant : universe)</span><br><span class="line">            m.put(((Enum&lt;?&gt;)constant).name(), constant); <span class="comment">// 填充 enumConstantDirectory</span></span><br><span class="line">        enumConstantDirectory = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enumConstantDirectory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从👆可以看出，JVM 对枚举类型序列化有保证。</p><p>枚举类型是一个 final 类型的继承自 Enum 的类，所以枚举类型不能被继承，而且这个类中的属性和方法都是static 类型的。当一个 Java 类第一次被真正使用到的时候静态资源初始化、Java 类的加载和初始化过程都是线程安全的。所以，<strong>创建一个enum类型是线程安全的</strong>。</p><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>在StakcOverflow中，有一个关于<a href="https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java" target="_blank" rel="noopener">在 Java 中哪种写单例的方式最好</a>的讨论。</p><p>Joshua Bloch大神在《Effective Java》中明确表达过的观点：</p><blockquote><p>使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</p></blockquote><p>使用枚举实现单例的好处：</p><ol><li><p>枚举单例写法简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程安全：枚举实现的单例是天生线程安全的。</p></li><li><p>反序列化不会破坏单例。</p><blockquote><p>普通的 Java 类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。所以，即使单例中构造函数是私有的，也会被反射给破坏掉。由于反序列化后的对象是重新 new 出来的，所以这就破坏了单例。</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;枚举类型（&lt;code&gt;enum type&lt;/code&gt;）是指由一组固定的常量组成合法的类型。&lt;code&gt;Java&lt;/code&gt; 中由关键字 
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="枚举类型" scheme="https://muhouer.github.io/tags/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>杂记-天秀</title>
    <link href="https://muhouer.github.io/posts/ff247979/"/>
    <id>https://muhouer.github.io/posts/ff247979/</id>
    <published>2019-08-20T15:06:47.000Z</published>
    <updated>2019-08-20T16:44:49.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。"><a href="#在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。" class="headerlink" title="在一个8×8的国际象棋棋盘上, 显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。"></a>在一个8×8的国际象棋棋盘上, 显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。</h2><h3 id="问：如果将对角线上的两个方格挖掉-那剩下来的62个格子还能用31张骨牌覆盖住吗？"><a href="#问：如果将对角线上的两个方格挖掉-那剩下来的62个格子还能用31张骨牌覆盖住吗？" class="headerlink" title="问：如果将对角线上的两个方格挖掉, 那剩下来的62个格子还能用31张骨牌覆盖住吗？"></a>问：如果将对角线上的两个方格挖掉, 那剩下来的62个格子还能用31张骨牌覆盖住吗？</h3><img src="/images/201908201107.png" width="500px" height="500px" align="center"><p>答：每一张骨牌在棋盘上必是覆盖住两个相邻方格, 一白一黑。挖掉两个角之后只有 32 黑 30 白, 于是就不存在这样一种能用31个骨牌覆盖的方法。</p><h3 id="问：任意切掉一个一白一黑的格子就一定可以吗？"><a href="#问：任意切掉一个一白一黑的格子就一定可以吗？" class="headerlink" title="问：任意切掉一个一白一黑的格子就一定可以吗？"></a>问：任意切掉一个一白一黑的格子就一定可以吗？</h3><img src="/images/201908201108.png" width="500px" height="500px" align="center"><p>答：可以。粗黑线条将整个棋盘转变为一条首尾相连、黑白格相间的封闭路线。从这棋盘上切掉任何两个颜色不同的方格, 会让这个封闭线路变成两段线路, 当然如果切掉的方格是相连的, 那就是一条线路。显然, 在任何线路中, 两种颜色的格子数量都是偶数，故分别都可以被若干张骨牌覆盖。从而整个棋盘一定可以被31张骨牌完全覆盖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。&quot;&gt;&lt;a href=&quot;#在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。&quot; class=&quot;headerlink&quot; title=&quot;在一个8
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>杂记-科学与方法</title>
    <link href="https://muhouer.github.io/posts/b549d39b/"/>
    <id>https://muhouer.github.io/posts/b549d39b/</id>
    <published>2019-08-20T14:40:00.000Z</published>
    <updated>2019-08-20T14:44:59.797Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>假如在那里居住着智者，这些智者毫无好奇心，避免一切过度行为，那么他们不会死于疾病，而确实将死于无聊。</p></li><li><p>法则一经确立，我们首先就要寻找这个法则具有最大失效机遇的情况。我们应该达到的目的主要不在于弄清相似和差异，而是要认出隐藏在表观偏离下的类似性。</p></li><li><p>科学家研究自然，并非因为它有用处；他研究它，是因为他喜欢它，他之所以喜欢它，是因为它是美的。如果自然不美，它就不值得了解；如果自然不值得了解，生命也就不值得活着。</p></li><li><p>假如没有能够在事实中选择、分辨在哪些事实背后隐藏某种东西，以及识别什么正在隐藏着的精神，假如没有在未加工的事实下察觉事实精髓的精神，事实也许是毫无成果的。</p></li><li><p>事实的重要性用它产生的效益来衡量，也就是说，用它容许我们节省的思维数量来衡量。思维经济是我们应该对准的目标，因此提供仿效的模型还是不够的。需要使我们之后的人能够省却这些模型，不去重复已做出的论据，而用几句话概括它。</p></li><li><p>我们应该经常力图去做的，可以说是定性地解决问题；也就是说，力图去了解表示未知函数的曲线的一般形状。依然要寻找问题的定量的解。</p></li><li><p>往往发生这种情况：不完美的解把我们引向比较完美的解。有时，级数收敛过慢，以致计算无法实际进行。我们仅仅得以证明问题的可能性。</p></li><li><p>偶然性仅仅是我们无知的度量。按照定义，偶然发生的现象就是我们不知道其规律的现象。</p></li><li><p>对称性的最小欠缺将使它稍微倾斜到一侧或另一侧，而且如果它倾斜了，不管倾斜得多么小，它必将完全倾向那一侧。</p></li><li><p>我不可能预见我推动的指针将停在何处，这就是我的心紧张地跳动，期望一切都交好运的缘由。原因上的差别是难以觉察的，而结果上的差别对我来说却是至关重要的，由于它就是我的整个赌注。</p></li><li><p>我们忽路了这样一些情况,这些情况乍看起来似乎完全是在我们预见之外发生的，人们从来也没有梦想到把任何影响归咎于它，不过与我们的预期相反，它最终却起着重要的作用。</p></li><li><p>我们不知道偶然误差由什么引起的，而且正因为我们不知道，我们才意识到它们服从高斯定律。</p></li><li><p>不是严格的证明微不足道。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;&lt;li&gt;&lt;p&gt;假如在那里居住着智者，这些智者毫无好奇心，避免一切过度行为，那么他们不会死于疾病，而确实将死于无聊。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;法则一经确立，我们首先就要寻找这个法则具有最大失效机遇的情况。我们应该达到的目的主要不在于弄清相似和差异，而是要认出隐藏在表观
      
    
    </summary>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="科学与方法" scheme="https://muhouer.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>证明杂记</title>
    <link href="https://muhouer.github.io/posts/c1a19f3f/"/>
    <id>https://muhouer.github.io/posts/c1a19f3f/</id>
    <published>2019-08-18T06:22:00.000Z</published>
    <updated>2019-08-21T16:06:47.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何证明-0-99999……-1"><a href="#如何证明-0-99999……-1" class="headerlink" title="如何证明 0.99999…… = 1"></a>如何证明 <code>0.99999…… = 1</code></h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><code>1/3 = 0.33333……</code> ==&gt; <code>1 = 0.99999……</code></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><code>10 * 0.99999…… = 9.9999……</code><br>两边各减去一个 <code>0.99999……</code> ==&gt; <code>9 * 0.99999…… = 9</code> ==&gt; <code>0.99999…… = 1</code></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p><code>0.99999…… = 0.9 + 0.09 + 0.009 + ……</code><br>采用等比数列求和，然后求极限。</p><p>从而可以得到 <strong>0.99999…… + n = n + 1</strong>，例如： <strong>9.99999…… = 10</strong></p><h2 id="有趣的-PI-和-E"><a href="#有趣的-PI-和-E" class="headerlink" title="有趣的 PI 和 E"></a>有趣的 <code>PI</code> 和 <code>E</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.pow(Math.PI, 4) + Math.pow(Math.PI, 5)</span><br><span class="line">403.4287758192838</span><br><span class="line">&gt; Math.pow(Math.E, 6)</span><br><span class="line">403.428793492735</span><br></pre></td></tr></table></figure><p><code>PI^4 + PI^5 约等于 E^6</code> 可以精确到小数点后四位。<br>紧跟这个精度之后的是 <code>PI^146 + PI^152 约等于 E^174</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.pow(Math.PI, 146) + Math.pow(Math.PI, 152)</span><br><span class="line">3.6917488742520865e+75</span><br><span class="line">&gt; Math.pow(Math.E, 174)</span><br><span class="line">3.6918143295804325e+75</span><br></pre></td></tr></table></figure><p>神奇！神奇！神奇！<br>有趣！有趣！有趣！</p><h2 id="时间复利"><a href="#时间复利" class="headerlink" title="时间复利"></a>时间复利</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.pow((1+1/365), 365)</span><br><span class="line">2.714567482021973</span><br><span class="line">&gt; Math.pow((1+1/365), 365*10)</span><br><span class="line">21727.333146076744</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何证明-0-99999……-1&quot;&gt;&lt;a href=&quot;#如何证明-0-99999……-1&quot; class=&quot;headerlink&quot; title=&quot;如何证明 0.99999…… = 1&quot;&gt;&lt;/a&gt;如何证明 &lt;code&gt;0.99999…… = 1&lt;/code&gt;&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数学" scheme="https://muhouer.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>HashSet分析</title>
    <link href="https://muhouer.github.io/posts/88817346/"/>
    <id>https://muhouer.github.io/posts/88817346/</id>
    <published>2019-08-18T05:58:00.000Z</published>
    <updated>2019-08-20T16:46:43.638Z</updated>
    
    <content type="html"><![CDATA[<p><code>HashSet</code> 是一个不允许存储重复元素的集合，它的实现比较简单，只要理解了 <code>HashMap</code>，<code>HashSet</code> 基本就没什么问题。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>主要就两个变量:</p><ul><li><code>map</code> ：用于存放最终数据的。</li><li><code>PRESENT</code> ：是所有写入 map 的 <code>value</code> 值。</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数也很简单，利用 <code>HashMap</code> 初始化了 map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new set containing the elements in the specified</span></span><br><span class="line"><span class="comment"> * collection.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor</span></span><br><span class="line"><span class="comment"> * (0.75) and an initial capacity sufficient to contain the elements in</span></span><br><span class="line"><span class="comment"> * the specified collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash table</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的就是这个 <code>add()</code> 方法。 可以看出它是将存放的对象当做了 <code>HashMap</code> 的健，<code>value</code> 都是相同的 <code>PRESENT</code> 。由于 <code>HashMap</code> 的 <code>key</code> 是不能重复的，所以每当有重复的值写入到 <code>HashSet</code> 时，<code>value</code> 会被覆盖，但 <code>key</code> 不会受到影响，这样就保证了 <code>HashSet</code> 中只能存放不重复的元素。</p><h2 id="TreeSet-与-HashSet-的区别"><a href="#TreeSet-与-HashSet-的区别" class="headerlink" title="TreeSet 与 HashSet 的区别"></a>TreeSet 与 HashSet 的区别</h2><p>1、<code>TreeSet</code> 是二差树实现的，<code>Treeset</code>c中的数据是自动排好序的，不允许放入 null 值 2、<code>HashSet</code> 是哈希表实现的，<code>HashSet</code> 中的数据是无序的，可以放入 null，但只能放入一个 null，两者中的值都不能重复，就如数据库中唯一约束。</p><p>在 <code>HashSet</code> 中，基本的操作都是由 <code>HashMap</code> 底层实现的，因为 <code>HashSet</code> 底层是用 <code>HashMap</code> 存储数据的。当向<code>HashSet</code> 中添加元素的时候，首先计算元素的hashcode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。</p><p><code>TreeSet</code> 的底层是 <code>TreeMap</code> 的 keySet()，而 <code>TreeMap</code> 是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。</p><p><code>TreeMap</code> 是按key排序的，元素在插入 <code>TreeSet</code> 时 compareTo() 方法要被调用，所以 <code>TreeSet</code> 中的元素要实现Comparable 接口。<code>TreeSet</code> 作为一种Set，它不允许出现重复元素。<code>TreeSet</code> 是用 compareTo() 来判断重复元素的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>HashSet</code> 的原理比较简单，几乎全部借助于 <code>HashMap</code> 来实现的。即 <code>HashSet</code> 和 <code>HashMap</code> 是命运共同体，一荣俱荣，一损俱损。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;HashSet&lt;/code&gt; 是一个不允许存储重复元素的集合，它的实现比较简单，只要理解了 &lt;code&gt;HashMap&lt;/code&gt;，&lt;code&gt;HashSet&lt;/code&gt; 基本就没什么问题。&lt;/p&gt;&lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; 
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HashSet" scheme="https://muhouer.github.io/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList分析</title>
    <link href="https://muhouer.github.io/posts/5c1acfc0/"/>
    <id>https://muhouer.github.io/posts/5c1acfc0/</id>
    <published>2019-08-18T05:55:00.000Z</published>
    <updated>2019-08-20T16:46:27.303Z</updated>
    
    <content type="html"><![CDATA[<p><code>LinkedList</code> 底层是基于双向链表 <code>Deque</code> 实现的，也是实现了 <code>List</code> 接口，所以也拥有 List 的一些特点，出场率不高，了解一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>即类似如下形式：</p><p><code>first.prev == null &amp;&amp; first.next == a</code> &lt;——&gt; <code>a.prev = first&amp;&amp; a.next == last</code> &lt;——&gt; <code>last.prev == a &amp;&amp; last.next == null</code></p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>每次插入都是移动指针，和 <code>ArrayList</code> 的拷贝数组相比效率提升不少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>利用了双向链表的特性，使用空间来换取时间。如果索引值小于链表大小的一半，即 <code>index</code> 离链表头比较近，就从节点头部遍历，否则将从尾结点开始遍历。这就导致效率降低，特别是当 <code>index</code> 越接近 <code>size</code> 的中间值时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>LinkedList 插入，删除都是移动指针效率很高。</li><li>查找需要进行遍历查询，效率较低。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; 底层是基于双向链表 &lt;code&gt;Deque&lt;/code&gt; 实现的，也是实现了 &lt;code&gt;List&lt;/code&gt; 接口，所以也拥有 List 的一些特点，出场率不高，了解一下。&lt;/p&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="LinkedList" scheme="https://muhouer.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>HashMap分析</title>
    <link href="https://muhouer.github.io/posts/9c86c04c/"/>
    <id>https://muhouer.github.io/posts/9c86c04c/</id>
    <published>2019-08-18T01:34:00.000Z</published>
    <updated>2019-08-18T06:07:55.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Map 这样的 <code>Key Value</code> 在软件开发中是非常经典的结构，常用于在内存中存放数据。Java 中最常用的 Map 有两种，首先是 HashMap ，其次是 ConcurrentHashMap 。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>从整个 HashMap 的声明可以看出它内部是基于<strong>数组</strong> + <strong>链表</strong>实现的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p><h3 id="基于-1-7"><a href="#基于-1-7" class="headerlink" title="基于 1.7"></a>基于 1.7</h3><p>HashMap 在 jdk1.7 中的数据结构图：<br><img src="/images/5cd1d2be77958.png" width="900px" height="600px" align="center"><br>首先来看 jdk1.7 中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//初始化桶大小，因为底层是数组，所以这是数组默认的大小。默认大小16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">//桶最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; <span class="comment">//真正存放数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;      <span class="comment">//存放key-value元素的个数</span></span><br><span class="line"><span class="keyword">int</span> threshold;           <span class="comment">//桶容量大小，可在初始化时显式指定，扩容判定threshold = capacity * loadFactor，默认为0.75 * 16 = 12</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;  <span class="comment">//负载因子，可在初始化时显式指定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个属性是在抽象类AbstractMap中定义的</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt;        keySet = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Map 在使用过程中不断的往里面存放数据，当数量达到了 threshold 就需要将当前容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。因此通常建议能<strong>提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗</strong>。</p></blockquote><p>根据代码可以看到其实真正存放数据的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p>这个数组，那么它又是如何定义的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry 是 HashMap 中的一个内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;     <span class="comment">// key，写入时的键</span></span><br><span class="line">    V value;         <span class="comment">// value，值</span></span><br><span class="line">    Entry&lt;K,V&gt; next; <span class="comment">// 用于实现链表结构，当有hash冲突，存储的下一个元素</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">// 当前 key 的 hashcode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> key;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">      V oldValue = value;</span><br><span class="line">      value = newValue;</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上即为 HashMap 的基本结构，接下来来看写入和获取方法：</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123; // 判断当前数组是否需要初始化。</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key == null) // 如果 key 为空，则 put 一个空值进去</span><br><span class="line">        return putForNullKey(value); // </span><br><span class="line">    int hash = hash(key); // 计算根据 key 计算出 hash 值------</span><br><span class="line">    int i = indexFor(hash, table.length); // 根据计算出的 hash 值定位出所在桶</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 如果桶是一个链表则，需要遍历判断</span><br><span class="line">        Object k;</span><br><span class="line">        // hash 值、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 桶是空的，说明当前位置没有数据存入</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i); // 新增一个 Entry 对象写入当前位置</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    // 初始容量是一个偶数，当 length-1 的时候，这个数的有效二进制位都是1。</span><br><span class="line">    // 只要保证了 h 的分散性就行。&amp;用来取mod运算，效率比%高。</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; // 判断是否需要扩容</span><br><span class="line">        resize(2 * table.length); // 两倍扩充</span><br><span class="line">        hash = (null != key) ? hash(key) : 0; // 当前的 key 重新 hash</span><br><span class="line">        bucketIndex = indexFor(hash, table.length); // 重新定位</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key); <span class="comment">// 根据 key 计算出 hash 值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; </span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123; <span class="comment">// 定位到具体的桶中</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">            <span class="keyword">return</span> e; <span class="comment">//  key 及 hash 值相等时候就返回对应的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回 null </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表死循环"><a href="#链表死循环" class="headerlink" title="链表死循环"></a>链表死循环</h4><p><a href="https://blog.csdn.net/xyh930929/article/details/84777301" target="_blank" rel="noopener">HashMap由并发引起的链表死循环</a></p><h3 id="基于-1-8"><a href="#基于-1-8" class="headerlink" title="基于 1.8"></a>基于 1.8</h3><p>HashMap 在 jdk1.7 的实现中有个明显缺点：</p><blockquote><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。</p></blockquote><p>因此 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 <code>O(logn)</code>。</p><p>话不多说，上🐎：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>和 1.7 大体上都差不多，还是有几个重要的区别：</p><ul><li><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</li><li><code>Entry</code> 修改为 <code>Node</code>。</li></ul><p>Node 的核心组成其实也是和 1.7 中的 Entry 一样，存放的都是 <code>key value hashcode next</code> 等数据。</p><h4 id="put-方法-1"><a href="#put-方法-1" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length; <span class="comment">// 当前桶为空，进行初始化（resize 中会判断是否进行初始化）</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 根据当前 key 的 hash 值定位到具体的桶中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 为空表明没有 Hash 冲突就直接在当前位置创建一个新桶</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 不为空，有 Hash 冲突</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p; <span class="comment">// 比较当前桶中的 key、key 的 hash 值与写入的 key 是否相等，相等就赋值给 e</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前桶为红黑树，那就要按照红黑树的方式写入数据</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果在遍历过程中找到 key 相同时直接退出遍历</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 存在相同的 key ，需要将值覆盖</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 判断是否需要进行扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="comment">// 将 key hash 之后取得所定位的桶</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断桶的第一个位置的 key 是否为查询的 key，是就直接返回 value。</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 红黑树</span></span><br><span class="line">                    <span class="comment">// 按照树的查找方式返回值</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">// 链表</span></span><br><span class="line">                    <span class="comment">// 按照链表的方式遍历匹配返回值</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 桶为空则直接返回 null </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>HashMap 在并发时可能出现的问题主要有三个方面：</p><ul><li><p>如果多个线程同时使用 put 方法添加元素，而且假设正好存在两个 put 的 key 发生了碰撞（根据 hash 值计算的 bucket 一样），那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程 put 的数据被覆盖。</p></li><li><p>如果多个线程同时检测到元素个数超过 threshold，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。</p></li></ul><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String key = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>强烈建议</code>使用第一种 EntrySet 进行遍历。第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。</p><blockquote><p>无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题）。</p></blockquote><p>因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 <code>java.util.concurrent</code> 包下，专门用于解决并发问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Map 这样的 &lt;code&gt;Key Value&lt;/code&gt; 在软件开发中是非常经典的结构，常用于在内存中存放数据。Java 中最常用的 M
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HashMap" scheme="https://muhouer.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>String分析</title>
    <link href="https://muhouer.github.io/posts/4a48cd1d/"/>
    <id>https://muhouer.github.io/posts/4a48cd1d/</id>
    <published>2019-08-18T01:31:00.000Z</published>
    <updated>2019-08-18T01:33:43.976Z</updated>
    
    <content type="html"><![CDATA[<p><code>String</code> 这个类是我们在写 Java 代码中用得最多的一个类，没有之一，今天我们就讲讲它。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>String</code> 并不是基本数据类型，而是一个对象，并且是不可变的对象。</p><p>查看源码就会发现 <code>String</code> 类为<code>final</code> 型的(当然也不可被继承)，而且通过查看 JDK 文档会发现几乎每一个修改 <code>String</code> 对象的操作，实际上都是创建了一个全新的 <code>String</code> 对象。</p><p><code>String</code> 类实现了 <code>Serializable</code>，<code>Comparable</code>，<code>CharSequence</code>接口，被 <code>final</code> 修饰。内部维护了一个字符数组。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">== <span class="comment">// 判断内容与地址是否相同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> <span class="comment">// 判断两个字符串内容是否相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> <span class="comment">// 忽略大小写，判断两个字符串内容是否相同，底层调用了regionMatches方法</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span> <span class="comment">// 判断字符序列和字符串内容是否相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span> <span class="comment">// 判断StringBuffer和字符串内容是否相同，实际上调用的是contentEquals方法</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> <span class="comment">// 按照字典大小比较两个字符串的大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span> <span class="comment">// 忽略大小写，按照字典大小比较两个字符串的大小，使用忽略大小写比较器</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断两个字符串部分内容是否相同，ignoreCase:是否忽略大小写，toffset:子字符串的偏移量，ooffset:参数字符串中子字符串的偏移量，len:比较的子字符串的长度</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 返回索引上的字符，索引从0开始</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> <span class="comment">// 从字符串开始检索字符(Unicode 码) ch，并返回第一次出现的位置，未出现返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch，<span class="keyword">int</span> fromIndex)</span> <span class="comment">// 从字符串的第fromIndex个字符开始检索字符(Unicode 码) ch，未出现返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> <span class="comment">// 从字符串检索字符(Unicode 码) ch最后一次出现的位置。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> <span class="comment">//从字符串的第fromIndex个字符检索字符(Unicode 码) ch最后一次出现的位置。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> <span class="comment">// 判断此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> <span class="comment">// 判断此字符串是否以指定前缀开始。</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> <span class="comment">// 判断此字符串是否以指定后缀结尾。</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串截取与替换"><a href="#字符串截取与替换" class="headerlink" title="字符串截取与替换"></a>字符串截取与替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> <span class="comment">// 返回一个新的字符串，是从beginIndex开始到length-1的串。</span></span></span><br><span class="line"><span class="function">String <span class="title">subString</span><span class="params">(<span class="keyword">int</span> beginIndex，<span class="keyword">int</span> endIndex)</span>------返回一个新的字符串，是从beginIndex开始到endIndex-1的串。</span></span><br><span class="line"><span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> <span class="comment">// 返回从beginIndex开始到endIndex-1的字符序列</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> <span class="comment">// 将字符串中的oldChar字符替换为newChar</span></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> <span class="comment">// 将字符串中的target字符序列替换为replacement序列</span></span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> <span class="comment">// 使用replacement替换第一个通过regex匹配到子串。</span></span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> <span class="comment">// 使用replacement替换所有通过regex匹配到子串。</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串其他常用方法"><a href="#字符串其他常用方法" class="headerlink" title="字符串其他常用方法"></a>字符串其他常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="comment">// 获取字符串长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="comment">// 判断字符串是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span> <span class="comment">// 判断字符串是否包含字符序列 s</span></span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span> <span class="comment">// 字符串拼接</span></span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span> <span class="comment">// 字符串去掉首尾空白</span></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">(Locale locale)</span> <span class="comment">// 字符串转大写</span></span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span> <span class="comment">// 字符串转小写</span></span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex)</span> <span class="comment">// 字符串分割</span></span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span> <span class="comment">// 字符串分割，多了结果阈值参数</span></span></span><br></pre></td></tr></table></figure><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>第一种方式是在常量池中直接拿对象，第二种是在堆内存空间创建一个新的对象。只要使用new方法，就需要创建新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Freya"</span>); <span class="comment">// 这句话创建了两个对象。</span></span><br></pre></td></tr></table></figure><p>首先，字符串“Freya”放入常量池，然后 new 了一个字符串“Freya”放入 Java 堆。字符串常量”Freya”在编译期就已经确定放入常量池，而 Java 堆上的”Freya”是在运行期初始化阶段才确定。然后 Java 栈中的 str 指向了 Java 堆中的 “Freya”。</p><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>字符串常量池是 JVM 实例全局共享的，全局只有一个。字符串常量池及到一个设计模式，叫“享元模式”，顾名思义 就是<strong>共享元素模式</strong>。也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素。</p><ul><li>直接使用双引号声明的 String 对象直接存储在字符串常量池。</li><li>不是双引号声明的，可以使用 <code>String.intern()</code> 方法，这是一个Native方法。如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"Freya"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String b = <span class="string">"Freya"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String c = <span class="keyword">new</span> String(<span class="string">"Freya"</span>);</span><br><span class="line">    String d = a.intern();</span><br><span class="line">    String e = <span class="string">"Freya"</span> + <span class="string">" 17"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String f = <span class="string">" 17"</span>;</span><br><span class="line">    String g = a + f; <span class="comment">//在堆上创建的新的对象</span></span><br><span class="line">    String h = <span class="string">"Freya 17"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line">    System.out.println(a == c); <span class="comment">//false</span></span><br><span class="line">    System.out.println(a == d); <span class="comment">//true</span></span><br><span class="line">    System.out.println(e == g); <span class="comment">//false</span></span><br><span class="line">    System.out.println(e == h); <span class="comment">//true</span></span><br><span class="line">    System.out.println(g == h); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变，可以使用StringBuilder或者StringBuffer。</p></blockquote><h2 id="String-对象的不可变性"><a href="#String-对象的不可变性" class="headerlink" title="String 对象的不可变性"></a>String 对象的不可变性</h2><p>打开 <code>String</code> 类源码，可以看到一句话:</p><blockquote><p>Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared.</p></blockquote><p>意思是 <code>String</code> 是个常量，创建之后就是不可变的。不可变的意思是不能改变对象内的成员变量，包括基本数据类型变量的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><h3 id="String-对象不可变性是如何实现的？"><a href="#String-对象不可变性是如何实现的？" class="headerlink" title="String 对象不可变性是如何实现的？"></a>String 对象不可变性是如何实现的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length); <span class="comment">// deep copy操作</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">     <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">        <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];</span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出：</p><ul><li>String 类被 final 修饰，不可继承。</li><li>String内部所有成员都设置为私有变量。</li><li>不存在value的setter方法。</li><li>将value和offset设置为final。</li><li>当传入可变数组value[]时，进行copy而不是直接将value[]复制给内部变量。</li><li>获取value时不是直接返回对象引用，而是返回对象的copy。</li></ul><h3 id="String-对象不可变性的优缺点"><a href="#String-对象不可变性的优缺点" class="headerlink" title="String 对象不可变性的优缺点"></a>String 对象不可变性的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p><strong>字符串常量池的需要</strong><br>字符串常量池可以将一些字符常量放在常量池中重复使用，避免每次都重新创建相同的对象、节省存储空间。但如果字符串是可变的，此时相同内容的String还指向常量池的同一个内存空间，当某个变量改变了该内存的值时，其他遍历的值也会发生改变。所以不符合常量池设计的初衷。</p></li><li><p><strong>线程安全考虑</strong><br>同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p></li><li><p><strong>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载</strong></p><p>譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</p></li><li><p><strong>支持hash映射和缓存</strong><br>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果有对String对象值改变的需求，那么会创建大量的String对象。</p><h2 id="String对象是否真的不可变"><a href="#String对象是否真的不可变" class="headerlink" title="String对象是否真的不可变"></a>String对象是否真的不可变</h2><p>虽然 String 对象将 value 设置为 final，并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>;</span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s); <span class="comment">//Hello World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">//Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="其他相关内容"><a href="#其他相关内容" class="headerlink" title="其他相关内容"></a>其他相关内容</h2><h3 id="substring-方法"><a href="#substring-方法" class="headerlink" title="substring 方法"></a>substring 方法</h3><p>在 JDK 1.6中，当调用 substring 方法的时候，会创建一个新的 String 对象，但是这个 String 的值仍然指向堆中的同一个字符数组。这两个对象中只有 count 和offset 的值是不同的。如果你有一个很长很长的字符串，但是当你使用 substring 进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 1.6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x.substring(x, y) + <span class="string">""</span></span><br></pre></td></tr></table></figure><p>以上问题在jdk 7+中得到解决。在jdk 7+ 中，substring方法会在堆内存中创建一个新的数组。其使用<code>new String</code>创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。</p><h3 id="String-valueOf和Integer-toString的区别"><a href="#String-valueOf和Integer-toString的区别" class="headerlink" title="String.valueOf和Integer.toString的区别"></a>String.valueOf和Integer.toString的区别</h3><p>我们有三种方式将一个int类型的变量变成呢过String类型，那么他们有什么区别？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">String i1 = <span class="string">""</span> + i; <span class="comment">//其实是String i1 = (new StringBuilder()).append(i).toString();，首先创建一个StringBuilder对象，然后再调用append方法，再调用toString方法。</span></span><br><span class="line">String i2 = String.valueOf(i); <span class="comment">//调用 Integer.toString(i)</span></span><br><span class="line">String i3 = Integer.toString(i);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;String&lt;/code&gt; 这个类是我们在写 Java 代码中用得最多的一个类，没有之一，今天我们就讲讲它。&lt;/p&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;co
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="String" scheme="https://muhouer.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList分析</title>
    <link href="https://muhouer.github.io/posts/b0d3e399/"/>
    <id>https://muhouer.github.io/posts/b0d3e399/</id>
    <published>2019-08-18T01:27:00.000Z</published>
    <updated>2019-08-18T01:33:09.325Z</updated>
    
    <content type="html"><![CDATA[<p><code>ArrayList</code> 实现于 <code>List</code>、<code>RandomAccess</code> 接口。可以插入空数据，也支持随机访问。</p><p><code>ArrayList</code> 相当于动态数据，其中最重要的两个属性分别是: <code>elementData</code> 数组，以及 <code>size</code> 大小。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 默认的初始化容量 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/** 空 ArrayList 实例共享的空数组实例 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/** 默认大小的空 ArrayList 实例共享的空数组实例，和 EMPTY_ELEMENTDATA 区分开 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 存储arraylist元素的数组缓冲区。</span></span><br><span class="line"><span class="comment"> * 任何使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空 ArrayList 实例，</span></span><br><span class="line"><span class="comment"> * 在首次添加元素时容量扩展到默认容量 DEFAULT_CAPACITY 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// 非私有以简化嵌套类访问</span></span><br><span class="line"><span class="comment">/** ArrayList包含的元素个数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123; <span class="comment">// 新建 initialCapacity 大小的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123; <span class="comment">// 采用 EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123; <span class="comment">// 采用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，和 EMPTY_ELEMENTDATA 区分开来</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-toArray-might-incorrectly-not-return-Object-see-6260652"><a href="#c-toArray-might-incorrectly-not-return-Object-see-6260652" class="headerlink" title="c.toArray might (incorrectly) not return Object[] (see 6260652)"></a>c.toArray might (incorrectly) not return Object[] (see 6260652)</h2><p>查看 <code>ArrayList(Collection&lt;? extends E&gt; c)</code> 构造函数时，有个注释 <strong>c.toArray might (incorrectly) not return Object[] (see 6260652)</strong>，具体什么意思呢？先看个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>));</span><br><span class="line">list.set(<span class="number">0</span>, <span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure><p>如果 ArrayList 的构造函数中没有类型检查的代码 <code>elementData.getClass() != Object[].class</code>，会导致其elementData 的实际类型是String[]，而不是 Object[]，所以当你将其中一个元素更换为 Object 元素时会报错，你可以试下如下代码，肯定会报 ArrayStoreException 的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>&#125;;</span><br><span class="line">arr[<span class="number">0</span>]=<span class="keyword">new</span> Object(); <span class="comment">// Causes ArrayStoreException,</span></span><br><span class="line">                     <span class="comment">// because you cannot put arbitrary Object into String[]</span></span><br></pre></td></tr></table></figure><p>主要问题出在 <code>Arrays.asList</code> 上面，<code>Arrays.asList</code> 返回的 ArrayList 实际上是内部类 ArrayList ，并不是我们经常使用的 <code>ArrayList</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>内部类 ArrayList 的 <code>toArray()</code> 使用的是 <code>clone</code> 方法，而我们经常使用的 <code>ArrayList</code> 的 <code>toArray()</code> 使用的是 <code>Arrays.copyOf()</code> 方法，具体差别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = <span class="keyword">new</span> ArrayList&lt;Object&gt;(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>)).toArray();</span><br><span class="line">System.out.println(arr.getClass()); <span class="comment">// class [Ljava.lang.Object; Object数组</span></span><br><span class="line">Object[] arr1 = Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>).toArray();</span><br><span class="line">System.out.println(arr1.getClass()); <span class="comment">// class [Ljava.lang.String; String 数组，操作不当会引起 ArrayStoreException</span></span><br></pre></td></tr></table></figure><p>关于 <code>Arrays.asList</code> 的一个坑 <a href="/posts/45d267df/" title="使用Java时的一些坑">使用Java时的一些坑</a></p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>在调用 <code>add()</code> 方法的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先进行扩容校验。</li><li>将插入的值放到尾部，并将 size + 1 。</li></ul><p>如果是调用 <code>add(index,e)</code> 在指定位置添加的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//复制，向后移动</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也是首先扩容校验。</li><li>接着对数据进行复制，目的是把 index 位置空出来放本次插入的数据，并将后面的数据向后移动一个位置。</li></ul><p>其实扩容最终调用的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是一个数组复制的过程。</p><p>由此可见 <code>ArrayList</code> 的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>由于 ArrayList 是基于动态数组实现的，所以并不是所有的空间都被使用。因此使用了 <code>transient</code> 修饰，可以防止被自动序列化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure><p>因此 ArrayList 自定义了序列化与反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="comment">//只序列化了被使用的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从实现中可以看出 ArrayList 只序列化了被使用的数据。</p><h2 id="ArrayList-VS-Vector"><a href="#ArrayList-VS-Vector" class="headerlink" title="ArrayList VS Vector"></a>ArrayList VS Vector</h2><p><code>Vector</code> 也是实现于 <code>List</code> 接口，底层数据结构和 <code>ArrayList</code> 类似，也是一个动态数组存放数据。不过是在 <code>add()</code> 方法的时候使用 <code>synchronized</code> 进行同步写数据，但是开销较大，所以 <code>Vector</code> 是一个同步容器并不是一个并发容器。</p><p>以下是 <code>add()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及指定位置插入数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 实现于 &lt;code&gt;List&lt;/code&gt;、&lt;code&gt;RandomAccess&lt;/code&gt; 接口。可以插入空数据，也支持随机访问。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 相当于动态数据，其中最重要的两个属
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ArrayList" scheme="https://muhouer.github.io/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式备忘</title>
    <link href="https://muhouer.github.io/posts/2c992fa9/"/>
    <id>https://muhouer.github.io/posts/2c992fa9/</id>
    <published>2019-08-17T15:54:00.000Z</published>
    <updated>2019-08-17T16:04:20.975Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子。</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式主要依赖于元字符. 元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>句号匹配任意单个字符除了换行符.</td></tr><tr><td>[ ]</td><td>字符种类. 匹配方括号内的任意字符.</td></tr><tr><td>[^ ]</td><td>否定的字符种类. 匹配除了方括号里的任意字符</td></tr><tr><td>*</td><td>匹配&gt;=0个重复的在*号之前的字符.</td></tr><tr><td>+</td><td>匹配&gt;=1个重复的+号前的字符.</td></tr><tr><td>?</td><td>标记?之前的字符为可选.</td></tr><tr><td>{n,m}</td><td>匹配num个大括号之前的字符 (n &lt;= num &lt;= m).</td></tr><tr><td>(xyz)</td><td>字符集, 匹配与 xyz 完全相等的字符串.</td></tr><tr><td>|</td><td>或运算符,匹配符号前或后的字符.</td></tr><tr><td>\</td><td>转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td></tr><tr><td>^</td><td>从开始行开始匹配.</td></tr><tr><td>$</td><td>从末端开始匹配.</td></tr></tbody></table><h2 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h2><p>正则表达式提供一些常用的字符集简写. 如下:</p><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>除换行符外的所有字符</td></tr><tr><td>\w</td><td>匹配所有字母数字, 等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td>\W</td><td>匹配所有非字母数字, 即符号, 等同于: <code>[^\w]</code></td></tr><tr><td>\d</td><td>匹配数字: <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配非数字: <code>[^\d]</code></td></tr><tr><td>\s</td><td>匹配所有空格字符, 等同于: <code>[\t\n\f\r\p{Z}]</code></td></tr><tr><td>\S</td><td>匹配所有非空格字符: <code>[^\s]</code></td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符</td></tr><tr><td>\p</td><td>匹配 CR/LF (等同于 <code>\r\n</code>)，用来匹配 DOS 行终止符</td></tr></tbody></table><h2 id="零宽度断言-前后预查"><a href="#零宽度断言-前后预查" class="headerlink" title="零宽度断言(前后预查)"></a>零宽度断言(前后预查)</h2><p>先行断言和后发断言都属于<strong>非捕获簇</strong>(不捕获文本 ，也不针对组合计进行计数). 先行断言用于判断所匹配的格式是否在另一个确定的格式之前, 匹配结果不包含该确定格式(仅作为约束).</p><p>例如, 我们想要获得所有跟在 <code>$</code> 符号后的数字, 我们可以使用正后发断言 <code>(?&lt;=\$)[0-9\.]*</code>. 这个表达式匹配 <code>$</code> 开头, 之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p><p>零宽度断言如下:</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>?=</td><td>正先行断言-存在</td></tr><tr><td>?!</td><td>负先行断言-排除</td></tr><tr><td>?&lt;=</td><td>正后发断言-存在</td></tr><tr><td>?&lt;!</td><td>负后发断言-排除</td></tr></tbody></table><h3 id="正先行断言"><a href="#正先行断言" class="headerlink" title="?=... 正先行断言"></a><code>?=...</code> 正先行断言</h3><p><code>?=...</code> 正先行断言, 表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式.</p><p>返回结果只包含满足匹配条件的第一部分表达式. 定义一个正先行断言要使用 <code>()</code>. 在括号内部使用一个问号和等号: <code>(?=...)</code>.</p><p>正先行断言的内容写在括号中的等号后面. 例如, 表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ,即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he(?=\sfat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h3 id="负先行断言"><a href="#负先行断言" class="headerlink" title="?!... 负先行断言"></a><code>?!...</code> 负先行断言</h3><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果, 筛选条件为 其后不跟随着断言中定义的格式. <code>正先行断言</code> 定义和 <code>负先行断言</code> 一样, 区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>.</p><p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>(空格)fat</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he(?!\sfat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h3 id="lt-正后发断言"><a href="#lt-正后发断言" class="headerlink" title="?&lt;= ... 正后发断言"></a><code>?&lt;= ...</code> 正后发断言</h3><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着断言中定义的格式. 例如, 表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(?&lt;=(T|t)he\s)(fat|mat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h3 id="lt-负后发断言"><a href="#lt-负后发断言" class="headerlink" title="?&lt;!... 负后发断言"></a><code>?&lt;!...</code> 负后发断言</h3><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟随着断言中定义的格式. 例如, 表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(?&lt;!(T|t)he\s)(cat)&quot; =&gt; The cat sat on cat.</span><br></pre></td></tr></table></figure><h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志也叫模式修正符, 因为它可以用来修改表达式的搜索结果. 这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写.</td></tr><tr><td>g</td><td>全局搜索.</td></tr><tr><td>m</td><td>多行的: 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始.</td></tr></tbody></table><h2 id="贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h2><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/(.*at)/&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/(.*?at)/&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>点击<a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">learn-regex</a>即可去查看更详细信息。</p><p><a href="https://jex.im/regulex/" target="_blank" rel="noopener">Regulex</a>是一个JavaScript 正则表达式解析和可视化网站。具体效果参看👇示例。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h3><p>只允许英文字母、数字、下划线、英文句号、以及中划线组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$</span><br></pre></td></tr></table></figure><img src="/images/201908171144.png" width="900px" height="300px" align="center"><h3 id="汉字"><a href="#汉字" class="headerlink" title="汉字"></a>汉字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[\u4e00-\u9fa5]&#123;0,&#125;$</span><br></pre></td></tr></table></figure><img src="/images/201908171151.png" width="900px" height="300px" align="center"><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br></pre></td></tr></table></figure><img src="/images/201908171153.png" width="900px" height="300px" align="center">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子。&lt;/p&gt;&lt;h2 id=&quot;元字符&quot;&gt;&lt;a href=&quot;#元字符&quot; class=&quot;headerlink&quot; title=&quot;元字符&quot;&gt;&lt;/a&gt;元字符&lt;/h2&gt;&lt;p&gt;正则表达式主要依赖于元字符
      
    
    </summary>
    
      <category term="备忘" scheme="https://muhouer.github.io/categories/%E5%A4%87%E5%BF%98/"/>
    
    
      <category term="正则表达式" scheme="https://muhouer.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>拾句-玩笑</title>
    <link href="https://muhouer.github.io/posts/25a3a536/"/>
    <id>https://muhouer.github.io/posts/25a3a536/</id>
    <published>2019-08-16T15:16:00.000Z</published>
    <updated>2019-08-16T15:19:54.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="001"><a href="#001" class="headerlink" title="001"></a>001</h3><hr><ol><li><strong>女大三抱金砖。女大三十送江山。女大三百送仙丹。</strong></li><li><strong>上帝是公平的，不是公的就是平的。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;001&quot;&gt;&lt;a href=&quot;#001&quot; class=&quot;headerlink&quot; title=&quot;001&quot;&gt;&lt;/a&gt;001&lt;/h3&gt;&lt;hr&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;女大三抱金砖。女大三十送江山。女大三百送仙丹。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="拾句" scheme="https://muhouer.github.io/categories/%E6%8B%BE%E5%8F%A5/"/>
    
    
      <category term="玩笑" scheme="https://muhouer.github.io/tags/%E7%8E%A9%E7%AC%91/"/>
    
  </entry>
  
  <entry>
    <title>一些名词</title>
    <link href="https://muhouer.github.io/posts/6bf34d15/"/>
    <id>https://muhouer.github.io/posts/6bf34d15/</id>
    <published>2019-08-12T13:45:00.000Z</published>
    <updated>2019-08-19T15:55:05.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="鞣酸"><a href="#鞣酸" class="headerlink" title="鞣酸"></a>鞣酸</h2><p>鞣酸系由五倍子中得到的一种鞣质。为黄色或淡棕色轻质无晶性粉末或鳞片；无臭，微有特殊气味，味极涩。溶于水及乙醇，易溶于甘油，几乎不溶于乙醚、氯仿或苯。其水溶液与铁盐溶液相遇变蓝黑色，加亚硫酸钠可延缓变色。在工业上，鞣酸被大量应用于鞣革与制造蓝墨水。鞣酸能使蛋白质凝固。人们把生猪皮、生牛皮用鞣酸进行化学处理，能使生皮中的可溶性蛋白质凝固。于是，本来放上几天就会发臭腐烂的生皮，变成了漂亮、干净、柔韧、经久耐用的皮革。</p><h2 id="选拔考试与诊断考试"><a href="#选拔考试与诊断考试" class="headerlink" title="选拔考试与诊断考试"></a>选拔考试与诊断考试</h2><p>选拔考试，类似于中考高考，你考多少分不重要，59分算高还是低无所谓，关键取决于别人考的怎么样，你考59分，别人都在58分以下，你就有机会读名校；你考59分，人家考95分，对不起，你就回家干活，这叫选拔考试。</p><p>除了中考高考以外，所有的考试都叫诊断考试（测验），即老师教了一个知识点，出一道题看看学生掌握得怎么样了。</p><h2 id="海姆立克急救法"><a href="#海姆立克急救法" class="headerlink" title="海姆立克急救法"></a>海姆立克急救法</h2><p>海姆立克教授是美国一位多年从事外科的医生。在临床实践中，他被大量的食物、异物窒息造成呼吸道梗阻致死的病例震惊了。在急救急诊中，医生常常采用拍打病人背部，或将手指伸进口腔咽喉去取的办法排除异物，其结果不仅无效反而使异物更深入呼吸道。他经过反复研究和多次的动物实验，终于发明了利用肺部残留气体，形成气流冲出异物的急救方法。1974年，他作了关于腹部冲击法解除气管异物的首次报告。</p><p>异物堵塞在呼吸道中的事情在我们的生活中并不少见，前段时间就出现了类似的案列。所以由于异物堵塞在呼吸道中引起的后果还是很严重的。海姆立克急救法也叫海姆里克腹部冲击法（Heimlich Maneuver），是美国医生海姆里克先生发明的，也称为海氏手技。</p><h3 id="成人"><a href="#成人" class="headerlink" title="成人"></a>成人</h3><p>如果是成人，救护者站在受害者身后，从背后抱住其腹部，双臂围环其腰腹部，一手握拳，拳心向内按压于受害人的肚脐和肋骨之间的部位；另一手成掌捂按在拳头之上，双手急速用力向里向上挤压，反复实施，直至阻塞物吐出为止。</p><h3 id="3岁以下孩子"><a href="#3岁以下孩子" class="headerlink" title="3岁以下孩子"></a>3岁以下孩子</h3><p>如果是3岁以下孩子，应该马上把孩子抱起来，一只手捏住孩子颧骨两侧，手臂贴着孩子的前胸，另一只手托住孩子后颈部，让其脸朝下，趴在救护人膝盖上。在孩子背上拍1-5次，并观察孩子是否将异物吐出。</p><h3 id="婴儿"><a href="#婴儿" class="headerlink" title="婴儿"></a>婴儿</h3><ol><li><strong>5次拍背法</strong>：将患者的身体扶于救护员的前臂上，头部朝下，救护员用手支撑伤病者头部及颈部；用另一手掌掌根在伤病者背部两肩胛骨之间拍击5次。</li><li><strong>5次压胸法</strong>：如果堵塞物仍未排除，实施5次压胸法。使患儿平卧，面向上，躺在坚硬的地面或床板上，抢救者跪下或立于其足侧,或取坐位，并使患儿骑在抢救者的两大腿上，面朝前。抢救者以两手的中指或食指，放在患儿胸廓下和脐上的腹部，快速向上重击压迫，但要刚中带柔。重复之，直至异物排出。</li></ol><h2 id="垃圾DNA"><a href="#垃圾DNA" class="headerlink" title="垃圾DNA"></a>垃圾DNA</h2><p>人类大约有95%的DNA并不编码蛋白质，另外5%的DNA可以分成大约十万个功能单位，它们被称为基因。</p><p>研究人员从对比结果中得到了一个惊人的模式：生物越复杂，垃圾DNA似乎就越重要。他们将酵母与更为复杂的蠕虫进行了比较，后者是一种多细胞生物，发现有40%的共有DNA没有被编码。随后，研究人员又将脊椎动物与昆虫进行了对比，这些生物比蠕虫更为复杂，结果发现，有超过66%的共有DNA包含有没有编码的DNA。</p><p>如果这些“垃圾DNA”序列能在电脑屏幕上展现出一个像素数组或一个简单的图像，那么，外星生物曾干预人类DNA的设想就极可能是真的。人类DNA可容纳“外星兴衰史”编码戴维斯称，人类的DNA编码足够容纳一部像样的小说，或者一段外星文明的兴盛和衰落简史。</p><p>垃圾DNA可以说是基因组的暗面，它将改变生物学的面貌，就像暗物质和暗能量改变宇宙学的面貌那样。它既不能给蛋白质编码、充当基因，也不能给RNA编码，也没有找到明显的与蛋白质等其他分子发生相互作用的迹象。当然，完全有可能它是行使了某种功能的，只不过是在“暗地下”进行，而我们还没有能力看到它行使功能的身影罢了。</p><p>这些同时存在于不同哺乳动物DNA序列当中的保守非基因序列的相似性，甚至比同源的编码蛋白质、或者是编码RNA的基因还强。对于其中同时在至少12种物种当中发现的保守非基因序列，如果比较它们的核苷酸排列差异的话，还不及它们的蛋白质编码序列的核苷酸排列差异的一半！</p><p>很多的“垃圾” DNA包含了回文结构，以此维持互补链之间的对称。在果蝇和家蚕里，对这些序列的分析表明，这些转座和散开的重复序列是高度非随机模式。这些模式反映出这些序列是在细胞调控之下，而不是无用或自私的垃圾DNA。 在关系很远的物种之间，例如大型偶蹄类哺乳动物和人，在主要组织相容性复合MHC-DRB基因里都有这些简单重复的(gt)n(ga)m DNA序列。如果这些序列真是垃圾，在数百万年的进化过程中就不可能保存下来。</p><p>另一个研究表明，DNA包含了大范围的不可解释模式。Eugene Stanley博士报道这些模式不是随机改变的结果。一个基因上的一个位置将影响到100万碱基之外的核苷酸，这真是让人难以置信。因而遗传学家Moran认为，L1在人类进化中扮演着重要角色——增加遗传多样性。在嗜酸粒细胞衍生神经毒素、嗜酸细胞阳离子蛋白、IgM重排基因的可变区域、α-球蛋白基因、微管蛋白基因、4-N-乙酰半乳糖氨基转移酶、醛缩酶B基因、乙醛还原酶基因k轻链基因等等,都有基因內增强作用的描述。</p><p>另一些研究证实非编码DNA作为沉默基因,对临近基因的转录起抑制作用。在成骨素基因、2-晶体蛋白基因、CD4基因、β-珠蛋白基因、神经胶质细胞粘连分子、神经元-神经胶质细胞粘连分子、血小板衍生的生长因子A链基因、肾素基因等等的研究中对此有描述。</p><h2 id="冒充者综合征"><a href="#冒充者综合征" class="headerlink" title="冒充者综合征"></a>冒充者综合征</h2><p>冒充者综合征是指有些人即使获得了一些成绩与成果，但却特别不自信，甚至认为这不是自己应得的，而是冒充那些真正厉害的人而得到的。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>大声说出这种 “冒名顶替” 的感受。</li><li>记下你的努力与成就。</li><li>设置合理的目标与期望。</li></ol><h2 id="劳伦斯魔咒"><a href="#劳伦斯魔咒" class="headerlink" title="劳伦斯魔咒"></a>劳伦斯魔咒</h2><p>1999年，经济学家劳伦斯总结出了一个“摩天大楼指数”。他发现，世界上所有的摩天大楼都与经济周期的波动有着紧密联系。摩天大厦的开工时间通常都是经济发展的鼎盛时期，而一旦大厦建成，经济危机便随之席卷而来。这一规律似乎屡试不爽，因此也被称为“劳伦斯魔咒”。</p><h2 id="双盲试验"><a href="#双盲试验" class="headerlink" title="双盲试验"></a>双盲试验</h2><p>在试验过程中，测验者与被测验者都不知道被测者所属的组别（实验组或对照组），分析者在分析资料时，通常也不知道正在分析的资料属于哪一组。旨在消除可能出现在实验者和参与者意识当中的主观偏差和个人偏好。在大多数情况下，双盲实验要求达到非常高的科学严格程度。</p><h2 id="泡文化"><a href="#泡文化" class="headerlink" title="泡文化"></a>泡文化</h2><p>中国社会是一个人情社会，中国有一个很出名的词，就是「泡」。泡吧、泡妞，好兄弟「泡」在一起等等。「泡」这个字的偏旁是三滴水，这三滴水分别是时间、金钱和感情。中国人办事喜欢吃饭，需要先跟他们「泡」在一起,而且这仅仅是一个开始，说明你的事情有了可能性。有时候，只是为了见见，就跑很远的路去和对方一起吃一顿饭。没有别的目的，就是为了取悦对方，让他高兴，这样沟通才顺畅。</p><h2 id="达克效应"><a href="#达克效应" class="headerlink" title="达克效应"></a>达克效应</h2><p>达克效应（D-Keffect），全称为邓宁-克鲁格效应（Dunning-Krugereffect），指的是能力欠缺的人在自己欠考虑的决定的基础上得出错误结论。 通俗点解释，就是谢博德博士说的：“总有一些人认为自己什么都懂，或者低估自己不懂的事情。”</p><p>这个效应是由社会心理学家邓宁和克鲁格联合发现的，他们通过对人们阅读、驾驶、下棋或打网球等各种技能的研究发现： 在幽默感、文字能力和逻辑能力上最欠缺的那部分人总是高估自己，当他们实际得分只有12%时，却认为自己的得分在60%以上。</p><h2 id="认知失调"><a href="#认知失调" class="headerlink" title="认知失调"></a>认知失调</h2><p>谢博德博士在演讲中说了一个故事：2017年飓风哈维登陆美国得克萨斯州休斯顿市，3天之内降雨50英寸，整个城市都陷入了一片汪洋之中。</p><p>但在飓风登录前一周，谢博德博士就已经反复提醒休斯顿市民：根据观察，这次飓风到来可能会造成40到50英寸的降雨量。即便如此，市民们依然无所作为，并在一周后迎来了洪灾，造成了重大损失。为什么会这样？休斯顿当地虽然经常下雨，但之前全年的降雨量也才34英寸。谢博德博士所预言的“短时间内降雨40到50英寸”，已经超过了休斯顿市民能够理解的范围——几天之内就下完一整年的雨？这怎么可能！因为和自己过去的经验发生冲突，所以休斯顿市民说得最多的一句话就是：我看到了预警，但没想到真的会这么糟糕。</p><p>这就是谢博德博士说的“认知失调”：新信息与已有的信念相矛盾，无法理解现有经验外的事物的时候，会让人产生失调的感觉，这种感觉会驱使一个人去寻找合理化的解释，让自己的认知达到一致。休斯顿的市民就是这样，他们面对无法理解的新信息，就去找一个合理化的解释，觉得灾情不会那么糟糕，忽视科学家的警告，最后造成重大损失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;鞣酸&quot;&gt;&lt;a href=&quot;#鞣酸&quot; class=&quot;headerlink&quot; title=&quot;鞣酸&quot;&gt;&lt;/a&gt;鞣酸&lt;/h2&gt;&lt;p&gt;鞣酸系由五倍子中得到的一种鞣质。为黄色或淡棕色轻质无晶性粉末或鳞片；无臭，微有特殊气味，味极涩。溶于水及乙醇，易溶于甘油，几乎不溶于乙醚、氯
      
    
    </summary>
    
      <category term="日常记录" scheme="https://muhouer.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="名词" scheme="https://muhouer.github.io/tags/%E5%90%8D%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>如何优化缓存中百万级并发的key</title>
    <link href="https://muhouer.github.io/posts/2bc946e8/"/>
    <id>https://muhouer.github.io/posts/2bc946e8/</id>
    <published>2019-08-09T14:53:35.000Z</published>
    <updated>2019-08-09T15:15:30.491Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这个问题实际上就是热点key问题，其实热点key问题说来也很简单，就是瞬间有几十万上百万，甚至更大的请求去访问redis上某个固定的key，从而压垮缓存服务的情情况。<br>其实生活中也是有不少这样的例子，比如XX明星结婚。那么关于XX明星的Key就会瞬间增大，就会出现热点数据问题。</p><blockquote><p>PS:hot key和big key问题，大家一定要有所了解，非常重要。</p></blockquote><h2 id="热点Key问题"><a href="#热点Key问题" class="headerlink" title="热点Key问题"></a>热点Key问题</h2><p>上面提到，所谓热点key问题就是，突然有几十万甚至更大的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到Redis单实例瓶颈（一般是10W OPS级别），或者物理网卡上限，从而导致这台redis的服务器Hold不住。</p><p>那接下来这个key的请求，就会压垮你的服务。</p><h3 id="怎么发现热key"><a href="#怎么发现热key" class="headerlink" title="怎么发现热key"></a>怎么发现热key</h3><h4 id="方法一-凭借业务经验，进行预估哪些是热key"><a href="#方法一-凭借业务经验，进行预估哪些是热key" class="headerlink" title="方法一:凭借业务经验，进行预估哪些是热key"></a>方法一:凭借业务经验，进行预估哪些是热key</h4><p>其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。</p><h4 id="方法二-在客户端进行收集"><a href="#方法二-在客户端进行收集" class="headerlink" title="方法二:在客户端进行收集"></a>方法二:在客户端进行收集</h4><p>这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。</p><h4 id="方法三-在Proxy层做收集"><a href="#方法三-在Proxy层做收集" class="headerlink" title="方法三:在Proxy层做收集"></a>方法三:在Proxy层做收集</h4><p>有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。</p><p><img src="/images/201908091100.png" alt="upload successful"></p><h4 id="方法四-用redis自带命令"><a href="#方法四-用redis自带命令" class="headerlink" title="方法四:用redis自带命令"></a>方法四:用redis自带命令</h4><p>(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。</p><p>(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。</p><h4 id="方法五-自己抓包评估"><a href="#方法五-自己抓包评估" class="headerlink" title="方法五:自己抓包评估"></a>方法五:自己抓包评估</h4><p>Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。</p><p>以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>目前业内的方案有两种：</p><h3 id="二级缓存（推荐）"><a href="#二级缓存（推荐）" class="headerlink" title="二级缓存（推荐）"></a>二级缓存（推荐）</h3><p>比如利用ehcache，或者guava-cache，或者一个HashMap或者List都可以。在你发现热key以后，把热key加载到JVM中（可以是堆内，也可以是堆外）。针对这种热key请求，会直接从JVM中取，而不会走到redis层。</p><p>假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。现在假设，你的应用层有10台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有10000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。</p><h3 id="备份热点key"><a href="#备份热点key" class="headerlink" title="备份热点key"></a>备份热点key</h3><p>这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。<br>假设redis的集群数量为N，步骤如下图所示：<br><img src="/images/201908091101.png" alt="upload successful"></p><p>说明: 不一定是2N，你想取4N，8N都可以，看要求。伪代码如下:</p><p>说明：这种方案有一个很明显的缺点，就是缓存的维护代价非常大。假设有100个备份KEY，那么在删除或者更新时，也需要更新100个KEY，所以这种方案不是很推荐。<br>业内方案</p><p>OK，其实看完上面的内容，大家可能会有一个疑问。</p><h3 id="自动发信热点key，程序自动处理"><a href="#自动发信热点key，程序自动处理" class="headerlink" title="自动发信热点key，程序自动处理"></a>自动发信热点key，程序自动处理</h3><p>有办法在项目运行过程中，自动发现热点key，然后程序自动处理么？<br>嗯，好问题，那我们来讲讲业内怎么做的。其实只有两步：</p><ol><li>监控热点key</li><li>通知系统做处理</li></ol><p>正巧，前几天有赞出了一篇《有赞透明多级缓存解决方案（TMC）》，里头也有提到热点key问题，我们刚好借此说明。</p><p>(1) 监控热点key<br>在监控热点key方面，有赞用的是方式二：在客户端进行收集。</p><p>在<a href="https://segmentfault.com/a/1190000017142556?utm_source=tag-newest" target="_blank" rel="noopener">《有赞透明多级缓存解决方案（TMC）》</a>中有一句话提到</p><blockquote><p>TMC 对原生jedis包的JedisPool和Jedis类做了改造，在JedisPool初始化过程中集成TMC“热点发现”+“本地缓存”功能Hermes-SDK包的初始化逻辑。<br>也就说人家改写了jedis原生的jar包，加入了Hermes-SDK包。</p></blockquote><p>那Hermes-SDK包用来干嘛？OK，就是做热点发现和本地缓存。</p><p>从监控的角度看，该包对于Jedis-Client的每次key值访问请求，Hermes-SDK 都会通过其通信模块将key访问事件异步上报给Hermes服务端集群，以便其根据上报数据进行“热点探测”。</p><p>当然，这只是其中一种方式，有的公司在监控方面用的是方式五: 自己抓包评估。具体是这么做的，先利用flink搭建一套流式计算系统。然后自己写一个抓包程序抓redis监听端口的数据，抓到数据后往kafka里丢。</p><p>接下来，流式计算系统消费kafka里的数据，进行数据统计即可，也能达到监控热key的目的。</p><p>(2) 通知系统做处理<br>在这个角度，有赞用的是上面的解决方案一:利用二级缓存进行处理。<br>有赞在监控到热key后，Hermes服务端集群会通过各种手段通知各业务系统里的Hermes-SDK，告诉他们:”老弟，这个key是热key，记得做本地缓存。”</p><p>于是Hermes-SDK就会将该key缓存在本地，对于后面的请求。Hermes-SDK发现这个是一个热key，直接从本地中拿，而不会去访问集群。</p><p>除了这种通知方式以外。我们也可以这么做，比如你的流式计算系统监控到热key了，往zookeeper里头的某个节点里写。然后你的业务系统监听该节点，发现节点数据变化了，就代表发现热key。最后往本地缓存里写，也是可以的。</p><p>通知方式各种各样，大家可以自由发挥。本文只是提供一个思路。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望通过本文，大家明白如何处理生产上遇到的热key问题。</p><footer><strong>孤独烟</strong><cite><a href="https://mp.weixin.qq.com/s/cipWMjkBprbuRxZEb3a3vQ" target="_blank" rel="noopener">如何优化缓存中百万级并发的key</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;这个问题实际上就是热点key问题，其实热点key问题说来也很简单，就是瞬间有几十万上百万，甚至更大的请求去访问red
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Java时的一些坑</title>
    <link href="https://muhouer.github.io/posts/45d267df/"/>
    <id>https://muhouer.github.io/posts/45d267df/</id>
    <published>2019-08-09T14:27:00.000Z</published>
    <updated>2019-08-09T14:46:16.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Arrays-asList-存在的坑"><a href="#Arrays-asList-存在的坑" class="headerlink" title="Arrays.asList 存在的坑"></a>Arrays.asList 存在的坑</h3><p>阿里巴巴java开发规范说到使用工具类<code>Arrays.asList()</code>方法把数组转换成集合时，不能使用其修改集合相关的方法，它的<code>add</code>/<code>remove</code>/<code>clear</code>方法会抛出<code>UnsupportedOperationException</code>。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;F&quot;, &quot;r&quot;, &quot;e&quot;, &quot;y&quot;, &quot;a&quot;);</span><br><span class="line">//    list.clear();</span><br><span class="line">//    list.remove(&quot;a&quot;);</span><br><span class="line">      list.add(&quot;h&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上三个方法中任何一个都会报以下异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:148)</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:108)</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>点进去<code>Arrays.asList</code>，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SafeVarargs</span><br><span class="line">@SuppressWarnings(&quot;varargs&quot;)</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class="line">    return new ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>ArrayList</code> 并不是我们平时用的<code>ArrayList</code>。而是<code>Arrays</code>里面的一个内部类。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private static final long serialVersionUID = -2764017481108945198L;</span><br><span class="line">    private final E[] a;</span><br><span class="line"></span><br><span class="line">    ArrayList(E[] array) &#123;</span><br><span class="line">        a = Objects.requireNonNull(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return a.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object[] toArray() &#123;</span><br><span class="line">        return a.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        int size = size();</span><br><span class="line">        if (a.length &lt; size)</span><br><span class="line">            return Arrays.copyOf(this.a, size,</span><br><span class="line">                                 (Class&lt;? extends T[]&gt;) a.getClass());</span><br><span class="line">        System.arraycopy(this.a, 0, a, 0, size);</span><br><span class="line">        if (a.length &gt; size)</span><br><span class="line">            a[size] = null;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        return a[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E set(int index, E element) &#123;</span><br><span class="line">        E oldValue = a[index];</span><br><span class="line">        a[index] = element;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        E[] a = this.a;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; a.length; i++)</span><br><span class="line">                if (a[i] == null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; a.length; i++)</span><br><span class="line">                if (o.equals(a[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return indexOf(o) != -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliterator(a, Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void forEach(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        for (E e : a) &#123;</span><br><span class="line">            action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        E[] a = this.a;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = operator.apply(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">        Arrays.sort(a, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个内部类没有<code>add</code>，<code>clear</code>，<code>remove</code>方法，所以抛出的异常其实来自于<code>AbstractList</code>。点进去就会发现抛出异常的地方，clear底层也会调用到remove所以也会抛出异常。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h4><p><code>Arrays.asList()</code>底层其实还是数组。如果使用了<code>Arrays.asList()</code>的话，最好不要使用其集合的操作方法。如果想要使用，<code>List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;F&quot;, &quot;r&quot;, &quot;e&quot;, &quot;y&quot;, &quot;a&quot;))</code>可以在外面这样包一层真正的ArrayList。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Arrays-asList-存在的坑&quot;&gt;&lt;a href=&quot;#Arrays-asList-存在的坑&quot; class=&quot;headerlink&quot; title=&quot;Arrays.asList 存在的坑&quot;&gt;&lt;/a&gt;Arrays.asList 存在的坑&lt;/h3&gt;&lt;p&gt;阿里巴巴ja
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>一些金融概念</title>
    <link href="https://muhouer.github.io/posts/6b8c9691/"/>
    <id>https://muhouer.github.io/posts/6b8c9691/</id>
    <published>2019-08-09T14:11:00.000Z</published>
    <updated>2019-08-11T04:36:38.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Q-什么是戴维斯双击和戴维斯双杀？"><a href="#Q-什么是戴维斯双击和戴维斯双杀？" class="headerlink" title="Q: 什么是戴维斯双击和戴维斯双杀？"></a>Q: 什么是戴维斯双击和戴维斯双杀？</h3><ol><li>戴维斯双击: 在景气周期里，上市公司的业绩和估值同步上升。</li><li>戴维斯双杀: 在不景气周期里，上市公司的业绩和估值同步下降。</li></ol><h3 id="Q-什么是LOF基金？"><a href="#Q-什么是LOF基金？" class="headerlink" title="Q: 什么是LOF基金？"></a>Q: 什么是LOF基金？</h3><p>LOF基金（Listed Open-Ended Fund），也称为“上市型开放式基金”。投资者既可以通过一级市场开放式基金账户申购与赎回基金份额，也可以在证券交易所二级市场买卖基金。不过，投资者如果是通过一级市场开放式基金账户申购的基金份额，想要在交易所二级市场卖出，则须办理转托管手续；同样，如果是在交易所二级市场买进的基金份额，想要在一级市场赎回，也要办理转托管手续。</p><h3 id="Q-关于熊市大跌"><a href="#Q-关于熊市大跌" class="headerlink" title="Q: 关于熊市大跌"></a>Q: 关于熊市大跌</h3><p>“在过去70多年历史上发生的40次股市暴跌中，即使其中39次我提前预测到，而且在暴跌前卖掉了所有的股票，我最后也会后悔万分的。因为即使是跌幅最大的那次股灾，股价最终也涨回来了，而且涨得更高。”——基金经理，彼得林奇</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Q-什么是戴维斯双击和戴维斯双杀？&quot;&gt;&lt;a href=&quot;#Q-什么是戴维斯双击和戴维斯双杀？&quot; class=&quot;headerlink&quot; title=&quot;Q: 什么是戴维斯双击和戴维斯双杀？&quot;&gt;&lt;/a&gt;Q: 什么是戴维斯双击和戴维斯双杀？&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;戴维斯
      
    
    </summary>
    
      <category term="理财" scheme="https://muhouer.github.io/categories/%E7%90%86%E8%B4%A2/"/>
    
    
      <category term="金融概念" scheme="https://muhouer.github.io/tags/%E9%87%91%E8%9E%8D%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>拾句系列</title>
    <link href="https://muhouer.github.io/posts/53e650a7/"/>
    <id>https://muhouer.github.io/posts/53e650a7/</id>
    <published>2019-08-09T14:02:00.000Z</published>
    <updated>2019-08-09T14:09:30.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拾句系列1"><a href="#拾句系列1" class="headerlink" title="拾句系列1"></a>拾句系列1</h2><p>拾句系列主要记录平常生活和工作中遇到的一些句子，当时有点感触，特此记录一下。记录还会继续，不过，随着时间的流逝，可能也会删除一部分或做一些修改。</p><ol><li><a href="/posts/922764cc/" title="拾句-惊艳">拾句-惊艳</a></li><li><a href="/posts/497a5083/" title="拾句-爱">拾句-爱</a></li><li><a href="/posts/60ae6d78/" title="拾句-丧">拾句-丧</a></li><li><a href="/posts/4be8e193/" title="拾句-开解自己">拾句-开解自己</a></li><li><a href="/posts/70b9f430/" title="拾句-乐评">拾句-乐评</a></li><li><a href="/posts/a9bf165e/" title="拾句-现实">拾句-现实</a></li><li><a href="/posts/ef52fadf/" title="拾句-思考">拾句-思考</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;拾句系列1&quot;&gt;&lt;a href=&quot;#拾句系列1&quot; class=&quot;headerlink&quot; title=&quot;拾句系列1&quot;&gt;&lt;/a&gt;拾句系列1&lt;/h2&gt;&lt;p&gt;拾句系列主要记录平常生活和工作中遇到的一些句子，当时有点感触，特此记录一下。记录还会继续，不过，随着时间的流逝，可能
      
    
    </summary>
    
      <category term="拾句" scheme="https://muhouer.github.io/categories/%E6%8B%BE%E5%8F%A5/"/>
    
    
      <category term="汇总" scheme="https://muhouer.github.io/tags/%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Muhouer</title>
  
  <subtitle>开始记录只需5分钟!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muhouer.github.io/"/>
  <updated>2019-09-09T15:50:16.015Z</updated>
  <id>https://muhouer.github.io/</id>
  
  <author>
    <name>Muhouer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人类愚蠢辞典</title>
    <link href="https://muhouer.github.io/posts/c6491e95/"/>
    <id>https://muhouer.github.io/posts/c6491e95/</id>
    <published>2019-09-08T15:28:00.000Z</published>
    <updated>2019-09-09T15:50:16.015Z</updated>
    
    <content type="html"><![CDATA[<ol><li>习惯的力量与其愚蠢度成正比。我们在个人与社会生活中，总会用同样的方式思考以及做同样的事。</li><li>对于银行来说，25% 就已经是高利贷的标准了。而一些酒吧、饭店来说，它们宣称出于对”卫生问题“的重视不提供直饮水，转而以高达10倍价格向它们愚蠢的顾客推销瓶装水。</li><li>人类的不忠行为远比我们愚蠢地自认为的要多。实际上，男性会偏向于夸大性伴侣的数量，而女性则会倾向于隐藏。不忠行为是对反自然的一夫一妻制进行的自然修正过程。</li><li>往生世界，相信死后我们会有跟活着时一样的烦恼。</li><li>”保护地球“是很愚蠢的：充其量是我们自己有点儿危险罢了。早在25亿年前，光合作用就已经对地球环境的构成造成了更甚于今日的剧烈变化，即所谓的”大氧化事件“。然而，我们地球通过一项调整成功挽救了自己：消灭厌氧生物，并养育需氧生物，也就是人类本身。</li><li>通常，人们愚蠢地认为爱动物就是喜欢小猫小狗，不忍观看斗牛或海豹被屠杀的画面。极少人意识到，真正的问题存在于动物被用于饮食和实验造成的权益侵害。</li><li>愚蠢的种族主义者虽然目标常常变化，但本质永远是不变的。</li><li>斯特金定律：90%的东西都是无意义的废物。</li><li>愚蠢的人有两种截然相反的行事方式，却总能殊途同归，制造麻烦。要么让那些明智的人生活难以为继，无法施展抱负；要么为害群之马铺平道路，帮助他们达成危害大业。</li><li>同样的习惯，于自身都很正常，到了别人那里就怎么看怎么别扭。</li><li>我们愚蠢无知的程度，恰如我们自以为的智慧狡黠一般。</li><li>在任意一群人里，蠢人的比例是固定的，即使是在诺贝尔奖获得者中。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;&lt;li&gt;习惯的力量与其愚蠢度成正比。我们在个人与社会生活中，总会用同样的方式思考以及做同样的事。&lt;/li&gt;&lt;li&gt;对于银行来说，25% 就已经是高利贷的标准了。而一些酒吧、饭店来说，它们宣称出于对”卫生问题“的重视不提供直饮水，转而以高达10倍价格向它们愚蠢的顾客推销瓶装
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://muhouer.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="愚蠢" scheme="https://muhouer.github.io/tags/%E6%84%9A%E8%A0%A2/"/>
    
  </entry>
  
  <entry>
    <title>JavaBean</title>
    <link href="https://muhouer.github.io/posts/207a79f8/"/>
    <id>https://muhouer.github.io/posts/207a79f8/</id>
    <published>2019-09-08T01:15:24.000Z</published>
    <updated>2019-09-08T01:17:59.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaBean-定义"><a href="#JavaBean-定义" class="headerlink" title="JavaBean 定义"></a>JavaBean 定义</h2><p>在 Java 中，有很多<code>class</code>的定义都符合这样的规范：</p><ul><li>若干<code>private</code>实例字段；</li><li>通过<code>public</code>方法来读写实例字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果读写方法符合以下这种命名规范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">getXyz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXyz</span><span class="params">(Type value)</span></span></span><br></pre></td></tr></table></figure><p>那么这种<code>class</code>被称为<code>JavaBean</code></p><p>JavaBean 是一种 Java 语言写成的可重用组件。为写成 JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性。众所周知，属性名称符合这种模式，其他 Java 类可以通过自身机制发现和操作这些 JavaBean 的属性。</p><p>JavaBean 更多的是一种规范，即包含一组 set 和 get 方法的 Java 对象。JavaBean 主要用来传递数据，即把一组数据组合成一个 JavaBean 便于传输。</p><h2 id="枚举-JavaBean-属性"><a href="#枚举-JavaBean-属性" class="headerlink" title="枚举 JavaBean 属性"></a>枚举 JavaBean 属性</h2><p><strong>内省(Introspector) 是 Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。</strong></p><p>调用 <code>Introspector.getBeanInfo()</code> 方法，得到的 BeanInfo 对象封装了把这个类当做 JavaBean 看的结果信息，即属性的信息。调用 <code>BeanInfo</code> 的 <code>getPropertyDescriptors()</code>，可以获得属性的描述，可以采用遍历 BeanInfo 的方法，来查找、设置类的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntrospectorTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    BeanInfo info = Introspector.getBeanInfo(Person.class);</span><br><span class="line">    <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pd.getName().equals(<span class="string">"name"</span>))&#123;</span><br><span class="line">        Method methodSetName = pd.getWriteMethod();</span><br><span class="line">        methodSetName.invoke(person, <span class="string">"Freya"</span>);</span><br><span class="line">        Method methodGetName = pd.getReadMethod();</span><br><span class="line">        System.out.println(methodGetName.invoke(person, <span class="keyword">null</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内省操作非常的繁琐，所以 Apache 开发了一套简单、易用的API来操作 Bean 的属性——<a href="http://commons.apache.org/beanutils/" target="_blank" rel="noopener">BeanUtils工具包</a>。</p><blockquote><p>注意：应用的时候还需要一个 <a href="http://commons.apache.org/logging/" target="_blank" rel="noopener">logging包</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/commons-beanutils/commons-beanutils --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用 BeanUtils 示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Person person = <span class="keyword">new</span> Person();</span><br><span class="line">  BeanUtils.setProperty(person, <span class="string">"name"</span>, <span class="string">"Freya"</span>);</span><br><span class="line">  BeanUtils.setProperty(person, <span class="string">"age"</span>, <span class="number">17</span>);</span><br><span class="line">  BeanUtils.setProperty(person, <span class="string">"id"</span>, <span class="number">1011</span>);</span><br><span class="line">  System.out.println(BeanUtils.getProperty(person, <span class="string">"name"</span>));</span><br><span class="line">  System.out.println(<span class="string">"get name type:"</span> + BeanUtils.getProperty(person, <span class="string">"name"</span>).getClass().getName());</span><br><span class="line">  System.out.println(BeanUtils.getProperty(person, <span class="string">"age"</span>));</span><br><span class="line">  System.out.println(<span class="string">"get age type:"</span> + BeanUtils.getProperty(person, <span class="string">"age"</span>).getClass().getName()); <span class="comment">// get age type:java.lang.String</span></span><br><span class="line">  System.out.println(<span class="string">"get age type:"</span> + PropertyUtils.getProperty(person, <span class="string">"age"</span>).getClass().getName()); <span class="comment">// get age type:java.lang.Integer</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设置属性的值，例如，BeanUtils.setProperty(person, “age”, 8)，参数是字符串或基本类型自动包装。设置属性的值是字符串，获得的值也是字符串，不是基本类型。</p><p>PropertyUtils 类和 BeanUtils 不同在于，运行 getProperty、setProperty 操作时，没有类型转换，使用属性的原有类型或者包装类。</p></blockquote><h2 id="VO、DTO、POJO、DTO、BO的区别"><a href="#VO、DTO、POJO、DTO、BO的区别" class="headerlink" title="VO、DTO、POJO、DTO、BO的区别"></a>VO、DTO、POJO、DTO、BO的区别</h2><h3 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h3><p>value object值对象，主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象。然后用一个 VO 对象在控制层与视图层进行传输交换。</p><h3 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h3><p>Data Transfer Object 数据传输对象，经过处理后的PO，可能增加或者减少PO的属性。主要用于远程调用等需要大量传输对象的地方。比如我们一张表有100个字段，那么对应的 PO 就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</p><h3 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h3><p>Plain Ordinary Java Object，是一个简单的普通的Java对象。简单 Java 对象是一种概念或者接口，身份及作用随环境变化而变化。POJO 有一些private的参数作为对象的属性。然后针对每个参数定义了get和set方法作为访问的接口。它不包含业务逻辑或持久逻辑等，但不是JavaBean、EntityBean等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。POJO对象有时也被称为Data对象，大量应用于表现现实中的对象。<br>一个POJO持久化以后就是PO。直接用它传递、传递过程中就是DTO。直接用来对应表示层就是VO。</p><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>PO持久化到数据库是要进行相关的数据库操作的(CRUQ)，这些对数据库操作的方法会统一放到一个 Java 对象中，这就是DAO。</p><h3 id="BO"><a href="#BO" class="headerlink" title="BO"></a>BO</h3><p>POJO在业务层的体现，对于业务操作来说，更多的是从业务上来包装对象，如一个User的BO，可能包括name, age, sex, privilege, group等，这些属性在数据库中可能会在多张表中，因为每一张表对应一个PO，而我们的BO需要这些PO组合起来(或说重新拼装)才能成为业务上的一个完整对象。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>POJO仅包含最简单的字段属性，没有多余的东西，它本质上就是一个普通的 JavaBean。但是在POJO的基础上，能够扩展出不同的对象。</p><ol><li>为 POJO 增加了持久化的方法（Insert、Update、Delete……）之后，POJO 就变成了 PO。</li><li>为 POJO 增加了数据绑定功能之后，POJO 就变成了 View Object，即UI Model。</li><li>为 POJO 增加业务逻辑的方法（比如单据审核、转帐……）之后，POJO就变成了Domain Model。</li><li>POJO 还可以当作 DTO 使用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaBean-定义&quot;&gt;&lt;a href=&quot;#JavaBean-定义&quot; class=&quot;headerlink&quot; title=&quot;JavaBean 定义&quot;&gt;&lt;/a&gt;JavaBean 定义&lt;/h2&gt;&lt;p&gt;在 Java 中，有很多&lt;code&gt;class&lt;/code&gt;的定义都
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java常用工具类</title>
    <link href="https://muhouer.github.io/posts/8b50b566/"/>
    <id>https://muhouer.github.io/posts/8b50b566/</id>
    <published>2019-09-08T01:08:00.000Z</published>
    <updated>2019-09-08T01:08:31.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK-自带"><a href="#JDK-自带" class="headerlink" title="JDK 自带"></a>JDK 自带</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p><p>求绝对值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(-<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">Math.abs(-<span class="number">2.2</span>); <span class="comment">// 2.2</span></span><br></pre></td></tr></table></figure><p>取最大或最小值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max(100, 101); // 101</span><br><span class="line">Math.min(1.2, 3.1); // 1.2</span><br></pre></td></tr></table></figure><p>计算x^y次方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure><p>计算√x：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.4142135623730951</span></span><br></pre></td></tr></table></figure><p>计算指数与对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.38905609893065</span></span><br><span class="line">Math.log(<span class="number">2</span>); <span class="comment">// 以 e 为底的对数 0.6931471805599453</span></span><br><span class="line">Math.log10(<span class="number">2</span>); <span class="comment">// 以 10 为底的对数 0.3010299956639812</span></span><br></pre></td></tr></table></figure><p>三角函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br></pre></td></tr></table></figure><p>Math还提供了几个数学常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">// 2.7182818...</span></span><br></pre></td></tr></table></figure><p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure><p>Java 标准库还提供了一个 <code>StrictMath</code>，它提供了和 <code>Math</code> 几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，<code>StrictMath</code> 保证所有平台计算结果都是完全相同的，而 <code>Math</code> 会尽量针对平台优化计算速度，所以，绝大多数情况下，使用 <code>Math</code> 就足够了。</p><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p><p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">r.nextInt(); <span class="comment">// 245439114,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 9,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// -485876652878521410,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.6454043,生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.44460046556701727,生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure><p>创建 <code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。如果我们在创建 <code>Random</code> 实例时指定一个种子，就会得到完全确定的随机数序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random(<span class="number">12345</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   System.out.println(r.nextInt(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    51</span></span><br><span class="line"><span class="comment">//    80</span></span><br><span class="line"><span class="comment">//    41</span></span><br><span class="line"><span class="comment">//    28</span></span><br><span class="line"><span class="comment">//    55</span></span><br><span class="line"><span class="comment">//    84</span></span><br><span class="line"><span class="comment">//    75</span></span><br><span class="line"><span class="comment">//    2</span></span><br><span class="line"><span class="comment">//    1</span></span><br><span class="line"><span class="comment">//    89</span></span><br></pre></td></tr></table></figure><p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code> 无法指定种子，它使用RNG（random number generator）算法。JDK的 <code>SecureRandom</code> 实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SecureRandom sr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      sr = SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">      sr = <span class="keyword">new</span> SecureRandom(); <span class="comment">// 获取普通的安全随机数生成器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">    sr.nextBytes(buffer); <span class="comment">// 用安全随机数填充buffer</span></span><br><span class="line">    System.out.println(Arrays.toString(buffer));</span><br><span class="line">    System.out.println(sr.nextInt());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code> 的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p><p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用 <code>SecureRandom</code> 来产生安全的随机数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK-自带&quot;&gt;&lt;a href=&quot;#JDK-自带&quot; class=&quot;headerlink&quot; title=&quot;JDK 自带&quot;&gt;&lt;/a&gt;JDK 自带&lt;/h2&gt;&lt;h3 id=&quot;Math&quot;&gt;&lt;a href=&quot;#Math&quot; class=&quot;headerlink&quot; title=&quot;M
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="常用工具类" scheme="https://muhouer.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java中大数表示</title>
    <link href="https://muhouer.github.io/posts/d9f6149f/"/>
    <id>https://muhouer.github.io/posts/d9f6149f/</id>
    <published>2019-09-08T00:39:30.000Z</published>
    <updated>2019-09-08T00:40:19.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>在 Java 中，由 CPU 原生提供的整型最大范围是 64 位 <code>long</code> 型整数。使用 <code>long</code> 型整数可以直接通过 CPU 指令进行计算，速度非常快。如果我们使用的整数范围超过了 <code>long</code> 型就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code> 就是用来表示任意大小的整数。<code>BigInteger</code> 内部用一个 <code>int[]</code> 数组来模拟一个非常大的整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure><p>使用 BigInteger` 做运算的时候，只能使用实例方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i1 = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);</span><br><span class="line">BigInteger i2 = <span class="keyword">new</span> BigInteger(<span class="string">"12345678901234567890"</span>);</span><br><span class="line">BigInteger sum = i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure><p>和 <code>long</code> 型整数运算比，<code>BigInteger</code> 不会有范围限制，但缺点是速度比较慢。也可以把 <code>BigInteger</code> 转换成 <code>long</code> 型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i = <span class="keyword">new</span> BigInteger(<span class="string">"123456789000"</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure><p>使用 <code>longValueExact()</code> 方法时，如果超出了 <code>long</code> 型的范围，会抛出 <code>ArithmeticException</code>。</p><p><code>BigInteger</code> 和 <code>Integer</code>、<code>Long</code> 一样，也是不可变类，并且也继承自 <code>Number</code> 类。因为 <code>Number</code> 定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>因此，通过上述方法，可以把 <code>BigInteger</code> 转换成基本类型。<strong>如果 <code>BigInteger</code> 表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</strong></p><p>如果 <code>BigInteger</code> 的值甚至超过了<code>float</code>的最大范围（3.4x1038），那么返回的float是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BigInteger n = <span class="keyword">new</span> BigInteger(<span class="string">"999999"</span>).pow(<span class="number">99</span>);</span><br><span class="line">    <span class="keyword">float</span> f = n.floatValue();</span><br><span class="line">    System.out.println(f); <span class="comment">// Infinity</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>和 <code>BigInteger</code> 类似，<code>BigDecimal</code> 可以表示一个任意大小且精度完全准确的浮点数，常用于财务计算。如果查看 <code>BigDecimal</code> 的源码，可以发现，实际上一个 <code>BigDecimal</code> 是通过一个 <code>BigInteger</code> 和一个 <code>scale</code> 来表示的，即 <code>BigInteger</code> 表示一个完整的整数，而 <code>scale</code> 表示小数位数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimal</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code> 也是从 <code>Number</code> 继承的，也是不可变对象。</p><p>通过 <code>BigDecimal</code> 的 <code>stripTrailingZeros()</code> 方法，可以将一个 <code>BigDecimal</code> 格式化为一个相等的，但去掉了末尾0的 <code>BigDecimal</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.4500"</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">"1234500"</span>);</span><br><span class="line">BigDecimal d4 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><p>如果一个 <code>BigDecimal</code> 的 <code>scale()</code> 返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个 <code>BigDecimal</code> 设置它的 <code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456789"</span>);</span><br><span class="line">        BigDecimal d2 = d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">        BigDecimal d3 = d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456"</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">"23.456789"</span>);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br></pre></td></tr></table></figure><p>在比较两个 <code>BigDecimal</code> 的值是否相等时，要特别注意，使用 <code>equals()</code> 方法不但要求两个 <code>BigDecimal</code> 的值相等，还要求它们的 <code>scale()</code> 相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456"</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.45600"</span>);</span><br><span class="line">System.out.println(d1.equals(d2)); <span class="comment">// false,因为scale不同</span></span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="comment">// true,因为d2去除尾部0后scale变为2</span></span><br><span class="line">System.out.println(d1.compareTo(d2)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>必须使用 <code>compareTo()</code> 方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BigInteger&quot;&gt;&lt;a href=&quot;#BigInteger&quot; class=&quot;headerlink&quot; title=&quot;BigInteger&quot;&gt;&lt;/a&gt;BigInteger&lt;/h2&gt;&lt;p&gt;在 Java 中，由 CPU 原生提供的整型最大范围是 64 位 &lt;code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="https://muhouer.github.io/posts/4522df16/"/>
    <id>https://muhouer.github.io/posts/4522df16/</id>
    <published>2019-09-07T07:25:00.000Z</published>
    <updated>2019-09-08T01:13:41.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><blockquote><p>序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。恰当的序列化协议不仅可以提高系统的通用性、强健性、安全性、优化系统性能，而且会让系统更加易于调试、便于扩展。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li><strong>序列化：将数据结构或对象转换成二进制串的过程，在 Java 中对应把对象转换为字节序列的过程。</strong></li><li><strong>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程，在 Java 中对应把字节序列恢复为对象的过程。</strong></li></ol><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li><p>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。</p></li><li><p>在网络上传送对象的字节序列。</p></li></ol><h2 id="JDK-类库中的序列化API"><a href="#JDK-类库中的序列化API" class="headerlink" title="JDK 类库中的序列化API"></a>JDK 类库中的序列化API</h2><blockquote><ol><li><p>在序列化过程中，如果被序列化的类中定义了 writeObject() 和 readObject() 方法，虚拟机会试图调用对象类里的 writeObject() 和 readObject() 方法，进行用户自定义的序列化和反序列化。如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject() 方法以及 ObjectInputStream 的 defaultReadObject() 方法。</p></li><li><p>用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。</p></li></ol></blockquote><p><code>ObjectOutputStream</code> 代表对象输出流，它的 <code>writeObject(Object obj)</code> 方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p><code>ObjectInputStream</code> 代表对象输入流，它的 <code>readObject()</code> 方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</p><p>只有实现了 <code>Serializable</code> 和 <code>Externalizable</code> 接口的类的对象才能被序列化。<code>Externalizable</code> 接口继承自 <code>Serializable</code> 接口，实现 <code>Externalizable</code> 接口的类完全由自身来控制序列化的行为，而仅实现 <code>Serializable</code> 接口的类可以采用默认的序列化方式 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><strong>对象序列化步骤</strong></p><ol><li>创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；</li><li>通过对象输出流的writeObject()方法写对象。</li></ol><p><strong>对象反序列化步骤</strong></p><ol><li>创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；</li><li>通过对象输入流的readObject()方法读取对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Initializes The Object</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"Freya"</span>);</span><br><span class="line">        user.setAge(<span class="number">17</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Write Obj to File</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>));</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(oos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Read Obj from File</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">            User newUser = (User) ois.readObject();</span><br><span class="line">            System.out.println(newUser);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(ois);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileUtils.forceDelete(file);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化版本号"><a href="#序列化版本号" class="headerlink" title="序列化版本号"></a>序列化版本号</h3><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量 <code>serialVersionUID</code>。<code>serialVersionUID</code> 的取值是 Java 运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的 <code>serialVersionUID</code> 的取值有可能也会发生变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID</span><br></pre></td></tr></table></figure><p>如果没有指定类的 <code>serialVersionUID</code>，Java 编译器会自动给这个 class 进行一个摘要算法，类似于指纹算法，只要这个文件多一个空格，得到的 <code>serialVersionUID</code> 就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个字段后，由于没有显指定 <code>serialVersionUID</code>，编译器又为我们生成了一个 <code>serialVersionUID</code>，当然和前面保存在文件中的那个不会一样了，于是就会出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了 <code>serialVersionUID</code>，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原。</p><p>类的 <code>serialVersionUID</code> 的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。<strong>为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值</strong>。</p><p>显式地定义serialVersionUID有两种用途：</p><ol><li><p>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的 <code>serialVersionUID</code>；</p></li><li><p>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的 <code>serialVersionUID</code>。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p><code>Serializable</code> 只是一个接口，本身没有任何实现。如果一个类想被序列化，需要实现Serializable接口。否则将抛出<code>NotSerializableException</code>异常。因为在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum、String和Serializable类型其中的任何一种。(当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。)</p></li><li><p>对象的反序列化并没有调用对象的任何构造方法。序列化时，只对对象的状态进行保存，而不管对象的方法。</p></li><li><p>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化。</p></li><li><p>并非所有的对象都可以序列化，比如：</p><ul><li>安全方面的原因，比如一个对象拥有 private，public 等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</li><li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</li></ul></li><li><p>serialVersionUID 是用于记录文件版本信息的，最好能够自定义。否则，系统会自动生成 serialVersionUID，文件或者对象的任何改变，都会改变 serialVersionUID，导致反序列化的失败，如果自定义就没有这个问题</p></li><li><p>声明为 <code>static</code> 和 <code>transient</code> 类型的成员数据不能被序列化。因为 <code>static</code> 代表类的状态，<code>transient</code> 代表对象的临时数据。</p></li><li><p><code>Serializable</code> 的系统实现是采用 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 实现的，调用 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 时，需要对应的类实现 <code>Serializable</code> 接口。</p></li><li><p>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p></li><li><p>Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。反序列化时，恢复引用关系。该存储规则极大的节省了存储空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>));</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//试图将对象两次写入文件</span></span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.flush();</span><br><span class="line">System.out.println(<span class="keyword">new</span> File(<span class="string">"tempFile"</span>).length());</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line">System.out.println(<span class="keyword">new</span> File(<span class="string">"tempFile"</span>).length());</span><br><span class="line"></span><br><span class="line">ObjectInputStream oin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"tempFile"</span>));</span><br><span class="line"><span class="comment">//从文件依次读出两个文件</span></span><br><span class="line">User t1 = (User) oin.readObject();</span><br><span class="line">User t2 = (User) oin.readObject();</span><br><span class="line">oin.close();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//判断两个引用是否指向同一个对象</span></span><br><span class="line">System.out.println(t1 == t2);</span><br></pre></td></tr></table></figure></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="序列化与单例模式"><a href="#序列化与单例模式" class="headerlink" title="序列化与单例模式"></a>序列化与单例模式</h3><h4 id="序列化对单例的破坏"><a href="#序列化对单例的破坏" class="headerlink" title="序列化对单例的破坏"></a>序列化对单例的破坏</h4><p>使用反射可以破坏单例模式，除了反射以外，使用序列化与反序列化也同样会破坏单例。</p><p>单例示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试序列化对单例模式的破坏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonSerializableTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Write Obj to file</span></span><br><span class="line">    <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>))) &#123;</span><br><span class="line">      oos.writeObject(Singleton.getSingleton());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Read Obj from file</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">    Singleton newInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file))) &#123;</span><br><span class="line">      newInstance = (Singleton) ois.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == newInstance) &#123;</span><br><span class="line">        System.out.println(<span class="string">"newInstance is null"</span>); <span class="comment">// 不打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是同一个对象</span></span><br><span class="line">    System.out.println(Singleton.getSingleton() == newInstance); <span class="comment">// false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过对 Singleton 的序列化与反序列化得到的对象是一个新的对象，这就破坏了 Singleton 的单例性。这是因为序列化会通过反射调用无参数的构造方法创建一个新的对象。</strong></p><h4 id="防止序列化破坏单例模式"><a href="#防止序列化破坏单例模式" class="headerlink" title="防止序列化破坏单例模式"></a>防止序列化破坏单例模式</h4><p>在 Singleton 类中定义 <code>readResolve</code> 就可以解决该问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Singleton 类中定义 <code>readResolve</code> 可以防止序列化破坏单例模式，实现如下：</p><ol><li><code>ObjectOutputStream</code> 的 <code>writeObject()</code> 调用 <code>writeObject0()</code>，<code>writeObject0()</code> 里会调用 <code>writeOrdinaryObject()</code>。</li><li>在 <code>writeOrdinaryObject()</code> 中会通过 <code>hasReadResolveMethod</code> 进行判断，如果实现了Serializable 或者 Externalizable 接口的类中包含 <code>readResolve</code> 则返回 true。从而调用 <code>invokeReadResolve</code>，通过反射的方式调用要被反序列化的类的 <code>readResolve()</code> 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="keyword">null</span> </span><br><span class="line">    &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">    <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">        rep = cloneArray(rep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">        handles.setObject(passHandle, obj = rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化与对象的深拷贝"><a href="#序列化与对象的深拷贝" class="headerlink" title="序列化与对象的深拷贝"></a>序列化与对象的深拷贝</h3><p>实现对象的深拷贝有以下几种方法：</p><ol><li>实现 Clonable 接口，重写 clone() 方法，这种方法没有通用性，优点在于实现简单，并且可以实现定制化。</li><li>基于反射，BeanUtil、Spring 核心包提供的一个工具类，基本原理就是获取 class 实例化，再通过反射实现对象的深拷贝。</li><li>基于Serialize、Deserialize 实现，这种办法比较多，本质上和反射类似，反射相当于 JVM 提供，而 Serialize 是基于上层协议。具体实现可以参考 RMI、thrift、protobuf 序列化方式。</li><li>基于 Unsafe 内存，这种方法极不推荐使用，直接复制对象内存空间，容易造成内存泄露。</li></ol><p>在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">    T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//写入字节流</span></span><br><span class="line">      ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">      ObjectOutputStream obs = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">      obs.writeObject(obj);</span><br><span class="line">      obs.close();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//分配内存，写入原始对象，生成新对象</span></span><br><span class="line">      ByteArrayInputStream ios = <span class="keyword">new</span> ByteArrayInputStream(out.toByteArray());</span><br><span class="line">      ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(ios);</span><br><span class="line">      <span class="comment">//返回生成的新对象</span></span><br><span class="line">      cloneObj = (T) ois.readObject();</span><br><span class="line">      ois.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也可以使用 Apache 推出的 SerializationUtils 序列化工具类</p><h4 id="SerializationUtils-功能"><a href="#SerializationUtils-功能" class="headerlink" title="SerializationUtils 功能"></a>SerializationUtils 功能</h4><ul><li>使用序列化进行深度克隆</li><li>序列化对象</li><li>反序列化对象</li></ul><h4 id="SerializationUtils-优缺点"><a href="#SerializationUtils-优缺点" class="headerlink" title="SerializationUtils  优缺点"></a>SerializationUtils 优缺点</h4><ul><li>深度拷贝实现比较简单，不用实现Cloneable接口。</li><li>深度拷贝<strong>效率不如实现Cloneable接口高</strong>。</li><li>序列化和反序列化，是基于jdk自带的序列化，速度慢，占空间。效率不如Protostuff、Hessian、Kryo等专业序列化工具高。</li></ul><p>更深入的序列化知识可以参考: <a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html" target="_blank" rel="noopener">序列化和反序列化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序列化和反序列化&quot;&gt;&lt;a href=&quot;#序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化和反序列化&quot;&gt;&lt;/a&gt;序列化和反序列化&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="序列化" scheme="https://muhouer.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>演化杂记</title>
    <link href="https://muhouer.github.io/posts/4b4e75fa/"/>
    <id>https://muhouer.github.io/posts/4b4e75fa/</id>
    <published>2019-09-03T16:50:36.000Z</published>
    <updated>2019-09-03T16:56:25.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为什么现在的孩子越来越高、越来越胖？<br>为什么青少年糖尿病越来越多、发病年龄越来越小？<br>为什么越来越多的现代人患上了哮喘、过敏性鼻炎以及五花八门的食物过敏？<br>种种“现代疾病”背后是否有个共同的“罪魁祸首”？</p><p>美国著名科学家马丁布莱泽认为，在过去的几十年里，由于滥用抗生素及剖宫产，我们在不经意间已经伤害了与人类协同演化了数十万年之久的“微生物朋友”，特别是在我们的孩子们身上。这扰乱了人体内微生物的稳态，打破了人体与微生物之间的平衡，进而危害了我们孩子的代谢、免疫和认知能力。</p><footer><strong>微生物</strong></footer></blockquote><hr><blockquote><p>所谓碳基，其实是碳氮合体，碳四氮五氧六氢一，勾结出的一类扭曲生命，柔弱而多愁善感，利用电子结合化学能繁衍生息，能量利用总量低而熵效率高，因此能一直默默不查的偷生于宇宙中而繁衍数十亿年。碳基生命需要用氧氢化合物为催化剂，所以在宇宙背景温度到373k以下时才有萌芽可能，之前没有碳基生命存在。</p><p>地球上的碳基生命经过数亿年进化，于西元1900年发现光电效应，并进一步开发出硅基光电板，由此接触到硅基生命能量模式。硅基生命为镓锗合体，以硅氧为催化剂，利用光电效应直接产生能量繁衍生息。硅基以光传导能量进行代谢，低端硅基生命身体透明，有智能的高级硅基生命布满光纤，以硅氧熔沸点预测，在宇宙背景温度到2500k以下时才有萌芽可能，之前没有硅基生命存在。</p><p>碳基生命西元1945年第一次核爆敲开了铁基生命的大门。铁基以核能为驱动，生命温度在铁沸点以上，以气态和离子态存在，可以说在第一个铁元素诞生的时候就有了铁基生命，铁基生命能量利用巨大，一个低端铁基生命每秒耗费的能量相当于一个广岛原子弹。铁基生命是宇宙中最耀眼的生命，信息以量子纠缠传递，可以轻易实现虫洞在星系间穿梭，是最适合宇宙级生存的生命。</p><p>以能量产生和消耗方式来看，硅基生命不过是在食用铁基生命代谢出的废物－光来生存，而碳基生命则是更低等的生命，食用硅基生命的代谢产物－低端化学能来生存，这些低端化学能产生的光和热能不足以满足硅基生命的生存下限。</p><footer><strong>碳基、硅基、铁基</strong></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;为什么现在的孩子越来越高、越来越胖？&lt;br&gt;为什么青少年糖尿病越来越多、发病年龄越来越小？&lt;br&gt;为什么越来越多的现代人患上了哮喘、过敏性鼻炎以及五花八门的食物过敏？&lt;br&gt;种种“现代疾病”背后是否有个共同的“罪魁祸首”？&lt;/p&gt;&lt;p&gt;美国著名科学家
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="https://muhouer.github.io/posts/2b9621c6/"/>
    <id>https://muhouer.github.io/posts/2b9621c6/</id>
    <published>2019-09-03T16:39:00.000Z</published>
    <updated>2019-09-03T16:41:56.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul><li><p><strong>进程(Process)</strong>：计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p></li><li><p><strong>线程(Thread)</strong>：进程的组成部分，它代表了一条顺序的执行流。线程依托于进程存在，在进程之下，可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据。</p></li><li><p><strong>并行(parallel)</strong>：指在同一时刻，有多条指令在多个处理器上同时执行。</p></li></ul><p><img src="/images/201909040011.png" alt="parallel"></p><ul><li><strong>并发(concurrency)</strong>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li></ul><p><img src="/images/201909040012.png" alt="concurrency"></p><blockquote><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><p>不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源。</p></blockquote><hr><p><strong>@UsesJava8</strong></p><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><p>使用线程池有三个好处</p><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><p>但是只有对线程池原理有深入的了解才能最大程度发挥线程池的作用。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过 <code>ThreadPoolExecutor</code> 来创建一个线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="comment">// 核心线程数</span></span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize, <span class="comment">// 最大线程数</span></span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime, <span class="comment">// 线程存活时间</span></span><br><span class="line">                   TimeUnit unit, <span class="comment">// 线程存活时间的单位</span></span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 阻塞队列</span></span><br><span class="line">                   ThreadFactory threadFactory, <span class="comment">// 创建线程的工厂</span></span><br><span class="line">                   RejectedExecutionHandler handler)  <span class="comment">// 拒绝策略</span></span><br></pre></td></tr></table></figure><p>参数解释如下：</p><ul><li><p><strong>corePoolSize</strong>: 当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于<strong>核心线程数</strong>时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有核心线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>maximumPoolSize</strong>: 线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</p></li><li><p><strong>keepAliveTime</strong>: 线程池的工作线程空闲后，存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p></li><li><p><strong>unit</strong>： 可选的单位有 <code>DAYS</code>，<code>HOURS</code>，<code>MINUTES</code>，<code>MILLISECONDS</code>，<code>MICROSECONDS</code>，<code>NANOSECONDS</code>。参考<code>TimeUnit</code></p></li><li><p><strong>workQueue</strong>: 用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ul><li><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法 <code>Executors.newFixedThreadPool()</code> 使用了这个队列</li><li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 <code>LinkedBlockingQueue</code>，静态工厂方法 <code>Executors.newCachedThreadPool</code> 使用了这个队列。</li><li><code>PriorityBlockingQueue</code>：一个具有优先级得无限阻塞队列。</li></ul></li><li><p><strong>threadFactory</strong>: 可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug 和定位问题时非常又帮助。</p></li><li><p><strong>handler</strong>: 当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。</p><ul><li><p><code>CallerRunsPolicy</code>: 调用者运行策略。当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。一般在不允许失败的、对性能要求不高、并发量较小的场景下使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>AbortPolicy</code>: 中止策略。当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>DiscardPolicy</code>: 丢弃策略。不触发任何动作地丢弃这个任务。如果你提交的任务无关紧要，你就可以使用它 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>DiscardOldestPolicy</code>: 弃老策略。如果线程池未关闭，就弹出队列头部的元素，然后尝试执行。发布消息，和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><h4 id="通过-execute-向线程池提交任务"><a href="#通过-execute-向线程池提交任务" class="headerlink" title="通过 execute 向线程池提交任务"></a>通过 <code>execute</code> 向线程池提交任务</h4><p>execute 方法没有返回值，无法判断任务知否被线程池执行成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get(); <span class="comment">// 获取到当前有效的线程数和线程池的状态</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 线程数小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 在addWorker中创建工作线程执行任务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 线程池是否处于运行状态，且是否任务插入任务队列成功</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 线程池是否处于运行状态，如果不是则使刚刚的任务出队</span></span><br><span class="line">            reject(command); <span class="comment">// 执行拒绝策略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 继续创建线程</span></span><br><span class="line">    &#125; <span class="comment">// 插入队列不成功，且当前线程数数量小于最大线程池数量，此时则创建新线程执行任务，创建失败抛出异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command); <span class="comment">// 创建线程失败执行拒绝策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过-submit向线程池提交任务"><a href="#通过-submit向线程池提交任务" class="headerlink" title="通过 submit向线程池提交任务"></a>通过 <code>submit</code>向线程池提交任务</h4><p>submit 方法返回一个 future ，可以通过这个 future 来判断任务是否执行成功，通过 future 的 get() 方法来获取返回值，get() 方法会阻塞住直到任务完成，而使用 get(long timeout, TimeUnit unit) 方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p>我们可以通过调用线程池的 shutdown() 或 shutdownNow() 方法来关闭线程池，但是它们的实现原理不同，shutdown 的原理是只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。shutdownNow 的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt() 方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow 会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</p><p>只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 isTerminaed() 方法会返回 true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。</p><h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p><strong>通过线程池提供的参数进行监控</strong>。线程池里有一些属性在监控线程池的时候可以使用</p><ul><li><strong>taskCount</strong>: 线程池需要执行的任务数量。</li><li><strong>completedTaskCount</strong>: 线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li><li><strong>largestPoolSize</strong>: 线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li><li><strong>getPoolSize</strong>: 线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。</li><li><strong>getActiveCount</strong>：获取活动的线程数。</li></ul><p><strong>通过扩展线程池进行监控</strong>。通过继承线程池并重写线程池的 beforeExecute，afterExecute 和 terminated 方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的配置策略"><a href="#线程池的配置策略" class="headerlink" title="线程池的配置策略"></a>线程池的配置策略</h2><h3 id="根据任务性质设置"><a href="#根据任务性质设置" class="headerlink" title="根据任务性质设置"></a>根据任务性质设置</h3><p>通常这种设置方式是比较粗略的方式。要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p><ol><li><p><strong>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</strong></p><p>CPU 密集型任务配置尽可能小的线程，如配置CPU数+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*CPU数。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 方法获得当前设备的CPU个数。</p></li><li><p><strong>任务的优先级：高，中和低。</strong></p></li><li><p><strong>任务的执行时间：长，中和短。</strong></p><p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p></li><li><p><strong>任务的依赖性：是否依赖其他系统资源，如数据库连接。</strong></p><p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p></li></ol><p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。如果使用无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。</p><h3 id="利特尔法则"><a href="#利特尔法则" class="headerlink" title="利特尔法则"></a>利特尔法则</h3><blockquote><p>利特尔法则（Little’s law）是说，一个系统请求数等于请求的到达率与平均每个单独请求花费的时间之乘积。</p></blockquote><p>我们可以使用利特尔法则（Little’s law）来判定线程池大小。我们只需计算请求到达率和请求处理的平均时间。然后，将上述值放到利特尔法则（Little’s law）就可以算出系统平均请求数。若请求数小于我们线程池的大小，就相应地减小线程池的大小。与之相反，如果请求数大于线程池大小，事情就有点复杂了。</p><p>当遇到有更多请求待处理的情况时，我们首先需要评估系统是否有足够的能力支持更大的线程池。准确评估的前提是，我们必须评估哪些资源会限制应用程序的扩展能力。最简单的情况是，我们有足够的空间增加线程池的大小。若没有的话，你不得不考虑其它选项，如软件调优、增加硬件，或者调优并增加硬件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a&gt;一些概念&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;进程(Process)&lt;/strong&gt;：计算机中的程序关于某数据集合上的一次运行活动，是系
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
      <category term="线程池" scheme="https://muhouer.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>拾句-甜</title>
    <link href="https://muhouer.github.io/posts/ead251ab/"/>
    <id>https://muhouer.github.io/posts/ead251ab/</id>
    <published>2019-09-02T16:53:44.000Z</published>
    <updated>2019-09-02T17:02:33.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="星星睡不着，在数人类。"><a href="#星星睡不着，在数人类。" class="headerlink" title="星星睡不着，在数人类。"></a>星星睡不着，在数人类。</h3><ol><li><strong>有一些小猫假扮成人类来跟我们相爱。</strong></li><li><strong>我也就一般甜啦，也就半糖烤奶加泷珠。</strong></li><li><strong>我们一块儿发会呆吧。</strong></li><li><strong>我永远屈服于温柔，而你是温柔本身。</strong></li><li><strong>放下你的刀，来做本王的妻子吧。</strong></li><li><strong>每天都会有让人长胖的好事情发生。</strong></li><li><strong>你的春日好运正在派件，请保持心情舒畅。</strong></li><li><strong>可爱之人必遇可爱之事。</strong></li><li><strong>希望下次喜欢和合适可以撞个满怀。</strong></li></ol><hr><h3 id="你是我见一个爱一个里面最爱的一个。"><a href="#你是我见一个爱一个里面最爱的一个。" class="headerlink" title="你是我见一个爱一个里面最爱的一个。"></a>你是我见一个爱一个里面最爱的一个。</h3><ol><li><strong>我要去宇宙了，回来摘星星给你。</strong></li><li><strong>好好生活，活到夏天。</strong></li><li><strong>这个人很懒，什么都没有留下。</strong></li><li><strong>既然来到这个世界的话，那就稍微喜欢一下它吧。</strong></li><li><strong>研究了一晚上宇宙，宇宙没理我。</strong></li><li><strong>这家伙很懒，却还想留下点儿什么。</strong></li><li><strong>一觉醒来，觉得甚是爱你。</strong></li><li><strong>你再不来，我就要下雪了。</strong></li><li><strong>所有的告别中，我最喜欢明天见。</strong></li></ol><hr><h3 id="我马上要恋爱了，和谁不知道，先替他高兴一下。"><a href="#我马上要恋爱了，和谁不知道，先替他高兴一下。" class="headerlink" title="我马上要恋爱了，和谁不知道，先替他高兴一下。"></a>我马上要恋爱了，和谁不知道，先替他高兴一下。</h3><ol><li><strong>薏仁做事薏仁汤，小丁做事小叮当。</strong></li><li><strong>既然来了就磕个头再走吧。</strong></li><li><strong>成熟的大人会不动声色的穿上秋裤。</strong></li><li><strong>请你一定要对号入座，我说的所有星光月亮、清泉小溪、蘸着糖的奶油和蜂蜜——这世间所有的美好事物，都只是为了形容你。</strong></li><li><strong>你不是什么小人物，在我这里你是所有的天气和心情。</strong></li><li><strong>我想对你做春天对樱桃树做的事。</strong></li><li><strong>国家二级退堂鼓演奏家</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;星星睡不着，在数人类。&quot;&gt;&lt;a href=&quot;#星星睡不着，在数人类。&quot; class=&quot;headerlink&quot; title=&quot;星星睡不着，在数人类。&quot;&gt;&lt;/a&gt;星星睡不着，在数人类。&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;有一些小猫假扮成人类来跟我们相爱。&lt;/st
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>今天就和孩子签订一份成长协议</title>
    <link href="https://muhouer.github.io/posts/9085c4b7/"/>
    <id>https://muhouer.github.io/posts/9085c4b7/</id>
    <published>2019-09-01T14:20:17.000Z</published>
    <updated>2019-09-01T14:25:14.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：连岳<br>原文链接： <a href="https://mp.weixin.qq.com/s/stMBnSo8YJKf5N2YEXrxdQ" target="_blank" rel="noopener">今天就和孩子签订一份成长协议</a></p></blockquote><p>一想到教育，任务繁重，多数人万千愁绪，不知从何抓起。但任务越重大，起点越要轻微。一点点改变，往往就能改变事物的性质。</p><p>有位家长提供了一份简单的成长协议，非常高明，值得推广：</p><img src="/images/201909011020.png" width="800px" height="300px" align="center"><p>初初一看，这没什么稀奇，开学之际，父母都会对孩子提出各种成长要求。这位家长提出的要求高得多，每天提早半小时到校，这个改变，孩子就算完成度只有50%，除了早上比同学更从容，更多一点学习时间，还意味着他更早睡，更早完成作业，效率更高，作息时间的细微调整，将重组一天的时间结构。</p><p>但是孩子提出了反制，这也不稀奇，当孩子被批评，被要求时，他们下意识的还击就是：那你自己如何如何。那你自己又做不到！是一句彻底激怒家长的话，羞愧、无能、耻辱、被冒犯、被伤害，一起发作，瞬间失去理智，家长将用强势地位压制孩子的反制，手段可能是物理或语言的暴力，或是各种辩解及转移话题，甚至流着泪说，要不是因为你耽误，我早就如何如何了。</p><p>家长的压制当然能成功，孩子依靠你生存，这是他天然的不利。但付出的代价，却是成功教育者两大要件的丧失，一是威信，二是真诚。这两大要件相辅相成，失去其一，另外一个也成立不了。</p><p>教育就是不停地讲道理，提要求。教育者本身的品德、能量令人敬佩，他讲道理事半功倍。一个天天玩手机的家长，警告孩子沉迷手机的危害，孩子当然认为你说假话。一个从不阅读，没有能力深阅读的家长，天天叨阅读的好处，必然没有任何效果，你只会学舌，他人说法的对错你都无法分辨，将一堆矛盾冲突的观点塞给孩子，他更加困惑，无所适从。</p><p>家长无法对孩子隐藏自己的真面目，你若不值得尊重，第一个瞧不起你的，就是传承你DNA的孩子。一旦你放纵、无能、愚蠢、不负责任，精神上的弑父（母）就在发生。无论你多么花言巧语，教育都失效了。说话的技巧并不是教育的根本，在孩子心目中有威信的父母，怎么说都有效，说话技术好，效果更好而已。</p><p>上面那位家长，接受孩子的反要求。有意无意，这迈出了质变的一小步。家长从孩子的要求中，可以发现自己忽视的缺点，那正是威信正在动摇的地方。同时有了被教育、被监督的弱势身份，在完成计划的过程中，可以体验学习与进步的艰难，不再只是轻松的动动嘴的教育者，和孩子一起学习， 一起成长，积累与交流这种经验就是不可替代的教育资源。而孩子突然有了教育者与监督者的强势身份，就像他小时候扮演老虎，他要表现得像只老虎，当他行使教育者与监督者职责时，他有了原来没有的视角与想法，这有利于他理解教育者。为了保有这份“权力”，他必须成为一个更好的学习者与履约者。</p><p>我建议家长与孩子坐下来谈一谈，有意识地赋予孩子反制权，签订一份合理的、双方认同的一起成长计划，双方互为教育者与被教育者，监督者与被监督者。根据完成度，执行相应的奖罚。我知道，很多家长也有阅读计划，锻炼计划，学习计划，以及各种其他计划，但是自律性差，往往虎头蛇尾。有个无情的监督者，尤其他是你的孩子，你不能输，那么，你计划的完成度将大大提升，你的人生，因为有了和孩子一起成长的具体约定与行动，将如开挂一般。</p><p>今天就订一个成长协议，虽然这对家长的要求更高了，但是一个负责任的家长，是不会怕的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者：连岳&lt;br&gt;原文链接： &lt;a href=&quot;https://mp.weixin.qq.com/s/stMBnSo8YJKf5N2YEXrxdQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;今天就和孩子签订一份成长协议&lt;/a&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java优雅之道</title>
    <link href="https://muhouer.github.io/posts/b9a3a63c/"/>
    <id>https://muhouer.github.io/posts/b9a3a63c/</id>
    <published>2019-09-01T01:23:00.000Z</published>
    <updated>2019-09-01T01:43:36.466Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文作者：</strong>陈昌毅，花名常意，高德地图技术专家，2018年加入阿里巴巴，一直从事地图数据采集的相关工作。</p><p><strong>原文地址：</strong><a href="https://mp.weixin.qq.com/s/rjK5OZ_Kx7E5YUGgVp0BCw" target="_blank" rel="noopener">Java 函数优雅之道</a></p></blockquote><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>随着软件项目代码的日积月累，系统维护成本变得越来越高，是所有软件团队面临的共同问题。持续地优化代码，提高代码的质量，是提升系统生命力的有效手段之一。软件系统思维有句话“<strong>Less coding, more thinking（少编码、多思考）</strong>”，也有这么一句俚语“<strong>Think more, code less（思考越多，编码越少）</strong>”。所以，我们在编码中多思考多总结，努力提升自己的编码水平，才能编写出更优雅、更高质、更高效的代码。</p><p>本文总结了一套与 Java 函数相关的编码规则，旨在给广大Java程序员一些编码建议，有助于大家编写出更优雅、更高质、更高效的代码。这套编码规则，通过在高德采集部门的实践，已经取得了不错的成效。</p><h2 id="使用通用工具函数"><a href="#使用通用工具函数" class="headerlink" title="使用通用工具函数"></a>使用通用工具函数</h2><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述:</strong></p><p><strong>不完善的写法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisName != <span class="keyword">null</span> &amp;&amp; thisName.equals(name);</span><br></pre></td></tr></table></figure><p><strong>更完善的写法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(thisName == name) || (thisName != <span class="keyword">null</span> &amp;&amp; thisName.equals(name));</span><br></pre></td></tr></table></figure><p><strong>建议方案:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(name, thisName);</span><br></pre></td></tr></table></figure><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p><strong>现象描述:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(list == <span class="keyword">null</span> || list.isEmpty());</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line">CollectionUtils.isNotEmpty(list);</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>函数式编程，业务代码减少，逻辑一目了然；</li><li>通用工具函数，逻辑考虑周全，出问题概率低。</li></ul><h2 id="拆分超大函数"><a href="#拆分超大函数" class="headerlink" title="拆分超大函数"></a>拆分超大函数</h2><p>当一个函数超过80行后，就属于超大函数，需要进行拆分。</p><h3 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h3><p><strong>每一个代码块必然有一个注释，用于解释这个代码块的功能。</strong>如果代码块前方有一行注释，就是在提醒你——可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。如果函数有一个描述恰当的名字，就不需要去看内部代码究竟是如何实现的。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    <span class="comment">// 吃饭相关代码几十行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="comment">// 编码相关代码几十行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    <span class="comment">// 睡觉相关代码几十行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吃饭函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭相关代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编码相关代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡觉函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 睡觉相关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二-每一个循环体都可以封装为一个函数。"><a href="#案例二-每一个循环体都可以封装为一个函数。" class="headerlink" title="案例二:每一个循环体都可以封装为一个函数。"></a>案例二:每一个循环体都可以封装为一个函数。</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive) &#123;</span><br><span class="line">        <span class="comment">// 吃饭</span></span><br><span class="line">        eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编码</span></span><br><span class="line">        code();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡觉</span></span><br><span class="line">        sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive) &#123;</span><br><span class="line">        <span class="comment">// 每日生活</span></span><br><span class="line">        liveDaily();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三-每一个条件体都可以封装为一个函数。"><a href="#案例三-每一个条件体都可以封装为一个函数。" class="headerlink" title="案例三:每一个条件体都可以封装为一个函数。"></a>案例三:每一个条件体都可以封装为一个函数。</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外出函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否周末</span></span><br><span class="line">    <span class="comment">// 判断是否周末: 是周末则游玩</span></span><br><span class="line">    <span class="keyword">if</span> (isWeekday()) &#123;</span><br><span class="line">        <span class="comment">// 游玩代码几十行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否周末: 非周末则工作</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 工作代码几十行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外出函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否周末</span></span><br><span class="line">    <span class="comment">// 判断是否周末: 是周末则游玩</span></span><br><span class="line">    <span class="keyword">if</span> (isWeekday()) &#123;</span><br><span class="line">        play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否周末: 非周末则工作</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游玩函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 游玩代码几十行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 工作代码几十行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>函数越短小精悍，功能就越单一，往往生命周期较长；</li><li>一个函数越长，就越不容易理解和维护，维护人员不敢轻易修改；</li><li>在过长函数中，往往含有难以发现的重复代码。</li></ul><h2 id="同一函数内代码块级别尽量一致"><a href="#同一函数内代码块级别尽量一致" class="headerlink" title="同一函数内代码块级别尽量一致"></a>同一函数内代码块级别尽量一致</h2><h3 id="案例一-2"><a href="#案例一-2" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    <span class="comment">// 睡觉相关代码几十行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，睡觉这块代码块，跟 eat（吃饭）和 code（编码）不在同一级别上，显得比较突兀。如果把写代码比作写文章，eat（吃饭）和code（编码）是段落大意，而睡觉这块代码块属于一个详细段落。而在 liveDaily（每日生活）这个函数上，只需要写出主要流程（段落大意）即可。</p><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡觉</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 睡觉相关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>函数调用表明用途，函数实现表达逻辑，层次分明便于理解；</li><li>不用层次的代码块放在一个函数中，容易让人觉得代码头重脚轻。</li></ul><h2 id="封装相同功能代码为函数"><a href="#封装相同功能代码为函数" class="headerlink" title="封装相同功能代码为函数"></a>封装相同功能代码为函数</h2><h3 id="案例一：封装相同代码为函数"><a href="#案例一：封装相同代码为函数" class="headerlink" title="案例一：封装相同代码为函数"></a>案例一：封装相同代码为函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disableUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 禁用黑名单用户</span></span><br><span class="line">    List&lt;Long&gt; userIdList = queryBlackUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        User userUpdate = <span class="keyword">new</span> User();</span><br><span class="line">        userUpdate.setId(userId);</span><br><span class="line">        userUpdate.setEnable(Boolean.FALSE);</span><br><span class="line">        userDAO.update(userUpdate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用过期用户</span></span><br><span class="line">    userIdList = queryExpiredUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        User userUpdate = <span class="keyword">new</span> User();</span><br><span class="line">        userUpdate.setId(userId);</span><br><span class="line">        userUpdate.setEnable(Boolean.FALSE);</span><br><span class="line">        userDAO.update(userUpdate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disableUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 禁用黑名单用户</span></span><br><span class="line">    List&lt;Long&gt; userIdList = queryBlackUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        disableUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用过期用户</span></span><br><span class="line">    userIdList = queryExpiredUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        disableUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disableUser</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    User userUpdate = <span class="keyword">new</span> User();</span><br><span class="line">    userUpdate.setId(userId);</span><br><span class="line">    userUpdate.setEnable(Boolean.FALSE);</span><br><span class="line">    userDAO.update(userUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：封装相似代码为函数"><a href="#案例二：封装相似代码为函数" class="headerlink" title="案例二：封装相似代码为函数"></a>案例二：封装相似代码为函数</h3><p>封装相似代码为函数，差异性通过函数参数控制。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adoptOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    Order orderUpdate = <span class="keyword">new</span> Order();</span><br><span class="line">    orderUpdate.setId(orderId);</span><br><span class="line">    orderUpdate.setStatus(OrderStatus.ADOPTED);</span><br><span class="line">    orderUpdate.setAuditTime(<span class="keyword">new</span> Date());</span><br><span class="line">    orderDAO.update(orderUpdate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驳回工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    Order orderUpdate = <span class="keyword">new</span> Order();</span><br><span class="line">    orderUpdate.setId(orderId);</span><br><span class="line">    orderUpdate.setStatus(OrderStatus.REJECTED);</span><br><span class="line">    orderUpdate.setAuditTime(<span class="keyword">new</span> Date());</span><br><span class="line">    orderDAO.update(orderUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adoptOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    auditOrder(orderId, OrderStatus.ADOPTED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驳回工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    auditOrder(orderId, OrderStatus.REJECTED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 审核工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">auditOrder</span><span class="params">(Long orderId, OrderStatus orderStatus)</span> </span>&#123;</span><br><span class="line">    Order orderUpdate = <span class="keyword">new</span> Order();</span><br><span class="line">    orderUpdate.setId(orderId);</span><br><span class="line">    orderUpdate.setStatus(orderStatus);</span><br><span class="line">    orderUpdate.setAuditTime(<span class="keyword">new</span> Date());</span><br><span class="line">    orderDAO.update(orderUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>封装公共函数，减少代码行数，提高代码质量；</li><li>封装公共函数，使业务代码更精炼，可读性可维护性更强。</li></ul><h2 id="封装获取参数值函数"><a href="#封装获取参数值函数" class="headerlink" title="封装获取参数值函数"></a>封装获取参数值函数</h2><h3 id="案例一-3"><a href="#案例一-3" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取通过阈值</span></span><br><span class="line">    <span class="keyword">double</span> thisPassThreshold = PASS_THRESHOLD;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(passThreshold)) &#123;</span><br><span class="line">        thisPassThreshold = passThreshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取通过率</span></span><br><span class="line">    <span class="keyword">double</span> passRate = getPassRate(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判读是否通过</span></span><br><span class="line">    <span class="keyword">return</span> passRate &gt;= thisPassThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取通过阈值</span></span><br><span class="line">    <span class="keyword">double</span> thisPassThreshold = getPassThreshold();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取通过率</span></span><br><span class="line">    <span class="keyword">double</span> passRate = getPassRate(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判读是否通过</span></span><br><span class="line">    <span class="keyword">return</span> passRate &gt;= thisPassThreshold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取通过阈值函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getPassThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(passThreshold)) &#123;</span><br><span class="line">        <span class="keyword">return</span> passThreshold;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PASS_THRESHOLD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>把获取参数值从业务函数中独立，使业务逻辑更清晰；</li><li>封装的获取参数值为独立函数，可以在代码中重复使用。</li></ul><h2 id="通过接口参数化封装相同逻辑"><a href="#通过接口参数化封装相同逻辑" class="headerlink" title="通过接口参数化封装相同逻辑"></a>通过接口参数化封装相同逻辑</h2><h3 id="案例一-4"><a href="#案例一-4" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送审核员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAuditorSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WorkerSettleData&gt; settleDataList = auditTaskDAO.statAuditorSettleData();</span><br><span class="line">    <span class="keyword">for</span> (WorkerSettleData settleData : settleDataList) &#123;</span><br><span class="line">        WorkerPushData pushData = <span class="keyword">new</span> WorkerPushData();</span><br><span class="line">        pushData.setId(settleData.getWorkerId());</span><br><span class="line">        pushData.setType(WorkerPushDataType.AUDITOR);</span><br><span class="line">        pushData.setData(settleData);</span><br><span class="line">        pushService.push(pushData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送验收员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCheckerSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WorkerSettleData&gt; settleDataList = auditTaskDAO.statCheckerSettleData();</span><br><span class="line">    <span class="keyword">for</span> (WorkerSettleData settleData : settleDataList) &#123;</span><br><span class="line">        WorkerPushData pushData = <span class="keyword">new</span> WorkerPushData();</span><br><span class="line">        pushData.setId(settleData.getWorkerId());</span><br><span class="line">        pushData.setType(WorkerPushDataType.CHECKER);</span><br><span class="line">        pushData.setData(settleData);</span><br><span class="line">        pushService.push(pushData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送审核员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAuditorSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendWorkerSettleData(WorkerPushDataType.AUDITOR, () -&gt; auditTaskDAO.statAuditorSettleData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送验收员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCheckerSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; auditTaskDAO.statCheckerSettleData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送作业员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendWorkerSettleData</span><span class="params">(WorkerPushDataType dataType, WorkerSettleDataProvider dataProvider)</span> </span>&#123;</span><br><span class="line">    List&lt;WorkerSettleData&gt; settleDataList = dataProvider.statWorkerSettleData();</span><br><span class="line">    <span class="keyword">for</span> (WorkerSettleData settleData : settleDataList) &#123;</span><br><span class="line">        WorkerPushData pushData = <span class="keyword">new</span> WorkerPushData();</span><br><span class="line">        pushData.setId(settleData.getWorkerId());</span><br><span class="line">        pushData.setType(dataType);</span><br><span class="line">        pushData.setData(settleData);</span><br><span class="line">        pushService.push(pushData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作业员结算数据提供者接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerSettleDataProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 统计作业员结算数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;WorkerSettleData&gt; <span class="title">statWorkerSettleData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>把核心逻辑从各个业务函数中抽析，使业务代码更清晰更易维护；</li><li>避免重复性代码多次编写，精简重复函数越多收益越大。</li></ul><h2 id="减少函数代码层级"><a href="#减少函数代码层级" class="headerlink" title="减少函数代码层级"></a>减少函数代码层级</h2><p>如果要使函数优美，建议函数代码层级在1-4之间，过多的缩进会让函数难以阅读。</p><h3 id="案例一：利用return提前返回函数"><a href="#案例一：利用return提前返回函数" class="headerlink" title="案例一：利用return提前返回函数"></a>案例一：利用return提前返回函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">getUserBalance</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    User user = getUser(userId);</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user)) &#123;</span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">            <span class="keyword">return</span> account.getBalance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">getUserBalance</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取用户信息</span></span><br><span class="line">    User user = getUser(userId);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户账户</span></span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(account)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回账户余额</span></span><br><span class="line">    <span class="keyword">return</span> account.getBalance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：利用continue提前结束循环"><a href="#案例二：利用continue提前结束循环" class="headerlink" title="案例二：利用continue提前结束循环"></a>案例二：利用continue提前结束循环</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取合计余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始合计余额</span></span><br><span class="line">    <span class="keyword">double</span> totalBalance = <span class="number">0.0</span>D;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次累加余额</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 获取用户账户</span></span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">            <span class="comment">// 累加用户余额</span></span><br><span class="line">            Double balance = account.getBalance();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(balance)) &#123;</span><br><span class="line">                totalBalance += balance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回合计余额</span></span><br><span class="line">    <span class="keyword">return</span> totalBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取合计余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始合计余额</span></span><br><span class="line">    <span class="keyword">double</span> totalBalance = <span class="number">0.0</span>D;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次累加余额</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 获取用户账户</span></span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(account)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累加用户余额</span></span><br><span class="line">        Double balance = account.getBalance();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(balance)) &#123;</span><br><span class="line">            totalBalance += balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回合计余额</span></span><br><span class="line">    <span class="keyword">return</span> totalBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>特殊说明</em></strong></p><p>其它方式：在循环体中，先调用案例1的函数 getUserBalance (获取用户余额)，再进行对余额进行累加。</p><p><strong>在循环体中，建议最多使用一次 continue 。</strong>如果需要有使用多次 continue 的需求，建议把循环体封装为一个函数。</p><h3 id="案例三：利用条件表达式函数减少层级"><a href="#案例三：利用条件表达式函数减少层级" class="headerlink" title="案例三：利用条件表达式函数减少层级"></a>案例三：利用条件表达式函数减少层级</h3><p>请参考下一章的”案例2: 把复杂条件表达式封装为函数”</p><p><strong>主要收益</strong></p><ul><li>代码层级减少，代码缩进减少；</li><li>模块划分清晰，方便阅读维护。</li></ul><h2 id="封装条件表达式函数"><a href="#封装条件表达式函数" class="headerlink" title="封装条件表达式函数"></a>封装条件表达式函数</h2><h3 id="案例一：把简单条件表达式封装为函数"><a href="#案例一：把简单条件表达式封装为函数" class="headerlink" title="案例一：把简单条件表达式封装为函数"></a>案例一：把简单条件表达式封装为函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取门票价格函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">(Date currDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(currDate) &amp;&amp; currDate.after(DISCOUNT_BEGIN_DATE)</span><br><span class="line">        &amp;&amp; currDate.before(DISCOUNT_END_DATE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> TICKET_PRICE * DISCOUNT_RATE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TICKET_PRICE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取门票价格函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">(Date currDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDiscountDate(currDate)) &#123;</span><br><span class="line">        <span class="keyword">return</span> TICKET_PRICE * DISCOUNT_RATE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TICKET_PRICE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否折扣日期函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDiscountDate</span><span class="params">(Date currDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.nonNull(currDate) &amp;&amp; </span><br><span class="line">currDate.after(DISCOUNT_BEGIN_DATE)</span><br><span class="line">        &amp;&amp; currDate.before(DISCOUNT_END_DATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：把复杂条件表达式封装为函数"><a href="#案例二：把复杂条件表达式封装为函数" class="headerlink" title="案例二：把复杂条件表达式封装为函数"></a>案例二：把复杂条件表达式封装为函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取土豪用户列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getRichUserList</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始土豪用户列表</span></span><br><span class="line">    List&lt;User&gt; richUserList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次查找土豪用户</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 获取用户账户</span></span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">            <span class="comment">// 判断用户余额</span></span><br><span class="line">            Double balance = account.getBalance();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(balance) &amp;&amp; balance.compareTo(RICH_THRESHOLD) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 添加土豪用户</span></span><br><span class="line">                richUserList.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回土豪用户列表</span></span><br><span class="line">    <span class="keyword">return</span> richUserList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取土豪用户列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getRichUserList</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始土豪用户列表</span></span><br><span class="line">    List&lt;User&gt; richUserList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次查找土豪用户</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 判断土豪用户</span></span><br><span class="line">        <span class="keyword">if</span> (isRichUser(user)) &#123;</span><br><span class="line">            <span class="comment">// 添加土豪用户</span></span><br><span class="line">            richUserList.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回土豪用户列表</span></span><br><span class="line">    <span class="keyword">return</span> richUserList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否土豪用户</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRichUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取用户账户</span></span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(account)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户余额</span></span><br><span class="line">    Double balance = account.getBalance();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(balance)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较用户余额</span></span><br><span class="line">    <span class="keyword">return</span> balance.compareTo(RICH_THRESHOLD) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码也可以用采用流式(Stream)编程的过滤来实现。</p><p><strong>主要收益</strong></p><ul><li>把条件表达式从业务函数中独立，使业务逻辑更清晰；</li><li>封装的条件表达式为独立函数，可以在代码中重复使用。</li></ul><h2 id="尽量避免不必要的空指针判断"><a href="#尽量避免不必要的空指针判断" class="headerlink" title="尽量避免不必要的空指针判断"></a>尽量避免不必要的空指针判断</h2><p>本章只适用于项目内部代码，并且是自己了解的代码，才能够尽量避免不必要的空指针判断。对于第三方中间件和系统接口，必须做好空指针判断，以保证代码的健壮性。</p><h3 id="案例一-调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断"><a href="#案例一-调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断" class="headerlink" title="案例一: 调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断"></a>案例一: 调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建用户信息</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">... <span class="comment">// 赋值用户相关信息</span></span><br><span class="line">createUser(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断用户为空</span></span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建用户信息</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">... <span class="comment">// 赋值用户相关信息</span></span><br><span class="line">createUser(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二-被调用函数保证返回不为空-调用函数尽量避免不必要的空指针判断"><a href="#案例二-被调用函数保证返回不为空-调用函数尽量避免不必要的空指针判断" class="headerlink" title="案例二: 被调用函数保证返回不为空,调用函数尽量避免不必要的空指针判断"></a>案例二: 被调用函数保证返回不为空,调用函数尽量避免不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建用户信息</span></span><br><span class="line">    User user = buildUser(id, name);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizRuntimeException(<span class="string">"构建用户信息为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">buildUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(id);</span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建用户信息</span></span><br><span class="line">    User user = buildUser(id, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">buildUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(id);</span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断"><a href="#案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断" class="headerlink" title="案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断"></a>案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户列表</span></span><br><span class="line">List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化用户列表</span></span><br><span class="line">List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">    UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVo.setId(user.getId());</span><br><span class="line">    userVo.setName(user.getName());</span><br><span class="line">    userVoList.add(userVo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次处理用户</span></span><br><span class="line"><span class="keyword">for</span> (UserVO userVo : userVoList) &#123;</span><br><span class="line">    <span class="comment">// 判断用户为空</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(userVo)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理相关逻辑</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户列表</span></span><br><span class="line">List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化用户列表</span></span><br><span class="line">List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">    UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVo.setId(user.getId());</span><br><span class="line">    userVo.setName(user.getName());</span><br><span class="line">    userVoList.add(userVo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次处理用户</span></span><br><span class="line"><span class="keyword">for</span> (UserVO userVo : userVoList) &#123;</span><br><span class="line">    <span class="comment">// 处理相关逻辑</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断"><a href="#案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断" class="headerlink" title="案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断"></a>案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断</h3><p>MyBatis 是一款优秀的持久层框架，是在项目中使用的最广泛的数据库中间件之一。通过对 MyBatis 源码进行分析，查询函数返回的列表和数据项都不为空，在代码中可以不用进行空指针判断。</p><p><strong>现象描述：</strong></p><p>这种写法没有问题，只是过于保守了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.query(id, name);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; voList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">        <span class="comment">// 判断对象为空</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加用户信息</span></span><br><span class="line">        UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        BeanUtils.copyProperties(user, vo);</span><br><span class="line">        voList.add(vo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> voList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.query(id, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; voList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">        UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        BeanUtils.copyProperties(user, vo);</span><br><span class="line">        voList.add(vo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> voList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>避免不必要的空指针判断，精简业务代码处理逻辑，提高业务代码运行效率；</li><li>这些不必要的空指针判断，基本属于永远不执行的 Death 代码，删除有助于代码维护。</li></ul><h2 id="内部函数参数尽量使用基础类型"><a href="#内部函数参数尽量使用基础类型" class="headerlink" title="内部函数参数尽量使用基础类型"></a>内部函数参数尽量使用基础类型</h2><h3 id="案例一：内部函数参数尽量使用基础类型"><a href="#案例一：内部函数参数尽量使用基础类型" class="headerlink" title="案例一：内部函数参数尽量使用基础类型"></a>案例一：内部函数参数尽量使用基础类型</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line"><span class="keyword">double</span> price = <span class="number">5.1</span>D;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">double</span> total = calculate(price, number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(Double price, Integer number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line"><span class="keyword">double</span> price = <span class="number">5.1</span>D;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">double</span> total = calculate(price, number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：内部函数返回值尽量使用基础类型"><a href="#案例二：内部函数返回值尽量使用基础类型" class="headerlink" title="案例二：内部函数返回值尽量使用基础类型"></a>案例二：内部函数返回值尽量使用基础类型</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取订单总额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getOrderAmount</span><span class="params">(List&lt;Product&gt; productList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> amount = <span class="number">0.0</span>D;</span><br><span class="line">    <span class="keyword">for</span> (Product product : productList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(product) || Objects.isNull(product.getPrice())</span><br><span class="line">            || Objects.isNull(product.getNumber())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        amount += calculate(product.getPrice(), product.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Double <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">double</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取订单总额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getOrderAmount</span><span class="params">(List&lt;Product&gt; productList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> amount = <span class="number">0.0</span>D;</span><br><span class="line">    <span class="keyword">for</span> (Product product : productList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(product) || Objects.isNull(product.getPrice())</span><br><span class="line">            || Objects.isNull(product.getNumber())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        amount += calculate(product.getPrice(), product.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">double</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处只是举例说明这种现象，更好的方式是采用流式(Stream)编程。</p><p><strong>主要收益</strong></p><ul><li>内部函数尽量使用基础类型，避免了隐式封装类型的打包和拆包；</li><li>内部函数参数使用基础类型，用语法上避免了内部函数的参数空指针判断；</li><li>内部函数返回值使用基础类型，用语法上避免了调用函数的返回值空指针判断。</li></ul><h2 id="尽量避免返回的数组和列表为-null"><a href="#尽量避免返回的数组和列表为-null" class="headerlink" title="尽量避免返回的数组和列表为 null"></a>尽量避免返回的数组和列表为 null</h2><h3 id="案例一：尽量避免返回的数组为-null-，引起不必要的空指针判断"><a href="#案例一：尽量避免返回的数组为-null-，引起不必要的空指针判断" class="headerlink" title="案例一：尽量避免返回的数组为 null ，引起不必要的空指针判断"></a>案例一：尽量避免返回的数组为 null ，引起不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">UserVO[] users = queryUser();</span><br><span class="line"><span class="keyword">if</span> (Objects.nonNull(users)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (UserVO user : users) &#123;</span><br><span class="line">        <span class="comment">// 处理用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="keyword">private</span> UserVO[] queryUser() &#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户数组</span></span><br><span class="line">    UserVO[] users = <span class="keyword">new</span> UserVO[userList.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userList.size(); i++) &#123;</span><br><span class="line">        UserDO user = userList.get(i);</span><br><span class="line">        users[i] = <span class="keyword">new</span> UserVO();</span><br><span class="line">        users[i].setId(user.getId());</span><br><span class="line">        users[i].setName(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户数组</span></span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">UserVO[] users = queryUser();</span><br><span class="line"><span class="keyword">for</span> (UserVO user : users) &#123;</span><br><span class="line">    <span class="comment">// 处理用户信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="keyword">private</span> UserVO[] queryUser() &#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserVO[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户数组</span></span><br><span class="line">    UserVO[] users = <span class="keyword">new</span> UserVO[userList.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userList.size(); i++) &#123;</span><br><span class="line">        UserDO user = userList.get(i);</span><br><span class="line">        users[i] = <span class="keyword">new</span> UserVO();</span><br><span class="line">        users[i].setId(user.getId());</span><br><span class="line">        users[i].setName(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户数组</span></span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：尽量避免返回的列表为-null-，引起不必要的空指针判断"><a href="#案例二：尽量避免返回的列表为-null-，引起不必要的空指针判断" class="headerlink" title="案例二：尽量避免返回的列表为 null ，引起不必要的空指针判断"></a>案例二：尽量避免返回的列表为 null ，引起不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">List&lt;UserVO&gt; userList = queryUser();</span><br><span class="line"><span class="keyword">if</span> (Objects.nonNull(userList)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (UserVO user : userList) &#123;</span><br><span class="line">        <span class="comment">// 处理用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span>(UserDO user : userList) &#123;</span><br><span class="line">        UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        userVo.setId(user.getId());</span><br><span class="line">        userVo.setName(user.getName());</span><br><span class="line">        userVoList.add(userVo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> userVoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">List&lt;UserVO&gt; userList = queryUser();</span><br><span class="line"><span class="keyword">for</span> (UserVO user : userList) &#123;</span><br><span class="line">   <span class="comment">// 处理用户信息</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span>(UserDO user : userList) &#123;</span><br><span class="line">        UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        userVo.setId(user.getId());</span><br><span class="line">        userVo.setName(user.getName());</span><br><span class="line">        userVoList.add(userVo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> userVoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>保证返回的数组和列表不为 null , 避免调用函数的空指针判断。</li></ul><h2 id="封装函数传入参数"><a href="#封装函数传入参数" class="headerlink" title="封装函数传入参数"></a>封装函数传入参数</h2><h3 id="案例一：当传入参数过多时，应封装为参数类"><a href="#案例一：当传入参数过多时，应封装为参数类" class="headerlink" title="案例一：当传入参数过多时，应封装为参数类"></a>案例一：当传入参数过多时，应封装为参数类</h3><p>Java 规范不允许函数参数太多，不便于维护也不便于扩展。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyUser</span><span class="params">(Long id, String name, String phone, Integer age, </span></span></span><br><span class="line"><span class="function"><span class="params">    Integer sex, String address, String description)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二-当传入成组参数时，应封装为参数类"><a href="#案例二-当传入成组参数时，应封装为参数类" class="headerlink" title="案例二: 当传入成组参数时，应封装为参数类"></a>案例二: 当传入成组参数时，应封装为参数类</h3><p>既然参数成组出现，就需要封装一个类去描述这种现象。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取距离函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取距离函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(Point point1, Point point2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>封装过多函数参数为类，使函数更便于扩展和维护；</li><li>封装成组函数参数为类，使业务概念更明确更清晰。</li></ul><h2 id="尽量用函数替换匿名内部类的实现"><a href="#尽量用函数替换匿名内部类的实现" class="headerlink" title="尽量用函数替换匿名内部类的实现"></a>尽量用函数替换匿名内部类的实现</h2><p>在匿名内部类（包括Lambda表达式）中可以直接访问外部类的成员，包括类的成员变量、函数的内部变量。正因为可以随意访问外部变量，所以会导致代码边界不清晰。</p><p>首先推荐用 Lambda 表达式简化匿名内部类，其次推荐用函数替换复杂的 Lambda 表达式的实现。</p><h3 id="案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现"><a href="#案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现" class="headerlink" title="案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现"></a>案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送结算数据</span></span><br><span class="line">sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; &#123;</span><br><span class="line">    Date beginDate = DateUtils.addDays(currDate, -aheadDays);</span><br><span class="line">    Date endDate = DateUtils.addDays(currDate, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> auditTaskDAO.statCheckerSettleData(beginDate, endDate);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送结算数据</span></span><br><span class="line">sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; statCheckerSettleData(currDate, aheadDays));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计验收员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;WorkerSettleData&gt; <span class="title">statCheckerSettleData</span><span class="params">(Date currDate, <span class="keyword">int</span> aheadDays)</span> </span>&#123;</span><br><span class="line">    Date beginDate = DateUtils.addDays(currDate, -aheadDays);</span><br><span class="line">    Date endDate = DateUtils.addDays(currDate, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> auditTaskDAO.statCheckerSettleData(beginDate, endDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，还有一个更简单的办法。在调用函数 sendWorkerSettleData（发送作业员结算数据）之前计算开始日期、结束日期，就直接可以用函数auditTaskDAO.statCheckerSettleData(beginDate, endDate)代替匿名内部类实现。</p><h3 id="案例二：拆分复杂匿名内部类实现接口为多个函数类接口"><a href="#案例二：拆分复杂匿名内部类实现接口为多个函数类接口" class="headerlink" title="案例二：拆分复杂匿名内部类实现接口为多个函数类接口"></a>案例二：拆分复杂匿名内部类实现接口为多个函数类接口</h3><p>如果一个匿名内部类实现的接口几个函数间关联性不大，可以把这个接口拆分为几个函数式接口，便于使用 Lambda 表达式。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除过期数据</span></span><br><span class="line">cleanExpiredData(<span class="string">"用户日志表"</span>, <span class="keyword">new</span> CleanExpiredDataOperator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Date&gt; <span class="title">queryExpiredDate</span><span class="params">(Integer remainDays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDAO.queryExpiredDate(remainDays);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(Date expiredDate)</span> </span>&#123;</span><br><span class="line">        userDAO.cleanExpiredData(expiredDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(String tableName, CleanExpiredDataOperator cleanExpiredDataOperator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 功能实现代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期操作接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CleanExpiredDataOperator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询过期日期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Date&gt; <span class="title">queryExpiredDate</span><span class="params">(Integer remainDays)</span></span>;</span><br><span class="line">    <span class="comment">// 清除过期数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(Date expiredDate)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除过期数据</span></span><br><span class="line">cleanExpiredData(<span class="string">"用户日志表"</span>, userDAO::queryExpiredDate,userDAO::cleanExpiredData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(String tableName, QueryExpiredDateOperator queryExpiredDateOperator, CleanExpiredDataOperator cleanExpiredDataOperator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 功能实现代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询过期日期接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">QueryExpiredDateOperator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询过期日期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Date&gt; <span class="title">queryExpiredDate</span><span class="params">(Integer remainDays)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期操作接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CleanExpiredDataOperator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清除过期数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(Date expiredDate)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>定义函数并指定参数，明确规定了匿名内部类的代码边界；</li><li>利用 Lambda 表达式简化匿名内部类实现，使代码更简洁。</li></ul><h2 id="利用-return-精简不必要的代码"><a href="#利用-return-精简不必要的代码" class="headerlink" title="利用 return 精简不必要的代码"></a>利用 return 精简不必要的代码</h2><h3 id="案例一：删除不必要的-if"><a href="#案例一：删除不必要的-if" class="headerlink" title="案例一：删除不必要的 if"></a>案例一：删除不必要的 if</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Double passRate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(passRate) &amp;&amp; passRate.compareTo(PASS_THRESHOLD) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Double passRate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.nonNull(passRate) &amp;&amp; passRate.compareTo(PASS_THRESHOLD) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：删除不必要的-else"><a href="#案例二：删除不必要的-else" class="headerlink" title="案例二：删除不必要的 else"></a>案例二：删除不必要的 else</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结算工资函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">settleSalary</span><span class="params">(Long workId, <span class="keyword">int</span> workDays)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据是否合格处理</span></span><br><span class="line">    <span class="keyword">if</span> (isQualified(workId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> settleQualifiedSalary(workDays);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> settleUnqualifiedSalary(workDays);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 结算工资函数</span><br><span class="line">public double settleSalary(Long workId, int workDays) &#123;</span><br><span class="line">    // 根据是否合格处理</span><br><span class="line">    if (isQualified(workId)) &#123;</span><br><span class="line">        return settleQualifiedSalary(workDays);</span><br><span class="line">    &#125;</span><br><span class="line">    return settleUnqualifiedSalary(workDays);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三：删除不必要的变量"><a href="#案例三：删除不必要的变量" class="headerlink" title="案例三：删除不必要的变量"></a>案例三：删除不必要的变量</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserDO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    UserQuery userQuery = <span class="keyword">new</span> UserQuery();</span><br><span class="line">    userQuery.setId(id);</span><br><span class="line">    userQuery.setName(name);</span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.query(userQuery);</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserDO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    UserQuery userQuery = <span class="keyword">new</span> UserQuery();</span><br><span class="line">    userQuery.setId(id);</span><br><span class="line">    userQuery.setName(name);</span><br><span class="line">    <span class="keyword">return</span> userDAO.query(userQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>精简不必要的代码，让代码看起来更清爽。</li></ul><h2 id="利用临时变量优化代码"><a href="#利用临时变量优化代码" class="headerlink" title="利用临时变量优化代码"></a>利用临时变量优化代码</h2><p>在一些代码中，经常会看到 a.getB().getC()…getN() 的写法，姑且叫做“函数的级联调用”，代码健壮性和可读性太差。建议：<strong>杜绝函数的级联调用，利用临时变量进行拆分，并做好对象空指针检查</strong>。</p><h3 id="案例一：利用临时变量厘清逻辑"><a href="#案例一：利用临时变量厘清逻辑" class="headerlink" title="案例一：利用临时变量厘清逻辑"></a>案例一：利用临时变量厘清逻辑</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否土豪用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRichUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.nonNull(user.getAccount())</span><br><span class="line">        &amp;&amp; Objects.nonNull(user.getAccount().getBalance())</span><br><span class="line">        &amp;&amp; user.getAccount().getBalance().compareTo(RICH_THRESHOLD) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是精简代码控的最爱，但是可读性实在太差。</p><p><strong>建议方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 是否土豪用户函数</span><br><span class="line">private boolean isRichUser(User user) &#123;</span><br><span class="line">    // 获取用户账户</span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    if (Objects.isNull(account)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取用户余额</span><br><span class="line">    Double balance = account.getBalance();</span><br><span class="line">    if (Objects.isNull(balance)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 比较用户余额</span><br><span class="line">    return balance.compareTo(RICH_THRESHOLD) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案，增加了代码行数，但是逻辑更清晰。<br>有时候，当代码的精简性和可读性发生冲突时，个人更偏向于保留代码的可读性。</p><h3 id="案例二：利用临时变量精简代码"><a href="#案例二：利用临时变量精简代码" class="headerlink" title="案例二：利用临时变量精简代码"></a>案例二：利用临时变量精简代码</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserVO <span class="title">buildUser</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    vo.setId(user.getId());</span><br><span class="line">    vo.setName(user.getName());</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user.getAccount())) &#123;</span><br><span class="line">        vo.setBalance(user.getAccount().getBalance());</span><br><span class="line">        vo.setDebt(user.getAccount().getDebt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写，大约是为了节约一个临时变量吧。</p><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserVO <span class="title">buildUser1</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    vo.setId(user.getId());</span><br><span class="line">    vo.setName(user.getName());</span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">        vo.setBalance(account.getBalance());</span><br><span class="line">        vo.setDebt(account.getDebt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>利用临时变量厘清逻辑，显得业务逻辑更清晰；</li><li>利用临时变量精简代码，看变量名称即知其义，减少了大量无用代码；</li><li>如果获取函数比较复杂耗时，利用临时变量可以提高运行效率；</li><li>利用临时变量避免函数的级联调用，可有效预防空指针异常。</li></ul><h2 id="仅保留函数需要的参数"><a href="#仅保留函数需要的参数" class="headerlink" title="仅保留函数需要的参数"></a>仅保留函数需要的参数</h2><h3 id="案例一：删除多余的参数"><a href="#案例一：删除多余的参数" class="headerlink" title="案例一：删除多余的参数"></a>案例一：删除多余的参数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户状态函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserStatus</span><span class="params">(Long userId, Integer status, String unused)</span> </span>&#123;</span><br><span class="line">    userCache.modifyStatus(userId, status);</span><br><span class="line">    userDAO.modifyStatus(userId, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，unused 参数是无用参数。</p><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户状态函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserStatus</span><span class="params">(Long userId, Integer status)</span> </span>&#123;</span><br><span class="line">    userCache.modifyStatus(userId, status);</span><br><span class="line">    userDAO.modifyStatus(userId, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：用属性取代对象"><a href="#案例二：用属性取代对象" class="headerlink" title="案例二：用属性取代对象"></a>案例二：用属性取代对象</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    userCache.delete(user.getId());</span><br><span class="line">    userDAO.delete(user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    userCache.delete(userId);</span><br><span class="line">    userDAO.delete(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><p>调用函数时，参数对象不需要专门构建，而函数使用其属性超过3个，可以不必使用该规则。</p><p><strong>主要收益</strong></p><ul><li>仅保留函数需要的参数，明确了调用时需要赋值的参数，避免了调用时还要去构造些无用参数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;本文作者：&lt;/strong&gt;陈昌毅，花名常意，高德地图技术专家，2018年加入阿里巴巴，一直从事地图数据采集的相关工作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;原文地址：&lt;/strong&gt;&lt;a href=&quot;https://mp.weixin.q
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
      <category term="编程规范" scheme="https://muhouer.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>MD5简单了解</title>
    <link href="https://muhouer.github.io/posts/c9f1aafe/"/>
    <id>https://muhouer.github.io/posts/c9f1aafe/</id>
    <published>2019-08-30T15:50:00.000Z</published>
    <updated>2019-08-30T15:51:35.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-MD5"><a href="#什么是-MD5" class="headerlink" title="什么是 MD5"></a>什么是 MD5</h2><p>MD5 是 <strong>Message-Digest algorithm 5</strong>（信息-摘要算法）的缩写，被广泛用于加密和解密技术上，它可以说是文件的“<strong>数字指纹</strong>”。任何一个文件，无论是可执行程序、图像文件、临时文件或者其他任何类型的文件，也不管它体积多大，都有且只有一个独一无二的MD5信息值，并且如果这个文件被修改过，它的MD5值也将随之改变。因此，我们可以通过对比同一文件的MD5值，来校验这个文件是否被“篡改”过。</p><h2 id="MD5-用途"><a href="#MD5-用途" class="headerlink" title="MD5 用途"></a>MD5 用途</h2><h3 id="MD5-文件传输"><a href="#MD5-文件传输" class="headerlink" title="MD5 文件传输"></a>MD5 文件传输</h3><p>当我们下载了一个软件以后，如果想知道下载的这个软件和网站的原始文件是否一模一样，就可以给自己下载的文件做个 MD5 校验。如果得到的 MD5 值和网站公布的相同，可确认所下载的文件是完整的。如有不同，说明你下载的文件是不完整的：要么就是在网络下载的过程中出现错误，要么就是此文件已被别人修改。为防止他人更改该文件时放入病毒，最好不要使用。一般使用 MD5 计算工具计算后，和软件网站公布得MD5码进行比对。</p><p>校验值是一组16进制数，不区分大小写，校验值本身只与文件内容有关，只要文件内容不改变校验值就不变；如复制/剪切/粘贴，修改文件创建时间/访问时间，修改文件读/写/执行属性等操作都不会导致校验值发生改变。</p><h3 id="MD5-密码加密"><a href="#MD5-密码加密" class="headerlink" title="MD5 密码加密"></a>MD5 密码加密</h3><p>MD5 算法是不可逆的，可以应用在对密码(或者信用卡等)得加密，加密之后在数据库里面看到的密码是无用的。如果需要检验用户的密码，而是检验用户输入的密码经 md5 加密以后和数据库内的是否相符。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="彩虹表"><a href="#彩虹表" class="headerlink" title="彩虹表"></a>彩虹表</h3><p>现在的 MD5 密码数据库（彩虹表）的数据量已经非常庞大了，大部分常用密码都可以通过 MD5 摘要反向查询到密码明文。为了防止内部人员（能够接触到数据库或者数据库备份文件的人员）和外部入侵者通过MD5反查密码明文，更好地保护用户的密码和个人帐户安全（一个用户可能会在多个系统中使用同样的密码，因此涉及到用户在其他网站和系统中的数据安全），需要对 MD5 摘要结果掺入其他信息，称之为加盐。</p><p>通过 md5、sha1等全球通用公开的加密算法进行反向查询网站 : <a href="https://www.cmd5.com/" target="_blank" rel="noopener">https://www.cmd5.com/</a></p><p>例如：<br><img src="/images/201908301130.png" width="800px" height="300px" align="center"></p><h3 id="MD5-加密-加盐"><a href="#MD5-加密-加盐" class="headerlink" title="MD5 加密+加盐"></a>MD5 加密+加盐</h3><blockquote><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p></blockquote><p>加盐很好理解，就是给原始密码加上特定的字符串，这样给攻击者增加攻击的成本，加盐的关键在于如何选择盐。</p><h4 id="固定字符串"><a href="#固定字符串" class="headerlink" title="固定字符串"></a>固定字符串</h4><p><strong>MD5(Password+UserName)</strong>，即将用户名和密码字符串相加再 MD5，这样的 MD5 摘要基本上不可反查。<br>但有时候用户名可能会发生变化，发生变化后密码即不可用了（验证密码实际上就是再次计算摘要的过程）。</p><h4 id="随机字符串"><a href="#随机字符串" class="headerlink" title="随机字符串"></a>随机字符串</h4><p>盐一般要求是固定长度的随机字符串，且每个用户的盐不同，比如10位，数据库可以这样存储：</p><table><thead><tr><th>Username</th><th>Password</th><th>Salt</th></tr></thead><tbody><tr><td>Freya</td><td>26b74fc2e533289be4dae7018806d978</td><td>63UrCwJhTH</td></tr><tr><td>Asher</td><td>05e213b017e654d6edc134751bc9319f</td><td>84GljVnhDT</td></tr></tbody></table><p>采用加密方式 <code>MD5(MD5(password) + salt)</code></p><p><strong>注：以随机字符串作为盐对密码进行加盐仅仅是增加破解密码的难度，可以减少数据库泄露密码以后被破译的风险</strong>。</p><h3 id="计算文件的-MD5-校验值"><a href="#计算文件的-MD5-校验值" class="headerlink" title="计算文件的 MD5 校验值"></a>计算文件的 MD5 校验值</h3><p>在命令行下，可以使用 Windows 自带的 <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/certutil" target="_blank" rel="noopener">certuti</a>l 命令来计算一个文件的校验值。</p><p>certutil 支持的算法有：MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512。</p><p>certutil 的使用方法非常简单，只需要执行<code>certutil -hashfile 文件名 校验值类型</code>，即可计算出对应文件的校验值。也可以使用 <a href="http://www.pc-tools.net/win32/md5sums/" target="_blank" rel="noopener">md5sums</a> 或 <a href="http://keir.net/hash.html" target="_blank" rel="noopener">hash</a> 工具进行计算。</p><p>Linux 下可以直接使用 md5sum/sha1sum/sha256sum 等命令直接计算文件的对应校验值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-MD5&quot;&gt;&lt;a href=&quot;#什么是-MD5&quot; class=&quot;headerlink&quot; title=&quot;什么是 MD5&quot;&gt;&lt;/a&gt;什么是 MD5&lt;/h2&gt;&lt;p&gt;MD5 是 &lt;strong&gt;Message-Digest algorithm 5&lt;/strong&gt;（
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MD5" scheme="https://muhouer.github.io/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>HTTP与HTTPS的区别</title>
    <link href="https://muhouer.github.io/posts/80f14f93/"/>
    <id>https://muhouer.github.io/posts/80f14f93/</id>
    <published>2019-08-30T15:08:09.000Z</published>
    <updated>2019-08-30T15:13:56.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://www.runoob.com/w3cnote/http-vs-https.html" target="_blank" rel="noopener">HTTP 与 HTTPS 的区别</a></p></blockquote><img src="/images/201908301109.png" width="800px" height="300px" align="center"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><strong>HTTP</strong>（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。</p><p>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 <strong>http://</strong> 打头的都是标准 HTTP 服务。</p><p>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><strong>HTTPS</strong>（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 <a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS</a> 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><p>HTTPS 默认工作在 TCP 协议 443 端口，它的工作流程一般如以下方式：</p><ol><li>TCP 三次同步握手</li><li>客户端验证服务器数字证书</li><li>DH 算法协商对称加密算法的密钥、hash 算法的密钥</li><li>SSL 安全加密隧道协商完成</li><li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</li></ol><h2 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h2><ul><li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 SSL 握手需要的 9 个包，所以一共是 12 个包。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ul><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><img src="/images/201908301110.png" width="800px" height="300px" align="center"><ul><li>第一次握手：客户端尝试连接服务器，向服务器发送 SYN 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认。</li><li>第二次握手：服务器接收客户端 SYN 包并确认（ack=j+1），同时向客户端发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul><h2 id="HTTPS-的工作原理"><a href="#HTTPS-的工作原理" class="headerlink" title="HTTPS 的工作原理"></a>HTTPS 的工作原理</h2><p>我们都知道 HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议。</p><img src="/images/201908301111.png" width="800px" height="300px" align="center"><p><strong>1、客户端发起 HTTPS 请求</strong></p><p>这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。</p><p><strong>2、服务端的配置</strong></p><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。</p><p>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p><p><strong>3、传送证书</strong></p><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><p><strong>4、客户端解析证书</strong></p><p>这部分工作是有客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p><p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p><p><strong>5、传送加密信息</strong></p><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><p><strong>6、服务端解密信息</strong></p><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><p><strong>7、传输加密后的信息</strong></p><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><p><strong>8、客户端解密信息</strong></p><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;原文链接：&lt;a href=&quot;https://www.runoob.com/w3cnote/http-vs-https.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP 与 HTTPS 的区别&lt;/a&gt;&lt;/p&gt;&lt;/blo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java关键字</title>
    <link href="https://muhouer.github.io/posts/b960f15/"/>
    <id>https://muhouer.github.io/posts/b960f15/</id>
    <published>2019-08-29T15:50:42.000Z</published>
    <updated>2019-08-29T16:01:24.369Z</updated>
    
    <content type="html"><![CDATA[<p>Java中各种关键字 transient、instanceof、volatile、final、static 。</p><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a><code>transient</code></h2><p>一个对象只要实现了 Serializable 接口，这个对象就可以被序列化，Java 的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了 Serializable 接口，这个类的所有属性和方法都会自动序列化。</p><p>然而在实际开发过程中，一个类中并不是所有属性都需要进行序列化，打个比方，如果一个用户有一些敏感信息(如密码，银行卡号等)，为了安全起见，不希望在网络操作(主要涉及到序列化操作，本地序列化缓存也适用)中被传输，这些信息对应的变量就可以加上 <code>transient</code> 关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p><p><strong>小结</strong>：</p><ol><li>一旦变量被 transient 修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>transient 关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被 transient 关键字修饰的。变量如果是用户自定义类变量，则该类需要实现 Serializable 接口。</li><li>被 transient 关键字修饰的变量不再能被序列化，一个静态变量不管是否被 transient 修饰，均不能被序列化(静态变量的值不是从序列化得到，而是从 JVM 中得到)。</li></ol><p><strong>注意</strong>：</p><ol><li>Java 中的关键字 <code>transient</code> 是用来标识一个属性不被序列化的，而 JPA 的 <code>@Transient</code> 注解是用来标识一个属性不被持久化到数据库的。</li><li>若实现的是 Externalizable 接口，则没有任何东西可以自动序列化，需要在 writeExternal 方法中进行手工指定所要序列化的变量，这与是否被 transient 修饰无关。</li></ol><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p>可以用来检查对象是否是特定类的实例。比如，当您有一个对超类或接口类型的对象的引用或参数，你想知道实际对象是否有其他类型（通常更具体）时，可以使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Number param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (param <span class="keyword">instanceof</span> Double) &#123;</span><br><span class="line">    System.out.println(<span class="string">"param is a Double"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">    System.out.println(<span class="string">"param is an Integer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (param <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">    <span class="comment">//subclasses of Number like Double etc. implement Comparable</span></span><br><span class="line">    <span class="comment">//other subclasses might not -&gt; you could pass Number instances that don't implement that interface</span></span><br><span class="line">    System.out.println(<span class="string">"param is comparable"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用 instanceof 之前不需要做 null 检查，假如 x 是 null，则 <code>x instanceof SomeClass</code> 就是 false。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h2><p>参考 <a href="/posts/ce0f712d/" title="volatile关键字">volatile关键字</a></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a><code>final</code></h2><p>在 Java 中，被 <code>final</code> 修饰代表不能被改变。</p><ol><li>final 修饰的类不能被继承，但是可以继承其他类。</li><li>inal 修饰的变量在定义时，必须赋值，并且只能赋值一次</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的引用型变量，变量的值是固定不变的。注意：对象的引用值和对象的属性值！</li></ol><p><strong>注意</strong>：使用 <code>final</code> 关键字它能会提高性能，但充其量只是略微提高。还是根据实际需要去使用。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h2><p>当我们通过 new 关键字去创建对象的时候，那么数据的存储空间才会被分配，类中的成员方法才能被对象所使用。有两种特殊的情况：</p><ol><li>我们通过 new 关键字创建的对象共享同一个资源，而不是说每个对象都拥有自己的数据，或者说根本就不需要去创建对象，这个资源和对象之间是没有关系的。</li><li>希望某个方法不与包含它的类的任何对象联系在一起。</li></ol><p>总结下来就是说：<strong>即使没有创建对象，也能使用属性和调用方法</strong>，static 目的就是在于解决这个问题。</p><ul><li>static 可以修饰变量、方法。</li><li>被 static 修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</li><li>在类被加载的时候，就会去加载被 static 修饰的部分。</li><li>被 static 修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li></ul><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>被 static 修饰的成员变量叫做静态变量，也叫做类变量，说明这个变量是属于这个类的，而不是属于是对象，没有被 static 修饰的成员变量叫做实例变量，说明这个变量是属于某个具体的对象的。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>被 static 修饰的方法也叫做静态方法，因为对于静态方法来说是不属于任何实例对象的，那么就是说在静态方法内部是不能使用 this 的，因为既然不属于任何对象，那么就更谈不上 this 了。</p><p>Java 嵌套类分为两种，静态嵌套类和非静态嵌套类，其中非静态嵌套类才是真正的内部类。</p><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a><code>enum</code></h2><p>参考 <a href="/posts/4502a76f/" title="枚举类型">枚举类型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中各种关键字 transient、instanceof、volatile、final、static 。&lt;/p&gt;&lt;h2 id=&quot;transient&quot;&gt;&lt;a href=&quot;#transient&quot; class=&quot;headerlink&quot; title=&quot;transient&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java语法糖</title>
    <link href="https://muhouer.github.io/posts/a0d19409/"/>
    <id>https://muhouer.github.io/posts/a0d19409/</id>
    <published>2019-08-28T17:22:00.000Z</published>
    <updated>2019-09-11T15:16:12.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>语法糖(Syntactic Sugar)，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法。这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p><blockquote><p>语法盐(Syntactic Salt)是指在计算机语言设计中，不容易产生不良代码的特性。可以为容易犯的语法错误加上的额外语法限制，比如类型检查。</p><p>语法糖精也叫语法糖浆，指的是未能让编程更加方便的附加语法，一说是设计失败的语法糖。这个语法又麻烦又没用。</p><p>语法海洛因，是指过于喜欢操作符重载，使得程序表面上紧凑。操作符重载就是把已经定义的、有一定功能的操作符进行重新定义，来完成更为细致具体的运算等功能。操作符重载可以将概括性的抽象操作符具体化，便于外部调用而无需知晓内部具体运算过程。</p></blockquote><p>我们所熟知的编程语言中几乎都有语法糖。很多人说 Java 是一个 “低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在 “Project Coin” 项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着 “高糖” 的方向发展。</p><h2 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h2><p>语法糖的存在主要是方便开发人员使用。但其实，Java 虚拟机并不支持这些语法糖，这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</p><p><code>com.sun.tools.javac.main.JavaCompiler</code> 的源码中，compile() 有一个步骤就是调用 desugar() ，这个方法就是负责解语法糖的。</p><p>Java 中最常用的语法糖主要有 switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、foreach、try-with-resource、Lambda表达式等</p><h3 id="switch-支持-String-与枚举"><a href="#switch-支持-String-与枚举" class="headerlink" title="switch 支持 String 与枚举"></a>switch 支持 String 与枚举</h3><p>进行<code>switch</code>的实际是哈希值，然后通过使用<code>equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 switch 或者使用纯整数常量，但这也不是很差。</p><p>参考 <a href="/posts/4a48cd1d/" title="String分析">String分析</a></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>不同的编译器对于泛型的处理方式是不同的。通常情况下，一个编译器处理泛型有两种方式：<strong>Code specialization</strong>和 <strong>Code sharing</strong>。C++ 和 C#是使用 Code specialization 的处理机制，而 Java 使用的是 Code sharing 的处理机制。</p><p>Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。</p><p>也就是说，对于 Java 虚拟机来说，他根本不认识 <code>Map&lt;String, String&gt; map</code>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</p><p>参考 <a href="/posts/4127871b/" title="Java泛型解析">Java泛型解析</a></p><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱。</p><p>反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</p><p>原始类型 byte、short、char、int、long、float、double 和 boolean 对应的封装类为 Byte、Short、Character、Integer、Long、Float、Double、Boolean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;        </span><br><span class="line">Integer n = i; <span class="comment">//  装箱：Integer n = Integer.valueOf(i); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">Integer i = <span class="number">10</span>; <span class="comment">// Integer i = Integer.valueOf(10); </span></span><br><span class="line"><span class="keyword">int</span> n = i; <span class="comment">//  拆箱：int n = i.intValue(); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法变长参数"><a href="#方法变长参数" class="headerlink" title="方法变长参数"></a>方法变长参数</h3><p>可变参数 (<code>variable arguments</code>) 是在 Java 1.5 中引入的一个特性，它允许一个方法把任意数量的值作为参数。</p><p>可变参数在被使用的时候：</p><ol><li>首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数。</li><li>然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>Java SE5 提供了一种新的类型-Java 的枚举类型，关键字<code>enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p><p>当我们使用<code>enmu</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code>final</code>类型的类继承<code>Enum</code>类，所以枚举类型不能被继承。</p><p>参考 <a href="/posts/4502a76f/" title="枚举类型">枚举类型</a></p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。</p><p>Outer.java 里面定义了一个内部类 Inner，一旦编译成功，就会生成两个完全不同的 .class 文件了，分别是 Outer.class 和 Outer$Inner.class。所以<strong>内部类的名字完全可以和它的外部类名字相同</strong>。</p><p>匿名内部类也会被当作普通的类处理，只不过编译器生成它构造方法的时候，除了将外部类的引用传递了过来，还将基本数据类型的变量复制了一份过来，并把引用数据类型的变量引用也传递了过来。因此，基本数据类型的变量不能修改，不然就会跟外部的变量产生不一致，这样的话变量的传递也就变得毫无意义。</p><p>final 关键字除了能让类不能被继承之外，对应到这种场景，就是让变量也不能被重新赋值。</p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>C、C++ 等许多语言提供了预处理的功能，并通过预处理来实现条件编译。Java 并没有提供类似的预处理功能，但是 Java 也可以实现条件编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"block 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断言语句"><a href="#断言语句" class="headerlink" title="断言语句"></a>断言语句</h3><p>断言在编译过后被转化成了语句所处类中的一个 static final boolean 字段，并在类初始化阶段借助静态语句块完成其初始化。在程序执行过程中，直接根据该字段判断断言是否开启，来决定是否执行断言检查。</p><h3 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a>数值字面量</h3><h4 id="支持的数字字面量表示"><a href="#支持的数字字面量表示" class="headerlink" title="支持的数字字面量表示"></a>支持的数字字面量表示</h4><p>十进制：默认的。</p><p>八进制：整数之前加数字 0 来表示。</p><p>十六进制：整数之前加“0x”或“0X”来表示。</p><p>二进制：整数之前加“0b”或“0B”来表示。</p><h4 id="在数值字面量中使用下划线"><a href="#在数值字面量中使用下划线" class="headerlink" title="在数值字面量中使用下划线"></a>在数值字面量中使用下划线</h4><p>在 Java 7 中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1_500_000 </span><br><span class="line">5_6.3_4 </span><br><span class="line">89_3___1</span><br></pre></td></tr></table></figure><blockquote><p><strong>下划线只能出现在数字中间，前后必须是数字。</strong>所以<code>_100</code>、<code>0b_101</code>是不合法的，无法通过编译。<br>这样限制的动机就是可以降低实现的复杂度。有了这个限制，Java 编译器只需在扫描源代码的时候将所发现的数字中间的下划线直接删除就可以了。如果不添加这个限制，编译器需要进行语法分析才能做出判断。比如：<code>_100</code>,可能是一个整数字面量 100，也可能是一个变量名称。这就要求编译器的实现做出更复杂的改动。</p></blockquote><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ul><li>对有实现 Iterable 接口的对象采用 foreach 语法糖的话，编译器会将这个 for 关键字转化为对目标的迭代器使用。如果要想使自己自定义的类可以采用foreach语法糖就必须实现Iterable接口。</li><li>对于数组而言，其实就是转换为普通的遍历。</li><li>对于实现 RandomAccess 接口的集合比如 ArrayList，应当使用最普通的 for 循环而不是 foreach 循环来遍历。</li></ul><p>实现 RandomAccess 接口的类实例，假如是随机访问的，使用普通 for 循环效率将高于使用 foreach 循环；反过来，如果是顺序访问的，则使用 Iterator 会效率更高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterable(); </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">      iterator.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。编译之后会判断对象是否为 null，如果不是 null，则调用 close 函数进行资源回收。</p><p>所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。不同的是 java.io.Closable 要求实现者保证 close 函数可以被重复调用。而 java.lang.AutoCloseable 的close 函数则不要求是幂等的。</p><p>try-with-resources 声明在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>TODO 待补充</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>javap 是 JDK 自带的反汇编器，可以查看 java 编译器为我们生成的字节码。通过它，我们可以对照源代码和字节码，从而了解很多编译器内部的工作。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>  <code>javap [option] class</code><br>javap 命令用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。</p><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><p>-help 输出 javap 的帮助信息。<br>-l 输出行及局部变量表。<br>-b 确保与 JDK 1.1 javap 的向后兼容性。<br>-public 只显示 public 类及成员。<br>-protected 只显示 protected 和 public 类及成员。<br>-package 只显示包、protected 和 public 类及成员。这是缺省设置。<br>-private 显示所有类和成员。<br>-J[flag] 直接将 flag 传给运行时系统。<br>-s 输出内部类型签名。<br>-c 输出类中各方法的未解析的代码，即构成 Java 字节码的指令。<br>-verbose 输出堆栈大小、各方法的 locals 及 args 数,以及class文件的编译版本<br>-classpath[路径] 指定 javap 用来查找类的路径。如果设置了该选项，则它将覆盖缺省值或 CLASSPATH 环境变量。目录用冒号分隔。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语法糖&quot;&gt;&lt;a href=&quot;#语法糖&quot; class=&quot;headerlink&quot; title=&quot;语法糖&quot;&gt;&lt;/a&gt;语法糖&lt;/h2&gt;&lt;p&gt;语法糖(Syntactic Sugar)，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="语法糖" scheme="https://muhouer.github.io/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
  </entry>
  
  <entry>
    <title>编码方式杂记</title>
    <link href="https://muhouer.github.io/posts/d6bee64/"/>
    <id>https://muhouer.github.io/posts/d6bee64/</id>
    <published>2019-08-28T16:11:08.000Z</published>
    <updated>2019-08-28T16:14:00.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ASCII-Unicode-UTF-8"><a href="#ASCII-Unicode-UTF-8" class="headerlink" title="ASCII - Unicode - UTF-8"></a>ASCII - Unicode - UTF-8</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p><p>ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p><p>汉字使用的符号多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号，所以，中国制定了GB2312编码，用来把中文编进去。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode应运而生，Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。具体的符号对应表，可以查询<a href="http://www.unicode.org/" target="_blank" rel="noopener">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字对应表</a>。</p><p>不过，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。这就导致 Unicode 有多种存储方式，即有许多种不同的二进制格式，可以用来表示 Unicode。如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是<code>0</code>，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>互联网的普及，强烈要求出现一种统一的编码方式。<strong>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式</strong>。浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器。很多网页的源码上会有类似 <code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的 UTF-8 编码。</p><p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>UTF-8 的编码规则很简单，只有二条：</p><ol><li><p>对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p></li><li><p>对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围      |        UTF-8编码方式</span><br><span class="line">(十六进制)           |              （二进制）</span><br><span class="line">--------------------+------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p>例如：<br><img src="/images/201908281058.png" width="800px" height="500px" align="center"></p><h2 id="UTF-8、UTF-16、UTF-32区别"><a href="#UTF-8、UTF-16、UTF-32区别" class="headerlink" title="UTF-8、UTF-16、UTF-32区别"></a>UTF-8、UTF-16、UTF-32区别</h2><p>UTF 意思是 Unicode 转换格式(Unicode Transform Format)， UTF-8、UTF-16、UTF-32 是为了在内存中存储字符而对 Unicode 字符编号进行编码。它们都是 Unicode 的实现方式，其中 <strong>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式</strong>。<strong>UTF-16(字符用 2 个字节或 4 个字节表示)</strong> 和 <strong>UTF-32(字符用 4 个字节表示)</strong>，不过在互联网上基本不用。</p><p>UTF-16 使用 2 或 4 个字节进行存储。对于 Unicode 编号范围在 0~FFFF 之间的字符，统一用两个字节存储，无需字符转换，直接存储 Unicode 编号。对于 Unicode 字符编号在 10000-10FFFF 之间的字符，UTF16 用 4 个字节存储。</p><p>UTF-32 用固定长度的字节存储字符编码，不管 Unicode 字符编号需要几个字节，全部都用 4 个字节存储，直接存储 Unicode 编号。无需经过字符编号向字符编码的转换步骤，提高效率，用空间换时间。</p><h2 id="GB2312、GBK、GB18030、GB13000之间的区别"><a href="#GB2312、GBK、GB18030、GB13000之间的区别" class="headerlink" title="GB2312、GBK、GB18030、GB13000之间的区别"></a>GB2312、GBK、GB18030、GB13000之间的区别</h2><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p><strong>GB2312 或 GB2312-80 是中国国家标准简体中文字符集</strong>，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持 GB2312。<br>，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。</p><ul><li>GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。</li><li>对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。</li></ul><p><strong>GB2312对任意一个图形字符都采用两个字节表示</strong>，并对所收汉字进行了“分区”处理，每区含有94个汉字／符号，分别对应第一字节和第二字节。这种表示方式也称为区位码。</p><ul><li>01-09区为特殊符号。</li><li>16-55区为一级汉字，按拼音排序。</li><li>56-87区为二级汉字，按部首／笔画排序。</li></ul><p>10-15区及88-94区则未有编码。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p><strong>GBK</strong>即，为汉语拼音 Kuo Zhan（扩展）中“扩”字的声母。英文全称Chinese Internal Code Specification。</p><ul><li>GB2312中的全部汉字、非汉字符号。</li><li>BIG5中的全部汉字。</li><li>与ISO 10646相应的国家标准GB13000中的其它CJK汉字，以上合计20902个汉字。</li><li>其它汉字、部首、符号，共计984个。</li></ul><p>GBK向下与GB2312 完全兼容，向上支持ISO 10646国际标准，在前者向后者过渡过程中起到的承上启下的作用。</p><p><strong>GBK 采用双字节表示</strong>，总体编码范围为8140-FEFE之间，首字节在81-FE之间，尾字节在40-FE之间，剔除XX7F一条线。GBK编码区分三部分：</p><ul><li><p>汉字区</p><ul><li>GBK/2：OXBOA1-F7FE，收录GB2312汉字6763个，按原序排列。</li><li>GBK/3：OX8140-AOFE，收录CJK汉字6080个。</li><li>GBK/4：OXAA40-FEAO，收录CJK汉字和增补的汉字8160个。</li></ul></li><li><p>图形符号区</p><ul><li>GBK/1：OXA1A1-A9FE，除GB2312的符号外，还增补了其它符号。</li><li>GBK/5：OXA840-A9AO，扩除非汉字区。</li></ul></li><li><p>用户自定义区</p><ul><li>GBK区域中的空白区，用户可以自己定义字符。</li></ul></li></ul><p>GBK 最初是由微软对 GB2312 的扩展，也就是CP936字码表 (Code Page 936)的扩展（原来的CP936和GB 2312-80一模一样），最初出现于Windows 95简体中文版中，由于Windows产品的流行和在大陆广泛被使用，中华人民共和国国家有关部门将其作为技术规范。<strong>注意 GBK 并非国家正式标准，只是国家技术监督局标准化司、电子工业部科技与质量监督司发布的“技术规范指导性文件”。</strong>虽然 GBK 收录了所有 Unicode 1.1 及 GB 13000.1-93 之中的汉字，但是编码方式与 Unicode 1.1 及 GB 13000.1-93 不同。仅仅是 GB2312 到 GB13000.1-93 之间的过渡方案。GBK 收录了 21886 个符号，它分为汉字区和图形符号区。汉字区包括 21003 个字符。</p><p>GBK 作为对 GB2312 的扩展，在现在的 Windows 系统中仍然使用代码页 CP936 表示，但是同样的 936 的代码页跟一开始的 936 的代码页只支持 GB2312 编码不同，现在的 936 代码页支持 GBK 的编码，GBK 同时也向下兼容 GB2312 编码。</p><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p><strong>GB18030</strong>，全称是中华人民共和国现时最新的内码字集，是GB18030-2000《信息技术信息交换用汉字编码字符集基本集的扩充》的修订版。</p><p><strong>GB18030</strong> 与 <strong>GB2312-1980</strong> 完全兼容，与 GBK 基本兼容，支持 GB13000 及 Unicode 的全部统一汉字，共收录汉字 70244 个。</p><ul><li>与 UTF-8 相同，采用多字节编码，每个字可以由1个、2个或4个字节组成。</li><li>编码空间庞大，最多可定义161万个字符。</li><li>支持中国国内少数民族的文字，不需要动用造字区。</li><li>汉字收录范围包含繁体汉字以及日韩汉字</li></ul><p><strong>GB18030 编码是一二四字节变长编码。</strong></p><ul><li>单字节，其值从0到0x7F，与 ASCII 编码兼容。</li><li>双字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x40到0xFE（不包括0x7F），与 GBK标准基本兼容。</li><li>四字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节从0x81到0xFE，第四个字节从0x30到0x39。</li></ul><p>2000 年的 GB18030 取代了 GBK1.0 的正式国家标准。该标准收录了 27484 个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的 PC 平台必须支持 GB18030，对嵌入式产品暂不作要求。所以手机、MP3 一般只支持 GB2312。</p><p>GB18030 在 Windows 中的代码页是 CP54936。</p><h3 id="GB13000"><a href="#GB13000" class="headerlink" title="GB13000"></a>GB13000</h3><p>GB13000 等同于国际标准的《通用多八位编码字符集 (UCS)》 ISO10646.1，就是等同于 Unicode 的标准，代码页等等的都使用 UTF 的一套标准。</p><p>从 ASCII、GB2312、GBK 到 GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为 0。按照程序员的称呼，GB2312、GBK 到 GB18030 都属于双字节字符集 (DBCS)。</p><h2 id="URL编解码"><a href="#URL编解码" class="headerlink" title="URL编解码"></a>URL编解码</h2><p>一般来说，网页URL只能使用英文、数字、还有一些特定的字符。根据网络标准<a href="http://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">RFC 1738</a>做了硬性规定：</p><blockquote><p>只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!*’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。</p></blockquote><p>如果 URL中包括中文等字符，就必须经过编码后使用，否则传给服务器的 request URL 就会包含乱码，服务器无法正确识别。因为RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定，所以导致“URL编码”领域非常混乱。想要了解浏览器多种情况下的编码处理，可以参考阮一峰大神的<a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">关于URL编码</a>。</p><ol><li><strong>网址路径的编码，用的是utf-8编码。</strong></li><li><strong>查询字符串的编码，用的是操作系统的默认编码。</strong></li><li><strong>GET和POST方法的编码，用的是网页的编码。</strong></li><li><strong>在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码。</strong></li></ol><p>不同的操作系统、不同的浏览器、不同的网页字符集，将导致完全不同的编码结果，为了保证客户端只用一种编码方法向服务器发出请求，可以使用 Javascript 先对 URL 编码，然后再向服务器提交，不要给浏览器插手的机会。</p><p>编码方法有三种：<code>escape(url)</code>、<code>encodeURL(url)</code>、<code>encodeURLComponent(url)</code></p><p>解码方法也有三种: <code>unescape(url)</code>、<code>decodeURL(url)</code>、<code>decodeURLComponent(url)</code></p><table><thead><tr><th>方法</th><th>规则</th><th>特点</th></tr></thead><tbody><tr><td>escape、unescape</td><td>除了ASCII字母、数字、标点符号”@ * _ + - . /“以外，对其他所有字符进行编码</td><td>它的作用是返回一个字符的 Unicode 编码值。现在已经不提倡使用这种方法了，它不能直接运用与 URL 编码。</td></tr><tr><td>encodeURI（编码）decodeURI（解码）</td><td>除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码</td><td>encodeURI() 是 Javascript 中真正用来对 URL 编码的函数，它着眼于对整个URL 进行编码</td></tr><tr><td>encodeURIComponent（编码）decodeURIComponent解码）</td><td>在encodeURI()中不被编码的符号”; / ? : @ &amp; = + $ , #”，在encodeURIComponent()中统统会被编码</td><td>与 encodeURI() 的区别是，它用于对 URL 的组成部分进行个别编码，而不用于对整个URL进行编码。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> url = <span class="string">"https://www.zhihu.com/question/342936488/answer/804030108"</span>;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; <span class="built_in">escape</span>(url)</span><br><span class="line"><span class="string">"https%3A//www.zhihu.com/question/342936488/answer/804030108"</span></span><br><span class="line">&gt; <span class="built_in">encodeURI</span>(url)</span><br><span class="line"><span class="string">"https://www.zhihu.com/question/342936488/answer/804030108"</span></span><br><span class="line">&gt; <span class="built_in">encodeURIComponent</span>(url)</span><br><span class="line"><span class="string">"https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F342936488%2Fanswer%2F804030108"</span></span><br></pre></td></tr></table></figure><h2 id="Big-Endian-和-Little-Endian"><a href="#Big-Endian-和-Little-Endian" class="headerlink" title="Big Endian 和 Little Endian"></a>Big Endian 和 Little Endian</h2><ul><li><strong>Little-endian：将低序字节存储在起始地址（低位编址）</strong></li><li><strong>Big-endian：将高序字节存储在起始地址（高位编址）</strong></li></ul><p>例如，如果我们将 0x1234abcd 写入到以 0x0000 开始的内存中，则结果为：</p><table><thead><tr><th>address</th><th>big-endian</th><th>little-endian</th></tr></thead><tbody><tr><td>0x0000</td><td>0x12</td><td>0xcd</td></tr><tr><td>0x0001</td><td>0x34</td><td>0xab</td></tr><tr><td>0x0002</td><td>0xab</td><td>0x34</td></tr><tr><td>0x0003</td><td>0xcd</td><td>0x12</td></tr></tbody></table><p>对于字节序列的存储格式，目前有两大阵营，那就是 Motorola 的 PowerPC 系列 CPU 和 Intel 的 x86 系列 CPU。PowerPC 系列采用 big endian 方式存储数据，而 x86 系列则采用 little endian 方式存储数据。</p><p>所有网络协议也都是采用 big endian 的方式来传输数据的。所以有时我们也会把 big endian 方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。</p><p>目前应该 little endian 是主流，因为在数据类型转换的时候（尤其是指针转换）不用考虑地址问题。</p><p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p><p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用 big endian 方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用 little endian 方式。</p><h2 id="如何解决乱码问题"><a href="#如何解决乱码问题" class="headerlink" title="如何解决乱码问题"></a>如何解决乱码问题</h2><p>乱码本质上都是由于<strong>字符串原本的编码格式与读取时解析用的编码格式不一致导致的</strong>。</p><h3 id="网页乱码问题"><a href="#网页乱码问题" class="headerlink" title="网页乱码问题"></a>网页乱码问题</h3><ul><li>服务器返回的响应头 Content-Type 指明字符编码。</li><li>网页内使用 meta http-equiv 标签指定字符编码。</li><li>网页文件本身存储时使用的字符编码和网页声明的字符编码一致。</li></ul><h3 id="Java代码乱码问题"><a href="#Java代码乱码问题" class="headerlink" title="Java代码乱码问题"></a>Java代码乱码问题</h3><ul><li><p>使用 getBytes() 方法指定编码。</p></li><li><p>使用字节流时指定编码。</p></li><li><p>使用 new String() 时指定编码。</p></li><li><p>使用 HttpClient post请求时指定编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求实体</span></span><br><span class="line">HttpEntity reqEntity = <span class="keyword">new</span> ByteArrayEntity(reqStr.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">httpPost.setEntity(reqEntity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求实体</span></span><br><span class="line">StringEntity reqEntity = <span class="keyword">new</span> StringEntity(reqStr, Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">httpPost.setEntity(reqEntity);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ASCII-Unicode-UTF-8&quot;&gt;&lt;a href=&quot;#ASCII-Unicode-UTF-8&quot; class=&quot;headerlink&quot; title=&quot;ASCII - Unicode - UTF-8&quot;&gt;&lt;/a&gt;ASCII - Unicode - UTF-8&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java中的基本类型</title>
    <link href="https://muhouer.github.io/posts/3f6a1294/"/>
    <id>https://muhouer.github.io/posts/3f6a1294/</id>
    <published>2019-08-27T16:06:49.000Z</published>
    <updated>2019-08-27T16:11:35.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>Java 中有 8 种基本数据类型，分为三大类。</p><ol><li><p>字符型：<code>char</code></p></li><li><p>布尔型：<code>boolean</code></p></li><li><p>数值型：</p><ol><li>整型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>浮点型：<code>float</code>、<code>double</code></li></ol></li></ol><p>String 不是基本数据类型，是引用类型。</p><h2 id="整型中byte、short、int、long的取值范围"><a href="#整型中byte、short、int、long的取值范围" class="headerlink" title="整型中byte、short、int、long的取值范围"></a>整型中byte、short、int、long的取值范围</h2><p>Java 中的整型主要包含 byte、short、int 和 long 这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。</p><ul><li>byte：byte 用 1 个字节来存储，范围为 -128(-2^7) 到 127(2^7-1)，在变量初始化的时候，byte类型的默认值为 0。</li><li>short：short 用 2 个字节存储，范围为 -32768 (-2^15) 到 32767 (2^15-1)，在变量初始化的时候，short类型的默认值为0，一般情况下，因为 Java 本身转型的原因，可以直接写为 0。</li><li>int：int 用 4 个字节存储，范围为 -2147483648 (-2^31) 到 2147483647 (2^31-1)，在变量初始化的时候，int类型的默认值为 0。</li><li>long：long 用 8 个字节存储，范围为 -9223372036854775808 (-2^63) 到 9223372036854775807 (2^63-1)，在变量初始化的时候，long 类型的默认值为 0L 或 0l，也可直接写为 0。</li></ul><p>整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。</p><p>溢出的时候并不会抛异常，也没有任何提示。所以，在程序中，使用同类型的数据进行运算的时候，一定要注意数据溢出的问题。</p><h2 id="什么是浮点型"><a href="#什么是浮点型" class="headerlink" title="什么是浮点型"></a>什么是浮点型</h2><p>在计算机科学中，浮点是一种对于实数的近似值数值表现法，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（floating-point number）。</p><p>计算机使用浮点数运算的主因，在于电脑使用二进位制的运算。例如：4÷2=2，4的二进制表示为100、2的二进制表示为010，在二进制中，相当于退一位数(100 -&gt; 010)。</p><p>1 的二进制是 01，1.0/2=0.5，那么，0.5 的二进制表示应该为(0.1)，以此类推，0.25的二进制表示为0.01，所以，并不是说所有的十进制小数都能准确的用二进制表示出来，如 0.1，因此只能使用近似值的方式表达。</p><p>也就是说，十进制的小数在计算机中是由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到的，这种表示方法类似于基数为 10 的科学计数法。</p><p>一个浮点数a由两个数m和e来表示：a = m × be。在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd…ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1）。如果m的第一位是非0整数，m称作正规化的。有一些描述使用一个单独的符号位（s 代表+或者-）来表示正负，这样m必须是正的。e是指数。</p><p>位(bit)是衡量浮点数所需存储空间的单位，通常为32位或64位，分别被叫作单精度和双精度。</p><p>单精度浮点数在计算机存储器中占用 4 个字节(32 bits)，利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。</p><p>比起单精度浮点数，双精度浮点数(double)使用 8 个字节(64 bits) 来存储一个浮点数。</p><p><strong>注意</strong>：由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。</p><p><strong>建议使用BigDecimal或者Long（单位为分）来表示金额。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;p&gt;Java 中有 8 种基本数据类型，分为三大类。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;字符型：&lt;code&gt;char&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么Java中byte类型的取值范围为-128~127?</title>
    <link href="https://muhouer.github.io/posts/ca021682/"/>
    <id>https://muhouer.github.io/posts/ca021682/</id>
    <published>2019-08-27T15:45:14.000Z</published>
    <updated>2019-08-27T15:52:45.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：探路的淮–Ontheway<br>原文链接：<a href="https://blog.csdn.net/qq_23418393/article/details/57421688" target="_blank" rel="noopener">https://blog.csdn.net/qq_23418393/article/details/57421688</a></p></blockquote><p>在学习 Java 基础语法的时候，初学者的我们可能都会有这么一个疑问为什么 byte 类型的取值范围为什么是 -128 ~ 127 而不是 -127 ~ 127。<code>01111111</code> 表示最大的数值：127，因为第一位是符号位，所以 <code>11111111</code> 应该是最小的数值：-127，不是这样才对？</p><p>在解释这个问题之前我们需要了解几个概念：机器数、真值、原码、反码、补码</p><h2 id="机器数、真值、原码、反码、补码"><a href="#机器数、真值、原码、反码、补码" class="headerlink" title="机器数、真值、原码、反码、补码"></a>机器数、真值、原码、反码、补码</h2><h3 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h3><p>一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为 0，负数为 1。</p><p>比如：十进制中的数 +3 ，计算机字长为 8 位，转换成二进制就是 <code>00000011</code>。如果是 -3 ，就是 <code>10000011</code> 。那么，这里的 <code>00000011</code> 和 <code>10000011</code> 就是机器数。</p><h3 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h3><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 <code>10000011</code>，其最高位 1代表负，其真正数值是 -3 而不是形式值 131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><p>​ 例：0000 0001 的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><p>​ [+1]原 = 0000 0001<br>​ [-1]原 = 1000 0001<br>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]<br>即[-127 , 127]。原码是人脑最容易理解和计算的表示方式.</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>反码的表示方法是：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p><p>​ [+1] = [00000001]原 = [00000001]反<br>​ [-1] = [10000001]原 = [11111110]反</p><p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算。</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码的表示方法是:</p><ol><li><p>正数的补码就是其本身。</p></li><li><p>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 +1。(即在反码的基础上 +1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补<br>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p></li></ol><p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。</p><h2 id="为什么-byte-类型的取值范围为-128-127？"><a href="#为什么-byte-类型的取值范围为-128-127？" class="headerlink" title="为什么 byte 类型的取值范围为 -128~127？"></a>为什么 byte 类型的取值范围为 -128~127？</h2><h3 id="为何计算机内部不使用原码表示一个数？"><a href="#为何计算机内部不使用原码表示一个数？" class="headerlink" title="为何计算机内部不使用原码表示一个数？"></a>为何计算机内部不使用原码表示一个数？</h3><p>现在我们知道了计算机可以有三种编码方式表示一个数，对于正数因为三种编码方式的结果都相同：</p><p>　　[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>但是对于负数:</p><p>　　[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>可见原码，反码和补码是完全不同的。 既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？</p><p>首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即: <code>1-1 = 1 + (-1) = 0</code> ，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。</p><p>于是人们开始探索 将符号位参与运算，并且只保留加法的方法。首先来看原码：</p><p>　　计算十进制的表达式: 1-1=0</p><p>　　1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p><p>如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。</p><h3 id="反码的诞生"><a href="#反码的诞生" class="headerlink" title="反码的诞生"></a>反码的诞生</h3><p>为了解决原码做减法的问题，出现了反码：</p><p>　　计算十进制的表达式: 1-1=0</p><p>　　1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p><p>发现用反码计算减法，结果的真值部分是正确的。而唯一的问题其实就出现在”0”这个特殊的数值上。虽然人们理解上 +0 和 -0 是一样的，但是 0 带符号是没有任何意义的。而且会有 [0000 0000]原 和 [1000 0000]原 两个编码表示 0。</p><h3 id="补码的诞生"><a href="#补码的诞生" class="headerlink" title="补码的诞生"></a>补码的诞生</h3><p>补码的出现，解决了 0 的符号以及两个编码的问题：</p><p>　　1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 =[0000 0001]反 + [1111 1110]反= [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p><p>这样0用 [0000 0000] 表示，而以前出现问题的 -0 则不存在了。而且可以用 [1000 0000] 表示-128：</p><p>　　(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p><p>-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补 就是 -128。但是注意因为实际上是使用以前的 -0 的补码来表示 -128, 所以 -128 并没有原码和反码表示。(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)，使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，<strong>使用原码或反码表示的范围为 -127<del>+127， 而使用补码表示的范围为 -128</del>127。</strong></p><p>因为机器使用补码，所以对于编程中常用到的 32 位 int 类型, 可以表示范围是：-2^31~2^31-1 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?</p><p>可以参考：<a href="https://www.cnblogs.com/zhengfengyun/p/5090601.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengfengyun/p/5090601.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者：探路的淮–Ontheway&lt;br&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/qq_23418393/article/details/57421688&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java泛型解析</title>
    <link href="https://muhouer.github.io/posts/4127871b/"/>
    <id>https://muhouer.github.io/posts/4127871b/</id>
    <published>2019-08-26T16:27:00.000Z</published>
    <updated>2019-09-10T17:43:08.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型是什么"><a href="#泛型是什么" class="headerlink" title="泛型是什么"></a>泛型是什么</h2><blockquote><p>泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。</p></blockquote><p>泛型的英文是 generics，generic 的意思是通用,而翻译成中文，泛应该意为广泛，型是类型。所以泛型就是能广泛适用的类型。<strong>但泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。</strong></p><p>Object 是所有类的根类，任何类的对象都可以设置给该 Object 引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T value;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的定义和使用"><a href="#泛型的定义和使用" class="headerlink" title="泛型的定义和使用"></a>泛型的定义和使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>如果一个类被 <code>&lt;T&gt;</code>的形式定义，那么它就被称为是泛型类。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号 &lt;&gt;中的 T 被称作是类型参数，用于指代任何类型。其中T只是一种习惯写法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T field1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，泛型类不至接受一个类型参数，它还可以这样接受多个类型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiType</span>&lt;<span class="title">E</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">E value1;</span><br><span class="line">T value2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getValue1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getValue2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如：</p><ol><li><p>E ——代表 Element (在集合中使用，因为集合中存放的是元素)，或者 Exception 异常的意思</p></li><li><p>T ——代表 Type（一般的任何 Java 类）</p></li><li><p>K——代表 Key（键）</p></li><li><p>V ——代表 Value（值），通常与 K 一起配合使用</p></li><li><p>N——代表 Number（数值类型）</p></li><li><p>？——表示不确定的java类型（无限制通配符类型）</p></li><li><p>S、U、V——代表 2nd、3rd、4th Subtype</p></li></ol><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法与泛型类稍有不同的地方是，类型参数也就是尖括号那一部分是写在返回值前面的。<code>&lt;T&gt;</code>中的 T 被称为类型参数，而方法中的 T 被称为参数化类型，它不是运行时真正的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">testMethodWithReturn</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型方法始终以自己定义的类型参数为准</strong>。即泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的。例如：泛型类的实际类型参数是 String，而传递给泛型方法的类型参数是 Integer，两者不想干。</p><p>但是，为了避免混淆，如果在一个泛型类中存在泛型方法，那么两者的类型参数最好不要同名。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口和泛型类类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限定通配符和非限定通配符"><a href="#限定通配符和非限定通配符" class="headerlink" title="限定通配符和非限定通配符"></a>限定通配符和非限定通配符</h2><p><strong>通配符的出现是为了指定泛型中的类型范围</strong>。</p><p>通配符有 3 种形式。</p><ol><li><code>&lt;?&gt;</code>被称作非限定通配符。</li><li><code>&lt;? extends T&gt;</code>被称作有上界通配符。</li><li><code>&lt;? super T&gt;</code>被称作有下界通配符。</li></ol><p>非限定通配符经常与容器类配合使用，它其中的 ? 其实代表的是未知类型，所以涉及到 ? 时的操作，一定与具体类型无关，类型是未知的。所以，你只能调用使用非限定通配符类中与类型无关的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWildCards</span><span class="params">(Collection&lt;?&gt; collection)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 只能调用 Collection 中与类型无关的方法。</span></span><br><span class="line">  <span class="comment">// 当你调用 add() 方法时，编译会失败。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限定通配符包括两种：</p><ol><li><code>&lt;？extends T&gt;</code> 表示类型的上界，即类型必须为T类型或者T子类。</li><li><code>&lt;？super T&gt;</code> 表示类型的下界，即类型必须为T类型或者T的父类。</li></ol><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>泛型是 Java 1.5 版本才引进的概念，在这之前是没有泛型的概念的，但显然，泛型代码能够很好地和之前版本的代码很好地兼容。</p><p>这是因为，泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</p><p>通俗地讲，泛型类和普通类在 java 虚拟机内是没有什么特别的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">System.out.println(strList.getClass() == intList.getClass()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 <code>&lt;T&gt;</code>则会被转译成普通的 Object 类型，如果指定了上限如 <code>&lt;T extends String&gt;</code>则类型参数就被替换成类型上限。</p><blockquote><p>原始类型 List 和带参数类型之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查。你可以把任何带参数的类型传递给原始类型 List，但却不能把 List 传递给接受 List 的方法，因为会产生编译错误。</p></blockquote><p>类型擦除，它会抹掉很多继承相关的特性，这是它带来的局限性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">integers.add(<span class="number">9</span>);</span><br><span class="line">integers.add(<span class="string">"freya"</span>); <span class="comment">// 由于泛型的限制，编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过基于对类型擦除的了解，利用反射，我们可以绕过这个限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">    integers.add(<span class="number">9</span>);</span><br><span class="line">    <span class="comment">// integers.add("freya");</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Method method = integers.getClass().getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        method.invoke(integers, <span class="string">"freya"</span>);</span><br><span class="line">        method.invoke(integers, <span class="number">10.11f</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(integers); <span class="comment">// [9, freya, 10.11]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类型擦除带来的局限：</p><ol><li>不能是基本类型；因为实际类型是 <code>Object</code>，<code>Object</code> 类型无法持有基本类型。</li><li>不能获取带泛型类型的 Class；因为编译后它们全部都是<code>Xxx&lt;Object&gt;</code>。</li><li>不能判断带泛型类型的类型，并不存在 <code>Xxx&lt;String&gt;.class</code>，而是只有唯一的 <code>Xxx.class</code>。</li><li>不能实例化T类型，例如：new T()。</li><li>泛型方法要防止重复定义方法，例如：public boolean equals(T obj)；编译器会阻止一个实际上会变成覆写的泛型方法定义。</li></ol><h2 id="实例化-T-类型与泛型继承"><a href="#实例化-T-类型与泛型继承" class="headerlink" title="实例化 T 类型与泛型继承"></a>实例化 T 类型与泛型继承</h2><h3 id="实例化-T-类型"><a href="#实例化-T-类型" class="headerlink" title="实例化 T 类型"></a>实例化 T 类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair() &#123;</span><br><span class="line">        // Compile error:</span><br><span class="line">        first = new T();</span><br><span class="line">        last = new T();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无法通过编译，因为构造方法的两行语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = new T();</span><br><span class="line">last = new T();</span><br></pre></td></tr></table></figure><p>擦拭后实际上变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = new Object();</span><br><span class="line">last = new Object();</span><br></pre></td></tr></table></figure><p>这样一来，创建 <code>new Pair&lt;String&gt;()</code> 和创建 <code>new Pair&lt;Integer&gt;()</code> 就全部成了Object，显然编译器要阻止这种类型不对的代码。</p><p>要实例化T类型，我们必须借助额外的Class<t>参数：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码借助 <code>Class&lt;T&gt;</code> 参数并通过反射来实例化T类型，使用的时候，也必须传入 <code>Class&lt;T&gt;</code>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; pair = new Pair&lt;&gt;(String.class);</span><br></pre></td></tr></table></figure><p>因为传入了 <code>Class&lt;String&gt;</code> 的实例，所以我们借助<code>String.class</code> 就可以实例化 <code>String</code> 类型。</p><h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>一个类可以继承自一个泛型类。例如：父类的类型是 <code>Pair&lt;Integer&gt;</code> ，子类的类型是 <code>IntPair</code>，可以这么继承：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class IntPair extends Pair&lt;Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，因为子类 <code>IntPair</code> 并没有泛型类型，所以，正常使用即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntPair ip = new IntPair(1, 2);</span><br></pre></td></tr></table></figure><p>前面讲了，我们无法获取 <code>Pair&lt;T&gt;</code> 的 T 类型，即给定一个变量<code>Pair&lt;Integer&gt; p</code> ，无法从 p 中获取到 <code>Integer</code>类型。但是，在父类是泛型类型的情况下，编译器就必须把类型 T（对IntPair来说，也就是Integer 类型）保存到子类的 class 文件中，不然编译器就不知道 <code>IntPair</code> 只能存取 <code>Integer</code> 这种类型。</p><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：<code>IntPair</code>可以获取到父类的泛型类型 <code>Integer</code> 。获取父类的泛型类型代码比较复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        Type t = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType pt = (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            Type firstType = types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntPair</span><span class="params">(Integer first, Integer last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>泛型类或者泛型方法中，不接受 8 种基本数据类型，需要使用它们对应的包装类。</li><li>Java 不能创建具体类型的泛型数组。这是因为所有的类型信息都被擦除，程序也无法分辨一个数组中的元素类型具体是哪种类型。</li><li>非限定通配符涉及的操作都基本上与类型无关，因此 JVM 不需要针对它对类型作判断，只提供了数组中的元素因为通配符原因，它只能读，不能写。</li><li>如果可以使用泛型的地方，尽量使用泛型。因为它抽离了数据类型与代码逻辑，本意是提高程序代码的简洁性和可读性，并提供可能的编译时类型转换安全检测功能。</li><li>部分反射API是泛型，例如：<code>Class&lt;T&gt;</code>，<code>Constructor&lt;T&gt;</code>；</li><li>可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；可以通过<code>Array.newInstance(Class&lt;T&gt;, int)</code>创建T[]数组，需要强制转型；</li><li>同时使用泛型和可变参数时需要特别小心。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;泛型是什么&quot;&gt;&lt;a href=&quot;#泛型是什么&quot; class=&quot;headerlink&quot; title=&quot;泛型是什么&quot;&gt;&lt;/a&gt;泛型是什么&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="泛型" scheme="https://muhouer.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>拾句-念念不忘</title>
    <link href="https://muhouer.github.io/posts/e5f2c01c/"/>
    <id>https://muhouer.github.io/posts/e5f2c01c/</id>
    <published>2019-08-26T14:52:53.000Z</published>
    <updated>2019-09-01T01:54:08.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="人生除了死亡，其他都是擦伤。"><a href="#人生除了死亡，其他都是擦伤。" class="headerlink" title="人生除了死亡，其他都是擦伤。"></a>人生除了死亡，其他都是擦伤。</h3><blockquote><p><strong>你是在拜佛，还是在拜自己的欲望？</strong><br>正义的反面不是邪恶，正义的反面是别的正义。<br><strong>不知道发⽣了什么，是这个世界；不知道在做什么，是⾃⼰。</strong><br>我的任性是理所当然，别人的任性是不可原谅。<br>如果一切祈祷都为了满足私欲，那所有的美好希望都是一种对别人的诅咒。<br><strong>让花谢的是⻛⾬/让花开的也是⻛⾬/但没了⻛⾬/花不会开也不会落</strong><br>并不是所有⼈都能轻盈地度过这⼀⽣，有些⼈，光是活着就已经竭尽全⼒。<br>我们终其⼀⽣都想成为那个喜欢的⼈，殊不知，⼈⼈都有光彩和阴影，只是有些⼈已经学会了欣赏⾃⼰，并且接纳了阴影。<br>没有⼀朵花，从⼀开始就是花。<br><strong>世界再⼤，不过是⼈与⼈之间的距离。</strong><br>所谓孩⼦，⼤多是在⽗⺟看不⻅的地⽅成⻓起来的。<br>当⼥⼉捡起落叶/我看到⽣命与季节/交汇的点——⼥⼉与秋天》理正道<br>如果房⼦没有窗户，⻔会望着谁。——《⻛适应着这个季节》晚⼭<br>我的身体在寂静中安置⾃⼰，时刻准备着成为灵魂的故乡——《回乡偶书》⾼寒<br><strong>纸质信回信要等⼀个⽉， 电⼦邮件回信等⼀周， LINE回复⼀⼩时。 不⽤等待的⼈⽣真忙碌啊。</strong><br>你认为“谢谢”的反义词是什么？<br>众⽣喧哗归⼀处，万物静默为⼀听。<br>形形⾊⾊的⼈⽣，五味杂陈的故事，百转千回，令⼈回味。<br>不必太纠结于当下，也不必太忧虑未来，当你经历过一些事情的时候，眼前的风景已经和从前不一样了。<br>不解释就弄不懂的事，就意味着怎样解释也弄不懂。——《1Q84》<br><strong>总有一天，你会离开这个世界。所以这辈子要活得更加精彩。</strong></p></blockquote><h3 id="我能承受任何痛苦，只要这种痛苦有意义。"><a href="#我能承受任何痛苦，只要这种痛苦有意义。" class="headerlink" title="我能承受任何痛苦，只要这种痛苦有意义。"></a>我能承受任何痛苦，只要这种痛苦有意义。</h3><blockquote><p><strong>遇到真正喜欢的人，你才发现之前定的标准都是空话。</strong><br>天裂了，去缝起。<br><strong>欲望本身没有对错善恶，只有当与规则碰撞，人对欲望的态度才显示出丑陋或者善良的一面。</strong><br>要有耐性，不要操之过急。越是心平气和，越有成绩。时时刻刻要承认自己是笨伯，不怕做笨功夫，那就不会期待太切，稍不进步就慌乱了。——傅雷<br>北美地区有一种蝉叫做“十七年蝉”，这种蝉从幼卵变成若虫以后将钻入地下蛰伏，在阴暗的泥土与恶劣的环境中度过17年的时间，在隐忍与煎熬中经历漫长的成长历程。在这17年当中，它们早就被人遗忘，只与孤独相伴，每次蜕变的痛苦只有自己最为清楚。<br><strong>目的虽有，却无路可循；我们称之为路的，无非是踌躇。</strong>——卡夫卡 《误入世界》<br>我有一壶酒，可以慰风尘。尽倾江海里，赠饮天下人。<br>花全开了，开得到处都是，后来就很孤单。——顾城《麦田》<br>诚觉世事尽可原谅，但不知去原谅谁。——木心<br><strong>凡畅言雅俗共赏者，结果都落得俗不可耐。</strong>——木心<br>迷失的人迷失了，相逢的人会再相逢。<br>你问人问题，她若答非所问，便已是答了，毋需再问。——木心<br>怕什么真理无穷，进一寸有一寸的欢喜。——胡适</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;人生除了死亡，其他都是擦伤。&quot;&gt;&lt;a href=&quot;#人生除了死亡，其他都是擦伤。&quot; class=&quot;headerlink&quot; title=&quot;人生除了死亡，其他都是擦伤。&quot;&gt;&lt;/a&gt;人生除了死亡，其他都是擦伤。&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;你是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于减肥</title>
    <link href="https://muhouer.github.io/posts/c8dcfc3f/"/>
    <id>https://muhouer.github.io/posts/c8dcfc3f/</id>
    <published>2019-08-25T10:32:00.000Z</published>
    <updated>2019-08-25T11:10:11.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者: 三木水<br>原文: <a href="https://mp.weixin.qq.com/s/Bgc2DbHBq_tRuMbTukaj9w" target="_blank" rel="noopener">求求珍珠奶茶放过我吧</a></p></blockquote><h2 id="减肥和毅力，没有半毛钱关系。"><a href="#减肥和毅力，没有半毛钱关系。" class="headerlink" title="减肥和毅力，没有半毛钱关系。"></a>减肥和毅力，没有半毛钱关系。</h2><p>很多人在减肥中，遇到的最大的障碍就是：管不住自己的嘴。总是忍不住要多吃，而且，一吃就停不下来。</p><p>就像我的一位女性来访者，30+，极度自律。但是，在减肥这件事上，她却遭遇了滑铁卢。她最大的困扰就是：吃。</p><p>像我一样，吃之前很理性，吃的时候管不住，事后很懊恼，伴随极度的焦虑和自责。有的时候，她还会把这份焦虑转移到伴侣身上，对伴侣发脾气。</p><p>当然，这只不过是对自己无力的这部分的一种向外投射。她说，她用极大的毅力来控制自己不要多吃。为了不吃晚饭，晚餐时，她是不上桌的：家人吃晚饭，她就在旁边找个地方啃个苹果。</p><p>即便这样，“吃”和“不吃”就好像在打游击战一样，在每一个毅力稍稍缺席的地方，“吃”的欲望就会铺天盖地地袭来。吃完之后，又陷入了懊恼、自责和极度的焦虑当中。</p><p>你也许就要问了，不靠毅力控制，那靠什么？</p><p>在提出这个问题的时候，你想的还是控制。</p><p>在回答这个问题之前，我们不妨换个角度，我们为什么对“吃”如此痴迷？那是因为，“吃”给我们带来了很大的快感。</p><p>我的很多痴迷于“吃”的朋友，曾这么跟我说：在吃的时候，让他们感觉到了无比的满足，就好像在天堂，如果不让他们“吃吃吃”一段时间，他们觉得，人生的意义都没有了。</p><p>“人生的意义”“生活的乐趣”“活着的快感”都没有了，这是多么严重的问题。在这样的情况下，你可曾看到，控制“吃”的背后，我们在尝试控制什么。控制“吃”，就是在和自己的人性做对，而和人性做对，这几乎是一场必输的游戏。</p><p>这就是为什么我们这么努力控制，却毫无进展的原因。</p><p>因为，“吃”，这是一件我们控制不了的事情。</p><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><ol><li><strong>想要减肥，不要节食，先满足吃欲。</strong>(少食多餐)</li><li><strong>别着急，慢慢吃。</strong>每一个食物，都是巨大的恩赐，值得好好品味，不可辜负。</li><li>每天或者每周安排一顿饭，放肆的吃。<strong>总有一个时空，我可以“为所欲为”。</strong></li></ol><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>这让我想起了《<a href="https://book.douban.com/subject/27052052/" target="_blank" rel="noopener">人体的故事：进化、健康与疾病</a>》里面的一个观点：</p><blockquote><p>如果他们开始节食或增加运动量，这就意味着他们摄入的热量少于消耗的，那么就会不可避免地变得又饿又累，而这又会激活他们体内的原始冲动：增加食量、减少运动。饥饿和嗜睡是古代的适应机制。</p></blockquote><blockquote><p>失配性疾病，即由于我们旧石器时代的身体不能或不足以适应某些现代行为和条件而导致的疾病。(没有说肥胖是疾病，这是书中解释一些现代社会才会遇到的疾病时提出的名词。)</p></blockquote><p>纵观整个人类历史，人类就好像突然从石器时代进入现代。因为我们人类在石器时代停留的时间为99%，现代才1%不到。人类的进化是缓慢的，已经跟不上现代社会的变化。</p><p>生活越来越好，这点无可否认，可是身体上的那些机能还没有转变过来。所以说，减肥这件事本身就是与人性在作对(还得和社会的审美做抗争)，基本没有胜利的可能。换回的是无尽的纠结、自责、懊恼……</p><p>这有点像电脑在国内刚起步那几年，家长们怕你沉迷，防这个，防那个。可是现在呢，电脑根本不是什么稀奇物，那些 00 后赶上了好时代，刚出生就接触电脑、智能机、平板…… 而石器时代食物匮乏，能吃到东西就很不错了，所以为了活下去，那种对甜食、脂肪的渴望很强烈，或者说有一种瘾。现代社会能吃饱也是近几十年的事情(感谢袁老)，食物极大丰富对体内的原始冲动来说，就像一夜暴富，开始肆意挥霍。</p><p>所以我们需要先满足体内的原始冲动，让它慢慢减弱那种食物匮乏的不安全感，然后驯服它，不过这一切都需要时间和耐心，不能一蹴而就，蛮干换回的只能是纠结、自责、懊恼……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者: 三木水&lt;br&gt;原文: &lt;a href=&quot;https://mp.weixin.qq.com/s/Bgc2DbHBq_tRuMbTukaj9w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;求求珍珠奶茶放过我吧&lt;/a&gt;&lt;/p&gt;&lt;
      
    
    </summary>
    
      <category term="减肥" scheme="https://muhouer.github.io/categories/%E5%87%8F%E8%82%A5/"/>
    
    
  </entry>
  
</feed>

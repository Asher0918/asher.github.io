<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Muhouer</title>
  
  <subtitle>开始记录只需5分钟!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muhouer.github.io/"/>
  <updated>2019-09-13T04:28:16.065Z</updated>
  <id>https://muhouer.github.io/</id>
  
  <author>
    <name>Muhouer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Semaphore解析</title>
    <link href="https://muhouer.github.io/posts/e73eaf42/"/>
    <id>https://muhouer.github.io/posts/e73eaf42/</id>
    <published>2019-09-13T04:15:30.000Z</published>
    <updated>2019-09-13T04:28:16.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Semaphore</code> 是JDK1.5的 <code>java.util.concurrent</code> 并发包中提供的一个并发工具类。所谓 <code>Semaphore</code> 即 信号量 的意思。这个叫法并不能很好地表示它的作用，更形象的说法应该是 许可证管理器 。</p><p><code>Semaphore</code> 是一个计数信号量。</p><ul><li>从概念上将，<code>Semaphore</code> 包含一组许可证。</li><li>如果有需要的话，每个 <code>acquire()</code> 方法都会阻塞，直到获取一个可用的许可证。</li><li>每个 <code>release()</code> 方法都会释放持有许可证的线程，并且归还 <code>Semaphore</code> 一个可用的许可证。</li><li>实际上并没有真实的许可证对象供线程使用，<code>Semaphore</code> 只是对可用的数量进行管理维护。</li></ul><h2 id="Semaphore类结构"><a href="#Semaphore类结构" class="headerlink" title="Semaphore类结构"></a>Semaphore类结构</h2><p><code>Semaphore</code> 类结构如下：</p><img src="/images/Semaphore.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code>、<code>FairSync</code>、<code>NonfairSync</code> 是 <code>Semaphore</code> 的内部类。<code>FairSync</code>、<code>NonfairSync</code> 均继承自 <code>Sync</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NonFair version</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 无论当前线程是不是在 CLH 队列的头部，它都会直接获取信号量。</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fair version</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前线程不在 CLH 队列的头部，则排队等候。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="comment">// 判断当前线程是不是在 CLH 队列的头部</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非公平模式共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享式释放同步状态</span></span><br><span class="line">    <span class="comment">// “非公平信号量许可的释放(release)”与“公平信号量许可的释放(release)”是一样的。 </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减少许可数</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取并返回立即可用的所有许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore-构造方法"><a href="#Semaphore-构造方法" class="headerlink" title="Semaphore 构造方法"></a>Semaphore 构造方法</h2><p>构造方法分为两种，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建具有给定的许可数和非公平模式的 Semaphore</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建具有给定的许可数和指定是否公平模式的 Semaphore</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore-获取、释放许可的方法"><a href="#Semaphore-获取、释放许可的方法" class="headerlink" title="Semaphore 获取、释放许可的方法"></a>Semaphore 获取、释放许可的方法</h2><p>获取、释放许可的方法分为两大类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 阻塞方法：</span></span><br><span class="line"><span class="comment"> * 1. 无许可能够获得，则会一直等待，直到获得许可。</span></span><br><span class="line"><span class="comment"> * 2. 在释放许可之前，必须先获获得许可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 获取一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 获取permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>; <span class="comment">// 释放一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span></span>; <span class="comment">// 释放permits个许可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 非阻塞方法：</span></span><br><span class="line"><span class="comment"> * 立即获取执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"><span class="comment">//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span></span>; </span><br><span class="line"><span class="comment">//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><h2 id="Semaphore的其他方法"><a href="#Semaphore的其他方法" class="headerlink" title="Semaphore的其他方法"></a>Semaphore的其他方法</h2><p>其他方法包括获取当前可用许可数、获取队列正在等待许可的线程数目、是否是公平模式等，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回此信号量中当前可用的许可数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回正在等待获取的线程的估计数目。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取并返回立即可用的所有许可。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 查询是否有线程正在等待获取。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 如果此信号量的公平设置为 true，则返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回标识此信号量的字符串，以及信号量的状态。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 collection，包含可能等待获取的线程。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 根据指定的缩减量减小可用许可的数目。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reduction)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Semaphore的使用"><a href="#Semaphore的使用" class="headerlink" title="Semaphore的使用"></a>Semaphore的使用</h2><p><code>Semaphore</code> 经常用于限制获取某种资源的线程数量。</p><p>以请求总数为 6，并发执行的线程数为 2 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求总数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 并发执行的线程数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 随机数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">      executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire(<span class="number">1</span>);</span><br><span class="line">          System.out.println(<span class="string">"处理请求 "</span> + count + <span class="string">" 前，当前许可证数量："</span> + semaphore.availablePermits());</span><br><span class="line">          resolve(count);</span><br><span class="line">          System.out.println(<span class="string">"处理请求 "</span> + count + <span class="string">" 中，正在等待许可证的请求数量："</span> + semaphore.getQueueLength());</span><br><span class="line">          semaphore.release(<span class="number">1</span>);</span><br><span class="line">          System.out.println(<span class="string">"处理请求 "</span> + count + <span class="string">" 后，当前许可证数量："</span> + semaphore.availablePermits());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolve</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"请求 "</span> + i + <span class="string">" 开始处理"</span>);</span><br><span class="line">    <span class="keyword">int</span> r = random.nextInt(i + <span class="number">3</span>) + <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"请求 "</span> + i + <span class="string">"处理"</span> + r + <span class="string">"秒"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span> * r);</span><br><span class="line">    System.out.println(<span class="string">"请求 "</span> + i + <span class="string">" 结束处理"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">处理请求 0 前，当前许可证数量：0</span><br><span class="line">处理请求 1 前，当前许可证数量：0</span><br><span class="line">请求 0 开始处理</span><br><span class="line">请求 1 开始处理</span><br><span class="line">请求 0处理4秒</span><br><span class="line">请求 1处理2秒</span><br><span class="line">请求 1 结束处理</span><br><span class="line">处理请求 1 中，正在等待许可证的请求数量：4</span><br><span class="line">处理请求 1 后，当前许可证数量：1</span><br><span class="line">处理请求 2 前，当前许可证数量：0</span><br><span class="line">请求 2 开始处理</span><br><span class="line">请求 2处理5秒</span><br><span class="line">请求 0 结束处理</span><br><span class="line">处理请求 0 中，正在等待许可证的请求数量：3</span><br><span class="line">处理请求 0 后，当前许可证数量：1</span><br><span class="line">处理请求 3 前，当前许可证数量：0</span><br><span class="line">请求 3 开始处理</span><br><span class="line">请求 3处理6秒</span><br><span class="line">请求 2 结束处理</span><br><span class="line">处理请求 2 中，正在等待许可证的请求数量：2</span><br><span class="line">处理请求 2 后，当前许可证数量：1</span><br><span class="line">处理请求 4 前，当前许可证数量：0</span><br><span class="line">请求 4 开始处理</span><br><span class="line">请求 4处理2秒</span><br><span class="line">请求 4 结束处理</span><br><span class="line">处理请求 4 中，正在等待许可证的请求数量：1</span><br><span class="line">处理请求 4 后，当前许可证数量：1</span><br><span class="line">处理请求 5 前，当前许可证数量：0</span><br><span class="line">请求 5 开始处理</span><br><span class="line">请求 5处理7秒</span><br><span class="line">请求 3 结束处理</span><br><span class="line">处理请求 3 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 3 后，当前许可证数量：1</span><br><span class="line">请求 5 结束处理</span><br><span class="line">处理请求 5 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 5 后，当前许可证数量：2</span><br></pre></td></tr></table></figure><p>当释放许可参数变成 2，即从 <code>semaphore.release(1)</code> 变成 <code>semaphore.release(2)</code>。执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">处理请求 0 前，当前许可证数量：0</span><br><span class="line">请求 0 开始处理</span><br><span class="line">请求 0处理4秒</span><br><span class="line">处理请求 1 前，当前许可证数量：0</span><br><span class="line">请求 1 开始处理</span><br><span class="line">请求 1处理3秒</span><br><span class="line">请求 1 结束处理</span><br><span class="line">处理请求 1 中，正在等待许可证的请求数量：4</span><br><span class="line">处理请求 1 后，当前许可证数量：2</span><br><span class="line">处理请求 2 前，当前许可证数量：1</span><br><span class="line">请求 2 开始处理</span><br><span class="line">处理请求 3 前，当前许可证数量：0</span><br><span class="line">请求 3 开始处理</span><br><span class="line">请求 3处理4秒</span><br><span class="line">请求 2处理5秒</span><br><span class="line">请求 0 结束处理</span><br><span class="line">处理请求 0 中，正在等待许可证的请求数量：2</span><br><span class="line">处理请求 0 后，当前许可证数量：2</span><br><span class="line">处理请求 4 前，当前许可证数量：1</span><br><span class="line">请求 4 开始处理</span><br><span class="line">处理请求 5 前，当前许可证数量：0</span><br><span class="line">请求 5 开始处理</span><br><span class="line">请求 5处理8秒</span><br><span class="line">请求 4处理2秒</span><br><span class="line">请求 4 结束处理</span><br><span class="line">处理请求 4 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 4 后，当前许可证数量：2</span><br><span class="line">请求 3 结束处理</span><br><span class="line">处理请求 3 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 3 后，当前许可证数量：4</span><br><span class="line">请求 2 结束处理</span><br><span class="line">处理请求 2 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 2 后，当前许可证数量：6</span><br><span class="line">请求 5 结束处理</span><br><span class="line">处理请求 5 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 5 后，当前许可证数量：8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Semaphore&lt;/code&gt; 是JDK1.5的 &lt;code&gt;java.util.concurrent&lt;/code&gt; 并发包中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReentrantReadWriteLock解析</title>
    <link href="https://muhouer.github.io/posts/cb5cf479/"/>
    <id>https://muhouer.github.io/posts/cb5cf479/</id>
    <published>2019-09-13T04:15:00.000Z</published>
    <updated>2019-09-13T08:56:28.700Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ReentrantReadWriteLock</code> 是 <code>Lock</code> 的另一种实现方式， <code>ReentrantLock</code>是一个排他锁，同一时间只允许一个线程访问，而 <code>ReentrantReadWriteLock</code> 允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时 <code>ReentrantReadWriteLock</code> 能够提供比排他锁更好的并发性和吞吐量。</p><p>读写锁内部维护了两个锁，一个用于读操作，一个用于写操作。所有 <code>ReadWriteLock</code> 实现都必须保证 <code>writeLock</code> 操作的内存同步效果也要保持与相关 <code>readLock</code> 的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</p><p><code>ReentrantReadWriteLock</code> 支持以下功能：</p><ul><li>支持公平和非公平的获取锁的方式；</li><li>支持可重入。读线程在获取了读锁后还可以获取读锁，写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</li><li>允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；</li><li>读取锁和写入锁都支持锁获取期间的中断；</li><li>支持 Condition 。<strong>仅写入锁提供了一个 Conditon 实现，读取锁不支持 Conditon</strong> 。<code>readLock().newCondition()</code> 会抛出 <code>UnsupportedOperationException</code>。</li></ul><h2 id="ReentrantReadWriteLock-类结构"><a href="#ReentrantReadWriteLock-类结构" class="headerlink" title="ReentrantReadWriteLock 类结构"></a>ReentrantReadWriteLock 类结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6992448646407690164L</span>;</span><br><span class="line">    <span class="comment">/** 内部类提供读取锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/** 内部类提供写入锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">/** 执行所有同步机制 */</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁默认是非公平模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 支持指导锁公平模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写入锁</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">    <span class="comment">// 获取读取锁</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/ReentrantReadWriteLock.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code> 、<code>FairSync</code>、<code>NonfairSync</code>、<code>ReadLock</code>、<code>WriteLock</code> 是 <code>ReentrantReadWriteLock</code> 的内部类，<code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> ，而 <code>FairSync</code>、<code>NonfairSync</code> 继承 <code>Sync</code>，分别对应公平锁和非公平锁。<code>ThreadLocalHoldCounter</code> 、<code>HoldCounter</code>是 <code>Sync</code>的内部类。</p><h2 id="Sync-锁"><a href="#Sync-锁" class="headerlink" title="Sync 锁"></a>Sync 锁</h2><p><code>Sync</code> 也是一个继承于AQS的抽象类。<code>Sync</code> 也包括公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code>。sync 对象是 <code>FairSync</code> 和 <code>NonfairSync</code> 中的一个，默认是 <code>NonfairSync</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;</span><br><span class="line">    <span class="comment">/** Lock 状态逻辑上分为两个无符号 short 类型：</span></span><br><span class="line"><span class="comment">     * 1. 低位表示独占（writer）锁写入计数</span></span><br><span class="line"><span class="comment">     * 2. 高位表示共享（reader）锁读取次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回共享（reader）锁被持有次数  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    <span class="comment">/** 返回独占（writer）锁被持有次数  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">    <span class="comment">// 持有计数器：每个线程持有锁的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 为了避免垃圾滞留(garbage retention)，使用 id 而不是引用</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 本地线程持有锁的计数器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程持有的可重入读锁数。每当线程的读取保持计数降至0时删除。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">    <span class="comment">// 成功获取读锁的最后一个线程的保持计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">    <span class="comment">// 第一个获取读锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">    Sync() &#123;</span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        setState(getState()); <span class="comment">// 确保读取锁持有次数可见</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前线程尝试获取读锁，且在其他情况下有资格获取该锁，但由于超过其他等待线程的策略而应该阻塞，则返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程尝试获取写锁，且在其他情况下有资格获取该锁，但由于超过其他等待线程的策略而应该阻塞，则返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 释放写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (free)</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">// 获取当前状态</span></span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 获取写的状态</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 读状态不为0，读锁已获取</span></span><br><span class="line">            <span class="comment">// 写状态为 0 或 当前线程不是独占线程</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 增加写状态，写锁获取成功</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读锁未获取</span></span><br><span class="line">        <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">            !compareAndSetState(c, c + acquires))</span><br><span class="line">            <span class="comment">// 当前线程应该阻塞或通过 CAS 更新 state 为 c + acquires 失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 设置当前线程为独占线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 当前线程是第一个成功获取读锁的线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 线程读锁数量为1，那么第一个成功获取读锁的线程置为null</span></span><br><span class="line">                firstReader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 线程读锁数量减一</span></span><br><span class="line">                firstReaderHoldCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从缓存中获取当前线程的读锁数量</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                rh = readHolds.get();</span><br><span class="line">            <span class="keyword">int</span> count = rh.count; <span class="comment">// 当前线程的读锁数量</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 从本地线程移除读锁线程</span></span><br><span class="line">                readHolds.remove();</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 无读锁可以释放</span></span><br><span class="line">                    <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 线程读锁数量减一</span></span><br><span class="line">            --rh.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> nextc = c - SHARED_UNIT; <span class="comment">// state读锁状态减一</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// 如果state为0，表示无锁状态，返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">// 获取当前状态态</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="comment">// 写状态不为 0 且当前线程是独占线程</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c); <span class="comment">// 获取读状态</span></span><br><span class="line">        <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">            r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">            compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">// 读锁线程不阻塞、读取锁的共享计数未超过限制且通过 CAS 获取锁失败</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 读状态为 0</span></span><br><span class="line">                firstReader = current; <span class="comment">//当前线程是第一个成功获取读锁的线程</span></span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程是第一个成功获取读锁的线程</span></span><br><span class="line">                firstReaderHoldCount++; <span class="comment">// 持有读锁数量加一</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从缓存中获取当前线程的读锁数量</span></span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    <span class="comment">// 缓存读锁为 null 或当前线程的 id 不等于缓存线程 id</span></span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 将读锁线程加到本地线程</span></span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++; <span class="comment">// 持有读锁数量加一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读锁线程阻塞等待</span></span><br><span class="line">        <span class="comment">// 读取锁的共享计数超过限制</span></span><br><span class="line">        <span class="comment">// 通过 CAS 获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果读锁线程阻塞等待、读取锁的共享计数超过限制、通过 CAS 获取锁失败，则通过该方法获取读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState(); <span class="comment">// 获取当前状态</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123; <span class="comment">// 写锁已经被获取</span></span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="comment">// 当前线程不是独占线程</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123; <span class="comment">// 读锁线程阻塞等待</span></span><br><span class="line">                <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前线程不是 firstReader</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123; <span class="comment">// 获取缓存读锁数量</span></span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                            <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                readHolds.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果读锁数量超过 MAX_COUNT，则抛出异常。</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// 通过 CAS 获取锁成功</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123; <span class="comment">// 当前读锁数量为 0</span></span><br><span class="line">                    firstReader = current; <span class="comment">// 当前线程设置为 firstReader</span></span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>; <span class="comment">// firstReader 计数初始化</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程是 firstReader</span></span><br><span class="line">                    firstReaderHoldCount++; <span class="comment">// firstReader 计数加一</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 获取缓存读锁数量</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++; <span class="comment">// 读锁数量加一</span></span><br><span class="line">                    cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并返回 Condition 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getReadLockCount() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 当前线程是首次成功获取读锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) </span><br><span class="line">            <span class="keyword">return</span> firstReaderHoldCount;</span><br><span class="line">        <span class="comment">// 获取缓存读锁数量</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh != <span class="keyword">null</span> &amp;&amp; rh.tid == getThreadId(current))</span><br><span class="line">            <span class="keyword">return</span> rh.count;</span><br><span class="line">        <span class="keyword">int</span> count = readHolds.get().count;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) readHolds.remove();</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反序列化方法，将当前 state 重置为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁和非公平锁实现"><a href="#公平锁和非公平锁实现" class="headerlink" title="公平锁和非公平锁实现"></a>公平锁和非公平锁实现</h2><p>和互斥锁 <code>ReentrantLock</code> 一样，读写锁也分为公平锁和非公平锁。公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 总是不阻塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只要该非公平读锁对应的线程不为 null，则返回 true。</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">       (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">       !s.isShared()         &amp;&amp;</span><br><span class="line">       s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。</span></span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。</span></span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">  <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">  <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReadLock-与-WriteLock"><a href="#ReadLock-与-WriteLock" class="headerlink" title="ReadLock 与 WriteLock"></a>ReadLock 与 WriteLock</h2><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><p>读锁是一个可重入的共享锁，获取读锁的思想(即 <code>lock()</code>的步骤)，是先通过 <code>tryAcquireShared()</code> 尝试获取共享锁。尝试成功的话，则直接返回；尝试失败的话，则通过 <code>doAcquireShared()</code> 不断的循环并尝试获取锁，若有需要，则阻塞等待。<code>doAcquireShared()</code> 在循环中每次尝试获取锁时，都是通过 <code>tryAcquireShared()</code> 来进行尝试的。</p><p>释放读锁的思想(即 <code>unlock()</code>的步骤)，是先通过 <code>tryReleaseShared()</code> 尝试释放共享锁。尝试成功的话，则通过<code>doReleaseShared()</code> 唤醒“其他等待获取共享锁的线程”，并返回true；否则的话，返回 flase。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="comment">// 读锁构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁，不感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 获取共享锁方法 acquireShared</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取读锁，感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 获取共享锁方法 acquireSharedInterruptibly</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState(); <span class="comment">//当前状态</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="comment">// 写锁已经被持有且当前线程不是独占线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c); <span class="comment">// 获取读锁数量</span></span><br><span class="line">            <span class="keyword">if</span> (r == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 通过 CAS 获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 写锁未被获取</span></span><br><span class="line">                    firstReader = current; <span class="comment">// 设置当前线程为 firstReader</span></span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>; <span class="comment">// firstReader 计数初始化</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程是 firstReader</span></span><br><span class="line">                    firstReaderHoldCount++; <span class="comment">// firstReader 计数加一</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从缓存获取读锁数量</span></span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取读锁，感知中断且有超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并返回 Condition，读锁不支持该操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>写锁是一个可重入的排它锁。如果当前线程获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="comment">// 写锁构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁，感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁，不感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryWriteLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">//获取当前状态</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 获取写状态</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="comment">// 写状态为0 或 当前线程不是独占线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (w == MAX_COUNT)</span><br><span class="line">                <span class="comment">// 写状态超过 MAX_COUNT</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 CAS 获取锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetState(c, c + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 设置当前线程为独占线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁，感知中断且有超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 的获取排它锁方法 tryAcquireNanos</span></span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放排它锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 的释放排它锁方法 release</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并返回 Condition 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前线程是否是独占线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getWriteHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Reen
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ReentrantReadWriteLock" scheme="https://muhouer.github.io/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock解析</title>
    <link href="https://muhouer.github.io/posts/b376c662/"/>
    <id>https://muhouer.github.io/posts/b376c662/</id>
    <published>2019-09-13T04:14:00.000Z</published>
    <updated>2019-09-13T04:27:16.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Reentrant 可重入的;重入;可再入的。即再次进入的意思，entrant: 新职员;新生;新会员;新成员。</p></blockquote><p>JDK 中独占锁的实现除了使用关键字 <code>synchronized</code> 外,还可以使用 <code>ReentrantLock</code>。虽然在性能上<code>ReentrantLock</code> 和 <code>synchronized</code> 没有什么区别，但 <code>ReentrantLock</code> 相比 <code>synchronized</code> 而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。即 <code>ReentrantLock</code> 粒度更小。</p><ul><li><code>ReentrantLock</code> 是独占锁且可重入的。</li><li><code>ReentrantLock</code> 可以实现公平锁。</li><li><code>ReentrantLock</code> 可以响应中断。</li><li><code>ReentrantLock</code> 提供了获取锁超时等待。</li><li><code>ReentrantLock</code> 结合 <code>Condition</code> 接口可以实现线程间的等待通知机制。</li></ul><h2 id="ReentrantLock-类结构"><a href="#ReentrantLock-类结构" class="headerlink" title="ReentrantLock 类结构"></a>ReentrantLock 类结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平可重入锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定可重入锁公平模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/ReentrantLock.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code> 、<code>FairSync</code>、<code>NonfairSync</code>是 <code>ReentrantLock</code> 的内部类，<code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> ，而 <code>FairSync</code>、<code>NonfairSync</code> 继承 <code>Sync</code>，分别对应公平锁和非公平锁。</p><h3 id="Sync-内部类"><a href="#Sync-内部类" class="headerlink" title="Sync 内部类"></a>Sync 内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line">    <span class="comment">// 执行锁操作，由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行非公平 tryLock()</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 利用 CAS 来更新 state 的状态</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 设置当前线程拥有独占访问权限</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取拥有独占访问权限的线程和当前线程比较</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="comment">// 溢出</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 设置新状态</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="comment">// 拥有独占访问权限的线程不是当前线程，抛出 IllegalMonitorStateException</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 清空拥有独占访问权限的线程</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置新状态</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程是否拥有独占访问权限</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 Condition 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取拥有独占访问权限的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否锁住</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解序列化，将状态重置为 0，即锁释放状态</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NonfairSync、FairSync-内部类"><a href="#NonfairSync、FairSync-内部类" class="headerlink" title="NonfairSync、FairSync 内部类"></a>NonfairSync、FairSync 内部类</h3><blockquote><p>线程会重复获取锁。如果申请获取锁的线程足够多，那么可能会造成某些线程长时间得不到锁。这就是非公平锁的“饥饿”问题。</p></blockquote><p>公平锁是指当锁可用时，在锁上等待时间最长的线程将获得锁的使用权，而非公平锁则随机分配这种使用权。和<code>synchronized</code> 一样，默认的 <code>ReentrantLock</code> 实现是非公平锁，因为相比公平锁，非公平锁性能更好。当然公平锁能防止饥饿，某些情况下也很有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">    <span class="comment">// 锁实现</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用 CAS 来更新 state 的状态为1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 设置当前线程拥有独占访问权限，随机分配</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// AQS 的 acquire()</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参考上文 Sync 的 nonfairTryAcquire 实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"><span class="comment">// 锁实现</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 的 acquire()</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，和 AQS 的 nonfairTryAcquire 相比，多了判断队列有没有前置节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 队列没有前置节点，且成功利用 CAS 来更新 state 的状态为 acquires </span></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 设置当前线程拥有独占访问权限</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReentrantLock-提供的方法"><a href="#ReentrantLock-提供的方法" class="headerlink" title="ReentrantLock 提供的方法"></a>ReentrantLock 提供的方法</h2><h3 id="ReentrantLock-锁方法"><a href="#ReentrantLock-锁方法" class="headerlink" title="ReentrantLock 锁方法"></a>ReentrantLock 锁方法</h3><p><code>ReentrantLock</code> 和 <code>synchronized</code> 都是独占锁。不同的是 <code>ReentrantLock</code> 需要手动加锁和解锁，且解锁的操作尽量要放在 finally 代码块中，保证线程正确释放锁。<code>ReentrantLock</code> 操作较为复杂，但是因为可以手动控制加锁和解锁过程，在复杂的并发场景中能派上用场。<code>synchronized</code> 加锁解锁的过程是隐式的，用户不用手动操作，优点是操作简单，但显得不够灵活。一般并发场景使用 <code>synchronized</code> 就足够。</p><p><code>ReentrantLock</code> 和 <code>synchronized</code> 都是可重入的。<code>synchronized</code> 因为可重入，所以可以放在被递归执行的方法上，且不用担心线程最后能否正确释放锁。而 <code>ReentrantLock</code> 在重入时要却<strong>确保重复获取锁的次数必须和重复释放锁的次数一样</strong>，否则可能导致其他线程无法获得该锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁，分别调用公平锁和非公平锁的加锁方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断敏感的加锁，参考 AQS 的 acquireInterruptibly 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平模式加锁，参考 Sync 的 nonfairTryAcquire 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁直至超时，参考 AQS 的 tryAcquireNanos 方法</span></span><br><span class="line"><span class="comment">// 使用该方法配合失败重试机制可以用来解决死锁问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Condition-相关方法"><a href="#Condition-相关方法" class="headerlink" title="Condition 相关方法"></a>Condition 相关方法</h3><p><code>Condition</code> 由 <code>ReentrantLock</code> 对象创建，并且可以同时创建多个。<code>Condition</code> 接口在使用前必须先调用<code>ReentrantLock</code> 的 <code>lock()</code> 方法获得锁。之后调用 <code>Condition</code> 接口的 <code>await()</code> 将释放锁，并且在该<code>Condition</code> 上等待，直到有其他线程调用 <code>Condition</code> 的 <code>signal()</code> 方法唤醒线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Condition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询在给定条件下，是否有线程在等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!(condition <span class="keyword">instanceof</span> AbstractQueuedSynchronizer.ConditionObject))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not owner"</span>);</span><br><span class="line">    <span class="keyword">return</span> sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询在给定条件下，等待线程队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!(condition <span class="keyword">instanceof</span> AbstractQueuedSynchronizer.ConditionObject))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not owner"</span>);</span><br><span class="line">    <span class="keyword">return</span> sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询在给定条件下，所有等待线程</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">(Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!(condition <span class="keyword">instanceof</span> AbstractQueuedSynchronizer.ConditionObject))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not owner"</span>);</span><br><span class="line">    <span class="keyword">return</span> sync.getWaitingThreads((AbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了锁方法和 Condition 相关方法外，还有一些判断是否是公平锁、是否加锁、获取阻塞队列长度、当前队列是否独占等方法，比较简单参考源码即可。</p><h2 id="ReentrantLock-使用示例"><a href="#ReentrantLock-使用示例" class="headerlink" title="ReentrantLock 使用示例"></a>ReentrantLock 使用示例</h2><h3 id="基于官方示例"><a href="#基于官方示例" class="headerlink" title="基于官方示例"></a>基于官方示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公平锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadDemo</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"获得锁的线程："</span> + id);</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是公平锁，线程几乎是轮流的获取到了锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：0</span><br><span class="line">获得锁的线程：0</span><br></pre></td></tr></table></figure><p>如果是非公平锁，线程会重复获取锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：0</span><br><span class="line">获得锁的线程：0</span><br></pre></td></tr></table></figure><h3 id="结合-Condition-实现等待通知机制"><a href="#结合-Condition-实现等待通知机制" class="headerlink" title="结合 Condition 实现等待通知机制"></a>结合 Condition 实现等待通知机制</h3><p>使用 <code>synchronized</code> 结合 Object 上的 <code>wait()</code> 和 <code>notify()</code> 方法可以实现线程间的等待通知机制。<code>ReentrantLock</code> 结合 <code>Condition</code> 接口同样可以实现这个功能，而且相比前者使用起来更清晰也更简单。</p><p>使用<code>Condition</code> 实现简单的阻塞队列，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionBlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 阻塞队列最大容量</span></span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// 可重入锁</span></span><br><span class="line">  ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 队列底层实现</span></span><br><span class="line">  LinkedList&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 队列满时的等待条件</span></span><br><span class="line">  Condition notFull = lock.newCondition();</span><br><span class="line">  <span class="comment">// 队列空时的等待条件</span></span><br><span class="line">  Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConditionBlockingQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 队列已满,在 notFull 条件上等待</span></span><br><span class="line">      <span class="keyword">while</span> (list.size() == size) &#123;</span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;</span><br><span class="line">      list.add(e); <span class="comment">// 加入链表末尾</span></span><br><span class="line">      notEmpty.signal(); <span class="comment">// 通知在 notEmpty 条件上等待的线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 队列为空,在 notEmpty 条件上等待</span></span><br><span class="line">      <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      e = list.removeFirst(); <span class="comment">// 移除链表首元素</span></span><br><span class="line">      notFull.signal(); <span class="comment">// 通知在 notFull 条件上等待的线程</span></span><br><span class="line">      <span class="keyword">return</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ReentrantLock</code> 是可重入的独占锁。比 <code>synchronized</code> 功能更加丰富，控制粒度更小，支持公平锁实现，支持中断响应以及超时等待…… <code>ReentrantLock</code> 还可以配合一个或多个 <code>Condition</code> 条件方便的实现等待通知机制。不过需要手动加锁和解锁，且解锁的操作尽量要放在 finally 代码块中，保证线程正确释放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ReentrantLock" scheme="https://muhouer.github.io/tags/ReentrantLock/"/>
    
  </entry>
  
  <entry>
    <title>AQS同步器解析</title>
    <link href="https://muhouer.github.io/posts/cdbd94c4/"/>
    <id>https://muhouer.github.io/posts/cdbd94c4/</id>
    <published>2019-09-13T04:09:00.000Z</published>
    <updated>2019-09-13T04:18:13.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>AQS</strong> (<code>AbstractQueuedSynchronizer</code>) 提供了基于 FIFO 队列机制的模板，可以用来实现阻塞锁以及相关的同步锁 (semaphores, events等)，是构建 Java 同步组件的基础。自定义子类通过继承 <strong>AQS</strong> 类，实现它的抽象方法来管理同步状态。<strong>AQS</strong> 提供了大量的模板方法来实现同步，主要是分为三类：</p><ol><li>独占式获取、释放同步状态。</li><li>共享式获取、释放同步状态</li><li>查询同步队列中的等待线程情况。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>继承关系及 public 方法如下图所示</p><img src="/images/AbstractQueuedSynchronizer.png" width="800px" height="600px" align="center"><h2 id="需要自定义同步组件实现的方法"><a href="#需要自定义同步组件实现的方法" class="headerlink" title="需要自定义同步组件实现的方法"></a>需要自定义同步组件实现的方法</h2><p>基于 <strong>AQS</strong> 实现的自定义同步组件主要有五种</p><ul><li>倒计时器：<code>CountDownLatch.Sync</code>——<a href="/posts/49d01824/" title="CountDownLatch解析">CountDownLatch解析</a></li><li>信号量：<code>Semaphore.Sync</code>——<a href="/posts/e73eaf42/" title="Semaphore解析">Semaphore解析</a></li><li>重入锁：<code>ReentrantLock.Sync</code>——<a href="/posts/b376c662/" title="ReentrantLock解析">ReentrantLock解析</a></li><li>读写锁：<code>ReentrantReadWriteLock.Sync</code> ——<a href="/posts/cb5cf479/" title="ReentrantReadWriteLock解析">ReentrantReadWriteLock解析</a></li><li>线程池执行器：<code>ThreadPoolExecutor.Worker</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占式获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 独占式释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享式获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享式释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前（调用）线程以独占方式持有同步，则返回&#123;@code true&#125;</span></span><br><span class="line"><span class="comment">// 每次调用非等待的方法时都会调用此方法。（等待方法改为调用&#123;@link release&#125;。）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h2><p>独占式，同一时刻仅有一个线程持有同步状态。</p><blockquote><p>在 AQS 中维护着一个 FIFO 的同步队列，当线程获取同步状态失败后，则会加入到这个 CLH 同步队列的对尾并一直保持着自旋。在 CLH 同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出 CLH 同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p></blockquote><h3 id="独占式获取同步状态"><a href="#独占式获取同步状态" class="headerlink" title="独占式获取同步状态"></a>独占式获取同步状态</h3><p><code>acquire(int arg)</code> 方法是 <strong>AQS</strong> 提供的模板方法，该方法为独占式获取同步状态，忽略中断，即线程获取同步状态失败加入到 CLH 同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryAcquire(int arg)</code> 去尝试获取锁，获取成功则设置锁状态并返回 <code>true</code>，否则返回 <code>false</code>。该方法需要自定义同步组件实现，该方法必须要保证线程安全的获取同步状态。</li><li>如果 <code>tryAcquire(int arg)</code> 返回 <code>false</code> 即获取同步状态失败，则调用 <code>addWaiter(Node mode)</code> 将当前线程加入到 CLH 同步队列尾部。</li><li><code>acquireQueued(final Node node, int arg)</code> : 当前线程会根据公平性原则来进行阻塞等待，直到获取锁为止，并且返回当前线程在等待过程中有没有中断过。</li><li><code>selfInterrupt()</code> 会产生一个中断。</li></ul><p><code>acquireQueued(final Node node, int arg)</code> 是一个自旋的过程，也就是说当前线程(Node) 进入同步队列后，当前线程会一直尝试获取同步状态，当前驱节点是头节点并且获取锁成功才会退出。其中只有其前驱节点为头结点才能够尝试获取同步状态，原因有二：1.保持 FIFO 同步队列原则。2.头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 中断标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">               <span class="comment">// 前驱节点是头节点并且获取锁成功</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取失败，线程等待 &amp;&amp; 检查中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 置中断标志位true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">【tryAcquire 获取锁--失败--&gt;【addWaiter 生成 Node 节点并将当前线程加入 CLH 同步队列】</span><br><span class="line">          |                              |&lt;-------------------------------</span><br><span class="line">          |                             ***                              |</span><br><span class="line">          |                              *                               |</span><br><span class="line">          |      【acquireQueued 判断前驱节点是否是头节点】--否--     线程被中断或前驱节点被释放</span><br><span class="line">          |                  |                 |             |</span><br><span class="line">          |                  是      【acquireQueued 线程进入线程等待】</span><br><span class="line">          |                    |                    *</span><br><span class="line">          |                   ***                  ***</span><br><span class="line">          |                              *                    |</span><br><span class="line">          |                  【acquireQueued 获取锁成功】---失败--</span><br><span class="line">          |                            |</span><br><span class="line">          |                           成功 </span><br><span class="line">          |                            |</span><br><span class="line">          |                           ***</span><br><span class="line">          |                            *</span><br><span class="line">         ***                  【设置当前节点为头节点】</span><br><span class="line">          *                               |</span><br><span class="line">          结束&lt;----------------------------</span><br></pre></td></tr></table></figure><h3 id="独占式中断获取同步状态"><a href="#独占式中断获取同步状态" class="headerlink" title="独占式中断获取同步状态"></a>独占式中断获取同步状态</h3><p><strong>AQS</strong> 提供了 <code>acquire(int arg)</code> 以独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于 CLH 同步队列中等待着获取同步状态。为了响应中断，<strong>AQS</strong> 提供了 <code>acquireInterruptibly(int arg)</code> ，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常<code>InterruptedException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 校验该线程是否已经中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">// 抛出InterruptedException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg)) <span class="comment">// 获取同步状态</span></span><br><span class="line">        <span class="comment">// 获取失败，执行doAcquireInterruptibly(arg)</span></span><br><span class="line">        <span class="comment">// 如果获取失败，线程等待 &amp;&amp; 检查有中断则抛出InterruptedException，和 acquireQueued 置中断标志位true不一样</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h3><p><strong>AQS</strong> 除了提供上面两个方法外，还提供了 <code>tryAcquireNanos(int arg,long nanos)</code>。该方法除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回 false，否则返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 获取到直接返回，否则执行 doAcquireNanos(arg, nanosTimeout)</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时获取同步状态最终是在 <code>doAcquireNanos(int arg, long nanosTimeout)</code>中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 生成 Node节点并当前线程加入 CLH 同步队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 前驱节点是头节点获取同步状态成功</span></span><br><span class="line">                setHead(node); <span class="comment">// 设置当前节点为头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 剩余时间计算</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 超时</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">// 获取失败，线程等待并且剩余时间大于 1000 纳秒</span></span><br><span class="line">                <span class="comment">// 等待 nanosTimeout 纳秒，线程会直接从LockSupport.parkNanos中返回</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 超时非常短nanosTimeout&lt;=spinForTimeoutThreshold，AQS会进行无条件的快速自旋。</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独占式释放同步状态"><a href="#独占式释放同步状态" class="headerlink" title="独占式释放同步状态"></a>独占式释放同步状态</h3><p>当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。<strong>AQS</strong> 提供了 <code>release(int arg)</code> 来释放同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用自定义同步器自定义的 tryRelease(int arg) 方法来释放同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h2><p>共享式与独占式的最主要区别在于独占式同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。</p><h3 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="共享式同步状态获取"></a>共享式同步状态获取</h3><p><strong>AQS</strong> 提供 <code>acquireShared(int arg)</code> 共享式获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试获取同步状态，需要自定义同步组件实现</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 自旋方式获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doAcquireShared(int arg)</code> 自旋方式获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建共享式节点并将当前线程加入 CLH 同步队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 前驱节点为头节点</span></span><br><span class="line">                <span class="comment">// 尝试获取同步</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 获取成功</span></span><br><span class="line">                  <span class="comment">// 设置当前节点为头节点并检查后续进程是否可以在共享模式下等待</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取失败线程等待并检查中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireShared(int arg)</code> 不响应中断，与独占式类似，<strong>AQS</strong> 也提供了响应中断、超时的方法，分别是：<code>acquireSharedInterruptibly(int arg)</code>、<code>tryAcquireSharedNanos(int arg,long nanos)</code>，与独占式类似。</p><h3 id="共享式释放同步状态"><a href="#共享式释放同步状态" class="headerlink" title="共享式释放同步状态"></a>共享式释放同步状态</h3><p>获取同步状态后，需要调用 <code>releaseShared(int arg)</code> 释放同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放同步状态，需要自定义同步组件实现</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 自旋释放同步状态</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doReleaseShared()</code> 自旋释放同步状态。因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过 CAS (Conmpare And Swap) 和循环来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;AQ
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="AQS" scheme="https://muhouer.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch解析</title>
    <link href="https://muhouer.github.io/posts/49d01824/"/>
    <id>https://muhouer.github.io/posts/49d01824/</id>
    <published>2019-09-13T04:05:00.000Z</published>
    <updated>2019-09-13T04:08:59.144Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>CountDownLatch</code> ，英文翻译为倒计时锁存器，是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。也是基于 <strong>AQS</strong>，它是 <strong>AQS</strong> 的共享功能的一个实现。</p><p>它主要用来保证完成某个任务的先决条件满足，是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</p><ul><li>确保某个计算在其需要的所有资源都被初始化之后才继续执行;</li><li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动;</li><li>等待直到某个操作所有参与者都准备就绪再继续执行。</li></ul><p><code>CountDownLatch</code> 有一个正数计数器，<code>countDown()</code> 方法对计数器做减操作，<code>await()</code> 方法等待计数器达到0。所有 await 的线程都会阻塞直到计数器为0或者等待线程中断或者超时。</p><h2 id="CountDownLatch-类结构"><a href="#CountDownLatch-类结构" class="headerlink" title="CountDownLatch 类结构"></a>CountDownLatch 类结构</h2><img src="/images/CountDownLatch.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code> 是 <code>CountDownLatch</code> 的内部类，<code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> 。使用 <strong>AQS</strong> state 表示 count 计数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"><span class="comment">// 设置初始计数</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取当前计数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 AQS 的 tryAcquireShared 方法，-1 表示 count&gt;0，可以获取。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="comment">// // count-1，如果 count 变为0，则唤醒所有。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前状态，为0表示未锁，不用释放。</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 利用 CAS 来更新 state 的状态，这里可能有并发，所以这也是用死循环更新的原因</span></span><br><span class="line">            <span class="comment">// c为期望值，nextc为更新值。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch-构造方法"><a href="#CountDownLatch-构造方法" class="headerlink" title="CountDownLatch 构造方法"></a>CountDownLatch 构造方法</h2><p>使用给定的 count 构造 <code>CountDownLatch</code>，count 表示线程通过 await 前必须要执行的次数，count 不能小于0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当<code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><h2 id="CountDownLatch-线程等待方法"><a href="#CountDownLatch-线程等待方法" class="headerlink" title="CountDownLatch 线程等待方法"></a>CountDownLatch 线程等待方法</h2><p><code>await()</code> 是通过轮询 state 的状态来判断所有的任务是否都完成。</p><h3 id="无限等待"><a href="#无限等待" class="headerlink" title="无限等待"></a>无限等待</h3><p>让当前线程等待直到 count 减数为0，除非线程被中断。如果 count 为0，线程将立即返回，不再阻塞等待。<br>如果当前计数大于零，则出于线程调度目的，当前线程将禁用，并处于休眠状态，直到发生以下两种情况之一：</p><ol><li><code>countDown()</code> 方法调用使得 count 减数为0；</li><li>当前线程被中断 (如果被中断将会抛出 InterruptedException 异常)。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 AQS 的 acquireSharedInterruptibly() 方法</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h3><p>使当前线程处理等待状态直到 count 减为0或者等待超时。如果当前count是0，则线程立即返回true。<br>如果当前计数大于零，则出于线程调度目的，当前线程将禁用，并处于休眠状态，直到发生以下三种情况之一：</p><ol><li><code>countDown()</code> 方法调用使得 count 减数为0；</li><li>当前线程被中断 (如果被中断将会抛出 InterruptedException 异常)；</li><li>等待超时。</li></ol><p><strong>如果等待超时但是 <code>count&gt;0</code>，则返回 false。如果超时时间小于或等于零，方法将不会等待。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 AQS 的 tryAcquireSharedNanos() 方法</span></span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch-其他方法"><a href="#CountDownLatch-其他方法" class="headerlink" title="CountDownLatch 其他方法"></a>CountDownLatch 其他方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒计时，将会将count-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 AQS 的 releaseShared() 方法</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 的 releaseShared() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 Sync 重写的 tryReleaseShared(int releases) 方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒主线程，因为如果 state 不等于0的话，主线程一直是阻塞的。</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前计数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.getCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回标识锁及其状态的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"[Count = "</span> + sync.getCount() + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AQS-的-doReleaseShared-方法"><a href="#AQS-的-doReleaseShared-方法" class="headerlink" title="AQS 的 doReleaseShared() 方法"></a>AQS 的 doReleaseShared() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123; <span class="comment">// 至少有两个节点</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 后继节点需要唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line">        doSomethingElse();            <span class="comment">// don't let run yet</span></span><br><span class="line">        <span class="comment">// 所有worker线程继续执行</span></span><br><span class="line">        startSignal.countDown();      <span class="comment">// let all threads proceed</span></span><br><span class="line">        doSomethingElse();</span><br><span class="line">        <span class="comment">// 允许driver等待直到所有的worker都完成</span></span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">  Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">    <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      startSignal.await(); <span class="comment">// 开始信号阻止任何worker直到driver准备好</span></span><br><span class="line">      doWork();</span><br><span class="line">      doneSignal.countDown(); <span class="comment">// 完成信号，计数减一</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="火箭发射示例"><a href="#火箭发射示例" class="headerlink" title="火箭发射示例"></a>火箭发射示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatchDemo demo = <span class="keyword">new</span> CountDownLatchDemo();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟检查任务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) * <span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"check complete"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//计数减一</span></span><br><span class="line">            <span class="comment">//放在finally避免任务执行过程出现异常，导致countDown()不能被执行</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            exec.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待检查</span></span><br><span class="line">        latch.await();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发射火箭</span></span><br><span class="line">        System.out.println(<span class="string">"Fire!"</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>CountDownLatch</code> 主要用来保证完成某个任务的先决条件满足，是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Coun
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="CountDownLatch" scheme="https://muhouer.github.io/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>人类愚蠢辞典</title>
    <link href="https://muhouer.github.io/posts/c6491e95/"/>
    <id>https://muhouer.github.io/posts/c6491e95/</id>
    <published>2019-09-08T15:28:00.000Z</published>
    <updated>2019-09-09T15:50:16.015Z</updated>
    
    <content type="html"><![CDATA[<ol><li>习惯的力量与其愚蠢度成正比。我们在个人与社会生活中，总会用同样的方式思考以及做同样的事。</li><li>对于银行来说，25% 就已经是高利贷的标准了。而一些酒吧、饭店来说，它们宣称出于对”卫生问题“的重视不提供直饮水，转而以高达10倍价格向它们愚蠢的顾客推销瓶装水。</li><li>人类的不忠行为远比我们愚蠢地自认为的要多。实际上，男性会偏向于夸大性伴侣的数量，而女性则会倾向于隐藏。不忠行为是对反自然的一夫一妻制进行的自然修正过程。</li><li>往生世界，相信死后我们会有跟活着时一样的烦恼。</li><li>”保护地球“是很愚蠢的：充其量是我们自己有点儿危险罢了。早在25亿年前，光合作用就已经对地球环境的构成造成了更甚于今日的剧烈变化，即所谓的”大氧化事件“。然而，我们地球通过一项调整成功挽救了自己：消灭厌氧生物，并养育需氧生物，也就是人类本身。</li><li>通常，人们愚蠢地认为爱动物就是喜欢小猫小狗，不忍观看斗牛或海豹被屠杀的画面。极少人意识到，真正的问题存在于动物被用于饮食和实验造成的权益侵害。</li><li>愚蠢的种族主义者虽然目标常常变化，但本质永远是不变的。</li><li>斯特金定律：90%的东西都是无意义的废物。</li><li>愚蠢的人有两种截然相反的行事方式，却总能殊途同归，制造麻烦。要么让那些明智的人生活难以为继，无法施展抱负；要么为害群之马铺平道路，帮助他们达成危害大业。</li><li>同样的习惯，于自身都很正常，到了别人那里就怎么看怎么别扭。</li><li>我们愚蠢无知的程度，恰如我们自以为的智慧狡黠一般。</li><li>在任意一群人里，蠢人的比例是固定的，即使是在诺贝尔奖获得者中。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;&lt;li&gt;习惯的力量与其愚蠢度成正比。我们在个人与社会生活中，总会用同样的方式思考以及做同样的事。&lt;/li&gt;&lt;li&gt;对于银行来说，25% 就已经是高利贷的标准了。而一些酒吧、饭店来说，它们宣称出于对”卫生问题“的重视不提供直饮水，转而以高达10倍价格向它们愚蠢的顾客推销瓶装
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://muhouer.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="愚蠢" scheme="https://muhouer.github.io/tags/%E6%84%9A%E8%A0%A2/"/>
    
  </entry>
  
  <entry>
    <title>JavaBean</title>
    <link href="https://muhouer.github.io/posts/207a79f8/"/>
    <id>https://muhouer.github.io/posts/207a79f8/</id>
    <published>2019-09-08T01:15:24.000Z</published>
    <updated>2019-09-08T01:17:59.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaBean-定义"><a href="#JavaBean-定义" class="headerlink" title="JavaBean 定义"></a>JavaBean 定义</h2><p>在 Java 中，有很多<code>class</code>的定义都符合这样的规范：</p><ul><li>若干<code>private</code>实例字段；</li><li>通过<code>public</code>方法来读写实例字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果读写方法符合以下这种命名规范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">getXyz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXyz</span><span class="params">(Type value)</span></span></span><br></pre></td></tr></table></figure><p>那么这种<code>class</code>被称为<code>JavaBean</code></p><p>JavaBean 是一种 Java 语言写成的可重用组件。为写成 JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性。众所周知，属性名称符合这种模式，其他 Java 类可以通过自身机制发现和操作这些 JavaBean 的属性。</p><p>JavaBean 更多的是一种规范，即包含一组 set 和 get 方法的 Java 对象。JavaBean 主要用来传递数据，即把一组数据组合成一个 JavaBean 便于传输。</p><h2 id="枚举-JavaBean-属性"><a href="#枚举-JavaBean-属性" class="headerlink" title="枚举 JavaBean 属性"></a>枚举 JavaBean 属性</h2><p><strong>内省(Introspector) 是 Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。</strong></p><p>调用 <code>Introspector.getBeanInfo()</code> 方法，得到的 BeanInfo 对象封装了把这个类当做 JavaBean 看的结果信息，即属性的信息。调用 <code>BeanInfo</code> 的 <code>getPropertyDescriptors()</code>，可以获得属性的描述，可以采用遍历 BeanInfo 的方法，来查找、设置类的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntrospectorTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    BeanInfo info = Introspector.getBeanInfo(Person.class);</span><br><span class="line">    <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pd.getName().equals(<span class="string">"name"</span>))&#123;</span><br><span class="line">        Method methodSetName = pd.getWriteMethod();</span><br><span class="line">        methodSetName.invoke(person, <span class="string">"Freya"</span>);</span><br><span class="line">        Method methodGetName = pd.getReadMethod();</span><br><span class="line">        System.out.println(methodGetName.invoke(person, <span class="keyword">null</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内省操作非常的繁琐，所以 Apache 开发了一套简单、易用的API来操作 Bean 的属性——<a href="http://commons.apache.org/beanutils/" target="_blank" rel="noopener">BeanUtils工具包</a>。</p><blockquote><p>注意：应用的时候还需要一个 <a href="http://commons.apache.org/logging/" target="_blank" rel="noopener">logging包</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/commons-beanutils/commons-beanutils --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用 BeanUtils 示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Person person = <span class="keyword">new</span> Person();</span><br><span class="line">  BeanUtils.setProperty(person, <span class="string">"name"</span>, <span class="string">"Freya"</span>);</span><br><span class="line">  BeanUtils.setProperty(person, <span class="string">"age"</span>, <span class="number">17</span>);</span><br><span class="line">  BeanUtils.setProperty(person, <span class="string">"id"</span>, <span class="number">1011</span>);</span><br><span class="line">  System.out.println(BeanUtils.getProperty(person, <span class="string">"name"</span>));</span><br><span class="line">  System.out.println(<span class="string">"get name type:"</span> + BeanUtils.getProperty(person, <span class="string">"name"</span>).getClass().getName());</span><br><span class="line">  System.out.println(BeanUtils.getProperty(person, <span class="string">"age"</span>));</span><br><span class="line">  System.out.println(<span class="string">"get age type:"</span> + BeanUtils.getProperty(person, <span class="string">"age"</span>).getClass().getName()); <span class="comment">// get age type:java.lang.String</span></span><br><span class="line">  System.out.println(<span class="string">"get age type:"</span> + PropertyUtils.getProperty(person, <span class="string">"age"</span>).getClass().getName()); <span class="comment">// get age type:java.lang.Integer</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设置属性的值，例如，BeanUtils.setProperty(person, “age”, 8)，参数是字符串或基本类型自动包装。设置属性的值是字符串，获得的值也是字符串，不是基本类型。</p><p>PropertyUtils 类和 BeanUtils 不同在于，运行 getProperty、setProperty 操作时，没有类型转换，使用属性的原有类型或者包装类。</p></blockquote><h2 id="VO、DTO、POJO、DTO、BO的区别"><a href="#VO、DTO、POJO、DTO、BO的区别" class="headerlink" title="VO、DTO、POJO、DTO、BO的区别"></a>VO、DTO、POJO、DTO、BO的区别</h2><h3 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h3><p>value object值对象，主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象。然后用一个 VO 对象在控制层与视图层进行传输交换。</p><h3 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h3><p>Data Transfer Object 数据传输对象，经过处理后的PO，可能增加或者减少PO的属性。主要用于远程调用等需要大量传输对象的地方。比如我们一张表有100个字段，那么对应的 PO 就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</p><h3 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h3><p>Plain Ordinary Java Object，是一个简单的普通的Java对象。简单 Java 对象是一种概念或者接口，身份及作用随环境变化而变化。POJO 有一些private的参数作为对象的属性。然后针对每个参数定义了get和set方法作为访问的接口。它不包含业务逻辑或持久逻辑等，但不是JavaBean、EntityBean等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。POJO对象有时也被称为Data对象，大量应用于表现现实中的对象。<br>一个POJO持久化以后就是PO。直接用它传递、传递过程中就是DTO。直接用来对应表示层就是VO。</p><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>PO持久化到数据库是要进行相关的数据库操作的(CRUQ)，这些对数据库操作的方法会统一放到一个 Java 对象中，这就是DAO。</p><h3 id="BO"><a href="#BO" class="headerlink" title="BO"></a>BO</h3><p>POJO在业务层的体现，对于业务操作来说，更多的是从业务上来包装对象，如一个User的BO，可能包括name, age, sex, privilege, group等，这些属性在数据库中可能会在多张表中，因为每一张表对应一个PO，而我们的BO需要这些PO组合起来(或说重新拼装)才能成为业务上的一个完整对象。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>POJO仅包含最简单的字段属性，没有多余的东西，它本质上就是一个普通的 JavaBean。但是在POJO的基础上，能够扩展出不同的对象。</p><ol><li>为 POJO 增加了持久化的方法（Insert、Update、Delete……）之后，POJO 就变成了 PO。</li><li>为 POJO 增加了数据绑定功能之后，POJO 就变成了 View Object，即UI Model。</li><li>为 POJO 增加业务逻辑的方法（比如单据审核、转帐……）之后，POJO就变成了Domain Model。</li><li>POJO 还可以当作 DTO 使用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaBean-定义&quot;&gt;&lt;a href=&quot;#JavaBean-定义&quot; class=&quot;headerlink&quot; title=&quot;JavaBean 定义&quot;&gt;&lt;/a&gt;JavaBean 定义&lt;/h2&gt;&lt;p&gt;在 Java 中，有很多&lt;code&gt;class&lt;/code&gt;的定义都
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java常用工具类</title>
    <link href="https://muhouer.github.io/posts/8b50b566/"/>
    <id>https://muhouer.github.io/posts/8b50b566/</id>
    <published>2019-09-08T01:08:00.000Z</published>
    <updated>2019-09-08T01:08:31.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK-自带"><a href="#JDK-自带" class="headerlink" title="JDK 自带"></a>JDK 自带</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p><p>求绝对值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(-<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">Math.abs(-<span class="number">2.2</span>); <span class="comment">// 2.2</span></span><br></pre></td></tr></table></figure><p>取最大或最小值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max(100, 101); // 101</span><br><span class="line">Math.min(1.2, 3.1); // 1.2</span><br></pre></td></tr></table></figure><p>计算x^y次方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure><p>计算√x：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.4142135623730951</span></span><br></pre></td></tr></table></figure><p>计算指数与对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.38905609893065</span></span><br><span class="line">Math.log(<span class="number">2</span>); <span class="comment">// 以 e 为底的对数 0.6931471805599453</span></span><br><span class="line">Math.log10(<span class="number">2</span>); <span class="comment">// 以 10 为底的对数 0.3010299956639812</span></span><br></pre></td></tr></table></figure><p>三角函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br></pre></td></tr></table></figure><p>Math还提供了几个数学常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">// 2.7182818...</span></span><br></pre></td></tr></table></figure><p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure><p>Java 标准库还提供了一个 <code>StrictMath</code>，它提供了和 <code>Math</code> 几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，<code>StrictMath</code> 保证所有平台计算结果都是完全相同的，而 <code>Math</code> 会尽量针对平台优化计算速度，所以，绝大多数情况下，使用 <code>Math</code> 就足够了。</p><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p><p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">r.nextInt(); <span class="comment">// 245439114,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 9,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// -485876652878521410,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.6454043,生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.44460046556701727,生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure><p>创建 <code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。如果我们在创建 <code>Random</code> 实例时指定一个种子，就会得到完全确定的随机数序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random(<span class="number">12345</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   System.out.println(r.nextInt(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    51</span></span><br><span class="line"><span class="comment">//    80</span></span><br><span class="line"><span class="comment">//    41</span></span><br><span class="line"><span class="comment">//    28</span></span><br><span class="line"><span class="comment">//    55</span></span><br><span class="line"><span class="comment">//    84</span></span><br><span class="line"><span class="comment">//    75</span></span><br><span class="line"><span class="comment">//    2</span></span><br><span class="line"><span class="comment">//    1</span></span><br><span class="line"><span class="comment">//    89</span></span><br></pre></td></tr></table></figure><p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code> 无法指定种子，它使用RNG（random number generator）算法。JDK的 <code>SecureRandom</code> 实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SecureRandom sr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      sr = SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">      sr = <span class="keyword">new</span> SecureRandom(); <span class="comment">// 获取普通的安全随机数生成器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">    sr.nextBytes(buffer); <span class="comment">// 用安全随机数填充buffer</span></span><br><span class="line">    System.out.println(Arrays.toString(buffer));</span><br><span class="line">    System.out.println(sr.nextInt());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code> 的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p><p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用 <code>SecureRandom</code> 来产生安全的随机数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK-自带&quot;&gt;&lt;a href=&quot;#JDK-自带&quot; class=&quot;headerlink&quot; title=&quot;JDK 自带&quot;&gt;&lt;/a&gt;JDK 自带&lt;/h2&gt;&lt;h3 id=&quot;Math&quot;&gt;&lt;a href=&quot;#Math&quot; class=&quot;headerlink&quot; title=&quot;M
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="常用工具类" scheme="https://muhouer.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java中大数表示</title>
    <link href="https://muhouer.github.io/posts/d9f6149f/"/>
    <id>https://muhouer.github.io/posts/d9f6149f/</id>
    <published>2019-09-08T00:39:30.000Z</published>
    <updated>2019-09-08T00:40:19.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>在 Java 中，由 CPU 原生提供的整型最大范围是 64 位 <code>long</code> 型整数。使用 <code>long</code> 型整数可以直接通过 CPU 指令进行计算，速度非常快。如果我们使用的整数范围超过了 <code>long</code> 型就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code> 就是用来表示任意大小的整数。<code>BigInteger</code> 内部用一个 <code>int[]</code> 数组来模拟一个非常大的整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure><p>使用 BigInteger` 做运算的时候，只能使用实例方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i1 = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);</span><br><span class="line">BigInteger i2 = <span class="keyword">new</span> BigInteger(<span class="string">"12345678901234567890"</span>);</span><br><span class="line">BigInteger sum = i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure><p>和 <code>long</code> 型整数运算比，<code>BigInteger</code> 不会有范围限制，但缺点是速度比较慢。也可以把 <code>BigInteger</code> 转换成 <code>long</code> 型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i = <span class="keyword">new</span> BigInteger(<span class="string">"123456789000"</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure><p>使用 <code>longValueExact()</code> 方法时，如果超出了 <code>long</code> 型的范围，会抛出 <code>ArithmeticException</code>。</p><p><code>BigInteger</code> 和 <code>Integer</code>、<code>Long</code> 一样，也是不可变类，并且也继承自 <code>Number</code> 类。因为 <code>Number</code> 定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>因此，通过上述方法，可以把 <code>BigInteger</code> 转换成基本类型。<strong>如果 <code>BigInteger</code> 表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</strong></p><p>如果 <code>BigInteger</code> 的值甚至超过了<code>float</code>的最大范围（3.4x1038），那么返回的float是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BigInteger n = <span class="keyword">new</span> BigInteger(<span class="string">"999999"</span>).pow(<span class="number">99</span>);</span><br><span class="line">    <span class="keyword">float</span> f = n.floatValue();</span><br><span class="line">    System.out.println(f); <span class="comment">// Infinity</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>和 <code>BigInteger</code> 类似，<code>BigDecimal</code> 可以表示一个任意大小且精度完全准确的浮点数，常用于财务计算。如果查看 <code>BigDecimal</code> 的源码，可以发现，实际上一个 <code>BigDecimal</code> 是通过一个 <code>BigInteger</code> 和一个 <code>scale</code> 来表示的，即 <code>BigInteger</code> 表示一个完整的整数，而 <code>scale</code> 表示小数位数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimal</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code> 也是从 <code>Number</code> 继承的，也是不可变对象。</p><p>通过 <code>BigDecimal</code> 的 <code>stripTrailingZeros()</code> 方法，可以将一个 <code>BigDecimal</code> 格式化为一个相等的，但去掉了末尾0的 <code>BigDecimal</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.4500"</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">"1234500"</span>);</span><br><span class="line">BigDecimal d4 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><p>如果一个 <code>BigDecimal</code> 的 <code>scale()</code> 返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个 <code>BigDecimal</code> 设置它的 <code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456789"</span>);</span><br><span class="line">        BigDecimal d2 = d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">        BigDecimal d3 = d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456"</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">"23.456789"</span>);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br></pre></td></tr></table></figure><p>在比较两个 <code>BigDecimal</code> 的值是否相等时，要特别注意，使用 <code>equals()</code> 方法不但要求两个 <code>BigDecimal</code> 的值相等，还要求它们的 <code>scale()</code> 相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456"</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.45600"</span>);</span><br><span class="line">System.out.println(d1.equals(d2)); <span class="comment">// false,因为scale不同</span></span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="comment">// true,因为d2去除尾部0后scale变为2</span></span><br><span class="line">System.out.println(d1.compareTo(d2)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>必须使用 <code>compareTo()</code> 方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BigInteger&quot;&gt;&lt;a href=&quot;#BigInteger&quot; class=&quot;headerlink&quot; title=&quot;BigInteger&quot;&gt;&lt;/a&gt;BigInteger&lt;/h2&gt;&lt;p&gt;在 Java 中，由 CPU 原生提供的整型最大范围是 64 位 &lt;code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="https://muhouer.github.io/posts/4522df16/"/>
    <id>https://muhouer.github.io/posts/4522df16/</id>
    <published>2019-09-07T07:25:00.000Z</published>
    <updated>2019-09-08T01:13:41.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><blockquote><p>序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。恰当的序列化协议不仅可以提高系统的通用性、强健性、安全性、优化系统性能，而且会让系统更加易于调试、便于扩展。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li><strong>序列化：将数据结构或对象转换成二进制串的过程，在 Java 中对应把对象转换为字节序列的过程。</strong></li><li><strong>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程，在 Java 中对应把字节序列恢复为对象的过程。</strong></li></ol><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li><p>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。</p></li><li><p>在网络上传送对象的字节序列。</p></li></ol><h2 id="JDK-类库中的序列化API"><a href="#JDK-类库中的序列化API" class="headerlink" title="JDK 类库中的序列化API"></a>JDK 类库中的序列化API</h2><blockquote><ol><li><p>在序列化过程中，如果被序列化的类中定义了 writeObject() 和 readObject() 方法，虚拟机会试图调用对象类里的 writeObject() 和 readObject() 方法，进行用户自定义的序列化和反序列化。如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject() 方法以及 ObjectInputStream 的 defaultReadObject() 方法。</p></li><li><p>用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。</p></li></ol></blockquote><p><code>ObjectOutputStream</code> 代表对象输出流，它的 <code>writeObject(Object obj)</code> 方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p><code>ObjectInputStream</code> 代表对象输入流，它的 <code>readObject()</code> 方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</p><p>只有实现了 <code>Serializable</code> 和 <code>Externalizable</code> 接口的类的对象才能被序列化。<code>Externalizable</code> 接口继承自 <code>Serializable</code> 接口，实现 <code>Externalizable</code> 接口的类完全由自身来控制序列化的行为，而仅实现 <code>Serializable</code> 接口的类可以采用默认的序列化方式 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><strong>对象序列化步骤</strong></p><ol><li>创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；</li><li>通过对象输出流的writeObject()方法写对象。</li></ol><p><strong>对象反序列化步骤</strong></p><ol><li>创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；</li><li>通过对象输入流的readObject()方法读取对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Initializes The Object</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"Freya"</span>);</span><br><span class="line">        user.setAge(<span class="number">17</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Write Obj to File</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>));</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(oos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Read Obj from File</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">            User newUser = (User) ois.readObject();</span><br><span class="line">            System.out.println(newUser);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(ois);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileUtils.forceDelete(file);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化版本号"><a href="#序列化版本号" class="headerlink" title="序列化版本号"></a>序列化版本号</h3><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量 <code>serialVersionUID</code>。<code>serialVersionUID</code> 的取值是 Java 运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的 <code>serialVersionUID</code> 的取值有可能也会发生变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID</span><br></pre></td></tr></table></figure><p>如果没有指定类的 <code>serialVersionUID</code>，Java 编译器会自动给这个 class 进行一个摘要算法，类似于指纹算法，只要这个文件多一个空格，得到的 <code>serialVersionUID</code> 就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个字段后，由于没有显指定 <code>serialVersionUID</code>，编译器又为我们生成了一个 <code>serialVersionUID</code>，当然和前面保存在文件中的那个不会一样了，于是就会出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了 <code>serialVersionUID</code>，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原。</p><p>类的 <code>serialVersionUID</code> 的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。<strong>为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值</strong>。</p><p>显式地定义serialVersionUID有两种用途：</p><ol><li><p>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的 <code>serialVersionUID</code>；</p></li><li><p>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的 <code>serialVersionUID</code>。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p><code>Serializable</code> 只是一个接口，本身没有任何实现。如果一个类想被序列化，需要实现Serializable接口。否则将抛出<code>NotSerializableException</code>异常。因为在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum、String和Serializable类型其中的任何一种。(当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。)</p></li><li><p>对象的反序列化并没有调用对象的任何构造方法。序列化时，只对对象的状态进行保存，而不管对象的方法。</p></li><li><p>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化。</p></li><li><p>并非所有的对象都可以序列化，比如：</p><ul><li>安全方面的原因，比如一个对象拥有 private，public 等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</li><li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</li></ul></li><li><p>serialVersionUID 是用于记录文件版本信息的，最好能够自定义。否则，系统会自动生成 serialVersionUID，文件或者对象的任何改变，都会改变 serialVersionUID，导致反序列化的失败，如果自定义就没有这个问题</p></li><li><p>声明为 <code>static</code> 和 <code>transient</code> 类型的成员数据不能被序列化。因为 <code>static</code> 代表类的状态，<code>transient</code> 代表对象的临时数据。</p></li><li><p><code>Serializable</code> 的系统实现是采用 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 实现的，调用 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 时，需要对应的类实现 <code>Serializable</code> 接口。</p></li><li><p>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p></li><li><p>Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。反序列化时，恢复引用关系。该存储规则极大的节省了存储空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>));</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//试图将对象两次写入文件</span></span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.flush();</span><br><span class="line">System.out.println(<span class="keyword">new</span> File(<span class="string">"tempFile"</span>).length());</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line">System.out.println(<span class="keyword">new</span> File(<span class="string">"tempFile"</span>).length());</span><br><span class="line"></span><br><span class="line">ObjectInputStream oin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"tempFile"</span>));</span><br><span class="line"><span class="comment">//从文件依次读出两个文件</span></span><br><span class="line">User t1 = (User) oin.readObject();</span><br><span class="line">User t2 = (User) oin.readObject();</span><br><span class="line">oin.close();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//判断两个引用是否指向同一个对象</span></span><br><span class="line">System.out.println(t1 == t2);</span><br></pre></td></tr></table></figure></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="序列化与单例模式"><a href="#序列化与单例模式" class="headerlink" title="序列化与单例模式"></a>序列化与单例模式</h3><h4 id="序列化对单例的破坏"><a href="#序列化对单例的破坏" class="headerlink" title="序列化对单例的破坏"></a>序列化对单例的破坏</h4><p>使用反射可以破坏单例模式，除了反射以外，使用序列化与反序列化也同样会破坏单例。</p><p>单例示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试序列化对单例模式的破坏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonSerializableTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Write Obj to file</span></span><br><span class="line">    <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>))) &#123;</span><br><span class="line">      oos.writeObject(Singleton.getSingleton());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Read Obj from file</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">    Singleton newInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file))) &#123;</span><br><span class="line">      newInstance = (Singleton) ois.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == newInstance) &#123;</span><br><span class="line">        System.out.println(<span class="string">"newInstance is null"</span>); <span class="comment">// 不打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是同一个对象</span></span><br><span class="line">    System.out.println(Singleton.getSingleton() == newInstance); <span class="comment">// false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过对 Singleton 的序列化与反序列化得到的对象是一个新的对象，这就破坏了 Singleton 的单例性。这是因为序列化会通过反射调用无参数的构造方法创建一个新的对象。</strong></p><h4 id="防止序列化破坏单例模式"><a href="#防止序列化破坏单例模式" class="headerlink" title="防止序列化破坏单例模式"></a>防止序列化破坏单例模式</h4><p>在 Singleton 类中定义 <code>readResolve</code> 就可以解决该问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Singleton 类中定义 <code>readResolve</code> 可以防止序列化破坏单例模式，实现如下：</p><ol><li><code>ObjectOutputStream</code> 的 <code>writeObject()</code> 调用 <code>writeObject0()</code>，<code>writeObject0()</code> 里会调用 <code>writeOrdinaryObject()</code>。</li><li>在 <code>writeOrdinaryObject()</code> 中会通过 <code>hasReadResolveMethod</code> 进行判断，如果实现了Serializable 或者 Externalizable 接口的类中包含 <code>readResolve</code> 则返回 true。从而调用 <code>invokeReadResolve</code>，通过反射的方式调用要被反序列化的类的 <code>readResolve()</code> 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="keyword">null</span> </span><br><span class="line">    &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">    <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">        rep = cloneArray(rep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">        handles.setObject(passHandle, obj = rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化与对象的深拷贝"><a href="#序列化与对象的深拷贝" class="headerlink" title="序列化与对象的深拷贝"></a>序列化与对象的深拷贝</h3><p>实现对象的深拷贝有以下几种方法：</p><ol><li>实现 Clonable 接口，重写 clone() 方法，这种方法没有通用性，优点在于实现简单，并且可以实现定制化。</li><li>基于反射，BeanUtil、Spring 核心包提供的一个工具类，基本原理就是获取 class 实例化，再通过反射实现对象的深拷贝。</li><li>基于Serialize、Deserialize 实现，这种办法比较多，本质上和反射类似，反射相当于 JVM 提供，而 Serialize 是基于上层协议。具体实现可以参考 RMI、thrift、protobuf 序列化方式。</li><li>基于 Unsafe 内存，这种方法极不推荐使用，直接复制对象内存空间，容易造成内存泄露。</li></ol><p>在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">    T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//写入字节流</span></span><br><span class="line">      ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">      ObjectOutputStream obs = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">      obs.writeObject(obj);</span><br><span class="line">      obs.close();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//分配内存，写入原始对象，生成新对象</span></span><br><span class="line">      ByteArrayInputStream ios = <span class="keyword">new</span> ByteArrayInputStream(out.toByteArray());</span><br><span class="line">      ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(ios);</span><br><span class="line">      <span class="comment">//返回生成的新对象</span></span><br><span class="line">      cloneObj = (T) ois.readObject();</span><br><span class="line">      ois.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也可以使用 Apache 推出的 SerializationUtils 序列化工具类</p><h4 id="SerializationUtils-功能"><a href="#SerializationUtils-功能" class="headerlink" title="SerializationUtils 功能"></a>SerializationUtils 功能</h4><ul><li>使用序列化进行深度克隆</li><li>序列化对象</li><li>反序列化对象</li></ul><h4 id="SerializationUtils-优缺点"><a href="#SerializationUtils-优缺点" class="headerlink" title="SerializationUtils  优缺点"></a>SerializationUtils 优缺点</h4><ul><li>深度拷贝实现比较简单，不用实现Cloneable接口。</li><li>深度拷贝<strong>效率不如实现Cloneable接口高</strong>。</li><li>序列化和反序列化，是基于jdk自带的序列化，速度慢，占空间。效率不如Protostuff、Hessian、Kryo等专业序列化工具高。</li></ul><p>更深入的序列化知识可以参考: <a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html" target="_blank" rel="noopener">序列化和反序列化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序列化和反序列化&quot;&gt;&lt;a href=&quot;#序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化和反序列化&quot;&gt;&lt;/a&gt;序列化和反序列化&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="序列化" scheme="https://muhouer.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>演化杂记</title>
    <link href="https://muhouer.github.io/posts/4b4e75fa/"/>
    <id>https://muhouer.github.io/posts/4b4e75fa/</id>
    <published>2019-09-03T16:50:36.000Z</published>
    <updated>2019-09-03T16:56:25.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为什么现在的孩子越来越高、越来越胖？<br>为什么青少年糖尿病越来越多、发病年龄越来越小？<br>为什么越来越多的现代人患上了哮喘、过敏性鼻炎以及五花八门的食物过敏？<br>种种“现代疾病”背后是否有个共同的“罪魁祸首”？</p><p>美国著名科学家马丁布莱泽认为，在过去的几十年里，由于滥用抗生素及剖宫产，我们在不经意间已经伤害了与人类协同演化了数十万年之久的“微生物朋友”，特别是在我们的孩子们身上。这扰乱了人体内微生物的稳态，打破了人体与微生物之间的平衡，进而危害了我们孩子的代谢、免疫和认知能力。</p><footer><strong>微生物</strong></footer></blockquote><hr><blockquote><p>所谓碳基，其实是碳氮合体，碳四氮五氧六氢一，勾结出的一类扭曲生命，柔弱而多愁善感，利用电子结合化学能繁衍生息，能量利用总量低而熵效率高，因此能一直默默不查的偷生于宇宙中而繁衍数十亿年。碳基生命需要用氧氢化合物为催化剂，所以在宇宙背景温度到373k以下时才有萌芽可能，之前没有碳基生命存在。</p><p>地球上的碳基生命经过数亿年进化，于西元1900年发现光电效应，并进一步开发出硅基光电板，由此接触到硅基生命能量模式。硅基生命为镓锗合体，以硅氧为催化剂，利用光电效应直接产生能量繁衍生息。硅基以光传导能量进行代谢，低端硅基生命身体透明，有智能的高级硅基生命布满光纤，以硅氧熔沸点预测，在宇宙背景温度到2500k以下时才有萌芽可能，之前没有硅基生命存在。</p><p>碳基生命西元1945年第一次核爆敲开了铁基生命的大门。铁基以核能为驱动，生命温度在铁沸点以上，以气态和离子态存在，可以说在第一个铁元素诞生的时候就有了铁基生命，铁基生命能量利用巨大，一个低端铁基生命每秒耗费的能量相当于一个广岛原子弹。铁基生命是宇宙中最耀眼的生命，信息以量子纠缠传递，可以轻易实现虫洞在星系间穿梭，是最适合宇宙级生存的生命。</p><p>以能量产生和消耗方式来看，硅基生命不过是在食用铁基生命代谢出的废物－光来生存，而碳基生命则是更低等的生命，食用硅基生命的代谢产物－低端化学能来生存，这些低端化学能产生的光和热能不足以满足硅基生命的生存下限。</p><footer><strong>碳基、硅基、铁基</strong></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;为什么现在的孩子越来越高、越来越胖？&lt;br&gt;为什么青少年糖尿病越来越多、发病年龄越来越小？&lt;br&gt;为什么越来越多的现代人患上了哮喘、过敏性鼻炎以及五花八门的食物过敏？&lt;br&gt;种种“现代疾病”背后是否有个共同的“罪魁祸首”？&lt;/p&gt;&lt;p&gt;美国著名科学家
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="https://muhouer.github.io/posts/2b9621c6/"/>
    <id>https://muhouer.github.io/posts/2b9621c6/</id>
    <published>2019-09-03T16:39:00.000Z</published>
    <updated>2019-09-03T16:41:56.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul><li><p><strong>进程(Process)</strong>：计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p></li><li><p><strong>线程(Thread)</strong>：进程的组成部分，它代表了一条顺序的执行流。线程依托于进程存在，在进程之下，可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据。</p></li><li><p><strong>并行(parallel)</strong>：指在同一时刻，有多条指令在多个处理器上同时执行。</p></li></ul><p><img src="/images/201909040011.png" alt="parallel"></p><ul><li><strong>并发(concurrency)</strong>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li></ul><p><img src="/images/201909040012.png" alt="concurrency"></p><blockquote><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><p>不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源。</p></blockquote><hr><p><strong>@UsesJava8</strong></p><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><p>使用线程池有三个好处</p><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><p>但是只有对线程池原理有深入的了解才能最大程度发挥线程池的作用。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过 <code>ThreadPoolExecutor</code> 来创建一个线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="comment">// 核心线程数</span></span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize, <span class="comment">// 最大线程数</span></span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime, <span class="comment">// 线程存活时间</span></span><br><span class="line">                   TimeUnit unit, <span class="comment">// 线程存活时间的单位</span></span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 阻塞队列</span></span><br><span class="line">                   ThreadFactory threadFactory, <span class="comment">// 创建线程的工厂</span></span><br><span class="line">                   RejectedExecutionHandler handler)  <span class="comment">// 拒绝策略</span></span><br></pre></td></tr></table></figure><p>参数解释如下：</p><ul><li><p><strong>corePoolSize</strong>: 当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于<strong>核心线程数</strong>时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有核心线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>maximumPoolSize</strong>: 线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</p></li><li><p><strong>keepAliveTime</strong>: 线程池的工作线程空闲后，存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p></li><li><p><strong>unit</strong>： 可选的单位有 <code>DAYS</code>，<code>HOURS</code>，<code>MINUTES</code>，<code>MILLISECONDS</code>，<code>MICROSECONDS</code>，<code>NANOSECONDS</code>。参考<code>TimeUnit</code></p></li><li><p><strong>workQueue</strong>: 用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ul><li><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法 <code>Executors.newFixedThreadPool()</code> 使用了这个队列</li><li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 <code>LinkedBlockingQueue</code>，静态工厂方法 <code>Executors.newCachedThreadPool</code> 使用了这个队列。</li><li><code>PriorityBlockingQueue</code>：一个具有优先级得无限阻塞队列。</li></ul></li><li><p><strong>threadFactory</strong>: 可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug 和定位问题时非常又帮助。</p></li><li><p><strong>handler</strong>: 当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。</p><ul><li><p><code>CallerRunsPolicy</code>: 调用者运行策略。当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。一般在不允许失败的、对性能要求不高、并发量较小的场景下使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>AbortPolicy</code>: 中止策略。当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>DiscardPolicy</code>: 丢弃策略。不触发任何动作地丢弃这个任务。如果你提交的任务无关紧要，你就可以使用它 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>DiscardOldestPolicy</code>: 弃老策略。如果线程池未关闭，就弹出队列头部的元素，然后尝试执行。发布消息，和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><h4 id="通过-execute-向线程池提交任务"><a href="#通过-execute-向线程池提交任务" class="headerlink" title="通过 execute 向线程池提交任务"></a>通过 <code>execute</code> 向线程池提交任务</h4><p>execute 方法没有返回值，无法判断任务知否被线程池执行成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get(); <span class="comment">// 获取到当前有效的线程数和线程池的状态</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 线程数小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 在addWorker中创建工作线程执行任务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 线程池是否处于运行状态，且是否任务插入任务队列成功</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 线程池是否处于运行状态，如果不是则使刚刚的任务出队</span></span><br><span class="line">            reject(command); <span class="comment">// 执行拒绝策略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 继续创建线程</span></span><br><span class="line">    &#125; <span class="comment">// 插入队列不成功，且当前线程数数量小于最大线程池数量，此时则创建新线程执行任务，创建失败抛出异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command); <span class="comment">// 创建线程失败执行拒绝策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过-submit向线程池提交任务"><a href="#通过-submit向线程池提交任务" class="headerlink" title="通过 submit向线程池提交任务"></a>通过 <code>submit</code>向线程池提交任务</h4><p>submit 方法返回一个 future ，可以通过这个 future 来判断任务是否执行成功，通过 future 的 get() 方法来获取返回值，get() 方法会阻塞住直到任务完成，而使用 get(long timeout, TimeUnit unit) 方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p>我们可以通过调用线程池的 shutdown() 或 shutdownNow() 方法来关闭线程池，但是它们的实现原理不同，shutdown 的原理是只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。shutdownNow 的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt() 方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow 会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</p><p>只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 isTerminaed() 方法会返回 true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。</p><h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p><strong>通过线程池提供的参数进行监控</strong>。线程池里有一些属性在监控线程池的时候可以使用</p><ul><li><strong>taskCount</strong>: 线程池需要执行的任务数量。</li><li><strong>completedTaskCount</strong>: 线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li><li><strong>largestPoolSize</strong>: 线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li><li><strong>getPoolSize</strong>: 线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。</li><li><strong>getActiveCount</strong>：获取活动的线程数。</li></ul><p><strong>通过扩展线程池进行监控</strong>。通过继承线程池并重写线程池的 beforeExecute，afterExecute 和 terminated 方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的配置策略"><a href="#线程池的配置策略" class="headerlink" title="线程池的配置策略"></a>线程池的配置策略</h2><h3 id="根据任务性质设置"><a href="#根据任务性质设置" class="headerlink" title="根据任务性质设置"></a>根据任务性质设置</h3><p>通常这种设置方式是比较粗略的方式。要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p><ol><li><p><strong>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</strong></p><p>CPU 密集型任务配置尽可能小的线程，如配置CPU数+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*CPU数。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 方法获得当前设备的CPU个数。</p></li><li><p><strong>任务的优先级：高，中和低。</strong></p></li><li><p><strong>任务的执行时间：长，中和短。</strong></p><p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p></li><li><p><strong>任务的依赖性：是否依赖其他系统资源，如数据库连接。</strong></p><p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p></li></ol><p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。如果使用无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。</p><h3 id="利特尔法则"><a href="#利特尔法则" class="headerlink" title="利特尔法则"></a>利特尔法则</h3><blockquote><p>利特尔法则（Little’s law）是说，一个系统请求数等于请求的到达率与平均每个单独请求花费的时间之乘积。</p></blockquote><p>我们可以使用利特尔法则（Little’s law）来判定线程池大小。我们只需计算请求到达率和请求处理的平均时间。然后，将上述值放到利特尔法则（Little’s law）就可以算出系统平均请求数。若请求数小于我们线程池的大小，就相应地减小线程池的大小。与之相反，如果请求数大于线程池大小，事情就有点复杂了。</p><p>当遇到有更多请求待处理的情况时，我们首先需要评估系统是否有足够的能力支持更大的线程池。准确评估的前提是，我们必须评估哪些资源会限制应用程序的扩展能力。最简单的情况是，我们有足够的空间增加线程池的大小。若没有的话，你不得不考虑其它选项，如软件调优、增加硬件，或者调优并增加硬件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a&gt;一些概念&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;进程(Process)&lt;/strong&gt;：计算机中的程序关于某数据集合上的一次运行活动，是系
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
      <category term="线程池" scheme="https://muhouer.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>拾句-甜</title>
    <link href="https://muhouer.github.io/posts/ead251ab/"/>
    <id>https://muhouer.github.io/posts/ead251ab/</id>
    <published>2019-09-02T16:53:44.000Z</published>
    <updated>2019-09-02T17:02:33.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="星星睡不着，在数人类。"><a href="#星星睡不着，在数人类。" class="headerlink" title="星星睡不着，在数人类。"></a>星星睡不着，在数人类。</h3><ol><li><strong>有一些小猫假扮成人类来跟我们相爱。</strong></li><li><strong>我也就一般甜啦，也就半糖烤奶加泷珠。</strong></li><li><strong>我们一块儿发会呆吧。</strong></li><li><strong>我永远屈服于温柔，而你是温柔本身。</strong></li><li><strong>放下你的刀，来做本王的妻子吧。</strong></li><li><strong>每天都会有让人长胖的好事情发生。</strong></li><li><strong>你的春日好运正在派件，请保持心情舒畅。</strong></li><li><strong>可爱之人必遇可爱之事。</strong></li><li><strong>希望下次喜欢和合适可以撞个满怀。</strong></li></ol><hr><h3 id="你是我见一个爱一个里面最爱的一个。"><a href="#你是我见一个爱一个里面最爱的一个。" class="headerlink" title="你是我见一个爱一个里面最爱的一个。"></a>你是我见一个爱一个里面最爱的一个。</h3><ol><li><strong>我要去宇宙了，回来摘星星给你。</strong></li><li><strong>好好生活，活到夏天。</strong></li><li><strong>这个人很懒，什么都没有留下。</strong></li><li><strong>既然来到这个世界的话，那就稍微喜欢一下它吧。</strong></li><li><strong>研究了一晚上宇宙，宇宙没理我。</strong></li><li><strong>这家伙很懒，却还想留下点儿什么。</strong></li><li><strong>一觉醒来，觉得甚是爱你。</strong></li><li><strong>你再不来，我就要下雪了。</strong></li><li><strong>所有的告别中，我最喜欢明天见。</strong></li></ol><hr><h3 id="我马上要恋爱了，和谁不知道，先替他高兴一下。"><a href="#我马上要恋爱了，和谁不知道，先替他高兴一下。" class="headerlink" title="我马上要恋爱了，和谁不知道，先替他高兴一下。"></a>我马上要恋爱了，和谁不知道，先替他高兴一下。</h3><ol><li><strong>薏仁做事薏仁汤，小丁做事小叮当。</strong></li><li><strong>既然来了就磕个头再走吧。</strong></li><li><strong>成熟的大人会不动声色的穿上秋裤。</strong></li><li><strong>请你一定要对号入座，我说的所有星光月亮、清泉小溪、蘸着糖的奶油和蜂蜜——这世间所有的美好事物，都只是为了形容你。</strong></li><li><strong>你不是什么小人物，在我这里你是所有的天气和心情。</strong></li><li><strong>我想对你做春天对樱桃树做的事。</strong></li><li><strong>国家二级退堂鼓演奏家</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;星星睡不着，在数人类。&quot;&gt;&lt;a href=&quot;#星星睡不着，在数人类。&quot; class=&quot;headerlink&quot; title=&quot;星星睡不着，在数人类。&quot;&gt;&lt;/a&gt;星星睡不着，在数人类。&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;有一些小猫假扮成人类来跟我们相爱。&lt;/st
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>今天就和孩子签订一份成长协议</title>
    <link href="https://muhouer.github.io/posts/9085c4b7/"/>
    <id>https://muhouer.github.io/posts/9085c4b7/</id>
    <published>2019-09-01T14:20:17.000Z</published>
    <updated>2019-09-01T14:25:14.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：连岳<br>原文链接： <a href="https://mp.weixin.qq.com/s/stMBnSo8YJKf5N2YEXrxdQ" target="_blank" rel="noopener">今天就和孩子签订一份成长协议</a></p></blockquote><p>一想到教育，任务繁重，多数人万千愁绪，不知从何抓起。但任务越重大，起点越要轻微。一点点改变，往往就能改变事物的性质。</p><p>有位家长提供了一份简单的成长协议，非常高明，值得推广：</p><img src="/images/201909011020.png" width="800px" height="300px" align="center"><p>初初一看，这没什么稀奇，开学之际，父母都会对孩子提出各种成长要求。这位家长提出的要求高得多，每天提早半小时到校，这个改变，孩子就算完成度只有50%，除了早上比同学更从容，更多一点学习时间，还意味着他更早睡，更早完成作业，效率更高，作息时间的细微调整，将重组一天的时间结构。</p><p>但是孩子提出了反制，这也不稀奇，当孩子被批评，被要求时，他们下意识的还击就是：那你自己如何如何。那你自己又做不到！是一句彻底激怒家长的话，羞愧、无能、耻辱、被冒犯、被伤害，一起发作，瞬间失去理智，家长将用强势地位压制孩子的反制，手段可能是物理或语言的暴力，或是各种辩解及转移话题，甚至流着泪说，要不是因为你耽误，我早就如何如何了。</p><p>家长的压制当然能成功，孩子依靠你生存，这是他天然的不利。但付出的代价，却是成功教育者两大要件的丧失，一是威信，二是真诚。这两大要件相辅相成，失去其一，另外一个也成立不了。</p><p>教育就是不停地讲道理，提要求。教育者本身的品德、能量令人敬佩，他讲道理事半功倍。一个天天玩手机的家长，警告孩子沉迷手机的危害，孩子当然认为你说假话。一个从不阅读，没有能力深阅读的家长，天天叨阅读的好处，必然没有任何效果，你只会学舌，他人说法的对错你都无法分辨，将一堆矛盾冲突的观点塞给孩子，他更加困惑，无所适从。</p><p>家长无法对孩子隐藏自己的真面目，你若不值得尊重，第一个瞧不起你的，就是传承你DNA的孩子。一旦你放纵、无能、愚蠢、不负责任，精神上的弑父（母）就在发生。无论你多么花言巧语，教育都失效了。说话的技巧并不是教育的根本，在孩子心目中有威信的父母，怎么说都有效，说话技术好，效果更好而已。</p><p>上面那位家长，接受孩子的反要求。有意无意，这迈出了质变的一小步。家长从孩子的要求中，可以发现自己忽视的缺点，那正是威信正在动摇的地方。同时有了被教育、被监督的弱势身份，在完成计划的过程中，可以体验学习与进步的艰难，不再只是轻松的动动嘴的教育者，和孩子一起学习， 一起成长，积累与交流这种经验就是不可替代的教育资源。而孩子突然有了教育者与监督者的强势身份，就像他小时候扮演老虎，他要表现得像只老虎，当他行使教育者与监督者职责时，他有了原来没有的视角与想法，这有利于他理解教育者。为了保有这份“权力”，他必须成为一个更好的学习者与履约者。</p><p>我建议家长与孩子坐下来谈一谈，有意识地赋予孩子反制权，签订一份合理的、双方认同的一起成长计划，双方互为教育者与被教育者，监督者与被监督者。根据完成度，执行相应的奖罚。我知道，很多家长也有阅读计划，锻炼计划，学习计划，以及各种其他计划，但是自律性差，往往虎头蛇尾。有个无情的监督者，尤其他是你的孩子，你不能输，那么，你计划的完成度将大大提升，你的人生，因为有了和孩子一起成长的具体约定与行动，将如开挂一般。</p><p>今天就订一个成长协议，虽然这对家长的要求更高了，但是一个负责任的家长，是不会怕的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者：连岳&lt;br&gt;原文链接： &lt;a href=&quot;https://mp.weixin.qq.com/s/stMBnSo8YJKf5N2YEXrxdQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;今天就和孩子签订一份成长协议&lt;/a&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java优雅之道</title>
    <link href="https://muhouer.github.io/posts/b9a3a63c/"/>
    <id>https://muhouer.github.io/posts/b9a3a63c/</id>
    <published>2019-09-01T01:23:00.000Z</published>
    <updated>2019-09-01T01:43:36.466Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文作者：</strong>陈昌毅，花名常意，高德地图技术专家，2018年加入阿里巴巴，一直从事地图数据采集的相关工作。</p><p><strong>原文地址：</strong><a href="https://mp.weixin.qq.com/s/rjK5OZ_Kx7E5YUGgVp0BCw" target="_blank" rel="noopener">Java 函数优雅之道</a></p></blockquote><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>随着软件项目代码的日积月累，系统维护成本变得越来越高，是所有软件团队面临的共同问题。持续地优化代码，提高代码的质量，是提升系统生命力的有效手段之一。软件系统思维有句话“<strong>Less coding, more thinking（少编码、多思考）</strong>”，也有这么一句俚语“<strong>Think more, code less（思考越多，编码越少）</strong>”。所以，我们在编码中多思考多总结，努力提升自己的编码水平，才能编写出更优雅、更高质、更高效的代码。</p><p>本文总结了一套与 Java 函数相关的编码规则，旨在给广大Java程序员一些编码建议，有助于大家编写出更优雅、更高质、更高效的代码。这套编码规则，通过在高德采集部门的实践，已经取得了不错的成效。</p><h2 id="使用通用工具函数"><a href="#使用通用工具函数" class="headerlink" title="使用通用工具函数"></a>使用通用工具函数</h2><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述:</strong></p><p><strong>不完善的写法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisName != <span class="keyword">null</span> &amp;&amp; thisName.equals(name);</span><br></pre></td></tr></table></figure><p><strong>更完善的写法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(thisName == name) || (thisName != <span class="keyword">null</span> &amp;&amp; thisName.equals(name));</span><br></pre></td></tr></table></figure><p><strong>建议方案:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(name, thisName);</span><br></pre></td></tr></table></figure><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p><strong>现象描述:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(list == <span class="keyword">null</span> || list.isEmpty());</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line">CollectionUtils.isNotEmpty(list);</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>函数式编程，业务代码减少，逻辑一目了然；</li><li>通用工具函数，逻辑考虑周全，出问题概率低。</li></ul><h2 id="拆分超大函数"><a href="#拆分超大函数" class="headerlink" title="拆分超大函数"></a>拆分超大函数</h2><p>当一个函数超过80行后，就属于超大函数，需要进行拆分。</p><h3 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h3><p><strong>每一个代码块必然有一个注释，用于解释这个代码块的功能。</strong>如果代码块前方有一行注释，就是在提醒你——可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。如果函数有一个描述恰当的名字，就不需要去看内部代码究竟是如何实现的。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    <span class="comment">// 吃饭相关代码几十行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="comment">// 编码相关代码几十行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    <span class="comment">// 睡觉相关代码几十行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吃饭函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭相关代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编码相关代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡觉函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 睡觉相关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二-每一个循环体都可以封装为一个函数。"><a href="#案例二-每一个循环体都可以封装为一个函数。" class="headerlink" title="案例二:每一个循环体都可以封装为一个函数。"></a>案例二:每一个循环体都可以封装为一个函数。</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive) &#123;</span><br><span class="line">        <span class="comment">// 吃饭</span></span><br><span class="line">        eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编码</span></span><br><span class="line">        code();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡觉</span></span><br><span class="line">        sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive) &#123;</span><br><span class="line">        <span class="comment">// 每日生活</span></span><br><span class="line">        liveDaily();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三-每一个条件体都可以封装为一个函数。"><a href="#案例三-每一个条件体都可以封装为一个函数。" class="headerlink" title="案例三:每一个条件体都可以封装为一个函数。"></a>案例三:每一个条件体都可以封装为一个函数。</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外出函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否周末</span></span><br><span class="line">    <span class="comment">// 判断是否周末: 是周末则游玩</span></span><br><span class="line">    <span class="keyword">if</span> (isWeekday()) &#123;</span><br><span class="line">        <span class="comment">// 游玩代码几十行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否周末: 非周末则工作</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 工作代码几十行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外出函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否周末</span></span><br><span class="line">    <span class="comment">// 判断是否周末: 是周末则游玩</span></span><br><span class="line">    <span class="keyword">if</span> (isWeekday()) &#123;</span><br><span class="line">        play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否周末: 非周末则工作</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游玩函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 游玩代码几十行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 工作代码几十行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>函数越短小精悍，功能就越单一，往往生命周期较长；</li><li>一个函数越长，就越不容易理解和维护，维护人员不敢轻易修改；</li><li>在过长函数中，往往含有难以发现的重复代码。</li></ul><h2 id="同一函数内代码块级别尽量一致"><a href="#同一函数内代码块级别尽量一致" class="headerlink" title="同一函数内代码块级别尽量一致"></a>同一函数内代码块级别尽量一致</h2><h3 id="案例一-2"><a href="#案例一-2" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    <span class="comment">// 睡觉相关代码几十行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，睡觉这块代码块，跟 eat（吃饭）和 code（编码）不在同一级别上，显得比较突兀。如果把写代码比作写文章，eat（吃饭）和code（编码）是段落大意，而睡觉这块代码块属于一个详细段落。而在 liveDaily（每日生活）这个函数上，只需要写出主要流程（段落大意）即可。</p><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡觉</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 睡觉相关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>函数调用表明用途，函数实现表达逻辑，层次分明便于理解；</li><li>不用层次的代码块放在一个函数中，容易让人觉得代码头重脚轻。</li></ul><h2 id="封装相同功能代码为函数"><a href="#封装相同功能代码为函数" class="headerlink" title="封装相同功能代码为函数"></a>封装相同功能代码为函数</h2><h3 id="案例一：封装相同代码为函数"><a href="#案例一：封装相同代码为函数" class="headerlink" title="案例一：封装相同代码为函数"></a>案例一：封装相同代码为函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disableUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 禁用黑名单用户</span></span><br><span class="line">    List&lt;Long&gt; userIdList = queryBlackUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        User userUpdate = <span class="keyword">new</span> User();</span><br><span class="line">        userUpdate.setId(userId);</span><br><span class="line">        userUpdate.setEnable(Boolean.FALSE);</span><br><span class="line">        userDAO.update(userUpdate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用过期用户</span></span><br><span class="line">    userIdList = queryExpiredUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        User userUpdate = <span class="keyword">new</span> User();</span><br><span class="line">        userUpdate.setId(userId);</span><br><span class="line">        userUpdate.setEnable(Boolean.FALSE);</span><br><span class="line">        userDAO.update(userUpdate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disableUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 禁用黑名单用户</span></span><br><span class="line">    List&lt;Long&gt; userIdList = queryBlackUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        disableUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用过期用户</span></span><br><span class="line">    userIdList = queryExpiredUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        disableUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disableUser</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    User userUpdate = <span class="keyword">new</span> User();</span><br><span class="line">    userUpdate.setId(userId);</span><br><span class="line">    userUpdate.setEnable(Boolean.FALSE);</span><br><span class="line">    userDAO.update(userUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：封装相似代码为函数"><a href="#案例二：封装相似代码为函数" class="headerlink" title="案例二：封装相似代码为函数"></a>案例二：封装相似代码为函数</h3><p>封装相似代码为函数，差异性通过函数参数控制。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adoptOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    Order orderUpdate = <span class="keyword">new</span> Order();</span><br><span class="line">    orderUpdate.setId(orderId);</span><br><span class="line">    orderUpdate.setStatus(OrderStatus.ADOPTED);</span><br><span class="line">    orderUpdate.setAuditTime(<span class="keyword">new</span> Date());</span><br><span class="line">    orderDAO.update(orderUpdate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驳回工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    Order orderUpdate = <span class="keyword">new</span> Order();</span><br><span class="line">    orderUpdate.setId(orderId);</span><br><span class="line">    orderUpdate.setStatus(OrderStatus.REJECTED);</span><br><span class="line">    orderUpdate.setAuditTime(<span class="keyword">new</span> Date());</span><br><span class="line">    orderDAO.update(orderUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adoptOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    auditOrder(orderId, OrderStatus.ADOPTED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驳回工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    auditOrder(orderId, OrderStatus.REJECTED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 审核工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">auditOrder</span><span class="params">(Long orderId, OrderStatus orderStatus)</span> </span>&#123;</span><br><span class="line">    Order orderUpdate = <span class="keyword">new</span> Order();</span><br><span class="line">    orderUpdate.setId(orderId);</span><br><span class="line">    orderUpdate.setStatus(orderStatus);</span><br><span class="line">    orderUpdate.setAuditTime(<span class="keyword">new</span> Date());</span><br><span class="line">    orderDAO.update(orderUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>封装公共函数，减少代码行数，提高代码质量；</li><li>封装公共函数，使业务代码更精炼，可读性可维护性更强。</li></ul><h2 id="封装获取参数值函数"><a href="#封装获取参数值函数" class="headerlink" title="封装获取参数值函数"></a>封装获取参数值函数</h2><h3 id="案例一-3"><a href="#案例一-3" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取通过阈值</span></span><br><span class="line">    <span class="keyword">double</span> thisPassThreshold = PASS_THRESHOLD;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(passThreshold)) &#123;</span><br><span class="line">        thisPassThreshold = passThreshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取通过率</span></span><br><span class="line">    <span class="keyword">double</span> passRate = getPassRate(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判读是否通过</span></span><br><span class="line">    <span class="keyword">return</span> passRate &gt;= thisPassThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取通过阈值</span></span><br><span class="line">    <span class="keyword">double</span> thisPassThreshold = getPassThreshold();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取通过率</span></span><br><span class="line">    <span class="keyword">double</span> passRate = getPassRate(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判读是否通过</span></span><br><span class="line">    <span class="keyword">return</span> passRate &gt;= thisPassThreshold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取通过阈值函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getPassThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(passThreshold)) &#123;</span><br><span class="line">        <span class="keyword">return</span> passThreshold;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PASS_THRESHOLD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>把获取参数值从业务函数中独立，使业务逻辑更清晰；</li><li>封装的获取参数值为独立函数，可以在代码中重复使用。</li></ul><h2 id="通过接口参数化封装相同逻辑"><a href="#通过接口参数化封装相同逻辑" class="headerlink" title="通过接口参数化封装相同逻辑"></a>通过接口参数化封装相同逻辑</h2><h3 id="案例一-4"><a href="#案例一-4" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送审核员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAuditorSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WorkerSettleData&gt; settleDataList = auditTaskDAO.statAuditorSettleData();</span><br><span class="line">    <span class="keyword">for</span> (WorkerSettleData settleData : settleDataList) &#123;</span><br><span class="line">        WorkerPushData pushData = <span class="keyword">new</span> WorkerPushData();</span><br><span class="line">        pushData.setId(settleData.getWorkerId());</span><br><span class="line">        pushData.setType(WorkerPushDataType.AUDITOR);</span><br><span class="line">        pushData.setData(settleData);</span><br><span class="line">        pushService.push(pushData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送验收员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCheckerSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WorkerSettleData&gt; settleDataList = auditTaskDAO.statCheckerSettleData();</span><br><span class="line">    <span class="keyword">for</span> (WorkerSettleData settleData : settleDataList) &#123;</span><br><span class="line">        WorkerPushData pushData = <span class="keyword">new</span> WorkerPushData();</span><br><span class="line">        pushData.setId(settleData.getWorkerId());</span><br><span class="line">        pushData.setType(WorkerPushDataType.CHECKER);</span><br><span class="line">        pushData.setData(settleData);</span><br><span class="line">        pushService.push(pushData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送审核员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAuditorSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendWorkerSettleData(WorkerPushDataType.AUDITOR, () -&gt; auditTaskDAO.statAuditorSettleData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送验收员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCheckerSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; auditTaskDAO.statCheckerSettleData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送作业员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendWorkerSettleData</span><span class="params">(WorkerPushDataType dataType, WorkerSettleDataProvider dataProvider)</span> </span>&#123;</span><br><span class="line">    List&lt;WorkerSettleData&gt; settleDataList = dataProvider.statWorkerSettleData();</span><br><span class="line">    <span class="keyword">for</span> (WorkerSettleData settleData : settleDataList) &#123;</span><br><span class="line">        WorkerPushData pushData = <span class="keyword">new</span> WorkerPushData();</span><br><span class="line">        pushData.setId(settleData.getWorkerId());</span><br><span class="line">        pushData.setType(dataType);</span><br><span class="line">        pushData.setData(settleData);</span><br><span class="line">        pushService.push(pushData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作业员结算数据提供者接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerSettleDataProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 统计作业员结算数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;WorkerSettleData&gt; <span class="title">statWorkerSettleData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>把核心逻辑从各个业务函数中抽析，使业务代码更清晰更易维护；</li><li>避免重复性代码多次编写，精简重复函数越多收益越大。</li></ul><h2 id="减少函数代码层级"><a href="#减少函数代码层级" class="headerlink" title="减少函数代码层级"></a>减少函数代码层级</h2><p>如果要使函数优美，建议函数代码层级在1-4之间，过多的缩进会让函数难以阅读。</p><h3 id="案例一：利用return提前返回函数"><a href="#案例一：利用return提前返回函数" class="headerlink" title="案例一：利用return提前返回函数"></a>案例一：利用return提前返回函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">getUserBalance</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    User user = getUser(userId);</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user)) &#123;</span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">            <span class="keyword">return</span> account.getBalance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">getUserBalance</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取用户信息</span></span><br><span class="line">    User user = getUser(userId);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户账户</span></span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(account)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回账户余额</span></span><br><span class="line">    <span class="keyword">return</span> account.getBalance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：利用continue提前结束循环"><a href="#案例二：利用continue提前结束循环" class="headerlink" title="案例二：利用continue提前结束循环"></a>案例二：利用continue提前结束循环</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取合计余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始合计余额</span></span><br><span class="line">    <span class="keyword">double</span> totalBalance = <span class="number">0.0</span>D;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次累加余额</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 获取用户账户</span></span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">            <span class="comment">// 累加用户余额</span></span><br><span class="line">            Double balance = account.getBalance();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(balance)) &#123;</span><br><span class="line">                totalBalance += balance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回合计余额</span></span><br><span class="line">    <span class="keyword">return</span> totalBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取合计余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始合计余额</span></span><br><span class="line">    <span class="keyword">double</span> totalBalance = <span class="number">0.0</span>D;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次累加余额</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 获取用户账户</span></span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(account)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累加用户余额</span></span><br><span class="line">        Double balance = account.getBalance();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(balance)) &#123;</span><br><span class="line">            totalBalance += balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回合计余额</span></span><br><span class="line">    <span class="keyword">return</span> totalBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>特殊说明</em></strong></p><p>其它方式：在循环体中，先调用案例1的函数 getUserBalance (获取用户余额)，再进行对余额进行累加。</p><p><strong>在循环体中，建议最多使用一次 continue 。</strong>如果需要有使用多次 continue 的需求，建议把循环体封装为一个函数。</p><h3 id="案例三：利用条件表达式函数减少层级"><a href="#案例三：利用条件表达式函数减少层级" class="headerlink" title="案例三：利用条件表达式函数减少层级"></a>案例三：利用条件表达式函数减少层级</h3><p>请参考下一章的”案例2: 把复杂条件表达式封装为函数”</p><p><strong>主要收益</strong></p><ul><li>代码层级减少，代码缩进减少；</li><li>模块划分清晰，方便阅读维护。</li></ul><h2 id="封装条件表达式函数"><a href="#封装条件表达式函数" class="headerlink" title="封装条件表达式函数"></a>封装条件表达式函数</h2><h3 id="案例一：把简单条件表达式封装为函数"><a href="#案例一：把简单条件表达式封装为函数" class="headerlink" title="案例一：把简单条件表达式封装为函数"></a>案例一：把简单条件表达式封装为函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取门票价格函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">(Date currDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(currDate) &amp;&amp; currDate.after(DISCOUNT_BEGIN_DATE)</span><br><span class="line">        &amp;&amp; currDate.before(DISCOUNT_END_DATE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> TICKET_PRICE * DISCOUNT_RATE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TICKET_PRICE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取门票价格函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">(Date currDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDiscountDate(currDate)) &#123;</span><br><span class="line">        <span class="keyword">return</span> TICKET_PRICE * DISCOUNT_RATE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TICKET_PRICE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否折扣日期函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDiscountDate</span><span class="params">(Date currDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.nonNull(currDate) &amp;&amp; </span><br><span class="line">currDate.after(DISCOUNT_BEGIN_DATE)</span><br><span class="line">        &amp;&amp; currDate.before(DISCOUNT_END_DATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：把复杂条件表达式封装为函数"><a href="#案例二：把复杂条件表达式封装为函数" class="headerlink" title="案例二：把复杂条件表达式封装为函数"></a>案例二：把复杂条件表达式封装为函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取土豪用户列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getRichUserList</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始土豪用户列表</span></span><br><span class="line">    List&lt;User&gt; richUserList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次查找土豪用户</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 获取用户账户</span></span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">            <span class="comment">// 判断用户余额</span></span><br><span class="line">            Double balance = account.getBalance();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(balance) &amp;&amp; balance.compareTo(RICH_THRESHOLD) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 添加土豪用户</span></span><br><span class="line">                richUserList.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回土豪用户列表</span></span><br><span class="line">    <span class="keyword">return</span> richUserList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取土豪用户列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getRichUserList</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始土豪用户列表</span></span><br><span class="line">    List&lt;User&gt; richUserList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次查找土豪用户</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 判断土豪用户</span></span><br><span class="line">        <span class="keyword">if</span> (isRichUser(user)) &#123;</span><br><span class="line">            <span class="comment">// 添加土豪用户</span></span><br><span class="line">            richUserList.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回土豪用户列表</span></span><br><span class="line">    <span class="keyword">return</span> richUserList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否土豪用户</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRichUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取用户账户</span></span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(account)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户余额</span></span><br><span class="line">    Double balance = account.getBalance();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(balance)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较用户余额</span></span><br><span class="line">    <span class="keyword">return</span> balance.compareTo(RICH_THRESHOLD) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码也可以用采用流式(Stream)编程的过滤来实现。</p><p><strong>主要收益</strong></p><ul><li>把条件表达式从业务函数中独立，使业务逻辑更清晰；</li><li>封装的条件表达式为独立函数，可以在代码中重复使用。</li></ul><h2 id="尽量避免不必要的空指针判断"><a href="#尽量避免不必要的空指针判断" class="headerlink" title="尽量避免不必要的空指针判断"></a>尽量避免不必要的空指针判断</h2><p>本章只适用于项目内部代码，并且是自己了解的代码，才能够尽量避免不必要的空指针判断。对于第三方中间件和系统接口，必须做好空指针判断，以保证代码的健壮性。</p><h3 id="案例一-调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断"><a href="#案例一-调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断" class="headerlink" title="案例一: 调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断"></a>案例一: 调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建用户信息</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">... <span class="comment">// 赋值用户相关信息</span></span><br><span class="line">createUser(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断用户为空</span></span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建用户信息</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">... <span class="comment">// 赋值用户相关信息</span></span><br><span class="line">createUser(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二-被调用函数保证返回不为空-调用函数尽量避免不必要的空指针判断"><a href="#案例二-被调用函数保证返回不为空-调用函数尽量避免不必要的空指针判断" class="headerlink" title="案例二: 被调用函数保证返回不为空,调用函数尽量避免不必要的空指针判断"></a>案例二: 被调用函数保证返回不为空,调用函数尽量避免不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建用户信息</span></span><br><span class="line">    User user = buildUser(id, name);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizRuntimeException(<span class="string">"构建用户信息为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">buildUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(id);</span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建用户信息</span></span><br><span class="line">    User user = buildUser(id, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">buildUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(id);</span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断"><a href="#案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断" class="headerlink" title="案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断"></a>案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户列表</span></span><br><span class="line">List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化用户列表</span></span><br><span class="line">List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">    UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVo.setId(user.getId());</span><br><span class="line">    userVo.setName(user.getName());</span><br><span class="line">    userVoList.add(userVo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次处理用户</span></span><br><span class="line"><span class="keyword">for</span> (UserVO userVo : userVoList) &#123;</span><br><span class="line">    <span class="comment">// 判断用户为空</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(userVo)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理相关逻辑</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户列表</span></span><br><span class="line">List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化用户列表</span></span><br><span class="line">List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">    UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVo.setId(user.getId());</span><br><span class="line">    userVo.setName(user.getName());</span><br><span class="line">    userVoList.add(userVo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次处理用户</span></span><br><span class="line"><span class="keyword">for</span> (UserVO userVo : userVoList) &#123;</span><br><span class="line">    <span class="comment">// 处理相关逻辑</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断"><a href="#案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断" class="headerlink" title="案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断"></a>案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断</h3><p>MyBatis 是一款优秀的持久层框架，是在项目中使用的最广泛的数据库中间件之一。通过对 MyBatis 源码进行分析，查询函数返回的列表和数据项都不为空，在代码中可以不用进行空指针判断。</p><p><strong>现象描述：</strong></p><p>这种写法没有问题，只是过于保守了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.query(id, name);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; voList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">        <span class="comment">// 判断对象为空</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加用户信息</span></span><br><span class="line">        UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        BeanUtils.copyProperties(user, vo);</span><br><span class="line">        voList.add(vo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> voList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.query(id, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; voList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">        UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        BeanUtils.copyProperties(user, vo);</span><br><span class="line">        voList.add(vo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> voList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>避免不必要的空指针判断，精简业务代码处理逻辑，提高业务代码运行效率；</li><li>这些不必要的空指针判断，基本属于永远不执行的 Death 代码，删除有助于代码维护。</li></ul><h2 id="内部函数参数尽量使用基础类型"><a href="#内部函数参数尽量使用基础类型" class="headerlink" title="内部函数参数尽量使用基础类型"></a>内部函数参数尽量使用基础类型</h2><h3 id="案例一：内部函数参数尽量使用基础类型"><a href="#案例一：内部函数参数尽量使用基础类型" class="headerlink" title="案例一：内部函数参数尽量使用基础类型"></a>案例一：内部函数参数尽量使用基础类型</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line"><span class="keyword">double</span> price = <span class="number">5.1</span>D;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">double</span> total = calculate(price, number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(Double price, Integer number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line"><span class="keyword">double</span> price = <span class="number">5.1</span>D;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">double</span> total = calculate(price, number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：内部函数返回值尽量使用基础类型"><a href="#案例二：内部函数返回值尽量使用基础类型" class="headerlink" title="案例二：内部函数返回值尽量使用基础类型"></a>案例二：内部函数返回值尽量使用基础类型</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取订单总额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getOrderAmount</span><span class="params">(List&lt;Product&gt; productList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> amount = <span class="number">0.0</span>D;</span><br><span class="line">    <span class="keyword">for</span> (Product product : productList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(product) || Objects.isNull(product.getPrice())</span><br><span class="line">            || Objects.isNull(product.getNumber())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        amount += calculate(product.getPrice(), product.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Double <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">double</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取订单总额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getOrderAmount</span><span class="params">(List&lt;Product&gt; productList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> amount = <span class="number">0.0</span>D;</span><br><span class="line">    <span class="keyword">for</span> (Product product : productList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(product) || Objects.isNull(product.getPrice())</span><br><span class="line">            || Objects.isNull(product.getNumber())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        amount += calculate(product.getPrice(), product.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">double</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处只是举例说明这种现象，更好的方式是采用流式(Stream)编程。</p><p><strong>主要收益</strong></p><ul><li>内部函数尽量使用基础类型，避免了隐式封装类型的打包和拆包；</li><li>内部函数参数使用基础类型，用语法上避免了内部函数的参数空指针判断；</li><li>内部函数返回值使用基础类型，用语法上避免了调用函数的返回值空指针判断。</li></ul><h2 id="尽量避免返回的数组和列表为-null"><a href="#尽量避免返回的数组和列表为-null" class="headerlink" title="尽量避免返回的数组和列表为 null"></a>尽量避免返回的数组和列表为 null</h2><h3 id="案例一：尽量避免返回的数组为-null-，引起不必要的空指针判断"><a href="#案例一：尽量避免返回的数组为-null-，引起不必要的空指针判断" class="headerlink" title="案例一：尽量避免返回的数组为 null ，引起不必要的空指针判断"></a>案例一：尽量避免返回的数组为 null ，引起不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">UserVO[] users = queryUser();</span><br><span class="line"><span class="keyword">if</span> (Objects.nonNull(users)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (UserVO user : users) &#123;</span><br><span class="line">        <span class="comment">// 处理用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="keyword">private</span> UserVO[] queryUser() &#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户数组</span></span><br><span class="line">    UserVO[] users = <span class="keyword">new</span> UserVO[userList.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userList.size(); i++) &#123;</span><br><span class="line">        UserDO user = userList.get(i);</span><br><span class="line">        users[i] = <span class="keyword">new</span> UserVO();</span><br><span class="line">        users[i].setId(user.getId());</span><br><span class="line">        users[i].setName(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户数组</span></span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">UserVO[] users = queryUser();</span><br><span class="line"><span class="keyword">for</span> (UserVO user : users) &#123;</span><br><span class="line">    <span class="comment">// 处理用户信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="keyword">private</span> UserVO[] queryUser() &#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserVO[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户数组</span></span><br><span class="line">    UserVO[] users = <span class="keyword">new</span> UserVO[userList.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userList.size(); i++) &#123;</span><br><span class="line">        UserDO user = userList.get(i);</span><br><span class="line">        users[i] = <span class="keyword">new</span> UserVO();</span><br><span class="line">        users[i].setId(user.getId());</span><br><span class="line">        users[i].setName(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户数组</span></span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：尽量避免返回的列表为-null-，引起不必要的空指针判断"><a href="#案例二：尽量避免返回的列表为-null-，引起不必要的空指针判断" class="headerlink" title="案例二：尽量避免返回的列表为 null ，引起不必要的空指针判断"></a>案例二：尽量避免返回的列表为 null ，引起不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">List&lt;UserVO&gt; userList = queryUser();</span><br><span class="line"><span class="keyword">if</span> (Objects.nonNull(userList)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (UserVO user : userList) &#123;</span><br><span class="line">        <span class="comment">// 处理用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span>(UserDO user : userList) &#123;</span><br><span class="line">        UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        userVo.setId(user.getId());</span><br><span class="line">        userVo.setName(user.getName());</span><br><span class="line">        userVoList.add(userVo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> userVoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">List&lt;UserVO&gt; userList = queryUser();</span><br><span class="line"><span class="keyword">for</span> (UserVO user : userList) &#123;</span><br><span class="line">   <span class="comment">// 处理用户信息</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span>(UserDO user : userList) &#123;</span><br><span class="line">        UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        userVo.setId(user.getId());</span><br><span class="line">        userVo.setName(user.getName());</span><br><span class="line">        userVoList.add(userVo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> userVoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>保证返回的数组和列表不为 null , 避免调用函数的空指针判断。</li></ul><h2 id="封装函数传入参数"><a href="#封装函数传入参数" class="headerlink" title="封装函数传入参数"></a>封装函数传入参数</h2><h3 id="案例一：当传入参数过多时，应封装为参数类"><a href="#案例一：当传入参数过多时，应封装为参数类" class="headerlink" title="案例一：当传入参数过多时，应封装为参数类"></a>案例一：当传入参数过多时，应封装为参数类</h3><p>Java 规范不允许函数参数太多，不便于维护也不便于扩展。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyUser</span><span class="params">(Long id, String name, String phone, Integer age, </span></span></span><br><span class="line"><span class="function"><span class="params">    Integer sex, String address, String description)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二-当传入成组参数时，应封装为参数类"><a href="#案例二-当传入成组参数时，应封装为参数类" class="headerlink" title="案例二: 当传入成组参数时，应封装为参数类"></a>案例二: 当传入成组参数时，应封装为参数类</h3><p>既然参数成组出现，就需要封装一个类去描述这种现象。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取距离函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取距离函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(Point point1, Point point2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>封装过多函数参数为类，使函数更便于扩展和维护；</li><li>封装成组函数参数为类，使业务概念更明确更清晰。</li></ul><h2 id="尽量用函数替换匿名内部类的实现"><a href="#尽量用函数替换匿名内部类的实现" class="headerlink" title="尽量用函数替换匿名内部类的实现"></a>尽量用函数替换匿名内部类的实现</h2><p>在匿名内部类（包括Lambda表达式）中可以直接访问外部类的成员，包括类的成员变量、函数的内部变量。正因为可以随意访问外部变量，所以会导致代码边界不清晰。</p><p>首先推荐用 Lambda 表达式简化匿名内部类，其次推荐用函数替换复杂的 Lambda 表达式的实现。</p><h3 id="案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现"><a href="#案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现" class="headerlink" title="案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现"></a>案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送结算数据</span></span><br><span class="line">sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; &#123;</span><br><span class="line">    Date beginDate = DateUtils.addDays(currDate, -aheadDays);</span><br><span class="line">    Date endDate = DateUtils.addDays(currDate, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> auditTaskDAO.statCheckerSettleData(beginDate, endDate);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送结算数据</span></span><br><span class="line">sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; statCheckerSettleData(currDate, aheadDays));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计验收员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;WorkerSettleData&gt; <span class="title">statCheckerSettleData</span><span class="params">(Date currDate, <span class="keyword">int</span> aheadDays)</span> </span>&#123;</span><br><span class="line">    Date beginDate = DateUtils.addDays(currDate, -aheadDays);</span><br><span class="line">    Date endDate = DateUtils.addDays(currDate, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> auditTaskDAO.statCheckerSettleData(beginDate, endDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，还有一个更简单的办法。在调用函数 sendWorkerSettleData（发送作业员结算数据）之前计算开始日期、结束日期，就直接可以用函数auditTaskDAO.statCheckerSettleData(beginDate, endDate)代替匿名内部类实现。</p><h3 id="案例二：拆分复杂匿名内部类实现接口为多个函数类接口"><a href="#案例二：拆分复杂匿名内部类实现接口为多个函数类接口" class="headerlink" title="案例二：拆分复杂匿名内部类实现接口为多个函数类接口"></a>案例二：拆分复杂匿名内部类实现接口为多个函数类接口</h3><p>如果一个匿名内部类实现的接口几个函数间关联性不大，可以把这个接口拆分为几个函数式接口，便于使用 Lambda 表达式。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除过期数据</span></span><br><span class="line">cleanExpiredData(<span class="string">"用户日志表"</span>, <span class="keyword">new</span> CleanExpiredDataOperator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Date&gt; <span class="title">queryExpiredDate</span><span class="params">(Integer remainDays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDAO.queryExpiredDate(remainDays);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(Date expiredDate)</span> </span>&#123;</span><br><span class="line">        userDAO.cleanExpiredData(expiredDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(String tableName, CleanExpiredDataOperator cleanExpiredDataOperator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 功能实现代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期操作接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CleanExpiredDataOperator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询过期日期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Date&gt; <span class="title">queryExpiredDate</span><span class="params">(Integer remainDays)</span></span>;</span><br><span class="line">    <span class="comment">// 清除过期数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(Date expiredDate)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除过期数据</span></span><br><span class="line">cleanExpiredData(<span class="string">"用户日志表"</span>, userDAO::queryExpiredDate,userDAO::cleanExpiredData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(String tableName, QueryExpiredDateOperator queryExpiredDateOperator, CleanExpiredDataOperator cleanExpiredDataOperator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 功能实现代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询过期日期接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">QueryExpiredDateOperator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询过期日期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Date&gt; <span class="title">queryExpiredDate</span><span class="params">(Integer remainDays)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期操作接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CleanExpiredDataOperator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清除过期数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(Date expiredDate)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>定义函数并指定参数，明确规定了匿名内部类的代码边界；</li><li>利用 Lambda 表达式简化匿名内部类实现，使代码更简洁。</li></ul><h2 id="利用-return-精简不必要的代码"><a href="#利用-return-精简不必要的代码" class="headerlink" title="利用 return 精简不必要的代码"></a>利用 return 精简不必要的代码</h2><h3 id="案例一：删除不必要的-if"><a href="#案例一：删除不必要的-if" class="headerlink" title="案例一：删除不必要的 if"></a>案例一：删除不必要的 if</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Double passRate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(passRate) &amp;&amp; passRate.compareTo(PASS_THRESHOLD) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Double passRate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.nonNull(passRate) &amp;&amp; passRate.compareTo(PASS_THRESHOLD) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：删除不必要的-else"><a href="#案例二：删除不必要的-else" class="headerlink" title="案例二：删除不必要的 else"></a>案例二：删除不必要的 else</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结算工资函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">settleSalary</span><span class="params">(Long workId, <span class="keyword">int</span> workDays)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据是否合格处理</span></span><br><span class="line">    <span class="keyword">if</span> (isQualified(workId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> settleQualifiedSalary(workDays);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> settleUnqualifiedSalary(workDays);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 结算工资函数</span><br><span class="line">public double settleSalary(Long workId, int workDays) &#123;</span><br><span class="line">    // 根据是否合格处理</span><br><span class="line">    if (isQualified(workId)) &#123;</span><br><span class="line">        return settleQualifiedSalary(workDays);</span><br><span class="line">    &#125;</span><br><span class="line">    return settleUnqualifiedSalary(workDays);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三：删除不必要的变量"><a href="#案例三：删除不必要的变量" class="headerlink" title="案例三：删除不必要的变量"></a>案例三：删除不必要的变量</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserDO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    UserQuery userQuery = <span class="keyword">new</span> UserQuery();</span><br><span class="line">    userQuery.setId(id);</span><br><span class="line">    userQuery.setName(name);</span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.query(userQuery);</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserDO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    UserQuery userQuery = <span class="keyword">new</span> UserQuery();</span><br><span class="line">    userQuery.setId(id);</span><br><span class="line">    userQuery.setName(name);</span><br><span class="line">    <span class="keyword">return</span> userDAO.query(userQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>精简不必要的代码，让代码看起来更清爽。</li></ul><h2 id="利用临时变量优化代码"><a href="#利用临时变量优化代码" class="headerlink" title="利用临时变量优化代码"></a>利用临时变量优化代码</h2><p>在一些代码中，经常会看到 a.getB().getC()…getN() 的写法，姑且叫做“函数的级联调用”，代码健壮性和可读性太差。建议：<strong>杜绝函数的级联调用，利用临时变量进行拆分，并做好对象空指针检查</strong>。</p><h3 id="案例一：利用临时变量厘清逻辑"><a href="#案例一：利用临时变量厘清逻辑" class="headerlink" title="案例一：利用临时变量厘清逻辑"></a>案例一：利用临时变量厘清逻辑</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否土豪用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRichUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.nonNull(user.getAccount())</span><br><span class="line">        &amp;&amp; Objects.nonNull(user.getAccount().getBalance())</span><br><span class="line">        &amp;&amp; user.getAccount().getBalance().compareTo(RICH_THRESHOLD) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是精简代码控的最爱，但是可读性实在太差。</p><p><strong>建议方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 是否土豪用户函数</span><br><span class="line">private boolean isRichUser(User user) &#123;</span><br><span class="line">    // 获取用户账户</span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    if (Objects.isNull(account)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取用户余额</span><br><span class="line">    Double balance = account.getBalance();</span><br><span class="line">    if (Objects.isNull(balance)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 比较用户余额</span><br><span class="line">    return balance.compareTo(RICH_THRESHOLD) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案，增加了代码行数，但是逻辑更清晰。<br>有时候，当代码的精简性和可读性发生冲突时，个人更偏向于保留代码的可读性。</p><h3 id="案例二：利用临时变量精简代码"><a href="#案例二：利用临时变量精简代码" class="headerlink" title="案例二：利用临时变量精简代码"></a>案例二：利用临时变量精简代码</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserVO <span class="title">buildUser</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    vo.setId(user.getId());</span><br><span class="line">    vo.setName(user.getName());</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user.getAccount())) &#123;</span><br><span class="line">        vo.setBalance(user.getAccount().getBalance());</span><br><span class="line">        vo.setDebt(user.getAccount().getDebt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写，大约是为了节约一个临时变量吧。</p><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserVO <span class="title">buildUser1</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    vo.setId(user.getId());</span><br><span class="line">    vo.setName(user.getName());</span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">        vo.setBalance(account.getBalance());</span><br><span class="line">        vo.setDebt(account.getDebt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>利用临时变量厘清逻辑，显得业务逻辑更清晰；</li><li>利用临时变量精简代码，看变量名称即知其义，减少了大量无用代码；</li><li>如果获取函数比较复杂耗时，利用临时变量可以提高运行效率；</li><li>利用临时变量避免函数的级联调用，可有效预防空指针异常。</li></ul><h2 id="仅保留函数需要的参数"><a href="#仅保留函数需要的参数" class="headerlink" title="仅保留函数需要的参数"></a>仅保留函数需要的参数</h2><h3 id="案例一：删除多余的参数"><a href="#案例一：删除多余的参数" class="headerlink" title="案例一：删除多余的参数"></a>案例一：删除多余的参数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户状态函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserStatus</span><span class="params">(Long userId, Integer status, String unused)</span> </span>&#123;</span><br><span class="line">    userCache.modifyStatus(userId, status);</span><br><span class="line">    userDAO.modifyStatus(userId, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，unused 参数是无用参数。</p><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户状态函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserStatus</span><span class="params">(Long userId, Integer status)</span> </span>&#123;</span><br><span class="line">    userCache.modifyStatus(userId, status);</span><br><span class="line">    userDAO.modifyStatus(userId, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：用属性取代对象"><a href="#案例二：用属性取代对象" class="headerlink" title="案例二：用属性取代对象"></a>案例二：用属性取代对象</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    userCache.delete(user.getId());</span><br><span class="line">    userDAO.delete(user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    userCache.delete(userId);</span><br><span class="line">    userDAO.delete(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><p>调用函数时，参数对象不需要专门构建，而函数使用其属性超过3个，可以不必使用该规则。</p><p><strong>主要收益</strong></p><ul><li>仅保留函数需要的参数，明确了调用时需要赋值的参数，避免了调用时还要去构造些无用参数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;本文作者：&lt;/strong&gt;陈昌毅，花名常意，高德地图技术专家，2018年加入阿里巴巴，一直从事地图数据采集的相关工作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;原文地址：&lt;/strong&gt;&lt;a href=&quot;https://mp.weixin.q
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
      <category term="编程规范" scheme="https://muhouer.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>MD5简单了解</title>
    <link href="https://muhouer.github.io/posts/c9f1aafe/"/>
    <id>https://muhouer.github.io/posts/c9f1aafe/</id>
    <published>2019-08-30T15:50:00.000Z</published>
    <updated>2019-08-30T15:51:35.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-MD5"><a href="#什么是-MD5" class="headerlink" title="什么是 MD5"></a>什么是 MD5</h2><p>MD5 是 <strong>Message-Digest algorithm 5</strong>（信息-摘要算法）的缩写，被广泛用于加密和解密技术上，它可以说是文件的“<strong>数字指纹</strong>”。任何一个文件，无论是可执行程序、图像文件、临时文件或者其他任何类型的文件，也不管它体积多大，都有且只有一个独一无二的MD5信息值，并且如果这个文件被修改过，它的MD5值也将随之改变。因此，我们可以通过对比同一文件的MD5值，来校验这个文件是否被“篡改”过。</p><h2 id="MD5-用途"><a href="#MD5-用途" class="headerlink" title="MD5 用途"></a>MD5 用途</h2><h3 id="MD5-文件传输"><a href="#MD5-文件传输" class="headerlink" title="MD5 文件传输"></a>MD5 文件传输</h3><p>当我们下载了一个软件以后，如果想知道下载的这个软件和网站的原始文件是否一模一样，就可以给自己下载的文件做个 MD5 校验。如果得到的 MD5 值和网站公布的相同，可确认所下载的文件是完整的。如有不同，说明你下载的文件是不完整的：要么就是在网络下载的过程中出现错误，要么就是此文件已被别人修改。为防止他人更改该文件时放入病毒，最好不要使用。一般使用 MD5 计算工具计算后，和软件网站公布得MD5码进行比对。</p><p>校验值是一组16进制数，不区分大小写，校验值本身只与文件内容有关，只要文件内容不改变校验值就不变；如复制/剪切/粘贴，修改文件创建时间/访问时间，修改文件读/写/执行属性等操作都不会导致校验值发生改变。</p><h3 id="MD5-密码加密"><a href="#MD5-密码加密" class="headerlink" title="MD5 密码加密"></a>MD5 密码加密</h3><p>MD5 算法是不可逆的，可以应用在对密码(或者信用卡等)得加密，加密之后在数据库里面看到的密码是无用的。如果需要检验用户的密码，而是检验用户输入的密码经 md5 加密以后和数据库内的是否相符。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="彩虹表"><a href="#彩虹表" class="headerlink" title="彩虹表"></a>彩虹表</h3><p>现在的 MD5 密码数据库（彩虹表）的数据量已经非常庞大了，大部分常用密码都可以通过 MD5 摘要反向查询到密码明文。为了防止内部人员（能够接触到数据库或者数据库备份文件的人员）和外部入侵者通过MD5反查密码明文，更好地保护用户的密码和个人帐户安全（一个用户可能会在多个系统中使用同样的密码，因此涉及到用户在其他网站和系统中的数据安全），需要对 MD5 摘要结果掺入其他信息，称之为加盐。</p><p>通过 md5、sha1等全球通用公开的加密算法进行反向查询网站 : <a href="https://www.cmd5.com/" target="_blank" rel="noopener">https://www.cmd5.com/</a></p><p>例如：<br><img src="/images/201908301130.png" width="800px" height="300px" align="center"></p><h3 id="MD5-加密-加盐"><a href="#MD5-加密-加盐" class="headerlink" title="MD5 加密+加盐"></a>MD5 加密+加盐</h3><blockquote><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p></blockquote><p>加盐很好理解，就是给原始密码加上特定的字符串，这样给攻击者增加攻击的成本，加盐的关键在于如何选择盐。</p><h4 id="固定字符串"><a href="#固定字符串" class="headerlink" title="固定字符串"></a>固定字符串</h4><p><strong>MD5(Password+UserName)</strong>，即将用户名和密码字符串相加再 MD5，这样的 MD5 摘要基本上不可反查。<br>但有时候用户名可能会发生变化，发生变化后密码即不可用了（验证密码实际上就是再次计算摘要的过程）。</p><h4 id="随机字符串"><a href="#随机字符串" class="headerlink" title="随机字符串"></a>随机字符串</h4><p>盐一般要求是固定长度的随机字符串，且每个用户的盐不同，比如10位，数据库可以这样存储：</p><table><thead><tr><th>Username</th><th>Password</th><th>Salt</th></tr></thead><tbody><tr><td>Freya</td><td>26b74fc2e533289be4dae7018806d978</td><td>63UrCwJhTH</td></tr><tr><td>Asher</td><td>05e213b017e654d6edc134751bc9319f</td><td>84GljVnhDT</td></tr></tbody></table><p>采用加密方式 <code>MD5(MD5(password) + salt)</code></p><p><strong>注：以随机字符串作为盐对密码进行加盐仅仅是增加破解密码的难度，可以减少数据库泄露密码以后被破译的风险</strong>。</p><h3 id="计算文件的-MD5-校验值"><a href="#计算文件的-MD5-校验值" class="headerlink" title="计算文件的 MD5 校验值"></a>计算文件的 MD5 校验值</h3><p>在命令行下，可以使用 Windows 自带的 <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/certutil" target="_blank" rel="noopener">certuti</a>l 命令来计算一个文件的校验值。</p><p>certutil 支持的算法有：MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512。</p><p>certutil 的使用方法非常简单，只需要执行<code>certutil -hashfile 文件名 校验值类型</code>，即可计算出对应文件的校验值。也可以使用 <a href="http://www.pc-tools.net/win32/md5sums/" target="_blank" rel="noopener">md5sums</a> 或 <a href="http://keir.net/hash.html" target="_blank" rel="noopener">hash</a> 工具进行计算。</p><p>Linux 下可以直接使用 md5sum/sha1sum/sha256sum 等命令直接计算文件的对应校验值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-MD5&quot;&gt;&lt;a href=&quot;#什么是-MD5&quot; class=&quot;headerlink&quot; title=&quot;什么是 MD5&quot;&gt;&lt;/a&gt;什么是 MD5&lt;/h2&gt;&lt;p&gt;MD5 是 &lt;strong&gt;Message-Digest algorithm 5&lt;/strong&gt;（
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MD5" scheme="https://muhouer.github.io/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>HTTP与HTTPS的区别</title>
    <link href="https://muhouer.github.io/posts/80f14f93/"/>
    <id>https://muhouer.github.io/posts/80f14f93/</id>
    <published>2019-08-30T15:08:09.000Z</published>
    <updated>2019-08-30T15:13:56.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://www.runoob.com/w3cnote/http-vs-https.html" target="_blank" rel="noopener">HTTP 与 HTTPS 的区别</a></p></blockquote><img src="/images/201908301109.png" width="800px" height="300px" align="center"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><strong>HTTP</strong>（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。</p><p>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 <strong>http://</strong> 打头的都是标准 HTTP 服务。</p><p>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><strong>HTTPS</strong>（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 <a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS</a> 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><p>HTTPS 默认工作在 TCP 协议 443 端口，它的工作流程一般如以下方式：</p><ol><li>TCP 三次同步握手</li><li>客户端验证服务器数字证书</li><li>DH 算法协商对称加密算法的密钥、hash 算法的密钥</li><li>SSL 安全加密隧道协商完成</li><li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</li></ol><h2 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h2><ul><li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 SSL 握手需要的 9 个包，所以一共是 12 个包。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ul><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><img src="/images/201908301110.png" width="800px" height="300px" align="center"><ul><li>第一次握手：客户端尝试连接服务器，向服务器发送 SYN 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认。</li><li>第二次握手：服务器接收客户端 SYN 包并确认（ack=j+1），同时向客户端发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul><h2 id="HTTPS-的工作原理"><a href="#HTTPS-的工作原理" class="headerlink" title="HTTPS 的工作原理"></a>HTTPS 的工作原理</h2><p>我们都知道 HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议。</p><img src="/images/201908301111.png" width="800px" height="300px" align="center"><p><strong>1、客户端发起 HTTPS 请求</strong></p><p>这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。</p><p><strong>2、服务端的配置</strong></p><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。</p><p>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p><p><strong>3、传送证书</strong></p><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><p><strong>4、客户端解析证书</strong></p><p>这部分工作是有客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p><p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p><p><strong>5、传送加密信息</strong></p><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><p><strong>6、服务端解密信息</strong></p><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><p><strong>7、传输加密后的信息</strong></p><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><p><strong>8、客户端解密信息</strong></p><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;原文链接：&lt;a href=&quot;https://www.runoob.com/w3cnote/http-vs-https.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP 与 HTTPS 的区别&lt;/a&gt;&lt;/p&gt;&lt;/blo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java关键字</title>
    <link href="https://muhouer.github.io/posts/b960f15/"/>
    <id>https://muhouer.github.io/posts/b960f15/</id>
    <published>2019-08-29T15:50:42.000Z</published>
    <updated>2019-08-29T16:01:24.369Z</updated>
    
    <content type="html"><![CDATA[<p>Java中各种关键字 transient、instanceof、volatile、final、static 。</p><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a><code>transient</code></h2><p>一个对象只要实现了 Serializable 接口，这个对象就可以被序列化，Java 的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了 Serializable 接口，这个类的所有属性和方法都会自动序列化。</p><p>然而在实际开发过程中，一个类中并不是所有属性都需要进行序列化，打个比方，如果一个用户有一些敏感信息(如密码，银行卡号等)，为了安全起见，不希望在网络操作(主要涉及到序列化操作，本地序列化缓存也适用)中被传输，这些信息对应的变量就可以加上 <code>transient</code> 关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p><p><strong>小结</strong>：</p><ol><li>一旦变量被 transient 修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>transient 关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被 transient 关键字修饰的。变量如果是用户自定义类变量，则该类需要实现 Serializable 接口。</li><li>被 transient 关键字修饰的变量不再能被序列化，一个静态变量不管是否被 transient 修饰，均不能被序列化(静态变量的值不是从序列化得到，而是从 JVM 中得到)。</li></ol><p><strong>注意</strong>：</p><ol><li>Java 中的关键字 <code>transient</code> 是用来标识一个属性不被序列化的，而 JPA 的 <code>@Transient</code> 注解是用来标识一个属性不被持久化到数据库的。</li><li>若实现的是 Externalizable 接口，则没有任何东西可以自动序列化，需要在 writeExternal 方法中进行手工指定所要序列化的变量，这与是否被 transient 修饰无关。</li></ol><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p>可以用来检查对象是否是特定类的实例。比如，当您有一个对超类或接口类型的对象的引用或参数，你想知道实际对象是否有其他类型（通常更具体）时，可以使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Number param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (param <span class="keyword">instanceof</span> Double) &#123;</span><br><span class="line">    System.out.println(<span class="string">"param is a Double"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">    System.out.println(<span class="string">"param is an Integer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (param <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">    <span class="comment">//subclasses of Number like Double etc. implement Comparable</span></span><br><span class="line">    <span class="comment">//other subclasses might not -&gt; you could pass Number instances that don't implement that interface</span></span><br><span class="line">    System.out.println(<span class="string">"param is comparable"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用 instanceof 之前不需要做 null 检查，假如 x 是 null，则 <code>x instanceof SomeClass</code> 就是 false。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h2><p>参考 <a href="/posts/ce0f712d/" title="volatile关键字">volatile关键字</a></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a><code>final</code></h2><p>在 Java 中，被 <code>final</code> 修饰代表不能被改变。</p><ol><li>final 修饰的类不能被继承，但是可以继承其他类。</li><li>inal 修饰的变量在定义时，必须赋值，并且只能赋值一次</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的引用型变量，变量的值是固定不变的。注意：对象的引用值和对象的属性值！</li></ol><p><strong>注意</strong>：使用 <code>final</code> 关键字它能会提高性能，但充其量只是略微提高。还是根据实际需要去使用。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h2><p>当我们通过 new 关键字去创建对象的时候，那么数据的存储空间才会被分配，类中的成员方法才能被对象所使用。有两种特殊的情况：</p><ol><li>我们通过 new 关键字创建的对象共享同一个资源，而不是说每个对象都拥有自己的数据，或者说根本就不需要去创建对象，这个资源和对象之间是没有关系的。</li><li>希望某个方法不与包含它的类的任何对象联系在一起。</li></ol><p>总结下来就是说：<strong>即使没有创建对象，也能使用属性和调用方法</strong>，static 目的就是在于解决这个问题。</p><ul><li>static 可以修饰变量、方法。</li><li>被 static 修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</li><li>在类被加载的时候，就会去加载被 static 修饰的部分。</li><li>被 static 修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li></ul><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>被 static 修饰的成员变量叫做静态变量，也叫做类变量，说明这个变量是属于这个类的，而不是属于是对象，没有被 static 修饰的成员变量叫做实例变量，说明这个变量是属于某个具体的对象的。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>被 static 修饰的方法也叫做静态方法，因为对于静态方法来说是不属于任何实例对象的，那么就是说在静态方法内部是不能使用 this 的，因为既然不属于任何对象，那么就更谈不上 this 了。</p><p>Java 嵌套类分为两种，静态嵌套类和非静态嵌套类，其中非静态嵌套类才是真正的内部类。</p><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a><code>enum</code></h2><p>参考 <a href="/posts/4502a76f/" title="枚举类型">枚举类型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中各种关键字 transient、instanceof、volatile、final、static 。&lt;/p&gt;&lt;h2 id=&quot;transient&quot;&gt;&lt;a href=&quot;#transient&quot; class=&quot;headerlink&quot; title=&quot;transient&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java语法糖</title>
    <link href="https://muhouer.github.io/posts/a0d19409/"/>
    <id>https://muhouer.github.io/posts/a0d19409/</id>
    <published>2019-08-28T17:22:00.000Z</published>
    <updated>2019-09-11T15:16:12.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>语法糖(Syntactic Sugar)，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法。这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p><blockquote><p>语法盐(Syntactic Salt)是指在计算机语言设计中，不容易产生不良代码的特性。可以为容易犯的语法错误加上的额外语法限制，比如类型检查。</p><p>语法糖精也叫语法糖浆，指的是未能让编程更加方便的附加语法，一说是设计失败的语法糖。这个语法又麻烦又没用。</p><p>语法海洛因，是指过于喜欢操作符重载，使得程序表面上紧凑。操作符重载就是把已经定义的、有一定功能的操作符进行重新定义，来完成更为细致具体的运算等功能。操作符重载可以将概括性的抽象操作符具体化，便于外部调用而无需知晓内部具体运算过程。</p></blockquote><p>我们所熟知的编程语言中几乎都有语法糖。很多人说 Java 是一个 “低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在 “Project Coin” 项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着 “高糖” 的方向发展。</p><h2 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h2><p>语法糖的存在主要是方便开发人员使用。但其实，Java 虚拟机并不支持这些语法糖，这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</p><p><code>com.sun.tools.javac.main.JavaCompiler</code> 的源码中，compile() 有一个步骤就是调用 desugar() ，这个方法就是负责解语法糖的。</p><p>Java 中最常用的语法糖主要有 switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、foreach、try-with-resource、Lambda表达式等</p><h3 id="switch-支持-String-与枚举"><a href="#switch-支持-String-与枚举" class="headerlink" title="switch 支持 String 与枚举"></a>switch 支持 String 与枚举</h3><p>进行<code>switch</code>的实际是哈希值，然后通过使用<code>equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 switch 或者使用纯整数常量，但这也不是很差。</p><p>参考 <a href="/posts/4a48cd1d/" title="String分析">String分析</a></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>不同的编译器对于泛型的处理方式是不同的。通常情况下，一个编译器处理泛型有两种方式：<strong>Code specialization</strong>和 <strong>Code sharing</strong>。C++ 和 C#是使用 Code specialization 的处理机制，而 Java 使用的是 Code sharing 的处理机制。</p><p>Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。</p><p>也就是说，对于 Java 虚拟机来说，他根本不认识 <code>Map&lt;String, String&gt; map</code>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</p><p>参考 <a href="/posts/4127871b/" title="Java泛型解析">Java泛型解析</a></p><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱。</p><p>反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</p><p>原始类型 byte、short、char、int、long、float、double 和 boolean 对应的封装类为 Byte、Short、Character、Integer、Long、Float、Double、Boolean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;        </span><br><span class="line">Integer n = i; <span class="comment">//  装箱：Integer n = Integer.valueOf(i); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">Integer i = <span class="number">10</span>; <span class="comment">// Integer i = Integer.valueOf(10); </span></span><br><span class="line"><span class="keyword">int</span> n = i; <span class="comment">//  拆箱：int n = i.intValue(); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法变长参数"><a href="#方法变长参数" class="headerlink" title="方法变长参数"></a>方法变长参数</h3><p>可变参数 (<code>variable arguments</code>) 是在 Java 1.5 中引入的一个特性，它允许一个方法把任意数量的值作为参数。</p><p>可变参数在被使用的时候：</p><ol><li>首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数。</li><li>然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>Java SE5 提供了一种新的类型-Java 的枚举类型，关键字<code>enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p><p>当我们使用<code>enmu</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code>final</code>类型的类继承<code>Enum</code>类，所以枚举类型不能被继承。</p><p>参考 <a href="/posts/4502a76f/" title="枚举类型">枚举类型</a></p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。</p><p>Outer.java 里面定义了一个内部类 Inner，一旦编译成功，就会生成两个完全不同的 .class 文件了，分别是 Outer.class 和 Outer$Inner.class。所以<strong>内部类的名字完全可以和它的外部类名字相同</strong>。</p><p>匿名内部类也会被当作普通的类处理，只不过编译器生成它构造方法的时候，除了将外部类的引用传递了过来，还将基本数据类型的变量复制了一份过来，并把引用数据类型的变量引用也传递了过来。因此，基本数据类型的变量不能修改，不然就会跟外部的变量产生不一致，这样的话变量的传递也就变得毫无意义。</p><p>final 关键字除了能让类不能被继承之外，对应到这种场景，就是让变量也不能被重新赋值。</p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>C、C++ 等许多语言提供了预处理的功能，并通过预处理来实现条件编译。Java 并没有提供类似的预处理功能，但是 Java 也可以实现条件编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"block 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断言语句"><a href="#断言语句" class="headerlink" title="断言语句"></a>断言语句</h3><p>断言在编译过后被转化成了语句所处类中的一个 static final boolean 字段，并在类初始化阶段借助静态语句块完成其初始化。在程序执行过程中，直接根据该字段判断断言是否开启，来决定是否执行断言检查。</p><h3 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a>数值字面量</h3><h4 id="支持的数字字面量表示"><a href="#支持的数字字面量表示" class="headerlink" title="支持的数字字面量表示"></a>支持的数字字面量表示</h4><p>十进制：默认的。</p><p>八进制：整数之前加数字 0 来表示。</p><p>十六进制：整数之前加“0x”或“0X”来表示。</p><p>二进制：整数之前加“0b”或“0B”来表示。</p><h4 id="在数值字面量中使用下划线"><a href="#在数值字面量中使用下划线" class="headerlink" title="在数值字面量中使用下划线"></a>在数值字面量中使用下划线</h4><p>在 Java 7 中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1_500_000 </span><br><span class="line">5_6.3_4 </span><br><span class="line">89_3___1</span><br></pre></td></tr></table></figure><blockquote><p><strong>下划线只能出现在数字中间，前后必须是数字。</strong>所以<code>_100</code>、<code>0b_101</code>是不合法的，无法通过编译。<br>这样限制的动机就是可以降低实现的复杂度。有了这个限制，Java 编译器只需在扫描源代码的时候将所发现的数字中间的下划线直接删除就可以了。如果不添加这个限制，编译器需要进行语法分析才能做出判断。比如：<code>_100</code>,可能是一个整数字面量 100，也可能是一个变量名称。这就要求编译器的实现做出更复杂的改动。</p></blockquote><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ul><li>对有实现 Iterable 接口的对象采用 foreach 语法糖的话，编译器会将这个 for 关键字转化为对目标的迭代器使用。如果要想使自己自定义的类可以采用foreach语法糖就必须实现Iterable接口。</li><li>对于数组而言，其实就是转换为普通的遍历。</li><li>对于实现 RandomAccess 接口的集合比如 ArrayList，应当使用最普通的 for 循环而不是 foreach 循环来遍历。</li></ul><p>实现 RandomAccess 接口的类实例，假如是随机访问的，使用普通 for 循环效率将高于使用 foreach 循环；反过来，如果是顺序访问的，则使用 Iterator 会效率更高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterable(); </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">      iterator.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。编译之后会判断对象是否为 null，如果不是 null，则调用 close 函数进行资源回收。</p><p>所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。不同的是 java.io.Closable 要求实现者保证 close 函数可以被重复调用。而 java.lang.AutoCloseable 的close 函数则不要求是幂等的。</p><p>try-with-resources 声明在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>TODO 待补充</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>javap 是 JDK 自带的反汇编器，可以查看 java 编译器为我们生成的字节码。通过它，我们可以对照源代码和字节码，从而了解很多编译器内部的工作。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>  <code>javap [option] class</code><br>javap 命令用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。</p><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><p>-help 输出 javap 的帮助信息。<br>-l 输出行及局部变量表。<br>-b 确保与 JDK 1.1 javap 的向后兼容性。<br>-public 只显示 public 类及成员。<br>-protected 只显示 protected 和 public 类及成员。<br>-package 只显示包、protected 和 public 类及成员。这是缺省设置。<br>-private 显示所有类和成员。<br>-J[flag] 直接将 flag 传给运行时系统。<br>-s 输出内部类型签名。<br>-c 输出类中各方法的未解析的代码，即构成 Java 字节码的指令。<br>-verbose 输出堆栈大小、各方法的 locals 及 args 数,以及class文件的编译版本<br>-classpath[路径] 指定 javap 用来查找类的路径。如果设置了该选项，则它将覆盖缺省值或 CLASSPATH 环境变量。目录用冒号分隔。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语法糖&quot;&gt;&lt;a href=&quot;#语法糖&quot; class=&quot;headerlink&quot; title=&quot;语法糖&quot;&gt;&lt;/a&gt;语法糖&lt;/h2&gt;&lt;p&gt;语法糖(Syntactic Sugar)，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="语法糖" scheme="https://muhouer.github.io/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
  </entry>
  
  <entry>
    <title>编码方式杂记</title>
    <link href="https://muhouer.github.io/posts/d6bee64/"/>
    <id>https://muhouer.github.io/posts/d6bee64/</id>
    <published>2019-08-28T16:11:08.000Z</published>
    <updated>2019-08-28T16:14:00.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ASCII-Unicode-UTF-8"><a href="#ASCII-Unicode-UTF-8" class="headerlink" title="ASCII - Unicode - UTF-8"></a>ASCII - Unicode - UTF-8</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p><p>ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p><p>汉字使用的符号多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号，所以，中国制定了GB2312编码，用来把中文编进去。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode应运而生，Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。具体的符号对应表，可以查询<a href="http://www.unicode.org/" target="_blank" rel="noopener">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字对应表</a>。</p><p>不过，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。这就导致 Unicode 有多种存储方式，即有许多种不同的二进制格式，可以用来表示 Unicode。如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是<code>0</code>，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>互联网的普及，强烈要求出现一种统一的编码方式。<strong>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式</strong>。浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器。很多网页的源码上会有类似 <code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的 UTF-8 编码。</p><p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>UTF-8 的编码规则很简单，只有二条：</p><ol><li><p>对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p></li><li><p>对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围      |        UTF-8编码方式</span><br><span class="line">(十六进制)           |              （二进制）</span><br><span class="line">--------------------+------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p>例如：<br><img src="/images/201908281058.png" width="800px" height="500px" align="center"></p><h2 id="UTF-8、UTF-16、UTF-32区别"><a href="#UTF-8、UTF-16、UTF-32区别" class="headerlink" title="UTF-8、UTF-16、UTF-32区别"></a>UTF-8、UTF-16、UTF-32区别</h2><p>UTF 意思是 Unicode 转换格式(Unicode Transform Format)， UTF-8、UTF-16、UTF-32 是为了在内存中存储字符而对 Unicode 字符编号进行编码。它们都是 Unicode 的实现方式，其中 <strong>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式</strong>。<strong>UTF-16(字符用 2 个字节或 4 个字节表示)</strong> 和 <strong>UTF-32(字符用 4 个字节表示)</strong>，不过在互联网上基本不用。</p><p>UTF-16 使用 2 或 4 个字节进行存储。对于 Unicode 编号范围在 0~FFFF 之间的字符，统一用两个字节存储，无需字符转换，直接存储 Unicode 编号。对于 Unicode 字符编号在 10000-10FFFF 之间的字符，UTF16 用 4 个字节存储。</p><p>UTF-32 用固定长度的字节存储字符编码，不管 Unicode 字符编号需要几个字节，全部都用 4 个字节存储，直接存储 Unicode 编号。无需经过字符编号向字符编码的转换步骤，提高效率，用空间换时间。</p><h2 id="GB2312、GBK、GB18030、GB13000之间的区别"><a href="#GB2312、GBK、GB18030、GB13000之间的区别" class="headerlink" title="GB2312、GBK、GB18030、GB13000之间的区别"></a>GB2312、GBK、GB18030、GB13000之间的区别</h2><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p><strong>GB2312 或 GB2312-80 是中国国家标准简体中文字符集</strong>，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持 GB2312。<br>，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。</p><ul><li>GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。</li><li>对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。</li></ul><p><strong>GB2312对任意一个图形字符都采用两个字节表示</strong>，并对所收汉字进行了“分区”处理，每区含有94个汉字／符号，分别对应第一字节和第二字节。这种表示方式也称为区位码。</p><ul><li>01-09区为特殊符号。</li><li>16-55区为一级汉字，按拼音排序。</li><li>56-87区为二级汉字，按部首／笔画排序。</li></ul><p>10-15区及88-94区则未有编码。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p><strong>GBK</strong>即，为汉语拼音 Kuo Zhan（扩展）中“扩”字的声母。英文全称Chinese Internal Code Specification。</p><ul><li>GB2312中的全部汉字、非汉字符号。</li><li>BIG5中的全部汉字。</li><li>与ISO 10646相应的国家标准GB13000中的其它CJK汉字，以上合计20902个汉字。</li><li>其它汉字、部首、符号，共计984个。</li></ul><p>GBK向下与GB2312 完全兼容，向上支持ISO 10646国际标准，在前者向后者过渡过程中起到的承上启下的作用。</p><p><strong>GBK 采用双字节表示</strong>，总体编码范围为8140-FEFE之间，首字节在81-FE之间，尾字节在40-FE之间，剔除XX7F一条线。GBK编码区分三部分：</p><ul><li><p>汉字区</p><ul><li>GBK/2：OXBOA1-F7FE，收录GB2312汉字6763个，按原序排列。</li><li>GBK/3：OX8140-AOFE，收录CJK汉字6080个。</li><li>GBK/4：OXAA40-FEAO，收录CJK汉字和增补的汉字8160个。</li></ul></li><li><p>图形符号区</p><ul><li>GBK/1：OXA1A1-A9FE，除GB2312的符号外，还增补了其它符号。</li><li>GBK/5：OXA840-A9AO，扩除非汉字区。</li></ul></li><li><p>用户自定义区</p><ul><li>GBK区域中的空白区，用户可以自己定义字符。</li></ul></li></ul><p>GBK 最初是由微软对 GB2312 的扩展，也就是CP936字码表 (Code Page 936)的扩展（原来的CP936和GB 2312-80一模一样），最初出现于Windows 95简体中文版中，由于Windows产品的流行和在大陆广泛被使用，中华人民共和国国家有关部门将其作为技术规范。<strong>注意 GBK 并非国家正式标准，只是国家技术监督局标准化司、电子工业部科技与质量监督司发布的“技术规范指导性文件”。</strong>虽然 GBK 收录了所有 Unicode 1.1 及 GB 13000.1-93 之中的汉字，但是编码方式与 Unicode 1.1 及 GB 13000.1-93 不同。仅仅是 GB2312 到 GB13000.1-93 之间的过渡方案。GBK 收录了 21886 个符号，它分为汉字区和图形符号区。汉字区包括 21003 个字符。</p><p>GBK 作为对 GB2312 的扩展，在现在的 Windows 系统中仍然使用代码页 CP936 表示，但是同样的 936 的代码页跟一开始的 936 的代码页只支持 GB2312 编码不同，现在的 936 代码页支持 GBK 的编码，GBK 同时也向下兼容 GB2312 编码。</p><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p><strong>GB18030</strong>，全称是中华人民共和国现时最新的内码字集，是GB18030-2000《信息技术信息交换用汉字编码字符集基本集的扩充》的修订版。</p><p><strong>GB18030</strong> 与 <strong>GB2312-1980</strong> 完全兼容，与 GBK 基本兼容，支持 GB13000 及 Unicode 的全部统一汉字，共收录汉字 70244 个。</p><ul><li>与 UTF-8 相同，采用多字节编码，每个字可以由1个、2个或4个字节组成。</li><li>编码空间庞大，最多可定义161万个字符。</li><li>支持中国国内少数民族的文字，不需要动用造字区。</li><li>汉字收录范围包含繁体汉字以及日韩汉字</li></ul><p><strong>GB18030 编码是一二四字节变长编码。</strong></p><ul><li>单字节，其值从0到0x7F，与 ASCII 编码兼容。</li><li>双字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x40到0xFE（不包括0x7F），与 GBK标准基本兼容。</li><li>四字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节从0x81到0xFE，第四个字节从0x30到0x39。</li></ul><p>2000 年的 GB18030 取代了 GBK1.0 的正式国家标准。该标准收录了 27484 个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的 PC 平台必须支持 GB18030，对嵌入式产品暂不作要求。所以手机、MP3 一般只支持 GB2312。</p><p>GB18030 在 Windows 中的代码页是 CP54936。</p><h3 id="GB13000"><a href="#GB13000" class="headerlink" title="GB13000"></a>GB13000</h3><p>GB13000 等同于国际标准的《通用多八位编码字符集 (UCS)》 ISO10646.1，就是等同于 Unicode 的标准，代码页等等的都使用 UTF 的一套标准。</p><p>从 ASCII、GB2312、GBK 到 GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为 0。按照程序员的称呼，GB2312、GBK 到 GB18030 都属于双字节字符集 (DBCS)。</p><h2 id="URL编解码"><a href="#URL编解码" class="headerlink" title="URL编解码"></a>URL编解码</h2><p>一般来说，网页URL只能使用英文、数字、还有一些特定的字符。根据网络标准<a href="http://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">RFC 1738</a>做了硬性规定：</p><blockquote><p>只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!*’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。</p></blockquote><p>如果 URL中包括中文等字符，就必须经过编码后使用，否则传给服务器的 request URL 就会包含乱码，服务器无法正确识别。因为RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定，所以导致“URL编码”领域非常混乱。想要了解浏览器多种情况下的编码处理，可以参考阮一峰大神的<a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">关于URL编码</a>。</p><ol><li><strong>网址路径的编码，用的是utf-8编码。</strong></li><li><strong>查询字符串的编码，用的是操作系统的默认编码。</strong></li><li><strong>GET和POST方法的编码，用的是网页的编码。</strong></li><li><strong>在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码。</strong></li></ol><p>不同的操作系统、不同的浏览器、不同的网页字符集，将导致完全不同的编码结果，为了保证客户端只用一种编码方法向服务器发出请求，可以使用 Javascript 先对 URL 编码，然后再向服务器提交，不要给浏览器插手的机会。</p><p>编码方法有三种：<code>escape(url)</code>、<code>encodeURL(url)</code>、<code>encodeURLComponent(url)</code></p><p>解码方法也有三种: <code>unescape(url)</code>、<code>decodeURL(url)</code>、<code>decodeURLComponent(url)</code></p><table><thead><tr><th>方法</th><th>规则</th><th>特点</th></tr></thead><tbody><tr><td>escape、unescape</td><td>除了ASCII字母、数字、标点符号”@ * _ + - . /“以外，对其他所有字符进行编码</td><td>它的作用是返回一个字符的 Unicode 编码值。现在已经不提倡使用这种方法了，它不能直接运用与 URL 编码。</td></tr><tr><td>encodeURI（编码）decodeURI（解码）</td><td>除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码</td><td>encodeURI() 是 Javascript 中真正用来对 URL 编码的函数，它着眼于对整个URL 进行编码</td></tr><tr><td>encodeURIComponent（编码）decodeURIComponent解码）</td><td>在encodeURI()中不被编码的符号”; / ? : @ &amp; = + $ , #”，在encodeURIComponent()中统统会被编码</td><td>与 encodeURI() 的区别是，它用于对 URL 的组成部分进行个别编码，而不用于对整个URL进行编码。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> url = <span class="string">"https://www.zhihu.com/question/342936488/answer/804030108"</span>;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; <span class="built_in">escape</span>(url)</span><br><span class="line"><span class="string">"https%3A//www.zhihu.com/question/342936488/answer/804030108"</span></span><br><span class="line">&gt; <span class="built_in">encodeURI</span>(url)</span><br><span class="line"><span class="string">"https://www.zhihu.com/question/342936488/answer/804030108"</span></span><br><span class="line">&gt; <span class="built_in">encodeURIComponent</span>(url)</span><br><span class="line"><span class="string">"https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F342936488%2Fanswer%2F804030108"</span></span><br></pre></td></tr></table></figure><h2 id="Big-Endian-和-Little-Endian"><a href="#Big-Endian-和-Little-Endian" class="headerlink" title="Big Endian 和 Little Endian"></a>Big Endian 和 Little Endian</h2><ul><li><strong>Little-endian：将低序字节存储在起始地址（低位编址）</strong></li><li><strong>Big-endian：将高序字节存储在起始地址（高位编址）</strong></li></ul><p>例如，如果我们将 0x1234abcd 写入到以 0x0000 开始的内存中，则结果为：</p><table><thead><tr><th>address</th><th>big-endian</th><th>little-endian</th></tr></thead><tbody><tr><td>0x0000</td><td>0x12</td><td>0xcd</td></tr><tr><td>0x0001</td><td>0x34</td><td>0xab</td></tr><tr><td>0x0002</td><td>0xab</td><td>0x34</td></tr><tr><td>0x0003</td><td>0xcd</td><td>0x12</td></tr></tbody></table><p>对于字节序列的存储格式，目前有两大阵营，那就是 Motorola 的 PowerPC 系列 CPU 和 Intel 的 x86 系列 CPU。PowerPC 系列采用 big endian 方式存储数据，而 x86 系列则采用 little endian 方式存储数据。</p><p>所有网络协议也都是采用 big endian 的方式来传输数据的。所以有时我们也会把 big endian 方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。</p><p>目前应该 little endian 是主流，因为在数据类型转换的时候（尤其是指针转换）不用考虑地址问题。</p><p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p><p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用 big endian 方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用 little endian 方式。</p><h2 id="如何解决乱码问题"><a href="#如何解决乱码问题" class="headerlink" title="如何解决乱码问题"></a>如何解决乱码问题</h2><p>乱码本质上都是由于<strong>字符串原本的编码格式与读取时解析用的编码格式不一致导致的</strong>。</p><h3 id="网页乱码问题"><a href="#网页乱码问题" class="headerlink" title="网页乱码问题"></a>网页乱码问题</h3><ul><li>服务器返回的响应头 Content-Type 指明字符编码。</li><li>网页内使用 meta http-equiv 标签指定字符编码。</li><li>网页文件本身存储时使用的字符编码和网页声明的字符编码一致。</li></ul><h3 id="Java代码乱码问题"><a href="#Java代码乱码问题" class="headerlink" title="Java代码乱码问题"></a>Java代码乱码问题</h3><ul><li><p>使用 getBytes() 方法指定编码。</p></li><li><p>使用字节流时指定编码。</p></li><li><p>使用 new String() 时指定编码。</p></li><li><p>使用 HttpClient post请求时指定编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求实体</span></span><br><span class="line">HttpEntity reqEntity = <span class="keyword">new</span> ByteArrayEntity(reqStr.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">httpPost.setEntity(reqEntity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求实体</span></span><br><span class="line">StringEntity reqEntity = <span class="keyword">new</span> StringEntity(reqStr, Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">httpPost.setEntity(reqEntity);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ASCII-Unicode-UTF-8&quot;&gt;&lt;a href=&quot;#ASCII-Unicode-UTF-8&quot; class=&quot;headerlink&quot; title=&quot;ASCII - Unicode - UTF-8&quot;&gt;&lt;/a&gt;ASCII - Unicode - UTF-8&lt;/
      
    
    </summary>
    
    
  </entry>
  
</feed>

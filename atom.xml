<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Muhouer</title>
  
  <subtitle>开始记录只需5分钟，剩下的自会摆平!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muhouer.github.io/"/>
  <updated>2019-09-07T07:27:59.167Z</updated>
  <id>https://muhouer.github.io/</id>
  
  <author>
    <name>Muhouer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="https://muhouer.github.io/posts/4522df16/"/>
    <id>https://muhouer.github.io/posts/4522df16/</id>
    <published>2019-09-07T07:25:00.000Z</published>
    <updated>2019-09-07T07:27:59.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><blockquote><p>序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。恰当的序列化协议不仅可以提高系统的通用性、强健性、安全性、优化系统性能，而且会让系统更加易于调试、便于扩展。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li><strong>序列化：将数据结构或对象转换成二进制串的过程，在 Java 中对应把对象转换为字节序列的过程。</strong></li><li><strong>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程，在 Java 中对应把字节序列恢复为对象的过程。</strong></li></ol><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li><p>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。</p></li><li><p>在网络上传送对象的字节序列。</p></li></ol><h2 id="JDK-类库中的序列化API"><a href="#JDK-类库中的序列化API" class="headerlink" title="JDK 类库中的序列化API"></a>JDK 类库中的序列化API</h2><blockquote><ol><li><p>在序列化过程中，如果被序列化的类中定义了 writeObject() 和 readObject() 方法，虚拟机会试图调用对象类里的 writeObject() 和 readObject() 方法，进行用户自定义的序列化和反序列化。如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject() 方法以及 ObjectInputStream 的 defaultReadObject() 方法。</p></li><li><p>用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。</p></li></ol></blockquote><p><code>ObjectOutputStream</code> 代表对象输出流，它的 <code>writeObject(Object obj)</code> 方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p><code>ObjectInputStream</code> 代表对象输入流，它的 <code>readObject()</code> 方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</p><p>只有实现了 <code>Serializable</code> 和 <code>Externalizable</code> 接口的类的对象才能被序列化。<code>Externalizable</code> 接口继承自 <code>Serializable</code> 接口，实现 <code>Externalizable</code> 接口的类完全由自身来控制序列化的行为，而仅实现 <code>Serializable</code> 接口的类可以采用默认的序列化方式 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><strong>对象序列化步骤</strong></p><ol><li>创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；</li><li>通过对象输出流的writeObject()方法写对象。</li></ol><p><strong>对象反序列化步骤</strong></p><ol><li>创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；</li><li>通过对象输入流的readObject()方法读取对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Initializes The Object</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"Freya"</span>);</span><br><span class="line">        user.setAge(<span class="number">17</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Write Obj to File</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>));</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(oos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Read Obj from File</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">            User newUser = (User) ois.readObject();</span><br><span class="line">            System.out.println(newUser);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(ois);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileUtils.forceDelete(file);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化版本号"><a href="#序列化版本号" class="headerlink" title="序列化版本号"></a>序列化版本号</h3><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量 <code>serialVersionUID</code>。<code>serialVersionUID</code> 的取值是 Java 运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的 <code>serialVersionUID</code> 的取值有可能也会发生变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID</span><br></pre></td></tr></table></figure><p>如果没有指定类的 <code>serialVersionUID</code>，Java 编译器会自动给这个 class 进行一个摘要算法，类似于指纹算法，只要这个文件多一个空格，得到的 <code>serialVersionUID</code> 就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个字段后，由于没有显指定 <code>serialVersionUID</code>，编译器又为我们生成了一个 <code>serialVersionUID</code>，当然和前面保存在文件中的那个不会一样了，于是就会出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了 <code>serialVersionUID</code>，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原。</p><p>类的 <code>serialVersionUID</code> 的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。<strong>为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值</strong>。</p><p>显式地定义serialVersionUID有两种用途：</p><ol><li><p>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的 <code>serialVersionUID</code>；</p></li><li><p>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的 <code>serialVersionUID</code>。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p><code>Serializable</code> 只是一个接口，本身没有任何实现。如果一个类想被序列化，需要实现Serializable接口。否则将抛出<code>NotSerializableException</code>异常。因为在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum、Array和Serializable类型其中的任何一种。(当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。)</p></li><li><p>对象的反序列化并没有调用对象的任何构造方法。序列化时，只对对象的状态进行保存，而不管对象的方法。</p></li><li><p>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化。</p></li><li><p>并非所有的对象都可以序列化，比如：</p><ul><li>安全方面的原因，比如一个对象拥有 private，public 等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</li><li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</li></ul></li><li><p>serialVersionUID 是用于记录文件版本信息的，最好能够自定义。否则，系统会自动生成 serialVersionUID，文件或者对象的任何改变，都会改变 serialVersionUID，导致反序列化的失败，如果自定义就没有这个问题</p></li><li><p>声明为 <code>static</code> 和 <code>transient</code> 类型的成员数据不能被序列化。因为 <code>static</code> 代表类的状态，<code>transient</code> 代表对象的临时数据。</p></li><li><p><code>Serializable</code> 的系统实现是采用 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 实现的，调用 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 时，需要对应的类实现 <code>Serializable</code> 接口。</p></li><li><p>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p></li><li><p>Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。反序列化时，恢复引用关系。该存储规则极大的节省了存储空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>));</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//试图将对象两次写入文件</span></span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.flush();</span><br><span class="line">System.out.println(<span class="keyword">new</span> File(<span class="string">"tempFile"</span>).length());</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line">System.out.println(<span class="keyword">new</span> File(<span class="string">"tempFile"</span>).length());</span><br><span class="line"></span><br><span class="line">ObjectInputStream oin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"tempFile"</span>));</span><br><span class="line"><span class="comment">//从文件依次读出两个文件</span></span><br><span class="line">User t1 = (User) oin.readObject();</span><br><span class="line">User t2 = (User) oin.readObject();</span><br><span class="line">oin.close();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//判断两个引用是否指向同一个对象</span></span><br><span class="line">System.out.println(t1 == t2);</span><br></pre></td></tr></table></figure></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="序列化与单例模式"><a href="#序列化与单例模式" class="headerlink" title="序列化与单例模式"></a>序列化与单例模式</h3><h4 id="序列化对单例的破坏"><a href="#序列化对单例的破坏" class="headerlink" title="序列化对单例的破坏"></a>序列化对单例的破坏</h4><p>使用反射可以破坏单例模式，除了反射以外，使用序列化与反序列化也同样会破坏单例。</p><p>单例示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试序列化对单例模式的破坏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonSerializableTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Write Obj to file</span></span><br><span class="line">    <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>))) &#123;</span><br><span class="line">      oos.writeObject(Singleton.getSingleton());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Read Obj from file</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">    Singleton newInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file))) &#123;</span><br><span class="line">      newInstance = (Singleton) ois.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == newInstance) &#123;</span><br><span class="line">        System.out.println(<span class="string">"newInstance is null"</span>); <span class="comment">// 不打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是同一个对象</span></span><br><span class="line">    System.out.println(Singleton.getSingleton() == newInstance); <span class="comment">// false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过对 Singleton 的序列化与反序列化得到的对象是一个新的对象，这就破坏了 Singleton 的单例性。这是因为序列化会通过反射调用无参数的构造方法创建一个新的对象。</strong></p><h4 id="防止序列化破坏单例模式"><a href="#防止序列化破坏单例模式" class="headerlink" title="防止序列化破坏单例模式"></a>防止序列化破坏单例模式</h4><p>在 Singleton 类中定义 <code>readResolve</code> 就可以解决该问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Singleton 类中定义 <code>readResolve</code> 可以防止序列化破坏单例模式，实现如下：</p><ol><li><code>ObjectOutputStream</code> 的 <code>writeObject()</code> 调用 <code>writeObject0()</code>，<code>writeObject0()</code> 里会调用 <code>writeOrdinaryObject()</code>。</li><li>在 <code>writeOrdinaryObject()</code> 中会通过 <code>hasReadResolveMethod</code> 进行判断，如果实现了Serializable 或者 Externalizable 接口的类中包含 <code>readResolve</code> 则返回 true。从而调用 <code>invokeReadResolve</code>，通过反射的方式调用要被反序列化的类的 <code>readResolve()</code> 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="keyword">null</span> </span><br><span class="line">    &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">    <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">        rep = cloneArray(rep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">        handles.setObject(passHandle, obj = rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化与对象的深拷贝"><a href="#序列化与对象的深拷贝" class="headerlink" title="序列化与对象的深拷贝"></a>序列化与对象的深拷贝</h3><p>实现对象的深拷贝有以下几种方法：</p><ol><li>实现 Clonable 接口，重写 clone() 方法，这种方法没有通用性，优点在于实现简单，并且可以实现定制化。</li><li>基于反射，BeanUtil、Spring 核心包提供的一个工具类，基本原理就是获取 class 实例化，再通过反射实现对象的深拷贝。</li><li>基于Serialize、Deserialize 实现，这种办法比较多，本质上和反射类似，反射相当于 JVM 提供，而 Serialize 是基于上层协议。具体实现可以参考 RMI、thrift、protobuf 序列化方式。</li><li>基于 Unsafe 内存，这种方法极不推荐使用，直接复制对象内存空间，容易造成内存泄露。</li></ol><p>在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">    T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//写入字节流</span></span><br><span class="line">      ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">      ObjectOutputStream obs = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">      obs.writeObject(obj);</span><br><span class="line">      obs.close();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//分配内存，写入原始对象，生成新对象</span></span><br><span class="line">      ByteArrayInputStream ios = <span class="keyword">new</span> ByteArrayInputStream(out.toByteArray());</span><br><span class="line">      ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(ios);</span><br><span class="line">      <span class="comment">//返回生成的新对象</span></span><br><span class="line">      cloneObj = (T) ois.readObject();</span><br><span class="line">      ois.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也可以使用 Apache 推出的 SerializationUtils 序列化工具类</p><h4 id="SerializationUtils-功能"><a href="#SerializationUtils-功能" class="headerlink" title="SerializationUtils 功能"></a>SerializationUtils 功能</h4><ul><li>使用序列化进行深度克隆</li><li>序列化对象</li><li>反序列化对象</li></ul><h4 id="SerializationUtils-优缺点"><a href="#SerializationUtils-优缺点" class="headerlink" title="SerializationUtils  优缺点"></a>SerializationUtils 优缺点</h4><ul><li>深度拷贝实现比较简单，不用实现Cloneable接口。</li><li>深度拷贝<strong>效率不如实现Cloneable接口高</strong>。</li><li>序列化和反序列化，是基于jdk自带的序列化，速度慢，占空间。效率不如Protostuff、Hessian、Kryo等专业序列化工具高。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序列化和反序列化&quot;&gt;&lt;a href=&quot;#序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化和反序列化&quot;&gt;&lt;/a&gt;序列化和反序列化&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="序列化" scheme="https://muhouer.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>演化杂记</title>
    <link href="https://muhouer.github.io/posts/4b4e75fa/"/>
    <id>https://muhouer.github.io/posts/4b4e75fa/</id>
    <published>2019-09-03T16:50:36.000Z</published>
    <updated>2019-09-03T16:56:25.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为什么现在的孩子越来越高、越来越胖？<br>为什么青少年糖尿病越来越多、发病年龄越来越小？<br>为什么越来越多的现代人患上了哮喘、过敏性鼻炎以及五花八门的食物过敏？<br>种种“现代疾病”背后是否有个共同的“罪魁祸首”？</p><p>美国著名科学家马丁布莱泽认为，在过去的几十年里，由于滥用抗生素及剖宫产，我们在不经意间已经伤害了与人类协同演化了数十万年之久的“微生物朋友”，特别是在我们的孩子们身上。这扰乱了人体内微生物的稳态，打破了人体与微生物之间的平衡，进而危害了我们孩子的代谢、免疫和认知能力。</p><footer><strong>微生物</strong></footer></blockquote><hr><blockquote><p>所谓碳基，其实是碳氮合体，碳四氮五氧六氢一，勾结出的一类扭曲生命，柔弱而多愁善感，利用电子结合化学能繁衍生息，能量利用总量低而熵效率高，因此能一直默默不查的偷生于宇宙中而繁衍数十亿年。碳基生命需要用氧氢化合物为催化剂，所以在宇宙背景温度到373k以下时才有萌芽可能，之前没有碳基生命存在。</p><p>地球上的碳基生命经过数亿年进化，于西元1900年发现光电效应，并进一步开发出硅基光电板，由此接触到硅基生命能量模式。硅基生命为镓锗合体，以硅氧为催化剂，利用光电效应直接产生能量繁衍生息。硅基以光传导能量进行代谢，低端硅基生命身体透明，有智能的高级硅基生命布满光纤，以硅氧熔沸点预测，在宇宙背景温度到2500k以下时才有萌芽可能，之前没有硅基生命存在。</p><p>碳基生命西元1945年第一次核爆敲开了铁基生命的大门。铁基以核能为驱动，生命温度在铁沸点以上，以气态和离子态存在，可以说在第一个铁元素诞生的时候就有了铁基生命，铁基生命能量利用巨大，一个低端铁基生命每秒耗费的能量相当于一个广岛原子弹。铁基生命是宇宙中最耀眼的生命，信息以量子纠缠传递，可以轻易实现虫洞在星系间穿梭，是最适合宇宙级生存的生命。</p><p>以能量产生和消耗方式来看，硅基生命不过是在食用铁基生命代谢出的废物－光来生存，而碳基生命则是更低等的生命，食用硅基生命的代谢产物－低端化学能来生存，这些低端化学能产生的光和热能不足以满足硅基生命的生存下限。</p><footer><strong>碳基、硅基、铁基</strong></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;为什么现在的孩子越来越高、越来越胖？&lt;br&gt;为什么青少年糖尿病越来越多、发病年龄越来越小？&lt;br&gt;为什么越来越多的现代人患上了哮喘、过敏性鼻炎以及五花八门的食物过敏？&lt;br&gt;种种“现代疾病”背后是否有个共同的“罪魁祸首”？&lt;/p&gt;&lt;p&gt;美国著名科学家
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="https://muhouer.github.io/posts/2b9621c6/"/>
    <id>https://muhouer.github.io/posts/2b9621c6/</id>
    <published>2019-09-03T16:39:00.000Z</published>
    <updated>2019-09-03T16:41:56.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul><li><p><strong>进程(Process)</strong>：计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p></li><li><p><strong>线程(Thread)</strong>：进程的组成部分，它代表了一条顺序的执行流。线程依托于进程存在，在进程之下，可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据。</p></li><li><p><strong>并行(parallel)</strong>：指在同一时刻，有多条指令在多个处理器上同时执行。</p></li></ul><p><img src="/images/201909040011.png" alt="parallel"></p><ul><li><strong>并发(concurrency)</strong>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li></ul><p><img src="/images/201909040012.png" alt="concurrency"></p><blockquote><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><p>不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源。</p></blockquote><hr><p><strong>@UsesJava8</strong></p><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><p>使用线程池有三个好处</p><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><p>但是只有对线程池原理有深入的了解才能最大程度发挥线程池的作用。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过 <code>ThreadPoolExecutor</code> 来创建一个线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="comment">// 核心线程数</span></span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize, <span class="comment">// 最大线程数</span></span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime, <span class="comment">// 线程存活时间</span></span><br><span class="line">                   TimeUnit unit, <span class="comment">// 线程存活时间的单位</span></span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 阻塞队列</span></span><br><span class="line">                   ThreadFactory threadFactory, <span class="comment">// 创建线程的工厂</span></span><br><span class="line">                   RejectedExecutionHandler handler)  <span class="comment">// 拒绝策略</span></span><br></pre></td></tr></table></figure><p>参数解释如下：</p><ul><li><p><strong>corePoolSize</strong>: 当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于<strong>核心线程数</strong>时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有核心线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>maximumPoolSize</strong>: 线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</p></li><li><p><strong>keepAliveTime</strong>: 线程池的工作线程空闲后，存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p></li><li><p><strong>unit</strong>： 可选的单位有 <code>DAYS</code>，<code>HOURS</code>，<code>MINUTES</code>，<code>MILLISECONDS</code>，<code>MICROSECONDS</code>，<code>NANOSECONDS</code>。参考<code>TimeUnit</code></p></li><li><p><strong>workQueue</strong>: 用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ul><li><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法 <code>Executors.newFixedThreadPool()</code> 使用了这个队列</li><li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 <code>LinkedBlockingQueue</code>，静态工厂方法 <code>Executors.newCachedThreadPool</code> 使用了这个队列。</li><li><code>PriorityBlockingQueue</code>：一个具有优先级得无限阻塞队列。</li></ul></li><li><p><strong>threadFactory</strong>: 可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug 和定位问题时非常又帮助。</p></li><li><p><strong>handler</strong>: 当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。</p><ul><li><p><code>CallerRunsPolicy</code>: 调用者运行策略。当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。一般在不允许失败的、对性能要求不高、并发量较小的场景下使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>AbortPolicy</code>: 中止策略。当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>DiscardPolicy</code>: 丢弃策略。不触发任何动作地丢弃这个任务。如果你提交的任务无关紧要，你就可以使用它 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>DiscardOldestPolicy</code>: 弃老策略。如果线程池未关闭，就弹出队列头部的元素，然后尝试执行。发布消息，和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><h4 id="通过-execute-向线程池提交任务"><a href="#通过-execute-向线程池提交任务" class="headerlink" title="通过 execute 向线程池提交任务"></a>通过 <code>execute</code> 向线程池提交任务</h4><p>execute 方法没有返回值，无法判断任务知否被线程池执行成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get(); <span class="comment">// 获取到当前有效的线程数和线程池的状态</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 线程数小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 在addWorker中创建工作线程执行任务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 线程池是否处于运行状态，且是否任务插入任务队列成功</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 线程池是否处于运行状态，如果不是则使刚刚的任务出队</span></span><br><span class="line">            reject(command); <span class="comment">// 执行拒绝策略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 继续创建线程</span></span><br><span class="line">    &#125; <span class="comment">// 插入队列不成功，且当前线程数数量小于最大线程池数量，此时则创建新线程执行任务，创建失败抛出异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command); <span class="comment">// 创建线程失败执行拒绝策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过-submit向线程池提交任务"><a href="#通过-submit向线程池提交任务" class="headerlink" title="通过 submit向线程池提交任务"></a>通过 <code>submit</code>向线程池提交任务</h4><p>submit 方法返回一个 future ，可以通过这个 future 来判断任务是否执行成功，通过 future 的 get() 方法来获取返回值，get() 方法会阻塞住直到任务完成，而使用 get(long timeout, TimeUnit unit) 方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p>我们可以通过调用线程池的 shutdown() 或 shutdownNow() 方法来关闭线程池，但是它们的实现原理不同，shutdown 的原理是只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。shutdownNow 的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt() 方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow 会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</p><p>只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 isTerminaed() 方法会返回 true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。</p><h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p><strong>通过线程池提供的参数进行监控</strong>。线程池里有一些属性在监控线程池的时候可以使用</p><ul><li><strong>taskCount</strong>: 线程池需要执行的任务数量。</li><li><strong>completedTaskCount</strong>: 线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li><li><strong>largestPoolSize</strong>: 线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li><li><strong>getPoolSize</strong>: 线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。</li><li><strong>getActiveCount</strong>：获取活动的线程数。</li></ul><p><strong>通过扩展线程池进行监控</strong>。通过继承线程池并重写线程池的 beforeExecute，afterExecute 和 terminated 方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的配置策略"><a href="#线程池的配置策略" class="headerlink" title="线程池的配置策略"></a>线程池的配置策略</h2><h3 id="根据任务性质设置"><a href="#根据任务性质设置" class="headerlink" title="根据任务性质设置"></a>根据任务性质设置</h3><p>通常这种设置方式是比较粗略的方式。要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p><ol><li><p><strong>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</strong></p><p>CPU 密集型任务配置尽可能小的线程，如配置CPU数+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*CPU数。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 方法获得当前设备的CPU个数。</p></li><li><p><strong>任务的优先级：高，中和低。</strong></p></li><li><p><strong>任务的执行时间：长，中和短。</strong></p><p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p></li><li><p><strong>任务的依赖性：是否依赖其他系统资源，如数据库连接。</strong></p><p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p></li></ol><p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。如果使用无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。</p><h3 id="利特尔法则"><a href="#利特尔法则" class="headerlink" title="利特尔法则"></a>利特尔法则</h3><blockquote><p>利特尔法则（Little’s law）是说，一个系统请求数等于请求的到达率与平均每个单独请求花费的时间之乘积。</p></blockquote><p>我们可以使用利特尔法则（Little’s law）来判定线程池大小。我们只需计算请求到达率和请求处理的平均时间。然后，将上述值放到利特尔法则（Little’s law）就可以算出系统平均请求数。若请求数小于我们线程池的大小，就相应地减小线程池的大小。与之相反，如果请求数大于线程池大小，事情就有点复杂了。</p><p>当遇到有更多请求待处理的情况时，我们首先需要评估系统是否有足够的能力支持更大的线程池。准确评估的前提是，我们必须评估哪些资源会限制应用程序的扩展能力。最简单的情况是，我们有足够的空间增加线程池的大小。若没有的话，你不得不考虑其它选项，如软件调优、增加硬件，或者调优并增加硬件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a&gt;一些概念&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;进程(Process)&lt;/strong&gt;：计算机中的程序关于某数据集合上的一次运行活动，是系
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
      <category term="线程池" scheme="https://muhouer.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>拾句-甜</title>
    <link href="https://muhouer.github.io/posts/ead251ab/"/>
    <id>https://muhouer.github.io/posts/ead251ab/</id>
    <published>2019-09-02T16:53:44.000Z</published>
    <updated>2019-09-02T17:02:33.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="星星睡不着，在数人类。"><a href="#星星睡不着，在数人类。" class="headerlink" title="星星睡不着，在数人类。"></a>星星睡不着，在数人类。</h3><ol><li><strong>有一些小猫假扮成人类来跟我们相爱。</strong></li><li><strong>我也就一般甜啦，也就半糖烤奶加泷珠。</strong></li><li><strong>我们一块儿发会呆吧。</strong></li><li><strong>我永远屈服于温柔，而你是温柔本身。</strong></li><li><strong>放下你的刀，来做本王的妻子吧。</strong></li><li><strong>每天都会有让人长胖的好事情发生。</strong></li><li><strong>你的春日好运正在派件，请保持心情舒畅。</strong></li><li><strong>可爱之人必遇可爱之事。</strong></li><li><strong>希望下次喜欢和合适可以撞个满怀。</strong></li></ol><hr><h3 id="你是我见一个爱一个里面最爱的一个。"><a href="#你是我见一个爱一个里面最爱的一个。" class="headerlink" title="你是我见一个爱一个里面最爱的一个。"></a>你是我见一个爱一个里面最爱的一个。</h3><ol><li><strong>我要去宇宙了，回来摘星星给你。</strong></li><li><strong>好好生活，活到夏天。</strong></li><li><strong>这个人很懒，什么都没有留下。</strong></li><li><strong>既然来到这个世界的话，那就稍微喜欢一下它吧。</strong></li><li><strong>研究了一晚上宇宙，宇宙没理我。</strong></li><li><strong>这家伙很懒，却还想留下点儿什么。</strong></li><li><strong>一觉醒来，觉得甚是爱你。</strong></li><li><strong>你再不来，我就要下雪了。</strong></li><li><strong>所有的告别中，我最喜欢明天见。</strong></li></ol><hr><h3 id="我马上要恋爱了，和谁不知道，先替他高兴一下。"><a href="#我马上要恋爱了，和谁不知道，先替他高兴一下。" class="headerlink" title="我马上要恋爱了，和谁不知道，先替他高兴一下。"></a>我马上要恋爱了，和谁不知道，先替他高兴一下。</h3><ol><li><strong>薏仁做事薏仁汤，小丁做事小叮当。</strong></li><li><strong>既然来了就磕个头再走吧。</strong></li><li><strong>成熟的大人会不动声色的穿上秋裤。</strong></li><li><strong>请你一定要对号入座，我说的所有星光月亮、清泉小溪、蘸着糖的奶油和蜂蜜——这世间所有的美好事物，都只是为了形容你。</strong></li><li><strong>你不是什么小人物，在我这里你是所有的天气和心情。</strong></li><li><strong>我想对你做春天对樱桃树做的事。</strong></li><li><strong>国家二级退堂鼓演奏家</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;星星睡不着，在数人类。&quot;&gt;&lt;a href=&quot;#星星睡不着，在数人类。&quot; class=&quot;headerlink&quot; title=&quot;星星睡不着，在数人类。&quot;&gt;&lt;/a&gt;星星睡不着，在数人类。&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;有一些小猫假扮成人类来跟我们相爱。&lt;/st
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>今天就和孩子签订一份成长协议</title>
    <link href="https://muhouer.github.io/posts/9085c4b7/"/>
    <id>https://muhouer.github.io/posts/9085c4b7/</id>
    <published>2019-09-01T14:20:17.000Z</published>
    <updated>2019-09-01T14:25:14.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：连岳<br>原文链接： <a href="https://mp.weixin.qq.com/s/stMBnSo8YJKf5N2YEXrxdQ" target="_blank" rel="noopener">今天就和孩子签订一份成长协议</a></p></blockquote><p>一想到教育，任务繁重，多数人万千愁绪，不知从何抓起。但任务越重大，起点越要轻微。一点点改变，往往就能改变事物的性质。</p><p>有位家长提供了一份简单的成长协议，非常高明，值得推广：</p><img src="/images/201909011020.png" width="800px" height="300px" align="center"><p>初初一看，这没什么稀奇，开学之际，父母都会对孩子提出各种成长要求。这位家长提出的要求高得多，每天提早半小时到校，这个改变，孩子就算完成度只有50%，除了早上比同学更从容，更多一点学习时间，还意味着他更早睡，更早完成作业，效率更高，作息时间的细微调整，将重组一天的时间结构。</p><p>但是孩子提出了反制，这也不稀奇，当孩子被批评，被要求时，他们下意识的还击就是：那你自己如何如何。那你自己又做不到！是一句彻底激怒家长的话，羞愧、无能、耻辱、被冒犯、被伤害，一起发作，瞬间失去理智，家长将用强势地位压制孩子的反制，手段可能是物理或语言的暴力，或是各种辩解及转移话题，甚至流着泪说，要不是因为你耽误，我早就如何如何了。</p><p>家长的压制当然能成功，孩子依靠你生存，这是他天然的不利。但付出的代价，却是成功教育者两大要件的丧失，一是威信，二是真诚。这两大要件相辅相成，失去其一，另外一个也成立不了。</p><p>教育就是不停地讲道理，提要求。教育者本身的品德、能量令人敬佩，他讲道理事半功倍。一个天天玩手机的家长，警告孩子沉迷手机的危害，孩子当然认为你说假话。一个从不阅读，没有能力深阅读的家长，天天叨阅读的好处，必然没有任何效果，你只会学舌，他人说法的对错你都无法分辨，将一堆矛盾冲突的观点塞给孩子，他更加困惑，无所适从。</p><p>家长无法对孩子隐藏自己的真面目，你若不值得尊重，第一个瞧不起你的，就是传承你DNA的孩子。一旦你放纵、无能、愚蠢、不负责任，精神上的弑父（母）就在发生。无论你多么花言巧语，教育都失效了。说话的技巧并不是教育的根本，在孩子心目中有威信的父母，怎么说都有效，说话技术好，效果更好而已。</p><p>上面那位家长，接受孩子的反要求。有意无意，这迈出了质变的一小步。家长从孩子的要求中，可以发现自己忽视的缺点，那正是威信正在动摇的地方。同时有了被教育、被监督的弱势身份，在完成计划的过程中，可以体验学习与进步的艰难，不再只是轻松的动动嘴的教育者，和孩子一起学习， 一起成长，积累与交流这种经验就是不可替代的教育资源。而孩子突然有了教育者与监督者的强势身份，就像他小时候扮演老虎，他要表现得像只老虎，当他行使教育者与监督者职责时，他有了原来没有的视角与想法，这有利于他理解教育者。为了保有这份“权力”，他必须成为一个更好的学习者与履约者。</p><p>我建议家长与孩子坐下来谈一谈，有意识地赋予孩子反制权，签订一份合理的、双方认同的一起成长计划，双方互为教育者与被教育者，监督者与被监督者。根据完成度，执行相应的奖罚。我知道，很多家长也有阅读计划，锻炼计划，学习计划，以及各种其他计划，但是自律性差，往往虎头蛇尾。有个无情的监督者，尤其他是你的孩子，你不能输，那么，你计划的完成度将大大提升，你的人生，因为有了和孩子一起成长的具体约定与行动，将如开挂一般。</p><p>今天就订一个成长协议，虽然这对家长的要求更高了，但是一个负责任的家长，是不会怕的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者：连岳&lt;br&gt;原文链接： &lt;a href=&quot;https://mp.weixin.qq.com/s/stMBnSo8YJKf5N2YEXrxdQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;今天就和孩子签订一份成长协议&lt;/a&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java优雅之道</title>
    <link href="https://muhouer.github.io/posts/b9a3a63c/"/>
    <id>https://muhouer.github.io/posts/b9a3a63c/</id>
    <published>2019-09-01T01:23:00.000Z</published>
    <updated>2019-09-01T01:43:36.466Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文作者：</strong>陈昌毅，花名常意，高德地图技术专家，2018年加入阿里巴巴，一直从事地图数据采集的相关工作。</p><p><strong>原文地址：</strong><a href="https://mp.weixin.qq.com/s/rjK5OZ_Kx7E5YUGgVp0BCw" target="_blank" rel="noopener">Java 函数优雅之道</a></p></blockquote><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>随着软件项目代码的日积月累，系统维护成本变得越来越高，是所有软件团队面临的共同问题。持续地优化代码，提高代码的质量，是提升系统生命力的有效手段之一。软件系统思维有句话“<strong>Less coding, more thinking（少编码、多思考）</strong>”，也有这么一句俚语“<strong>Think more, code less（思考越多，编码越少）</strong>”。所以，我们在编码中多思考多总结，努力提升自己的编码水平，才能编写出更优雅、更高质、更高效的代码。</p><p>本文总结了一套与 Java 函数相关的编码规则，旨在给广大Java程序员一些编码建议，有助于大家编写出更优雅、更高质、更高效的代码。这套编码规则，通过在高德采集部门的实践，已经取得了不错的成效。</p><h2 id="使用通用工具函数"><a href="#使用通用工具函数" class="headerlink" title="使用通用工具函数"></a>使用通用工具函数</h2><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述:</strong></p><p><strong>不完善的写法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisName != <span class="keyword">null</span> &amp;&amp; thisName.equals(name);</span><br></pre></td></tr></table></figure><p><strong>更完善的写法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(thisName == name) || (thisName != <span class="keyword">null</span> &amp;&amp; thisName.equals(name));</span><br></pre></td></tr></table></figure><p><strong>建议方案:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(name, thisName);</span><br></pre></td></tr></table></figure><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p><strong>现象描述:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(list == <span class="keyword">null</span> || list.isEmpty());</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line">CollectionUtils.isNotEmpty(list);</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>函数式编程，业务代码减少，逻辑一目了然；</li><li>通用工具函数，逻辑考虑周全，出问题概率低。</li></ul><h2 id="拆分超大函数"><a href="#拆分超大函数" class="headerlink" title="拆分超大函数"></a>拆分超大函数</h2><p>当一个函数超过80行后，就属于超大函数，需要进行拆分。</p><h3 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h3><p><strong>每一个代码块必然有一个注释，用于解释这个代码块的功能。</strong>如果代码块前方有一行注释，就是在提醒你——可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。如果函数有一个描述恰当的名字，就不需要去看内部代码究竟是如何实现的。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    <span class="comment">// 吃饭相关代码几十行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="comment">// 编码相关代码几十行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    <span class="comment">// 睡觉相关代码几十行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吃饭函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭相关代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编码相关代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡觉函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 睡觉相关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二-每一个循环体都可以封装为一个函数。"><a href="#案例二-每一个循环体都可以封装为一个函数。" class="headerlink" title="案例二:每一个循环体都可以封装为一个函数。"></a>案例二:每一个循环体都可以封装为一个函数。</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive) &#123;</span><br><span class="line">        <span class="comment">// 吃饭</span></span><br><span class="line">        eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编码</span></span><br><span class="line">        code();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡觉</span></span><br><span class="line">        sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive) &#123;</span><br><span class="line">        <span class="comment">// 每日生活</span></span><br><span class="line">        liveDaily();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三-每一个条件体都可以封装为一个函数。"><a href="#案例三-每一个条件体都可以封装为一个函数。" class="headerlink" title="案例三:每一个条件体都可以封装为一个函数。"></a>案例三:每一个条件体都可以封装为一个函数。</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外出函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否周末</span></span><br><span class="line">    <span class="comment">// 判断是否周末: 是周末则游玩</span></span><br><span class="line">    <span class="keyword">if</span> (isWeekday()) &#123;</span><br><span class="line">        <span class="comment">// 游玩代码几十行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否周末: 非周末则工作</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 工作代码几十行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外出函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否周末</span></span><br><span class="line">    <span class="comment">// 判断是否周末: 是周末则游玩</span></span><br><span class="line">    <span class="keyword">if</span> (isWeekday()) &#123;</span><br><span class="line">        play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否周末: 非周末则工作</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游玩函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 游玩代码几十行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 工作代码几十行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>函数越短小精悍，功能就越单一，往往生命周期较长；</li><li>一个函数越长，就越不容易理解和维护，维护人员不敢轻易修改；</li><li>在过长函数中，往往含有难以发现的重复代码。</li></ul><h2 id="同一函数内代码块级别尽量一致"><a href="#同一函数内代码块级别尽量一致" class="headerlink" title="同一函数内代码块级别尽量一致"></a>同一函数内代码块级别尽量一致</h2><h3 id="案例一-2"><a href="#案例一-2" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每日生活函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    <span class="comment">// 睡觉相关代码几十行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，睡觉这块代码块，跟 eat（吃饭）和 code（编码）不在同一级别上，显得比较突兀。如果把写代码比作写文章，eat（吃饭）和code（编码）是段落大意，而睡觉这块代码块属于一个详细段落。而在 liveDaily（每日生活）这个函数上，只需要写出主要流程（段落大意）即可。</p><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liveDaily</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 吃饭</span></span><br><span class="line">    eat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    code();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡觉</span></span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡觉</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 睡觉相关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>函数调用表明用途，函数实现表达逻辑，层次分明便于理解；</li><li>不用层次的代码块放在一个函数中，容易让人觉得代码头重脚轻。</li></ul><h2 id="封装相同功能代码为函数"><a href="#封装相同功能代码为函数" class="headerlink" title="封装相同功能代码为函数"></a>封装相同功能代码为函数</h2><h3 id="案例一：封装相同代码为函数"><a href="#案例一：封装相同代码为函数" class="headerlink" title="案例一：封装相同代码为函数"></a>案例一：封装相同代码为函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disableUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 禁用黑名单用户</span></span><br><span class="line">    List&lt;Long&gt; userIdList = queryBlackUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        User userUpdate = <span class="keyword">new</span> User();</span><br><span class="line">        userUpdate.setId(userId);</span><br><span class="line">        userUpdate.setEnable(Boolean.FALSE);</span><br><span class="line">        userDAO.update(userUpdate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用过期用户</span></span><br><span class="line">    userIdList = queryExpiredUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        User userUpdate = <span class="keyword">new</span> User();</span><br><span class="line">        userUpdate.setId(userId);</span><br><span class="line">        userUpdate.setEnable(Boolean.FALSE);</span><br><span class="line">        userDAO.update(userUpdate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disableUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 禁用黑名单用户</span></span><br><span class="line">    List&lt;Long&gt; userIdList = queryBlackUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        disableUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用过期用户</span></span><br><span class="line">    userIdList = queryExpiredUser();</span><br><span class="line">    <span class="keyword">for</span> (Long userId : userIdList) &#123;</span><br><span class="line">        disableUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disableUser</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    User userUpdate = <span class="keyword">new</span> User();</span><br><span class="line">    userUpdate.setId(userId);</span><br><span class="line">    userUpdate.setEnable(Boolean.FALSE);</span><br><span class="line">    userDAO.update(userUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：封装相似代码为函数"><a href="#案例二：封装相似代码为函数" class="headerlink" title="案例二：封装相似代码为函数"></a>案例二：封装相似代码为函数</h3><p>封装相似代码为函数，差异性通过函数参数控制。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adoptOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    Order orderUpdate = <span class="keyword">new</span> Order();</span><br><span class="line">    orderUpdate.setId(orderId);</span><br><span class="line">    orderUpdate.setStatus(OrderStatus.ADOPTED);</span><br><span class="line">    orderUpdate.setAuditTime(<span class="keyword">new</span> Date());</span><br><span class="line">    orderDAO.update(orderUpdate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驳回工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    Order orderUpdate = <span class="keyword">new</span> Order();</span><br><span class="line">    orderUpdate.setId(orderId);</span><br><span class="line">    orderUpdate.setStatus(OrderStatus.REJECTED);</span><br><span class="line">    orderUpdate.setAuditTime(<span class="keyword">new</span> Date());</span><br><span class="line">    orderDAO.update(orderUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adoptOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    auditOrder(orderId, OrderStatus.ADOPTED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驳回工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    auditOrder(orderId, OrderStatus.REJECTED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 审核工单函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">auditOrder</span><span class="params">(Long orderId, OrderStatus orderStatus)</span> </span>&#123;</span><br><span class="line">    Order orderUpdate = <span class="keyword">new</span> Order();</span><br><span class="line">    orderUpdate.setId(orderId);</span><br><span class="line">    orderUpdate.setStatus(orderStatus);</span><br><span class="line">    orderUpdate.setAuditTime(<span class="keyword">new</span> Date());</span><br><span class="line">    orderDAO.update(orderUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>封装公共函数，减少代码行数，提高代码质量；</li><li>封装公共函数，使业务代码更精炼，可读性可维护性更强。</li></ul><h2 id="封装获取参数值函数"><a href="#封装获取参数值函数" class="headerlink" title="封装获取参数值函数"></a>封装获取参数值函数</h2><h3 id="案例一-3"><a href="#案例一-3" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取通过阈值</span></span><br><span class="line">    <span class="keyword">double</span> thisPassThreshold = PASS_THRESHOLD;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(passThreshold)) &#123;</span><br><span class="line">        thisPassThreshold = passThreshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取通过率</span></span><br><span class="line">    <span class="keyword">double</span> passRate = getPassRate(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判读是否通过</span></span><br><span class="line">    <span class="keyword">return</span> passRate &gt;= thisPassThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取通过阈值</span></span><br><span class="line">    <span class="keyword">double</span> thisPassThreshold = getPassThreshold();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取通过率</span></span><br><span class="line">    <span class="keyword">double</span> passRate = getPassRate(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判读是否通过</span></span><br><span class="line">    <span class="keyword">return</span> passRate &gt;= thisPassThreshold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取通过阈值函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getPassThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(passThreshold)) &#123;</span><br><span class="line">        <span class="keyword">return</span> passThreshold;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PASS_THRESHOLD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>把获取参数值从业务函数中独立，使业务逻辑更清晰；</li><li>封装的获取参数值为独立函数，可以在代码中重复使用。</li></ul><h2 id="通过接口参数化封装相同逻辑"><a href="#通过接口参数化封装相同逻辑" class="headerlink" title="通过接口参数化封装相同逻辑"></a>通过接口参数化封装相同逻辑</h2><h3 id="案例一-4"><a href="#案例一-4" class="headerlink" title="案例一"></a>案例一</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送审核员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAuditorSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WorkerSettleData&gt; settleDataList = auditTaskDAO.statAuditorSettleData();</span><br><span class="line">    <span class="keyword">for</span> (WorkerSettleData settleData : settleDataList) &#123;</span><br><span class="line">        WorkerPushData pushData = <span class="keyword">new</span> WorkerPushData();</span><br><span class="line">        pushData.setId(settleData.getWorkerId());</span><br><span class="line">        pushData.setType(WorkerPushDataType.AUDITOR);</span><br><span class="line">        pushData.setData(settleData);</span><br><span class="line">        pushService.push(pushData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送验收员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCheckerSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WorkerSettleData&gt; settleDataList = auditTaskDAO.statCheckerSettleData();</span><br><span class="line">    <span class="keyword">for</span> (WorkerSettleData settleData : settleDataList) &#123;</span><br><span class="line">        WorkerPushData pushData = <span class="keyword">new</span> WorkerPushData();</span><br><span class="line">        pushData.setId(settleData.getWorkerId());</span><br><span class="line">        pushData.setType(WorkerPushDataType.CHECKER);</span><br><span class="line">        pushData.setData(settleData);</span><br><span class="line">        pushService.push(pushData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送审核员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAuditorSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendWorkerSettleData(WorkerPushDataType.AUDITOR, () -&gt; auditTaskDAO.statAuditorSettleData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送验收员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCheckerSettleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; auditTaskDAO.statCheckerSettleData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送作业员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendWorkerSettleData</span><span class="params">(WorkerPushDataType dataType, WorkerSettleDataProvider dataProvider)</span> </span>&#123;</span><br><span class="line">    List&lt;WorkerSettleData&gt; settleDataList = dataProvider.statWorkerSettleData();</span><br><span class="line">    <span class="keyword">for</span> (WorkerSettleData settleData : settleDataList) &#123;</span><br><span class="line">        WorkerPushData pushData = <span class="keyword">new</span> WorkerPushData();</span><br><span class="line">        pushData.setId(settleData.getWorkerId());</span><br><span class="line">        pushData.setType(dataType);</span><br><span class="line">        pushData.setData(settleData);</span><br><span class="line">        pushService.push(pushData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作业员结算数据提供者接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerSettleDataProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 统计作业员结算数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;WorkerSettleData&gt; <span class="title">statWorkerSettleData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>把核心逻辑从各个业务函数中抽析，使业务代码更清晰更易维护；</li><li>避免重复性代码多次编写，精简重复函数越多收益越大。</li></ul><h2 id="减少函数代码层级"><a href="#减少函数代码层级" class="headerlink" title="减少函数代码层级"></a>减少函数代码层级</h2><p>如果要使函数优美，建议函数代码层级在1-4之间，过多的缩进会让函数难以阅读。</p><h3 id="案例一：利用return提前返回函数"><a href="#案例一：利用return提前返回函数" class="headerlink" title="案例一：利用return提前返回函数"></a>案例一：利用return提前返回函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">getUserBalance</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    User user = getUser(userId);</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user)) &#123;</span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">            <span class="keyword">return</span> account.getBalance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">getUserBalance</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取用户信息</span></span><br><span class="line">    User user = getUser(userId);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户账户</span></span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(account)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回账户余额</span></span><br><span class="line">    <span class="keyword">return</span> account.getBalance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：利用continue提前结束循环"><a href="#案例二：利用continue提前结束循环" class="headerlink" title="案例二：利用continue提前结束循环"></a>案例二：利用continue提前结束循环</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取合计余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始合计余额</span></span><br><span class="line">    <span class="keyword">double</span> totalBalance = <span class="number">0.0</span>D;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次累加余额</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 获取用户账户</span></span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">            <span class="comment">// 累加用户余额</span></span><br><span class="line">            Double balance = account.getBalance();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(balance)) &#123;</span><br><span class="line">                totalBalance += balance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回合计余额</span></span><br><span class="line">    <span class="keyword">return</span> totalBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取合计余额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始合计余额</span></span><br><span class="line">    <span class="keyword">double</span> totalBalance = <span class="number">0.0</span>D;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次累加余额</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 获取用户账户</span></span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(account)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累加用户余额</span></span><br><span class="line">        Double balance = account.getBalance();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(balance)) &#123;</span><br><span class="line">            totalBalance += balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回合计余额</span></span><br><span class="line">    <span class="keyword">return</span> totalBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>特殊说明</em></strong></p><p>其它方式：在循环体中，先调用案例1的函数 getUserBalance (获取用户余额)，再进行对余额进行累加。</p><p><strong>在循环体中，建议最多使用一次 continue 。</strong>如果需要有使用多次 continue 的需求，建议把循环体封装为一个函数。</p><h3 id="案例三：利用条件表达式函数减少层级"><a href="#案例三：利用条件表达式函数减少层级" class="headerlink" title="案例三：利用条件表达式函数减少层级"></a>案例三：利用条件表达式函数减少层级</h3><p>请参考下一章的”案例2: 把复杂条件表达式封装为函数”</p><p><strong>主要收益</strong></p><ul><li>代码层级减少，代码缩进减少；</li><li>模块划分清晰，方便阅读维护。</li></ul><h2 id="封装条件表达式函数"><a href="#封装条件表达式函数" class="headerlink" title="封装条件表达式函数"></a>封装条件表达式函数</h2><h3 id="案例一：把简单条件表达式封装为函数"><a href="#案例一：把简单条件表达式封装为函数" class="headerlink" title="案例一：把简单条件表达式封装为函数"></a>案例一：把简单条件表达式封装为函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取门票价格函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">(Date currDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(currDate) &amp;&amp; currDate.after(DISCOUNT_BEGIN_DATE)</span><br><span class="line">        &amp;&amp; currDate.before(DISCOUNT_END_DATE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> TICKET_PRICE * DISCOUNT_RATE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TICKET_PRICE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取门票价格函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">(Date currDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDiscountDate(currDate)) &#123;</span><br><span class="line">        <span class="keyword">return</span> TICKET_PRICE * DISCOUNT_RATE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TICKET_PRICE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否折扣日期函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDiscountDate</span><span class="params">(Date currDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.nonNull(currDate) &amp;&amp; </span><br><span class="line">currDate.after(DISCOUNT_BEGIN_DATE)</span><br><span class="line">        &amp;&amp; currDate.before(DISCOUNT_END_DATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：把复杂条件表达式封装为函数"><a href="#案例二：把复杂条件表达式封装为函数" class="headerlink" title="案例二：把复杂条件表达式封装为函数"></a>案例二：把复杂条件表达式封装为函数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取土豪用户列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getRichUserList</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始土豪用户列表</span></span><br><span class="line">    List&lt;User&gt; richUserList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次查找土豪用户</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 获取用户账户</span></span><br><span class="line">        UserAccount account = user.getAccount();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">            <span class="comment">// 判断用户余额</span></span><br><span class="line">            Double balance = account.getBalance();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(balance) &amp;&amp; balance.compareTo(RICH_THRESHOLD) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 添加土豪用户</span></span><br><span class="line">                richUserList.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回土豪用户列表</span></span><br><span class="line">    <span class="keyword">return</span> richUserList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取土豪用户列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getRichUserList</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始土豪用户列表</span></span><br><span class="line">    List&lt;User&gt; richUserList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次查找土豪用户</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="comment">// 判断土豪用户</span></span><br><span class="line">        <span class="keyword">if</span> (isRichUser(user)) &#123;</span><br><span class="line">            <span class="comment">// 添加土豪用户</span></span><br><span class="line">            richUserList.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回土豪用户列表</span></span><br><span class="line">    <span class="keyword">return</span> richUserList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否土豪用户</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRichUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取用户账户</span></span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(account)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户余额</span></span><br><span class="line">    Double balance = account.getBalance();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(balance)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较用户余额</span></span><br><span class="line">    <span class="keyword">return</span> balance.compareTo(RICH_THRESHOLD) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码也可以用采用流式(Stream)编程的过滤来实现。</p><p><strong>主要收益</strong></p><ul><li>把条件表达式从业务函数中独立，使业务逻辑更清晰；</li><li>封装的条件表达式为独立函数，可以在代码中重复使用。</li></ul><h2 id="尽量避免不必要的空指针判断"><a href="#尽量避免不必要的空指针判断" class="headerlink" title="尽量避免不必要的空指针判断"></a>尽量避免不必要的空指针判断</h2><p>本章只适用于项目内部代码，并且是自己了解的代码，才能够尽量避免不必要的空指针判断。对于第三方中间件和系统接口，必须做好空指针判断，以保证代码的健壮性。</p><h3 id="案例一-调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断"><a href="#案例一-调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断" class="headerlink" title="案例一: 调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断"></a>案例一: 调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建用户信息</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">... <span class="comment">// 赋值用户相关信息</span></span><br><span class="line">createUser(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断用户为空</span></span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建用户信息</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">... <span class="comment">// 赋值用户相关信息</span></span><br><span class="line">createUser(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二-被调用函数保证返回不为空-调用函数尽量避免不必要的空指针判断"><a href="#案例二-被调用函数保证返回不为空-调用函数尽量避免不必要的空指针判断" class="headerlink" title="案例二: 被调用函数保证返回不为空,调用函数尽量避免不必要的空指针判断"></a>案例二: 被调用函数保证返回不为空,调用函数尽量避免不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建用户信息</span></span><br><span class="line">    User user = buildUser(id, name);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizRuntimeException(<span class="string">"构建用户信息为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">buildUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(id);</span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建用户信息</span></span><br><span class="line">    User user = buildUser(id, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存用户信息</span></span><br><span class="line">    userDAO.insert(user);</span><br><span class="line">    userRedis.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">buildUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(id);</span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断"><a href="#案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断" class="headerlink" title="案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断"></a>案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户列表</span></span><br><span class="line">List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化用户列表</span></span><br><span class="line">List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">    UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVo.setId(user.getId());</span><br><span class="line">    userVo.setName(user.getName());</span><br><span class="line">    userVoList.add(userVo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次处理用户</span></span><br><span class="line"><span class="keyword">for</span> (UserVO userVo : userVoList) &#123;</span><br><span class="line">    <span class="comment">// 判断用户为空</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(userVo)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理相关逻辑</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户列表</span></span><br><span class="line">List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化用户列表</span></span><br><span class="line">List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">    UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVo.setId(user.getId());</span><br><span class="line">    userVo.setName(user.getName());</span><br><span class="line">    userVoList.add(userVo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次处理用户</span></span><br><span class="line"><span class="keyword">for</span> (UserVO userVo : userVoList) &#123;</span><br><span class="line">    <span class="comment">// 处理相关逻辑</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断"><a href="#案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断" class="headerlink" title="案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断"></a>案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断</h3><p>MyBatis 是一款优秀的持久层框架，是在项目中使用的最广泛的数据库中间件之一。通过对 MyBatis 源码进行分析，查询函数返回的列表和数据项都不为空，在代码中可以不用进行空指针判断。</p><p><strong>现象描述：</strong></p><p>这种写法没有问题，只是过于保守了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.query(id, name);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; voList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">        <span class="comment">// 判断对象为空</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加用户信息</span></span><br><span class="line">        UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        BeanUtils.copyProperties(user, vo);</span><br><span class="line">        voList.add(vo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> voList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.query(id, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; voList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span> (UserDO user : userList) &#123;</span><br><span class="line">        UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        BeanUtils.copyProperties(user, vo);</span><br><span class="line">        voList.add(vo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> voList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>避免不必要的空指针判断，精简业务代码处理逻辑，提高业务代码运行效率；</li><li>这些不必要的空指针判断，基本属于永远不执行的 Death 代码，删除有助于代码维护。</li></ul><h2 id="内部函数参数尽量使用基础类型"><a href="#内部函数参数尽量使用基础类型" class="headerlink" title="内部函数参数尽量使用基础类型"></a>内部函数参数尽量使用基础类型</h2><h3 id="案例一：内部函数参数尽量使用基础类型"><a href="#案例一：内部函数参数尽量使用基础类型" class="headerlink" title="案例一：内部函数参数尽量使用基础类型"></a>案例一：内部函数参数尽量使用基础类型</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line"><span class="keyword">double</span> price = <span class="number">5.1</span>D;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">double</span> total = calculate(price, number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(Double price, Integer number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line"><span class="keyword">double</span> price = <span class="number">5.1</span>D;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">double</span> total = calculate(price, number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：内部函数返回值尽量使用基础类型"><a href="#案例二：内部函数返回值尽量使用基础类型" class="headerlink" title="案例二：内部函数返回值尽量使用基础类型"></a>案例二：内部函数返回值尽量使用基础类型</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取订单总额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getOrderAmount</span><span class="params">(List&lt;Product&gt; productList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> amount = <span class="number">0.0</span>D;</span><br><span class="line">    <span class="keyword">for</span> (Product product : productList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(product) || Objects.isNull(product.getPrice())</span><br><span class="line">            || Objects.isNull(product.getNumber())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        amount += calculate(product.getPrice(), product.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Double <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">double</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取订单总额函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getOrderAmount</span><span class="params">(List&lt;Product&gt; productList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> amount = <span class="number">0.0</span>D;</span><br><span class="line">    <span class="keyword">for</span> (Product product : productList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(product) || Objects.isNull(product.getPrice())</span><br><span class="line">            || Objects.isNull(product.getNumber())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        amount += calculate(product.getPrice(), product.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算金额函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">double</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处只是举例说明这种现象，更好的方式是采用流式(Stream)编程。</p><p><strong>主要收益</strong></p><ul><li>内部函数尽量使用基础类型，避免了隐式封装类型的打包和拆包；</li><li>内部函数参数使用基础类型，用语法上避免了内部函数的参数空指针判断；</li><li>内部函数返回值使用基础类型，用语法上避免了调用函数的返回值空指针判断。</li></ul><h2 id="尽量避免返回的数组和列表为-null"><a href="#尽量避免返回的数组和列表为-null" class="headerlink" title="尽量避免返回的数组和列表为 null"></a>尽量避免返回的数组和列表为 null</h2><h3 id="案例一：尽量避免返回的数组为-null-，引起不必要的空指针判断"><a href="#案例一：尽量避免返回的数组为-null-，引起不必要的空指针判断" class="headerlink" title="案例一：尽量避免返回的数组为 null ，引起不必要的空指针判断"></a>案例一：尽量避免返回的数组为 null ，引起不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">UserVO[] users = queryUser();</span><br><span class="line"><span class="keyword">if</span> (Objects.nonNull(users)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (UserVO user : users) &#123;</span><br><span class="line">        <span class="comment">// 处理用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="keyword">private</span> UserVO[] queryUser() &#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户数组</span></span><br><span class="line">    UserVO[] users = <span class="keyword">new</span> UserVO[userList.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userList.size(); i++) &#123;</span><br><span class="line">        UserDO user = userList.get(i);</span><br><span class="line">        users[i] = <span class="keyword">new</span> UserVO();</span><br><span class="line">        users[i].setId(user.getId());</span><br><span class="line">        users[i].setName(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户数组</span></span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">UserVO[] users = queryUser();</span><br><span class="line"><span class="keyword">for</span> (UserVO user : users) &#123;</span><br><span class="line">    <span class="comment">// 处理用户信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="keyword">private</span> UserVO[] queryUser() &#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserVO[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户数组</span></span><br><span class="line">    UserVO[] users = <span class="keyword">new</span> UserVO[userList.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userList.size(); i++) &#123;</span><br><span class="line">        UserDO user = userList.get(i);</span><br><span class="line">        users[i] = <span class="keyword">new</span> UserVO();</span><br><span class="line">        users[i].setId(user.getId());</span><br><span class="line">        users[i].setName(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户数组</span></span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：尽量避免返回的列表为-null-，引起不必要的空指针判断"><a href="#案例二：尽量避免返回的列表为-null-，引起不必要的空指针判断" class="headerlink" title="案例二：尽量避免返回的列表为 null ，引起不必要的空指针判断"></a>案例二：尽量避免返回的列表为 null ，引起不必要的空指针判断</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">List&lt;UserVO&gt; userList = queryUser();</span><br><span class="line"><span class="keyword">if</span> (Objects.nonNull(userList)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (UserVO user : userList) &#123;</span><br><span class="line">        <span class="comment">// 处理用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span>(UserDO user : userList) &#123;</span><br><span class="line">        UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        userVo.setId(user.getId());</span><br><span class="line">        userVo.setName(user.getName());</span><br><span class="line">        userVoList.add(userVo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> userVoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">List&lt;UserVO&gt; userList = queryUser();</span><br><span class="line"><span class="keyword">for</span> (UserVO user : userList) &#123;</span><br><span class="line">   <span class="comment">// 处理用户信息</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;UserVO&gt; <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户列表</span></span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.queryAll();</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化用户列表</span></span><br><span class="line">    List&lt;UserVO&gt; userVoList = <span class="keyword">new</span> ArrayList&lt;&gt;(userList.size());</span><br><span class="line">    <span class="keyword">for</span>(UserDO user : userList) &#123;</span><br><span class="line">        UserVO userVo = <span class="keyword">new</span> UserVO();</span><br><span class="line">        userVo.setId(user.getId());</span><br><span class="line">        userVo.setName(user.getName());</span><br><span class="line">        userVoList.add(userVo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回用户列表</span></span><br><span class="line">    <span class="keyword">return</span> userVoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>保证返回的数组和列表不为 null , 避免调用函数的空指针判断。</li></ul><h2 id="封装函数传入参数"><a href="#封装函数传入参数" class="headerlink" title="封装函数传入参数"></a>封装函数传入参数</h2><h3 id="案例一：当传入参数过多时，应封装为参数类"><a href="#案例一：当传入参数过多时，应封装为参数类" class="headerlink" title="案例一：当传入参数过多时，应封装为参数类"></a>案例一：当传入参数过多时，应封装为参数类</h3><p>Java 规范不允许函数参数太多，不便于维护也不便于扩展。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyUser</span><span class="params">(Long id, String name, String phone, Integer age, </span></span></span><br><span class="line"><span class="function"><span class="params">    Integer sex, String address, String description)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二-当传入成组参数时，应封装为参数类"><a href="#案例二-当传入成组参数时，应封装为参数类" class="headerlink" title="案例二: 当传入成组参数时，应封装为参数类"></a>案例二: 当传入成组参数时，应封装为参数类</h3><p>既然参数成组出现，就需要封装一个类去描述这种现象。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取距离函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取距离函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(Point point1, Point point2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>封装过多函数参数为类，使函数更便于扩展和维护；</li><li>封装成组函数参数为类，使业务概念更明确更清晰。</li></ul><h2 id="尽量用函数替换匿名内部类的实现"><a href="#尽量用函数替换匿名内部类的实现" class="headerlink" title="尽量用函数替换匿名内部类的实现"></a>尽量用函数替换匿名内部类的实现</h2><p>在匿名内部类（包括Lambda表达式）中可以直接访问外部类的成员，包括类的成员变量、函数的内部变量。正因为可以随意访问外部变量，所以会导致代码边界不清晰。</p><p>首先推荐用 Lambda 表达式简化匿名内部类，其次推荐用函数替换复杂的 Lambda 表达式的实现。</p><h3 id="案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现"><a href="#案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现" class="headerlink" title="案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现"></a>案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送结算数据</span></span><br><span class="line">sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; &#123;</span><br><span class="line">    Date beginDate = DateUtils.addDays(currDate, -aheadDays);</span><br><span class="line">    Date endDate = DateUtils.addDays(currDate, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> auditTaskDAO.statCheckerSettleData(beginDate, endDate);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送结算数据</span></span><br><span class="line">sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; statCheckerSettleData(currDate, aheadDays));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计验收员结算数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;WorkerSettleData&gt; <span class="title">statCheckerSettleData</span><span class="params">(Date currDate, <span class="keyword">int</span> aheadDays)</span> </span>&#123;</span><br><span class="line">    Date beginDate = DateUtils.addDays(currDate, -aheadDays);</span><br><span class="line">    Date endDate = DateUtils.addDays(currDate, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> auditTaskDAO.statCheckerSettleData(beginDate, endDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，还有一个更简单的办法。在调用函数 sendWorkerSettleData（发送作业员结算数据）之前计算开始日期、结束日期，就直接可以用函数auditTaskDAO.statCheckerSettleData(beginDate, endDate)代替匿名内部类实现。</p><h3 id="案例二：拆分复杂匿名内部类实现接口为多个函数类接口"><a href="#案例二：拆分复杂匿名内部类实现接口为多个函数类接口" class="headerlink" title="案例二：拆分复杂匿名内部类实现接口为多个函数类接口"></a>案例二：拆分复杂匿名内部类实现接口为多个函数类接口</h3><p>如果一个匿名内部类实现的接口几个函数间关联性不大，可以把这个接口拆分为几个函数式接口，便于使用 Lambda 表达式。</p><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除过期数据</span></span><br><span class="line">cleanExpiredData(<span class="string">"用户日志表"</span>, <span class="keyword">new</span> CleanExpiredDataOperator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Date&gt; <span class="title">queryExpiredDate</span><span class="params">(Integer remainDays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDAO.queryExpiredDate(remainDays);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(Date expiredDate)</span> </span>&#123;</span><br><span class="line">        userDAO.cleanExpiredData(expiredDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(String tableName, CleanExpiredDataOperator cleanExpiredDataOperator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 功能实现代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期操作接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CleanExpiredDataOperator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询过期日期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Date&gt; <span class="title">queryExpiredDate</span><span class="params">(Integer remainDays)</span></span>;</span><br><span class="line">    <span class="comment">// 清除过期数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(Date expiredDate)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除过期数据</span></span><br><span class="line">cleanExpiredData(<span class="string">"用户日志表"</span>, userDAO::queryExpiredDate,userDAO::cleanExpiredData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(String tableName, QueryExpiredDateOperator queryExpiredDateOperator, CleanExpiredDataOperator cleanExpiredDataOperator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 功能实现代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询过期日期接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">QueryExpiredDateOperator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询过期日期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Date&gt; <span class="title">queryExpiredDate</span><span class="params">(Integer remainDays)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期操作接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CleanExpiredDataOperator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清除过期数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredData</span><span class="params">(Date expiredDate)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>定义函数并指定参数，明确规定了匿名内部类的代码边界；</li><li>利用 Lambda 表达式简化匿名内部类实现，使代码更简洁。</li></ul><h2 id="利用-return-精简不必要的代码"><a href="#利用-return-精简不必要的代码" class="headerlink" title="利用 return 精简不必要的代码"></a>利用 return 精简不必要的代码</h2><h3 id="案例一：删除不必要的-if"><a href="#案例一：删除不必要的-if" class="headerlink" title="案例一：删除不必要的 if"></a>案例一：删除不必要的 if</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Double passRate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(passRate) &amp;&amp; passRate.compareTo(PASS_THRESHOLD) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否通过函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(Double passRate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.nonNull(passRate) &amp;&amp; passRate.compareTo(PASS_THRESHOLD) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：删除不必要的-else"><a href="#案例二：删除不必要的-else" class="headerlink" title="案例二：删除不必要的 else"></a>案例二：删除不必要的 else</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结算工资函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">settleSalary</span><span class="params">(Long workId, <span class="keyword">int</span> workDays)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据是否合格处理</span></span><br><span class="line">    <span class="keyword">if</span> (isQualified(workId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> settleQualifiedSalary(workDays);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> settleUnqualifiedSalary(workDays);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 结算工资函数</span><br><span class="line">public double settleSalary(Long workId, int workDays) &#123;</span><br><span class="line">    // 根据是否合格处理</span><br><span class="line">    if (isQualified(workId)) &#123;</span><br><span class="line">        return settleQualifiedSalary(workDays);</span><br><span class="line">    &#125;</span><br><span class="line">    return settleUnqualifiedSalary(workDays);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三：删除不必要的变量"><a href="#案例三：删除不必要的变量" class="headerlink" title="案例三：删除不必要的变量"></a>案例三：删除不必要的变量</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserDO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    UserQuery userQuery = <span class="keyword">new</span> UserQuery();</span><br><span class="line">    userQuery.setId(id);</span><br><span class="line">    userQuery.setName(name);</span><br><span class="line">    List&lt;UserDO&gt; userList = userDAO.query(userQuery);</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserDO&gt; <span class="title">queryUser</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    UserQuery userQuery = <span class="keyword">new</span> UserQuery();</span><br><span class="line">    userQuery.setId(id);</span><br><span class="line">    userQuery.setName(name);</span><br><span class="line">    <span class="keyword">return</span> userDAO.query(userQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>精简不必要的代码，让代码看起来更清爽。</li></ul><h2 id="利用临时变量优化代码"><a href="#利用临时变量优化代码" class="headerlink" title="利用临时变量优化代码"></a>利用临时变量优化代码</h2><p>在一些代码中，经常会看到 a.getB().getC()…getN() 的写法，姑且叫做“函数的级联调用”，代码健壮性和可读性太差。建议：<strong>杜绝函数的级联调用，利用临时变量进行拆分，并做好对象空指针检查</strong>。</p><h3 id="案例一：利用临时变量厘清逻辑"><a href="#案例一：利用临时变量厘清逻辑" class="headerlink" title="案例一：利用临时变量厘清逻辑"></a>案例一：利用临时变量厘清逻辑</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否土豪用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRichUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.nonNull(user.getAccount())</span><br><span class="line">        &amp;&amp; Objects.nonNull(user.getAccount().getBalance())</span><br><span class="line">        &amp;&amp; user.getAccount().getBalance().compareTo(RICH_THRESHOLD) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是精简代码控的最爱，但是可读性实在太差。</p><p><strong>建议方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 是否土豪用户函数</span><br><span class="line">private boolean isRichUser(User user) &#123;</span><br><span class="line">    // 获取用户账户</span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    if (Objects.isNull(account)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取用户余额</span><br><span class="line">    Double balance = account.getBalance();</span><br><span class="line">    if (Objects.isNull(balance)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 比较用户余额</span><br><span class="line">    return balance.compareTo(RICH_THRESHOLD) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案，增加了代码行数，但是逻辑更清晰。<br>有时候，当代码的精简性和可读性发生冲突时，个人更偏向于保留代码的可读性。</p><h3 id="案例二：利用临时变量精简代码"><a href="#案例二：利用临时变量精简代码" class="headerlink" title="案例二：利用临时变量精简代码"></a>案例二：利用临时变量精简代码</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserVO <span class="title">buildUser</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    vo.setId(user.getId());</span><br><span class="line">    vo.setName(user.getName());</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user.getAccount())) &#123;</span><br><span class="line">        vo.setBalance(user.getAccount().getBalance());</span><br><span class="line">        vo.setDebt(user.getAccount().getDebt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写，大约是为了节约一个临时变量吧。</p><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserVO <span class="title">buildUser1</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    UserVO vo = <span class="keyword">new</span> UserVO();</span><br><span class="line">    vo.setId(user.getId());</span><br><span class="line">    vo.setName(user.getName());</span><br><span class="line">    UserAccount account = user.getAccount();</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(account)) &#123;</span><br><span class="line">        vo.setBalance(account.getBalance());</span><br><span class="line">        vo.setDebt(account.getDebt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br></pre></td></tr></table></figure><p><strong>主要收益</strong></p><ul><li>利用临时变量厘清逻辑，显得业务逻辑更清晰；</li><li>利用临时变量精简代码，看变量名称即知其义，减少了大量无用代码；</li><li>如果获取函数比较复杂耗时，利用临时变量可以提高运行效率；</li><li>利用临时变量避免函数的级联调用，可有效预防空指针异常。</li></ul><h2 id="仅保留函数需要的参数"><a href="#仅保留函数需要的参数" class="headerlink" title="仅保留函数需要的参数"></a>仅保留函数需要的参数</h2><h3 id="案例一：删除多余的参数"><a href="#案例一：删除多余的参数" class="headerlink" title="案例一：删除多余的参数"></a>案例一：删除多余的参数</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户状态函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserStatus</span><span class="params">(Long userId, Integer status, String unused)</span> </span>&#123;</span><br><span class="line">    userCache.modifyStatus(userId, status);</span><br><span class="line">    userDAO.modifyStatus(userId, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，unused 参数是无用参数。</p><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改用户状态函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserStatus</span><span class="params">(Long userId, Integer status)</span> </span>&#123;</span><br><span class="line">    userCache.modifyStatus(userId, status);</span><br><span class="line">    userDAO.modifyStatus(userId, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二：用属性取代对象"><a href="#案例二：用属性取代对象" class="headerlink" title="案例二：用属性取代对象"></a>案例二：用属性取代对象</h3><p><strong>现象描述：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    userCache.delete(user.getId());</span><br><span class="line">    userDAO.delete(user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除用户函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    userCache.delete(userId);</span><br><span class="line">    userDAO.delete(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议方案：</strong></p><p>调用函数时，参数对象不需要专门构建，而函数使用其属性超过3个，可以不必使用该规则。</p><p><strong>主要收益</strong></p><ul><li>仅保留函数需要的参数，明确了调用时需要赋值的参数，避免了调用时还要去构造些无用参数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;本文作者：&lt;/strong&gt;陈昌毅，花名常意，高德地图技术专家，2018年加入阿里巴巴，一直从事地图数据采集的相关工作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;原文地址：&lt;/strong&gt;&lt;a href=&quot;https://mp.weixin.q
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
      <category term="编程规范" scheme="https://muhouer.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>MD5简单了解</title>
    <link href="https://muhouer.github.io/posts/c9f1aafe/"/>
    <id>https://muhouer.github.io/posts/c9f1aafe/</id>
    <published>2019-08-30T15:50:00.000Z</published>
    <updated>2019-08-30T15:51:35.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-MD5"><a href="#什么是-MD5" class="headerlink" title="什么是 MD5"></a>什么是 MD5</h2><p>MD5 是 <strong>Message-Digest algorithm 5</strong>（信息-摘要算法）的缩写，被广泛用于加密和解密技术上，它可以说是文件的“<strong>数字指纹</strong>”。任何一个文件，无论是可执行程序、图像文件、临时文件或者其他任何类型的文件，也不管它体积多大，都有且只有一个独一无二的MD5信息值，并且如果这个文件被修改过，它的MD5值也将随之改变。因此，我们可以通过对比同一文件的MD5值，来校验这个文件是否被“篡改”过。</p><h2 id="MD5-用途"><a href="#MD5-用途" class="headerlink" title="MD5 用途"></a>MD5 用途</h2><h3 id="MD5-文件传输"><a href="#MD5-文件传输" class="headerlink" title="MD5 文件传输"></a>MD5 文件传输</h3><p>当我们下载了一个软件以后，如果想知道下载的这个软件和网站的原始文件是否一模一样，就可以给自己下载的文件做个 MD5 校验。如果得到的 MD5 值和网站公布的相同，可确认所下载的文件是完整的。如有不同，说明你下载的文件是不完整的：要么就是在网络下载的过程中出现错误，要么就是此文件已被别人修改。为防止他人更改该文件时放入病毒，最好不要使用。一般使用 MD5 计算工具计算后，和软件网站公布得MD5码进行比对。</p><p>校验值是一组16进制数，不区分大小写，校验值本身只与文件内容有关，只要文件内容不改变校验值就不变；如复制/剪切/粘贴，修改文件创建时间/访问时间，修改文件读/写/执行属性等操作都不会导致校验值发生改变。</p><h3 id="MD5-密码加密"><a href="#MD5-密码加密" class="headerlink" title="MD5 密码加密"></a>MD5 密码加密</h3><p>MD5 算法是不可逆的，可以应用在对密码(或者信用卡等)得加密，加密之后在数据库里面看到的密码是无用的。如果需要检验用户的密码，而是检验用户输入的密码经 md5 加密以后和数据库内的是否相符。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="彩虹表"><a href="#彩虹表" class="headerlink" title="彩虹表"></a>彩虹表</h3><p>现在的 MD5 密码数据库（彩虹表）的数据量已经非常庞大了，大部分常用密码都可以通过 MD5 摘要反向查询到密码明文。为了防止内部人员（能够接触到数据库或者数据库备份文件的人员）和外部入侵者通过MD5反查密码明文，更好地保护用户的密码和个人帐户安全（一个用户可能会在多个系统中使用同样的密码，因此涉及到用户在其他网站和系统中的数据安全），需要对 MD5 摘要结果掺入其他信息，称之为加盐。</p><p>通过 md5、sha1等全球通用公开的加密算法进行反向查询网站 : <a href="https://www.cmd5.com/" target="_blank" rel="noopener">https://www.cmd5.com/</a></p><p>例如：<br><img src="/images/201908301130.png" width="800px" height="300px" align="center"></p><h3 id="MD5-加密-加盐"><a href="#MD5-加密-加盐" class="headerlink" title="MD5 加密+加盐"></a>MD5 加密+加盐</h3><blockquote><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p></blockquote><p>加盐很好理解，就是给原始密码加上特定的字符串，这样给攻击者增加攻击的成本，加盐的关键在于如何选择盐。</p><h4 id="固定字符串"><a href="#固定字符串" class="headerlink" title="固定字符串"></a>固定字符串</h4><p><strong>MD5(Password+UserName)</strong>，即将用户名和密码字符串相加再 MD5，这样的 MD5 摘要基本上不可反查。<br>但有时候用户名可能会发生变化，发生变化后密码即不可用了（验证密码实际上就是再次计算摘要的过程）。</p><h4 id="随机字符串"><a href="#随机字符串" class="headerlink" title="随机字符串"></a>随机字符串</h4><p>盐一般要求是固定长度的随机字符串，且每个用户的盐不同，比如10位，数据库可以这样存储：</p><table><thead><tr><th>Username</th><th>Password</th><th>Salt</th></tr></thead><tbody><tr><td>Freya</td><td>26b74fc2e533289be4dae7018806d978</td><td>63UrCwJhTH</td></tr><tr><td>Asher</td><td>05e213b017e654d6edc134751bc9319f</td><td>84GljVnhDT</td></tr></tbody></table><p>采用加密方式 <code>MD5(MD5(password) + salt)</code></p><p><strong>注：以随机字符串作为盐对密码进行加盐仅仅是增加破解密码的难度，可以减少数据库泄露密码以后被破译的风险</strong>。</p><h3 id="计算文件的-MD5-校验值"><a href="#计算文件的-MD5-校验值" class="headerlink" title="计算文件的 MD5 校验值"></a>计算文件的 MD5 校验值</h3><p>在命令行下，可以使用 Windows 自带的 <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/certutil" target="_blank" rel="noopener">certuti</a>l 命令来计算一个文件的校验值。</p><p>certutil 支持的算法有：MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512。</p><p>certutil 的使用方法非常简单，只需要执行<code>certutil -hashfile 文件名 校验值类型</code>，即可计算出对应文件的校验值。也可以使用 <a href="http://www.pc-tools.net/win32/md5sums/" target="_blank" rel="noopener">md5sums</a> 或 <a href="http://keir.net/hash.html" target="_blank" rel="noopener">hash</a> 工具进行计算。</p><p>Linux 下可以直接使用 md5sum/sha1sum/sha256sum 等命令直接计算文件的对应校验值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-MD5&quot;&gt;&lt;a href=&quot;#什么是-MD5&quot; class=&quot;headerlink&quot; title=&quot;什么是 MD5&quot;&gt;&lt;/a&gt;什么是 MD5&lt;/h2&gt;&lt;p&gt;MD5 是 &lt;strong&gt;Message-Digest algorithm 5&lt;/strong&gt;（
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MD5" scheme="https://muhouer.github.io/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>HTTP与HTTPS的区别</title>
    <link href="https://muhouer.github.io/posts/80f14f93/"/>
    <id>https://muhouer.github.io/posts/80f14f93/</id>
    <published>2019-08-30T15:08:09.000Z</published>
    <updated>2019-08-30T15:13:56.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://www.runoob.com/w3cnote/http-vs-https.html" target="_blank" rel="noopener">HTTP 与 HTTPS 的区别</a></p></blockquote><img src="/images/201908301109.png" width="800px" height="300px" align="center"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><strong>HTTP</strong>（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。</p><p>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 <strong>http://</strong> 打头的都是标准 HTTP 服务。</p><p>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><strong>HTTPS</strong>（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 <a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS</a> 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><p>HTTPS 默认工作在 TCP 协议 443 端口，它的工作流程一般如以下方式：</p><ol><li>TCP 三次同步握手</li><li>客户端验证服务器数字证书</li><li>DH 算法协商对称加密算法的密钥、hash 算法的密钥</li><li>SSL 安全加密隧道协商完成</li><li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</li></ol><h2 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h2><ul><li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 SSL 握手需要的 9 个包，所以一共是 12 个包。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ul><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><img src="/images/201908301110.png" width="800px" height="300px" align="center"><ul><li>第一次握手：客户端尝试连接服务器，向服务器发送 SYN 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认。</li><li>第二次握手：服务器接收客户端 SYN 包并确认（ack=j+1），同时向客户端发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul><h2 id="HTTPS-的工作原理"><a href="#HTTPS-的工作原理" class="headerlink" title="HTTPS 的工作原理"></a>HTTPS 的工作原理</h2><p>我们都知道 HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议。</p><img src="/images/201908301111.png" width="800px" height="300px" align="center"><p><strong>1、客户端发起 HTTPS 请求</strong></p><p>这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。</p><p><strong>2、服务端的配置</strong></p><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。</p><p>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p><p><strong>3、传送证书</strong></p><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><p><strong>4、客户端解析证书</strong></p><p>这部分工作是有客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p><p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p><p><strong>5、传送加密信息</strong></p><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><p><strong>6、服务端解密信息</strong></p><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><p><strong>7、传输加密后的信息</strong></p><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><p><strong>8、客户端解密信息</strong></p><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;原文链接：&lt;a href=&quot;https://www.runoob.com/w3cnote/http-vs-https.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP 与 HTTPS 的区别&lt;/a&gt;&lt;/p&gt;&lt;/blo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java关键字</title>
    <link href="https://muhouer.github.io/posts/b960f15/"/>
    <id>https://muhouer.github.io/posts/b960f15/</id>
    <published>2019-08-29T15:50:42.000Z</published>
    <updated>2019-08-29T16:01:24.369Z</updated>
    
    <content type="html"><![CDATA[<p>Java中各种关键字 transient、instanceof、volatile、final、static 。</p><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a><code>transient</code></h2><p>一个对象只要实现了 Serializable 接口，这个对象就可以被序列化，Java 的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了 Serializable 接口，这个类的所有属性和方法都会自动序列化。</p><p>然而在实际开发过程中，一个类中并不是所有属性都需要进行序列化，打个比方，如果一个用户有一些敏感信息(如密码，银行卡号等)，为了安全起见，不希望在网络操作(主要涉及到序列化操作，本地序列化缓存也适用)中被传输，这些信息对应的变量就可以加上 <code>transient</code> 关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p><p><strong>小结</strong>：</p><ol><li>一旦变量被 transient 修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>transient 关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被 transient 关键字修饰的。变量如果是用户自定义类变量，则该类需要实现 Serializable 接口。</li><li>被 transient 关键字修饰的变量不再能被序列化，一个静态变量不管是否被 transient 修饰，均不能被序列化(静态变量的值不是从序列化得到，而是从 JVM 中得到)。</li></ol><p><strong>注意</strong>：</p><ol><li>Java 中的关键字 <code>transient</code> 是用来标识一个属性不被序列化的，而 JPA 的 <code>@Transient</code> 注解是用来标识一个属性不被持久化到数据库的。</li><li>若实现的是 Externalizable 接口，则没有任何东西可以自动序列化，需要在 writeExternal 方法中进行手工指定所要序列化的变量，这与是否被 transient 修饰无关。</li></ol><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p>可以用来检查对象是否是特定类的实例。比如，当您有一个对超类或接口类型的对象的引用或参数，你想知道实际对象是否有其他类型（通常更具体）时，可以使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Number param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (param <span class="keyword">instanceof</span> Double) &#123;</span><br><span class="line">    System.out.println(<span class="string">"param is a Double"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">    System.out.println(<span class="string">"param is an Integer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (param <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">    <span class="comment">//subclasses of Number like Double etc. implement Comparable</span></span><br><span class="line">    <span class="comment">//other subclasses might not -&gt; you could pass Number instances that don't implement that interface</span></span><br><span class="line">    System.out.println(<span class="string">"param is comparable"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用 instanceof 之前不需要做 null 检查，假如 x 是 null，则 <code>x instanceof SomeClass</code> 就是 false。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h2><p>参考 <a href="/posts/ce0f712d/" title="volatile关键字">volatile关键字</a></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a><code>final</code></h2><p>在 Java 中，被 <code>final</code> 修饰代表不能被改变。</p><ol><li>final 修饰的类不能被继承，但是可以继承其他类。</li><li>inal 修饰的变量在定义时，必须赋值，并且只能赋值一次</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的引用型变量，变量的值是固定不变的。注意：对象的引用值和对象的属性值！</li></ol><p><strong>注意</strong>：使用 <code>final</code> 关键字它能会提高性能，但充其量只是略微提高。还是根据实际需要去使用。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h2><p>当我们通过 new 关键字去创建对象的时候，那么数据的存储空间才会被分配，类中的成员方法才能被对象所使用。有两种特殊的情况：</p><ol><li>我们通过 new 关键字创建的对象共享同一个资源，而不是说每个对象都拥有自己的数据，或者说根本就不需要去创建对象，这个资源和对象之间是没有关系的。</li><li>希望某个方法不与包含它的类的任何对象联系在一起。</li></ol><p>总结下来就是说：<strong>即使没有创建对象，也能使用属性和调用方法</strong>，static 目的就是在于解决这个问题。</p><ul><li>static 可以修饰变量、方法。</li><li>被 static 修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</li><li>在类被加载的时候，就会去加载被 static 修饰的部分。</li><li>被 static 修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li></ul><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>被 static 修饰的成员变量叫做静态变量，也叫做类变量，说明这个变量是属于这个类的，而不是属于是对象，没有被 static 修饰的成员变量叫做实例变量，说明这个变量是属于某个具体的对象的。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>被 static 修饰的方法也叫做静态方法，因为对于静态方法来说是不属于任何实例对象的，那么就是说在静态方法内部是不能使用 this 的，因为既然不属于任何对象，那么就更谈不上 this 了。</p><p>Java 嵌套类分为两种，静态嵌套类和非静态嵌套类，其中非静态嵌套类才是真正的内部类。</p><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a><code>enum</code></h2><p>参考 <a href="/posts/4502a76f/" title="枚举类型">枚举类型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中各种关键字 transient、instanceof、volatile、final、static 。&lt;/p&gt;&lt;h2 id=&quot;transient&quot;&gt;&lt;a href=&quot;#transient&quot; class=&quot;headerlink&quot; title=&quot;transient&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java语法糖</title>
    <link href="https://muhouer.github.io/posts/a0d19409/"/>
    <id>https://muhouer.github.io/posts/a0d19409/</id>
    <published>2019-08-28T17:22:00.000Z</published>
    <updated>2019-08-28T17:27:28.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>语法糖(Syntactic Sugar)，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法。这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p><blockquote><p>语法盐(Syntactic Salt)是指在计算机语言设计中，不容易产生不良代码的特性。可以为容易犯的语法错误加上的额外语法限制，比如类型检查。</p><p>语法糖精也叫语法糖浆，指的是未能让编程更加方便的附加语法，一说是设计失败的语法糖。这个语法又麻烦又没用。</p><p>语法海洛因，是指过于喜欢操作符重载，使得程序表面上紧凑。操作符重载就是把已经定义的、有一定功能的操作符进行重新定义，来完成更为细致具体的运算等功能。操作符重载可以将概括性的抽象操作符具体化，便于外部调用而无需知晓内部具体运算过程。</p></blockquote><p>我们所熟知的编程语言中几乎都有语法糖。很多人说 Java 是一个 “低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在 “Project Coin” 项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着 “高糖” 的方向发展。</p><h2 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h2><p>语法糖的存在主要是方便开发人员使用。但其实，Java 虚拟机并不支持这些语法糖，这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</p><p><code>com.sun.tools.javac.main.JavaCompiler</code> 的源码中，compile() 有一个步骤就是调用 desugar() ，这个方法就是负责解语法糖的。</p><p>Java 中最常用的语法糖主要有 switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、foreach、try-with-resource、Lambda表达式等</p><h3 id="switch-支持-String-与枚举"><a href="#switch-支持-String-与枚举" class="headerlink" title="switch 支持 String 与枚举"></a>switch 支持 String 与枚举</h3><p>进行<code>switch</code>的实际是哈希值，然后通过使用<code>equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 switch 或者使用纯整数常量，但这也不是很差。</p><p>参考 <a href="/posts/4a48cd1d/" title="String分析">String分析</a></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>不同的编译器对于泛型的处理方式是不同的。通常情况下，一个编译器处理泛型有两种方式：<strong>Code specialization</strong>和 <strong>Code sharing</strong>。C++ 和 C#是使用 Code specialization 的处理机制，而 Java 使用的是 Code sharing 的处理机制。</p><p>Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。</p><p>也就是说，对于 Java 虚拟机来说，他根本不认识 <code>Map&lt;String, String&gt; map</code>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</p><p>参考 <a href="/posts/4127871b/" title="Java泛型解析">Java泛型解析</a></p><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱。</p><p>反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</p><p>原始类型 byte、short、char、int、long、float、double 和 boolean 对应的封装类为 Byte、Short、Character、Integer、Long、Float、Double、Boolean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;        </span><br><span class="line">Integer n = i; <span class="comment">//  装箱：Integer n = Integer.valueOf(i); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">Integer i = <span class="number">10</span>; <span class="comment">// Integer i = Integer.valueOf(10); </span></span><br><span class="line"><span class="keyword">int</span> n = i; <span class="comment">//  拆箱：int n = i.intValue(); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法变长参数"><a href="#方法变长参数" class="headerlink" title="方法变长参数"></a>方法变长参数</h3><p>可变参数 (<code>variable arguments</code>) 是在 Java 1.5 中引入的一个特性，它允许一个方法把任意数量的值作为参数。</p><p>可变参数在被使用的时候：</p><ol><li>首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数。</li><li>然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>Java SE5 提供了一种新的类型-Java 的枚举类型，关键字<code>enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p><p>当我们使用<code>enmu</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code>final</code>类型的类继承<code>Enum</code>类，所以枚举类型不能被继承。</p><p>参考 <a href="/posts/4502a76f/" title="枚举类型">枚举类型</a></p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。</p><p>Outer.java 里面定义了一个内部类 Inner，一旦编译成功，就会生成两个完全不同的 .class 文件了，分别是 Outer.class 和 Outer$Inner.class。所以<strong>内部类的名字完全可以和它的外部类名字相同</strong>。</p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>C、C++ 等许多语言提供了预处理的功能，并通过预处理来实现条件编译。Java 并没有提供类似的预处理功能，但是 Java 也可以实现条件编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"block 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断言语句"><a href="#断言语句" class="headerlink" title="断言语句"></a>断言语句</h3><p>断言在编译过后被转化成了语句所处类中的一个 static final boolean 字段，并在类初始化阶段借助静态语句块完成其初始化。在程序执行过程中，直接根据该字段判断断言是否开启，来决定是否执行断言检查。</p><h3 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a>数值字面量</h3><h4 id="支持的数字字面量表示"><a href="#支持的数字字面量表示" class="headerlink" title="支持的数字字面量表示"></a>支持的数字字面量表示</h4><p>十进制：默认的。</p><p>八进制：整数之前加数字 0 来表示。</p><p>十六进制：整数之前加“0x”或“0X”来表示。</p><p>二进制：整数之前加“0b”或“0B”来表示。</p><h4 id="在数值字面量中使用下划线"><a href="#在数值字面量中使用下划线" class="headerlink" title="在数值字面量中使用下划线"></a>在数值字面量中使用下划线</h4><p>在 Java 7 中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1_500_000 </span><br><span class="line">5_6.3_4 </span><br><span class="line">89_3___1</span><br></pre></td></tr></table></figure><blockquote><p><strong>下划线只能出现在数字中间，前后必须是数字。</strong>所以<code>_100</code>、<code>0b_101</code>是不合法的，无法通过编译。<br>这样限制的动机就是可以降低实现的复杂度。有了这个限制，Java 编译器只需在扫描源代码的时候将所发现的数字中间的下划线直接删除就可以了。如果不添加这个限制，编译器需要进行语法分析才能做出判断。比如：<code>_100</code>,可能是一个整数字面量 100，也可能是一个变量名称。这就要求编译器的实现做出更复杂的改动。</p></blockquote><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ul><li>对有实现 Iterable 接口的对象采用 foreach 语法糖的话，编译器会将这个 for 关键字转化为对目标的迭代器使用。如果要想使自己自定义的类可以采用foreach语法糖就必须实现Iterable接口。</li><li>对于数组而言，其实就是转换为普通的遍历。</li><li>对于实现 RandomAccess 接口的集合比如 ArrayList，应当使用最普通的 for 循环而不是 foreach 循环来遍历。</li></ul><p>实现 RandomAccess 接口的类实例，假如是随机访问的，使用普通 for 循环效率将高于使用 foreach 循环；反过来，如果是顺序访问的，则使用 Iterator 会效率更高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterable(); </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">      iterator.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。编译之后会判断对象是否为 null，如果不是 null，则调用 close 函数进行资源回收。</p><p>所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。不同的是 java.io.Closable 要求实现者保证 close 函数可以被重复调用。而 java.lang.AutoCloseable 的close 函数则不要求是幂等的。</p><p>try-with-resources 声明在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>TODO 待补充</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>javap 是 JDK 自带的反汇编器，可以查看 java 编译器为我们生成的字节码。通过它，我们可以对照源代码和字节码，从而了解很多编译器内部的工作。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>  <code>javap [option] class</code><br>javap 命令用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。</p><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><p>-help 输出 javap 的帮助信息。<br>-l 输出行及局部变量表。<br>-b 确保与 JDK 1.1 javap 的向后兼容性。<br>-public 只显示 public 类及成员。<br>-protected 只显示 protected 和 public 类及成员。<br>-package 只显示包、protected 和 public 类及成员。这是缺省设置。<br>-private 显示所有类和成员。<br>-J[flag] 直接将 flag 传给运行时系统。<br>-s 输出内部类型签名。<br>-c 输出类中各方法的未解析的代码，即构成 Java 字节码的指令。<br>-verbose 输出堆栈大小、各方法的 locals 及 args 数,以及class文件的编译版本<br>-classpath[路径] 指定 javap 用来查找类的路径。如果设置了该选项，则它将覆盖缺省值或 CLASSPATH 环境变量。目录用冒号分隔。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语法糖&quot;&gt;&lt;a href=&quot;#语法糖&quot; class=&quot;headerlink&quot; title=&quot;语法糖&quot;&gt;&lt;/a&gt;语法糖&lt;/h2&gt;&lt;p&gt;语法糖(Syntactic Sugar)，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="语法糖" scheme="https://muhouer.github.io/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
  </entry>
  
  <entry>
    <title>编码方式杂记</title>
    <link href="https://muhouer.github.io/posts/d6bee64/"/>
    <id>https://muhouer.github.io/posts/d6bee64/</id>
    <published>2019-08-28T16:11:08.000Z</published>
    <updated>2019-08-28T16:14:00.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ASCII-Unicode-UTF-8"><a href="#ASCII-Unicode-UTF-8" class="headerlink" title="ASCII - Unicode - UTF-8"></a>ASCII - Unicode - UTF-8</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p><p>ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p><p>汉字使用的符号多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号，所以，中国制定了GB2312编码，用来把中文编进去。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode应运而生，Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。具体的符号对应表，可以查询<a href="http://www.unicode.org/" target="_blank" rel="noopener">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字对应表</a>。</p><p>不过，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。这就导致 Unicode 有多种存储方式，即有许多种不同的二进制格式，可以用来表示 Unicode。如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是<code>0</code>，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>互联网的普及，强烈要求出现一种统一的编码方式。<strong>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式</strong>。浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器。很多网页的源码上会有类似 <code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的 UTF-8 编码。</p><p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>UTF-8 的编码规则很简单，只有二条：</p><ol><li><p>对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p></li><li><p>对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围      |        UTF-8编码方式</span><br><span class="line">(十六进制)           |              （二进制）</span><br><span class="line">--------------------+------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p>例如：<br><img src="/images/201908281058.png" width="800px" height="500px" align="center"></p><h2 id="UTF-8、UTF-16、UTF-32区别"><a href="#UTF-8、UTF-16、UTF-32区别" class="headerlink" title="UTF-8、UTF-16、UTF-32区别"></a>UTF-8、UTF-16、UTF-32区别</h2><p>UTF 意思是 Unicode 转换格式(Unicode Transform Format)， UTF-8、UTF-16、UTF-32 是为了在内存中存储字符而对 Unicode 字符编号进行编码。它们都是 Unicode 的实现方式，其中 <strong>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式</strong>。<strong>UTF-16(字符用 2 个字节或 4 个字节表示)</strong> 和 <strong>UTF-32(字符用 4 个字节表示)</strong>，不过在互联网上基本不用。</p><p>UTF-16 使用 2 或 4 个字节进行存储。对于 Unicode 编号范围在 0~FFFF 之间的字符，统一用两个字节存储，无需字符转换，直接存储 Unicode 编号。对于 Unicode 字符编号在 10000-10FFFF 之间的字符，UTF16 用 4 个字节存储。</p><p>UTF-32 用固定长度的字节存储字符编码，不管 Unicode 字符编号需要几个字节，全部都用 4 个字节存储，直接存储 Unicode 编号。无需经过字符编号向字符编码的转换步骤，提高效率，用空间换时间。</p><h2 id="GB2312、GBK、GB18030、GB13000之间的区别"><a href="#GB2312、GBK、GB18030、GB13000之间的区别" class="headerlink" title="GB2312、GBK、GB18030、GB13000之间的区别"></a>GB2312、GBK、GB18030、GB13000之间的区别</h2><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p><strong>GB2312 或 GB2312-80 是中国国家标准简体中文字符集</strong>，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持 GB2312。<br>，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。</p><ul><li>GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。</li><li>对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。</li></ul><p><strong>GB2312对任意一个图形字符都采用两个字节表示</strong>，并对所收汉字进行了“分区”处理，每区含有94个汉字／符号，分别对应第一字节和第二字节。这种表示方式也称为区位码。</p><ul><li>01-09区为特殊符号。</li><li>16-55区为一级汉字，按拼音排序。</li><li>56-87区为二级汉字，按部首／笔画排序。</li></ul><p>10-15区及88-94区则未有编码。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p><strong>GBK</strong>即，为汉语拼音 Kuo Zhan（扩展）中“扩”字的声母。英文全称Chinese Internal Code Specification。</p><ul><li>GB2312中的全部汉字、非汉字符号。</li><li>BIG5中的全部汉字。</li><li>与ISO 10646相应的国家标准GB13000中的其它CJK汉字，以上合计20902个汉字。</li><li>其它汉字、部首、符号，共计984个。</li></ul><p>GBK向下与GB2312 完全兼容，向上支持ISO 10646国际标准，在前者向后者过渡过程中起到的承上启下的作用。</p><p><strong>GBK 采用双字节表示</strong>，总体编码范围为8140-FEFE之间，首字节在81-FE之间，尾字节在40-FE之间，剔除XX7F一条线。GBK编码区分三部分：</p><ul><li><p>汉字区</p><ul><li>GBK/2：OXBOA1-F7FE，收录GB2312汉字6763个，按原序排列。</li><li>GBK/3：OX8140-AOFE，收录CJK汉字6080个。</li><li>GBK/4：OXAA40-FEAO，收录CJK汉字和增补的汉字8160个。</li></ul></li><li><p>图形符号区</p><ul><li>GBK/1：OXA1A1-A9FE，除GB2312的符号外，还增补了其它符号。</li><li>GBK/5：OXA840-A9AO，扩除非汉字区。</li></ul></li><li><p>用户自定义区</p><ul><li>GBK区域中的空白区，用户可以自己定义字符。</li></ul></li></ul><p>GBK 最初是由微软对 GB2312 的扩展，也就是CP936字码表 (Code Page 936)的扩展（原来的CP936和GB 2312-80一模一样），最初出现于Windows 95简体中文版中，由于Windows产品的流行和在大陆广泛被使用，中华人民共和国国家有关部门将其作为技术规范。<strong>注意 GBK 并非国家正式标准，只是国家技术监督局标准化司、电子工业部科技与质量监督司发布的“技术规范指导性文件”。</strong>虽然 GBK 收录了所有 Unicode 1.1 及 GB 13000.1-93 之中的汉字，但是编码方式与 Unicode 1.1 及 GB 13000.1-93 不同。仅仅是 GB2312 到 GB13000.1-93 之间的过渡方案。GBK 收录了 21886 个符号，它分为汉字区和图形符号区。汉字区包括 21003 个字符。</p><p>GBK 作为对 GB2312 的扩展，在现在的 Windows 系统中仍然使用代码页 CP936 表示，但是同样的 936 的代码页跟一开始的 936 的代码页只支持 GB2312 编码不同，现在的 936 代码页支持 GBK 的编码，GBK 同时也向下兼容 GB2312 编码。</p><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p><strong>GB18030</strong>，全称是中华人民共和国现时最新的内码字集，是GB18030-2000《信息技术信息交换用汉字编码字符集基本集的扩充》的修订版。</p><p><strong>GB18030</strong> 与 <strong>GB2312-1980</strong> 完全兼容，与 GBK 基本兼容，支持 GB13000 及 Unicode 的全部统一汉字，共收录汉字 70244 个。</p><ul><li>与 UTF-8 相同，采用多字节编码，每个字可以由1个、2个或4个字节组成。</li><li>编码空间庞大，最多可定义161万个字符。</li><li>支持中国国内少数民族的文字，不需要动用造字区。</li><li>汉字收录范围包含繁体汉字以及日韩汉字</li></ul><p><strong>GB18030 编码是一二四字节变长编码。</strong></p><ul><li>单字节，其值从0到0x7F，与 ASCII 编码兼容。</li><li>双字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x40到0xFE（不包括0x7F），与 GBK标准基本兼容。</li><li>四字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节从0x81到0xFE，第四个字节从0x30到0x39。</li></ul><p>2000 年的 GB18030 取代了 GBK1.0 的正式国家标准。该标准收录了 27484 个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的 PC 平台必须支持 GB18030，对嵌入式产品暂不作要求。所以手机、MP3 一般只支持 GB2312。</p><p>GB18030 在 Windows 中的代码页是 CP54936。</p><h3 id="GB13000"><a href="#GB13000" class="headerlink" title="GB13000"></a>GB13000</h3><p>GB13000 等同于国际标准的《通用多八位编码字符集 (UCS)》 ISO10646.1，就是等同于 Unicode 的标准，代码页等等的都使用 UTF 的一套标准。</p><p>从 ASCII、GB2312、GBK 到 GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为 0。按照程序员的称呼，GB2312、GBK 到 GB18030 都属于双字节字符集 (DBCS)。</p><h2 id="URL编解码"><a href="#URL编解码" class="headerlink" title="URL编解码"></a>URL编解码</h2><p>一般来说，网页URL只能使用英文、数字、还有一些特定的字符。根据网络标准<a href="http://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">RFC 1738</a>做了硬性规定：</p><blockquote><p>只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!*’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。</p></blockquote><p>如果 URL中包括中文等字符，就必须经过编码后使用，否则传给服务器的 request URL 就会包含乱码，服务器无法正确识别。因为RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定，所以导致“URL编码”领域非常混乱。想要了解浏览器多种情况下的编码处理，可以参考阮一峰大神的<a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">关于URL编码</a>。</p><ol><li><strong>网址路径的编码，用的是utf-8编码。</strong></li><li><strong>查询字符串的编码，用的是操作系统的默认编码。</strong></li><li><strong>GET和POST方法的编码，用的是网页的编码。</strong></li><li><strong>在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码。</strong></li></ol><p>不同的操作系统、不同的浏览器、不同的网页字符集，将导致完全不同的编码结果，为了保证客户端只用一种编码方法向服务器发出请求，可以使用 Javascript 先对 URL 编码，然后再向服务器提交，不要给浏览器插手的机会。</p><p>编码方法有三种：<code>escape(url)</code>、<code>encodeURL(url)</code>、<code>encodeURLComponent(url)</code></p><p>解码方法也有三种: <code>unescape(url)</code>、<code>decodeURL(url)</code>、<code>decodeURLComponent(url)</code></p><table><thead><tr><th>方法</th><th>规则</th><th>特点</th></tr></thead><tbody><tr><td>escape、unescape</td><td>除了ASCII字母、数字、标点符号”@ * _ + - . /“以外，对其他所有字符进行编码</td><td>它的作用是返回一个字符的 Unicode 编码值。现在已经不提倡使用这种方法了，它不能直接运用与 URL 编码。</td></tr><tr><td>encodeURI（编码）decodeURI（解码）</td><td>除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码</td><td>encodeURI() 是 Javascript 中真正用来对 URL 编码的函数，它着眼于对整个URL 进行编码</td></tr><tr><td>encodeURIComponent（编码）decodeURIComponent解码）</td><td>在encodeURI()中不被编码的符号”; / ? : @ &amp; = + $ , #”，在encodeURIComponent()中统统会被编码</td><td>与 encodeURI() 的区别是，它用于对 URL 的组成部分进行个别编码，而不用于对整个URL进行编码。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> url = <span class="string">"https://www.zhihu.com/question/342936488/answer/804030108"</span>;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; <span class="built_in">escape</span>(url)</span><br><span class="line"><span class="string">"https%3A//www.zhihu.com/question/342936488/answer/804030108"</span></span><br><span class="line">&gt; <span class="built_in">encodeURI</span>(url)</span><br><span class="line"><span class="string">"https://www.zhihu.com/question/342936488/answer/804030108"</span></span><br><span class="line">&gt; <span class="built_in">encodeURIComponent</span>(url)</span><br><span class="line"><span class="string">"https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F342936488%2Fanswer%2F804030108"</span></span><br></pre></td></tr></table></figure><h2 id="Big-Endian-和-Little-Endian"><a href="#Big-Endian-和-Little-Endian" class="headerlink" title="Big Endian 和 Little Endian"></a>Big Endian 和 Little Endian</h2><ul><li><strong>Little-endian：将低序字节存储在起始地址（低位编址）</strong></li><li><strong>Big-endian：将高序字节存储在起始地址（高位编址）</strong></li></ul><p>例如，如果我们将 0x1234abcd 写入到以 0x0000 开始的内存中，则结果为：</p><table><thead><tr><th>address</th><th>big-endian</th><th>little-endian</th></tr></thead><tbody><tr><td>0x0000</td><td>0x12</td><td>0xcd</td></tr><tr><td>0x0001</td><td>0x34</td><td>0xab</td></tr><tr><td>0x0002</td><td>0xab</td><td>0x34</td></tr><tr><td>0x0003</td><td>0xcd</td><td>0x12</td></tr></tbody></table><p>对于字节序列的存储格式，目前有两大阵营，那就是 Motorola 的 PowerPC 系列 CPU 和 Intel 的 x86 系列 CPU。PowerPC 系列采用 big endian 方式存储数据，而 x86 系列则采用 little endian 方式存储数据。</p><p>所有网络协议也都是采用 big endian 的方式来传输数据的。所以有时我们也会把 big endian 方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。</p><p>目前应该 little endian 是主流，因为在数据类型转换的时候（尤其是指针转换）不用考虑地址问题。</p><p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p><p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用 big endian 方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用 little endian 方式。</p><h2 id="如何解决乱码问题"><a href="#如何解决乱码问题" class="headerlink" title="如何解决乱码问题"></a>如何解决乱码问题</h2><p>乱码本质上都是由于<strong>字符串原本的编码格式与读取时解析用的编码格式不一致导致的</strong>。</p><h3 id="网页乱码问题"><a href="#网页乱码问题" class="headerlink" title="网页乱码问题"></a>网页乱码问题</h3><ul><li>服务器返回的响应头 Content-Type 指明字符编码。</li><li>网页内使用 meta http-equiv 标签指定字符编码。</li><li>网页文件本身存储时使用的字符编码和网页声明的字符编码一致。</li></ul><h3 id="Java代码乱码问题"><a href="#Java代码乱码问题" class="headerlink" title="Java代码乱码问题"></a>Java代码乱码问题</h3><ul><li><p>使用 getBytes() 方法指定编码。</p></li><li><p>使用字节流时指定编码。</p></li><li><p>使用 new String() 时指定编码。</p></li><li><p>使用 HttpClient post请求时指定编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求实体</span></span><br><span class="line">HttpEntity reqEntity = <span class="keyword">new</span> ByteArrayEntity(reqStr.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">httpPost.setEntity(reqEntity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求实体</span></span><br><span class="line">StringEntity reqEntity = <span class="keyword">new</span> StringEntity(reqStr, Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">httpPost.setEntity(reqEntity);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ASCII-Unicode-UTF-8&quot;&gt;&lt;a href=&quot;#ASCII-Unicode-UTF-8&quot; class=&quot;headerlink&quot; title=&quot;ASCII - Unicode - UTF-8&quot;&gt;&lt;/a&gt;ASCII - Unicode - UTF-8&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java中的基本类型</title>
    <link href="https://muhouer.github.io/posts/3f6a1294/"/>
    <id>https://muhouer.github.io/posts/3f6a1294/</id>
    <published>2019-08-27T16:06:49.000Z</published>
    <updated>2019-08-27T16:11:35.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>Java 中有 8 种基本数据类型，分为三大类。</p><ol><li><p>字符型：<code>char</code></p></li><li><p>布尔型：<code>boolean</code></p></li><li><p>数值型：</p><ol><li>整型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>浮点型：<code>float</code>、<code>double</code></li></ol></li></ol><p>String 不是基本数据类型，是引用类型。</p><h2 id="整型中byte、short、int、long的取值范围"><a href="#整型中byte、short、int、long的取值范围" class="headerlink" title="整型中byte、short、int、long的取值范围"></a>整型中byte、short、int、long的取值范围</h2><p>Java 中的整型主要包含 byte、short、int 和 long 这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。</p><ul><li>byte：byte 用 1 个字节来存储，范围为 -128(-2^7) 到 127(2^7-1)，在变量初始化的时候，byte类型的默认值为 0。</li><li>short：short 用 2 个字节存储，范围为 -32768 (-2^15) 到 32767 (2^15-1)，在变量初始化的时候，short类型的默认值为0，一般情况下，因为 Java 本身转型的原因，可以直接写为 0。</li><li>int：int 用 4 个字节存储，范围为 -2147483648 (-2^31) 到 2147483647 (2^31-1)，在变量初始化的时候，int类型的默认值为 0。</li><li>long：long 用 8 个字节存储，范围为 -9223372036854775808 (-2^63) 到 9223372036854775807 (2^63-1)，在变量初始化的时候，long 类型的默认值为 0L 或 0l，也可直接写为 0。</li></ul><p>整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。</p><p>溢出的时候并不会抛异常，也没有任何提示。所以，在程序中，使用同类型的数据进行运算的时候，一定要注意数据溢出的问题。</p><h2 id="什么是浮点型"><a href="#什么是浮点型" class="headerlink" title="什么是浮点型"></a>什么是浮点型</h2><p>在计算机科学中，浮点是一种对于实数的近似值数值表现法，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（floating-point number）。</p><p>计算机使用浮点数运算的主因，在于电脑使用二进位制的运算。例如：4÷2=2，4的二进制表示为100、2的二进制表示为010，在二进制中，相当于退一位数(100 -&gt; 010)。</p><p>1 的二进制是 01，1.0/2=0.5，那么，0.5 的二进制表示应该为(0.1)，以此类推，0.25的二进制表示为0.01，所以，并不是说所有的十进制小数都能准确的用二进制表示出来，如 0.1，因此只能使用近似值的方式表达。</p><p>也就是说，十进制的小数在计算机中是由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到的，这种表示方法类似于基数为 10 的科学计数法。</p><p>一个浮点数a由两个数m和e来表示：a = m × be。在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd…ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1）。如果m的第一位是非0整数，m称作正规化的。有一些描述使用一个单独的符号位（s 代表+或者-）来表示正负，这样m必须是正的。e是指数。</p><p>位(bit)是衡量浮点数所需存储空间的单位，通常为32位或64位，分别被叫作单精度和双精度。</p><p>单精度浮点数在计算机存储器中占用 4 个字节(32 bits)，利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。</p><p>比起单精度浮点数，双精度浮点数(double)使用 8 个字节(64 bits) 来存储一个浮点数。</p><p><strong>注意</strong>：由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。</p><p><strong>建议使用BigDecimal或者Long（单位为分）来表示金额。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;p&gt;Java 中有 8 种基本数据类型，分为三大类。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;字符型：&lt;code&gt;char&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么Java中byte类型的取值范围为-128~127?</title>
    <link href="https://muhouer.github.io/posts/ca021682/"/>
    <id>https://muhouer.github.io/posts/ca021682/</id>
    <published>2019-08-27T15:45:14.000Z</published>
    <updated>2019-08-27T15:52:45.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：探路的淮–Ontheway<br>原文链接：<a href="https://blog.csdn.net/qq_23418393/article/details/57421688" target="_blank" rel="noopener">https://blog.csdn.net/qq_23418393/article/details/57421688</a></p></blockquote><p>在学习 Java 基础语法的时候，初学者的我们可能都会有这么一个疑问为什么 byte 类型的取值范围为什么是 -128 ~ 127 而不是 -127 ~ 127。<code>01111111</code> 表示最大的数值：127，因为第一位是符号位，所以 <code>11111111</code> 应该是最小的数值：-127，不是这样才对？</p><p>在解释这个问题之前我们需要了解几个概念：机器数、真值、原码、反码、补码</p><h2 id="机器数、真值、原码、反码、补码"><a href="#机器数、真值、原码、反码、补码" class="headerlink" title="机器数、真值、原码、反码、补码"></a>机器数、真值、原码、反码、补码</h2><h3 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h3><p>一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为 0，负数为 1。</p><p>比如：十进制中的数 +3 ，计算机字长为 8 位，转换成二进制就是 <code>00000011</code>。如果是 -3 ，就是 <code>10000011</code> 。那么，这里的 <code>00000011</code> 和 <code>10000011</code> 就是机器数。</p><h3 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h3><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 <code>10000011</code>，其最高位 1代表负，其真正数值是 -3 而不是形式值 131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><p>​ 例：0000 0001 的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><p>​ [+1]原 = 0000 0001<br>​ [-1]原 = 1000 0001<br>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]<br>即[-127 , 127]。原码是人脑最容易理解和计算的表示方式.</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>反码的表示方法是：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p><p>​ [+1] = [00000001]原 = [00000001]反<br>​ [-1] = [10000001]原 = [11111110]反</p><p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算。</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码的表示方法是:</p><ol><li><p>正数的补码就是其本身。</p></li><li><p>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 +1。(即在反码的基础上 +1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补<br>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p></li></ol><p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。</p><h2 id="为什么-byte-类型的取值范围为-128-127？"><a href="#为什么-byte-类型的取值范围为-128-127？" class="headerlink" title="为什么 byte 类型的取值范围为 -128~127？"></a>为什么 byte 类型的取值范围为 -128~127？</h2><h3 id="为何计算机内部不使用原码表示一个数？"><a href="#为何计算机内部不使用原码表示一个数？" class="headerlink" title="为何计算机内部不使用原码表示一个数？"></a>为何计算机内部不使用原码表示一个数？</h3><p>现在我们知道了计算机可以有三种编码方式表示一个数，对于正数因为三种编码方式的结果都相同：</p><p>　　[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>但是对于负数:</p><p>　　[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>可见原码，反码和补码是完全不同的。 既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？</p><p>首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即: <code>1-1 = 1 + (-1) = 0</code> ，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。</p><p>于是人们开始探索 将符号位参与运算，并且只保留加法的方法。首先来看原码：</p><p>　　计算十进制的表达式: 1-1=0</p><p>　　1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p><p>如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。</p><h3 id="反码的诞生"><a href="#反码的诞生" class="headerlink" title="反码的诞生"></a>反码的诞生</h3><p>为了解决原码做减法的问题，出现了反码：</p><p>　　计算十进制的表达式: 1-1=0</p><p>　　1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p><p>发现用反码计算减法，结果的真值部分是正确的。而唯一的问题其实就出现在”0”这个特殊的数值上。虽然人们理解上 +0 和 -0 是一样的，但是 0 带符号是没有任何意义的。而且会有 [0000 0000]原 和 [1000 0000]原 两个编码表示 0。</p><h3 id="补码的诞生"><a href="#补码的诞生" class="headerlink" title="补码的诞生"></a>补码的诞生</h3><p>补码的出现，解决了 0 的符号以及两个编码的问题：</p><p>　　1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 =[0000 0001]反 + [1111 1110]反= [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p><p>这样0用 [0000 0000] 表示，而以前出现问题的 -0 则不存在了。而且可以用 [1000 0000] 表示-128：</p><p>　　(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p><p>-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补 就是 -128。但是注意因为实际上是使用以前的 -0 的补码来表示 -128, 所以 -128 并没有原码和反码表示。(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)，使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，<strong>使用原码或反码表示的范围为 -127<del>+127， 而使用补码表示的范围为 -128</del>127。</strong></p><p>因为机器使用补码，所以对于编程中常用到的 32 位 int 类型, 可以表示范围是：-2^31~2^31-1 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?</p><p>可以参考：<a href="https://www.cnblogs.com/zhengfengyun/p/5090601.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengfengyun/p/5090601.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者：探路的淮–Ontheway&lt;br&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/qq_23418393/article/details/57421688&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java泛型解析</title>
    <link href="https://muhouer.github.io/posts/4127871b/"/>
    <id>https://muhouer.github.io/posts/4127871b/</id>
    <published>2019-08-26T16:27:00.000Z</published>
    <updated>2019-08-26T16:28:49.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型是什么"><a href="#泛型是什么" class="headerlink" title="泛型是什么"></a>泛型是什么</h2><blockquote><p>泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。</p></blockquote><p>泛型的英文是 generics，generic 的意思是通用,而翻译成中文，泛应该意为广泛，型是类型。所以泛型就是能广泛适用的类型。<strong>但泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。</strong></p><p>Object 是所有类的根类，任何类的对象都可以设置给该 Object 引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T value;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的定义和使用"><a href="#泛型的定义和使用" class="headerlink" title="泛型的定义和使用"></a>泛型的定义和使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>如果一个类被 <code>&lt;T&gt;</code>的形式定义，那么它就被称为是泛型类。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号 &lt;&gt;中的 T 被称作是类型参数，用于指代任何类型。其中T只是一种习惯写法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T field1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，泛型类不至接受一个类型参数，它还可以这样接受多个类型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiType</span>&lt;<span class="title">E</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">E value1;</span><br><span class="line">T value2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getValue1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getValue2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如：</p><ol><li><p>E ——代表 Element (在集合中使用，因为集合中存放的是元素)，或者 Exception 异常的意思</p></li><li><p>T ——代表 Type（一般的任何 Java 类）</p></li><li><p>K——代表 Key（键）</p></li><li><p>V ——代表 Value（值），通常与 K 一起配合使用</p></li><li><p>N——代表 Number（数值类型）</p></li><li><p>？——表示不确定的java类型（无限制通配符类型）</p></li><li><p>S、U、V——代表 2nd、3rd、4th Subtype</p></li></ol><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法与泛型类稍有不同的地方是，类型参数也就是尖括号那一部分是写在返回值前面的。<code>&lt;T&gt;</code>中的 T 被称为类型参数，而方法中的 T 被称为参数化类型，它不是运行时真正的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">testMethodWithReturn</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型方法始终以自己定义的类型参数为准</strong>。即泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的。例如：泛型类的实际类型参数是 String，而传递给泛型方法的类型参数是 Integer，两者不想干。</p><p>但是，为了避免混淆，如果在一个泛型类中存在泛型方法，那么两者的类型参数最好不要同名。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口和泛型类类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限定通配符和非限定通配符"><a href="#限定通配符和非限定通配符" class="headerlink" title="限定通配符和非限定通配符"></a>限定通配符和非限定通配符</h2><p><strong>通配符的出现是为了指定泛型中的类型范围</strong>。</p><p>通配符有 3 种形式。</p><ol><li><code>&lt;?&gt;</code>被称作非限定通配符。</li><li><code>&lt;? extends T&gt;</code>被称作有上界通配符。</li><li><code>&lt;? super T&gt;</code>被称作有下界通配符。</li></ol><p>非限定通配符经常与容器类配合使用，它其中的 ? 其实代表的是未知类型，所以涉及到 ? 时的操作，一定与具体类型无关，类型是未知的。所以，你只能调用使用非限定通配符类中与类型无关的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWildCards</span><span class="params">(Collection&lt;?&gt; collection)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 只能调用 Collection 中与类型无关的方法。</span></span><br><span class="line">  <span class="comment">// 当你调用 add() 方法时，编译会失败。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限定通配符包括两种：</p><ol><li><code>&lt;？extends T&gt;</code> 表示类型的上界，即类型必须为T类型或者T子类。</li><li><code>&lt;？super T&gt;</code> 表示类型的下界，即类型必须为T类型或者T的父类。</li></ol><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>泛型是 Java 1.5 版本才引进的概念，在这之前是没有泛型的概念的，但显然，泛型代码能够很好地和之前版本的代码很好地兼容。</p><p>这是因为，泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</p><p>通俗地讲，泛型类和普通类在 java 虚拟机内是没有什么特别的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">System.out.println(strList.getClass() == intList.getClass()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 <code>&lt;T&gt;</code>则会被转译成普通的 Object 类型，如果指定了上限如 <code>&lt;T extends String&gt;</code>则类型参数就被替换成类型上限。</p><blockquote><p>原始类型 List 和带参数类型之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查。你可以把任何带参数的类型传递给原始类型 List，但却不能把 List 传递给接受 List 的方法，因为会产生编译错误。</p></blockquote><p>类型擦除，它会抹掉很多继承相关的特性，这是它带来的局限性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">integers.add(<span class="number">9</span>);</span><br><span class="line">integers.add(<span class="string">"freya"</span>); <span class="comment">// 由于泛型的限制，编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过基于对类型擦除的了解，利用反射，我们可以绕过这个限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">    integers.add(<span class="number">9</span>);</span><br><span class="line">    <span class="comment">// integers.add("freya");</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Method method = integers.getClass().getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        method.invoke(integers, <span class="string">"freya"</span>);</span><br><span class="line">        method.invoke(integers, <span class="number">10.11f</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(integers); <span class="comment">// [9, freya, 10.11]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>泛型类或者泛型方法中，不接受 8 种基本数据类型，需要使用它们对应的包装类。</li><li>Java 不能创建具体类型的泛型数组。这是因为所有的类型信息都被擦除，程序也无法分辨一个数组中的元素类型具体是哪种类型。</li><li>非限定通配符涉及的操作都基本上与类型无关，因此 JVM 不需要针对它对类型作判断，只提供了数组中的元素因为通配符原因，它只能读，不能写。</li><li>如果可以使用泛型的地方，尽量使用泛型。因为它抽离了数据类型与代码逻辑，本意是提高程序代码的简洁性和可读性，并提供可能的编译时类型转换安全检测功能。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;泛型是什么&quot;&gt;&lt;a href=&quot;#泛型是什么&quot; class=&quot;headerlink&quot; title=&quot;泛型是什么&quot;&gt;&lt;/a&gt;泛型是什么&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="泛型" scheme="https://muhouer.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>拾句-念念不忘</title>
    <link href="https://muhouer.github.io/posts/e5f2c01c/"/>
    <id>https://muhouer.github.io/posts/e5f2c01c/</id>
    <published>2019-08-26T14:52:53.000Z</published>
    <updated>2019-09-01T01:54:08.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="人生除了死亡，其他都是擦伤。"><a href="#人生除了死亡，其他都是擦伤。" class="headerlink" title="人生除了死亡，其他都是擦伤。"></a>人生除了死亡，其他都是擦伤。</h3><blockquote><p><strong>你是在拜佛，还是在拜自己的欲望？</strong><br>正义的反面不是邪恶，正义的反面是别的正义。<br><strong>不知道发⽣了什么，是这个世界；不知道在做什么，是⾃⼰。</strong><br>我的任性是理所当然，别人的任性是不可原谅。<br>如果一切祈祷都为了满足私欲，那所有的美好希望都是一种对别人的诅咒。<br><strong>让花谢的是⻛⾬/让花开的也是⻛⾬/但没了⻛⾬/花不会开也不会落</strong><br>并不是所有⼈都能轻盈地度过这⼀⽣，有些⼈，光是活着就已经竭尽全⼒。<br>我们终其⼀⽣都想成为那个喜欢的⼈，殊不知，⼈⼈都有光彩和阴影，只是有些⼈已经学会了欣赏⾃⼰，并且接纳了阴影。<br>没有⼀朵花，从⼀开始就是花。<br><strong>世界再⼤，不过是⼈与⼈之间的距离。</strong><br>所谓孩⼦，⼤多是在⽗⺟看不⻅的地⽅成⻓起来的。<br>当⼥⼉捡起落叶/我看到⽣命与季节/交汇的点——⼥⼉与秋天》理正道<br>如果房⼦没有窗户，⻔会望着谁。——《⻛适应着这个季节》晚⼭<br>我的身体在寂静中安置⾃⼰，时刻准备着成为灵魂的故乡——《回乡偶书》⾼寒<br><strong>纸质信回信要等⼀个⽉， 电⼦邮件回信等⼀周， LINE回复⼀⼩时。 不⽤等待的⼈⽣真忙碌啊。</strong><br>你认为“谢谢”的反义词是什么？<br>众⽣喧哗归⼀处，万物静默为⼀听。<br>形形⾊⾊的⼈⽣，五味杂陈的故事，百转千回，令⼈回味。<br>不必太纠结于当下，也不必太忧虑未来，当你经历过一些事情的时候，眼前的风景已经和从前不一样了。<br>不解释就弄不懂的事，就意味着怎样解释也弄不懂。——《1Q84》<br><strong>总有一天，你会离开这个世界。所以这辈子要活得更加精彩。</strong></p></blockquote><h3 id="我能承受任何痛苦，只要这种痛苦有意义。"><a href="#我能承受任何痛苦，只要这种痛苦有意义。" class="headerlink" title="我能承受任何痛苦，只要这种痛苦有意义。"></a>我能承受任何痛苦，只要这种痛苦有意义。</h3><blockquote><p><strong>遇到真正喜欢的人，你才发现之前定的标准都是空话。</strong><br>天裂了，去缝起。<br><strong>欲望本身没有对错善恶，只有当与规则碰撞，人对欲望的态度才显示出丑陋或者善良的一面。</strong><br>要有耐性，不要操之过急。越是心平气和，越有成绩。时时刻刻要承认自己是笨伯，不怕做笨功夫，那就不会期待太切，稍不进步就慌乱了。——傅雷<br>北美地区有一种蝉叫做“十七年蝉”，这种蝉从幼卵变成若虫以后将钻入地下蛰伏，在阴暗的泥土与恶劣的环境中度过17年的时间，在隐忍与煎熬中经历漫长的成长历程。在这17年当中，它们早就被人遗忘，只与孤独相伴，每次蜕变的痛苦只有自己最为清楚。<br><strong>目的虽有，却无路可循；我们称之为路的，无非是踌躇。</strong>——卡夫卡 《误入世界》<br>我有一壶酒，可以慰风尘。尽倾江海里，赠饮天下人。<br>花全开了，开得到处都是，后来就很孤单。——顾城《麦田》<br>诚觉世事尽可原谅，但不知去原谅谁。——木心<br><strong>凡畅言雅俗共赏者，结果都落得俗不可耐。</strong>——木心<br>迷失的人迷失了，相逢的人会再相逢。<br>你问人问题，她若答非所问，便已是答了，毋需再问。——木心<br>怕什么真理无穷，进一寸有一寸的欢喜。——胡适</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;人生除了死亡，其他都是擦伤。&quot;&gt;&lt;a href=&quot;#人生除了死亡，其他都是擦伤。&quot; class=&quot;headerlink&quot; title=&quot;人生除了死亡，其他都是擦伤。&quot;&gt;&lt;/a&gt;人生除了死亡，其他都是擦伤。&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;你是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于减肥</title>
    <link href="https://muhouer.github.io/posts/c8dcfc3f/"/>
    <id>https://muhouer.github.io/posts/c8dcfc3f/</id>
    <published>2019-08-25T10:32:00.000Z</published>
    <updated>2019-08-25T11:10:11.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者: 三木水<br>原文: <a href="https://mp.weixin.qq.com/s/Bgc2DbHBq_tRuMbTukaj9w" target="_blank" rel="noopener">求求珍珠奶茶放过我吧</a></p></blockquote><h2 id="减肥和毅力，没有半毛钱关系。"><a href="#减肥和毅力，没有半毛钱关系。" class="headerlink" title="减肥和毅力，没有半毛钱关系。"></a>减肥和毅力，没有半毛钱关系。</h2><p>很多人在减肥中，遇到的最大的障碍就是：管不住自己的嘴。总是忍不住要多吃，而且，一吃就停不下来。</p><p>就像我的一位女性来访者，30+，极度自律。但是，在减肥这件事上，她却遭遇了滑铁卢。她最大的困扰就是：吃。</p><p>像我一样，吃之前很理性，吃的时候管不住，事后很懊恼，伴随极度的焦虑和自责。有的时候，她还会把这份焦虑转移到伴侣身上，对伴侣发脾气。</p><p>当然，这只不过是对自己无力的这部分的一种向外投射。她说，她用极大的毅力来控制自己不要多吃。为了不吃晚饭，晚餐时，她是不上桌的：家人吃晚饭，她就在旁边找个地方啃个苹果。</p><p>即便这样，“吃”和“不吃”就好像在打游击战一样，在每一个毅力稍稍缺席的地方，“吃”的欲望就会铺天盖地地袭来。吃完之后，又陷入了懊恼、自责和极度的焦虑当中。</p><p>你也许就要问了，不靠毅力控制，那靠什么？</p><p>在提出这个问题的时候，你想的还是控制。</p><p>在回答这个问题之前，我们不妨换个角度，我们为什么对“吃”如此痴迷？那是因为，“吃”给我们带来了很大的快感。</p><p>我的很多痴迷于“吃”的朋友，曾这么跟我说：在吃的时候，让他们感觉到了无比的满足，就好像在天堂，如果不让他们“吃吃吃”一段时间，他们觉得，人生的意义都没有了。</p><p>“人生的意义”“生活的乐趣”“活着的快感”都没有了，这是多么严重的问题。在这样的情况下，你可曾看到，控制“吃”的背后，我们在尝试控制什么。控制“吃”，就是在和自己的人性做对，而和人性做对，这几乎是一场必输的游戏。</p><p>这就是为什么我们这么努力控制，却毫无进展的原因。</p><p>因为，“吃”，这是一件我们控制不了的事情。</p><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><ol><li><strong>想要减肥，不要节食，先满足吃欲。</strong>(少食多餐)</li><li><strong>别着急，慢慢吃。</strong>每一个食物，都是巨大的恩赐，值得好好品味，不可辜负。</li><li>每天或者每周安排一顿饭，放肆的吃。<strong>总有一个时空，我可以“为所欲为”。</strong></li></ol><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>这让我想起了《<a href="https://book.douban.com/subject/27052052/" target="_blank" rel="noopener">人体的故事：进化、健康与疾病</a>》里面的一个观点：</p><blockquote><p>如果他们开始节食或增加运动量，这就意味着他们摄入的热量少于消耗的，那么就会不可避免地变得又饿又累，而这又会激活他们体内的原始冲动：增加食量、减少运动。饥饿和嗜睡是古代的适应机制。</p></blockquote><blockquote><p>失配性疾病，即由于我们旧石器时代的身体不能或不足以适应某些现代行为和条件而导致的疾病。(没有说肥胖是疾病，这是书中解释一些现代社会才会遇到的疾病时提出的名词。)</p></blockquote><p>纵观整个人类历史，人类就好像突然从石器时代进入现代。因为我们人类在石器时代停留的时间为99%，现代才1%不到。人类的进化是缓慢的，已经跟不上现代社会的变化。</p><p>生活越来越好，这点无可否认，可是身体上的那些机能还没有转变过来。所以说，减肥这件事本身就是与人性在作对(还得和社会的审美做抗争)，基本没有胜利的可能。换回的是无尽的纠结、自责、懊恼……</p><p>这有点像电脑在国内刚起步那几年，家长们怕你沉迷，防这个，防那个。可是现在呢，电脑根本不是什么稀奇物，那些 00 后赶上了好时代，刚出生就接触电脑、智能机、平板…… 而石器时代食物匮乏，能吃到东西就很不错了，所以为了活下去，那种对甜食、脂肪的渴望很强烈，或者说有一种瘾。现代社会能吃饱也是近几十年的事情(感谢袁老)，食物极大丰富对体内的原始冲动来说，就像一夜暴富，开始肆意挥霍。</p><p>所以我们需要先满足体内的原始冲动，让它慢慢减弱那种食物匮乏的不安全感，然后驯服它，不过这一切都需要时间和耐心，不能一蹴而就，蛮干换回的只能是纠结、自责、懊恼……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者: 三木水&lt;br&gt;原文: &lt;a href=&quot;https://mp.weixin.qq.com/s/Bgc2DbHBq_tRuMbTukaj9w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;求求珍珠奶茶放过我吧&lt;/a&gt;&lt;/p&gt;&lt;
      
    
    </summary>
    
      <category term="减肥" scheme="https://muhouer.github.io/categories/%E5%87%8F%E8%82%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>Java异常解析</title>
    <link href="https://muhouer.github.io/posts/d868df11/"/>
    <id>https://muhouer.github.io/posts/d868df11/</id>
    <published>2019-08-23T15:32:54.000Z</published>
    <updated>2019-08-23T15:39:51.253Z</updated>
    
    <content type="html"><![CDATA[<p>Java 将所有的错误封装为一个对象，其根本父类为 <code>Throwable</code>， <code>Throwable</code>有两个子类：<code>Error</code> 和 <code>Exception</code>。</p><img src="/images/201908231133.png" width="800px" height="500px" align="center"><p>Trowable 类中常用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回异常发生时的详细信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">getMessage</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">// 返回异常发生时的简要描述</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">toString</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">// 返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">getLocalizedMessage</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">// 在控制台上打印Throwable对象封装的异常信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><blockquote><p>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions.</p></blockquote><p><code>Error</code> 是 <code>Throwable</code> 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。虽然 <strong>ThreadDeath</strong> 错误是一个“正规”的条件，但它也是 Error 的子类，因为大多数应用程序都不应该试图捕获它。在执行该方法期间，无需在其 throws 子句中声明可能抛出但是未能捕获的 Error 的任何子类，因为这些错误可能是再也不会发生的异常条件。</p><blockquote><p>调用 stop() 方法时会抛出 java.lang.ThreadDeath 错误，但在通常的情况下，此错误不需要显式地捕捉。不过方法 stop() 已经被作废，因为如果强制让线程停止则有可能使一些清理性的工作得不到完成。另外一个情况就是对锁定的对象进行了“解锁”，导致数据得不到同步的处理，出现数据不一致的问题。</p></blockquote><p>经典 <code>Error</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutOfMemoryError</span><br><span class="line">StackOverflowError</span><br></pre></td></tr></table></figure><h3 id="VirtulMachineError"><a href="#VirtulMachineError" class="headerlink" title="VirtulMachineError"></a>VirtulMachineError</h3><p>有四种不同类型的 <code>VirtulMachineError</code>：</p><ul><li>OutOfMemoryError</li><li>StackOverflowError</li><li>InternalError</li><li>UnknownError</li></ul><h4 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h4><p>OutOfMemoryError 有八种不同类型：</p><ol><li>java.lang.OutOfMemoryError：Java 堆空间</li><li>java.lang.OutOfMemoryError：GC 开销超过限制</li><li>java.lang.OutOfMemoryError：请求的数组大小超过虚拟机限制</li><li>java.lang.OutOfMemoryError：PermGen 空间</li><li>java.lang.OutOfMemoryError：Metaspace</li><li>java.lang.OutOfMemoryError：无法新建本机线程</li><li>java.lang.OutOfMemoryError：杀死进程或子进程</li><li>java.lang.OutOfMemoryError：发生 stack_trace_with_native_method</li></ol><p>触发每种错误的原因各有不同。类似地，根据 OutOfMemoryError 不同的问题类型，对应的解决方案也不一样。</p><h4 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h4><p>线程的堆栈存储了执行的方法、基本数据类型值、局部变量、对象指针和返回值信息，所有这些都会消耗内存。当栈深度超过虚拟机分配给线程的栈大小时，那么就会抛出 java.lang.StackOverflowError。通常由于执行程序中有一个错误，在线程重复递归调用同一个函数时会发生这个问题。</p><h4 id="InternalError"><a href="#InternalError" class="headerlink" title="InternalError"></a>InternalError</h4><p>JVM 抛出 java.lang.InternalError 有三个原因，虚拟机软件出现错误、系统软件底层出现错误或者硬件出现故障。</p><p>一般极少会遇到 InternalError 这样的错误。要了解哪些特定情况可能导致 InternalError，请在 Oracle 的 <a href="https://bugs.java.com/bugdatabase/" target="_blank" rel="noopener">Java Bug 数据库</a> 中搜索 InternalError。</p><h4 id="UnknownError"><a href="#UnknownError" class="headerlink" title="UnknownError"></a>UnknownError</h4><p>当发生异常或错误，但 Java 虚拟机无法报告确切的异常或错误时，就会抛出 java.lang.UnknownError。UnknownError 很少出现。事实上，在 Oracle <a href="https://bugs.java.com/bugdatabase/" target="_blank" rel="noopener">Java Bug 数据库</a> 中搜索 UnknownError 时，只找到了2个 Bug。</p><blockquote><h4 id="Bug-ID-JDK-4023606-AppletViewer-generates-java-lang-UnknownError-when-loading-inner-class"><a href="#Bug-ID-JDK-4023606-AppletViewer-generates-java-lang-UnknownError-when-loading-inner-class" class="headerlink" title="Bug ID: JDK-4023606 AppletViewer generates java.lang.UnknownError when loading inner class."></a><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4023606" target="_blank" rel="noopener">Bug ID: JDK-4023606 AppletViewer generates java.lang.UnknownError when loading inner class.</a></h4><h4 id="Bug-ID-JDK-4054295-UnknownError-while-loading-class-with-super-class-equal-to-zero"><a href="#Bug-ID-JDK-4054295-UnknownError-while-loading-class-with-super-class-equal-to-zero" class="headerlink" title="Bug ID: JDK-4054295 UnknownError while loading class with super_class equal to zero"></a><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4054295" target="_blank" rel="noopener">Bug ID: JDK-4054295 UnknownError while loading class with super_class equal to zero</a></h4></blockquote><h3 id="AWTError"><a href="#AWTError" class="headerlink" title="AWTError"></a>AWTError</h3><p><strong>AWT(Abstract Window Toolkit)</strong>，中文译为抽象窗口工具包，是 Java 提供的用来建立和设置 Java 的图形用户界面的基本工具。<code>AWTError</code>一般也很少用到。事实上，在 Oracle <a href="https://bugs.java.com/bugdatabase/" target="_blank" rel="noopener">Java Bug 数据库</a> 中搜索 AWTError 时，只找到了8个 Bug。</p><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p><code>Exception</code> 类及其子类是 <code>Throwable</code> 的一种形式，它指出了合理的应用程序想要捕获的条件。<code>Exception</code> 分为未检查异常(<code>RuntimeException</code>)和已检查异常(非<code>RuntimeException</code>)。 未检查异常是因为程序员没有进行必需要的检查，因为疏忽和错误而引起的错误。几个经典的 <code>RunTimeException</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException</span><br><span class="line">ArithmaticException</span><br><span class="line">ArrayIndexoutofBoundsException</span><br></pre></td></tr></table></figure><blockquote><ol><li>可查异常(编译器要求必须处置的异常)：正确的程序在运行中，很容易出现的、情理可容的异常状况。除了 Exception 中的 RuntimeException 及其子类以外，其他的 Exception 类及其子类(例如：IOException和ClassNotFoundException)都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</li><li>不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。RuntimeException表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。</li></ol></blockquote><h3 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h3><p>运行时异常都是 RuntimeException 类及其子类异常，如 NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是 Java 编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用 try-catch 语句捕获它，也没有用 throws 子句声明抛出它，也会编译通过。</p><h3 id="非RuntimeException"><a href="#非RuntimeException" class="headerlink" title="非RuntimeException"></a>非RuntimeException</h3><p>非运行时异常(也称受检查的异常)是 RuntimeException 以外的异常，类型上都属于 Exception 类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException、SQLException 等以及用户自定义的 Exception 异常，一般情况下不自定义检查异常。</p><h3 id="异常处理的机制"><a href="#异常处理的机制" class="headerlink" title="异常处理的机制"></a>异常处理的机制</h3><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p><p>任何 Java 代码都可以抛出异常，如：自己编写的代码、来自 Java 开发环境包中代码，或者 Java 运行时系统。无论是谁，都可以通过 Java 的 throw 语句抛出异常。从方法中抛出的任何异常都必须使用throws子句。</p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p><p>捕捉异常通过try-catch语句或者try-catch-finally语句实现。</p><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throws</span> <span class="comment">//直接往上一层抛出异常；</span></span><br><span class="line"><span class="keyword">try</span>&#123;&#125;<span class="keyword">catch</span> <span class="comment">// 捕获异常</span></span><br><span class="line"><span class="keyword">finally</span> <span class="comment">// 扫尾工作</span></span><br></pre></td></tr></table></figure><h3 id="throw-和-throws-两个关键字有什么不同"><a href="#throw-和-throws-两个关键字有什么不同" class="headerlink" title="throw 和 throws 两个关键字有什么不同"></a>throw 和 throws 两个关键字有什么不同</h3><ul><li>throw 是用来抛出任意异常的，你可以抛出任意 Throwable，包括自定义的异常类对象；</li><li>throws 总是出现在一个函数头中，用来标明该成员函数可能抛出的各种异常。如果方法抛出了异常，那么调用这个方法的时候就需要处理这个异常。</li></ul><h3 id="try-catch-finally-return执行顺序"><a href="#try-catch-finally-return执行顺序" class="headerlink" title="try-catch-finally-return执行顺序"></a>try-catch-finally-return执行顺序</h3><ul><li>不管是否有异常产生，finally 块中代码都会执行；</li><li>当 try 和 catch 中有 return 语句时，finally 块仍然会执行；</li><li>finally 是在 return 后面的表达式运算后执行的，所以函数返回值是在 finally 执行前确定的。无论 finally 中的代码怎么样，返回的值都不会改变，仍然是之前 return 语句中保存的值；</li><li>finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按正常顺序执行。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 程序执行 try 块中 return 之前(包括 return 语句中的表达式运算)代码； </span></span><br><span class="line"><span class="comment"> * 2. 再执行 finally 块，最后执行 try 中 return; </span></span><br><span class="line"><span class="comment"> * 3. finally 块后面的 return 语句不再执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="keyword">return</span>; </span><br><span class="line">&#125; <span class="keyword">catch</span> ()&#123;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.程序先执行 try，如果遇到异常执行 catch 块， </span></span><br><span class="line"><span class="comment"> * 有异常则执行 catch 中 return 之前(包括 return 语句中的表达式运算)代码，再执行 finally 语句中全部代码，最后执行 catch 块中 return，finally 块后面的 return 语句不再执行。 </span></span><br><span class="line"><span class="comment"> * 无异常执行完 try 再 finally 再执行最后的 return 语句。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序执行 try 块中 return 之前(包括 return 语句中的表达式运算)代码； </span></span><br><span class="line"><span class="comment"> * 再执行 finally 块，因为 finally 块中有 return 所以提前退出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="keyword">return</span>; </span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序执行catch块中return之前（包括return语句中的表达式运算）代码； </span></span><br><span class="line"><span class="comment"> * 再执行finally块，因为finally块中有return所以提前退出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>在设计模式中有一个叫做责任链模式，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：异常链。</p><p>我们有两种方式处理异常，一是 throws 抛出交给上级处理，二是 try…catch 做具体处理。try…catch 的 catch 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 throws 继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。</p><p>​ <strong>通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。</strong></p><p>同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。在异常链的使用中，throw 抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在 Throwable 及其子类中的构造器中都可以接受一个 <code>Throwable cause</code> 参数，该参数保存了原有的异常信息，通过 getCause() 就可以获取该原始异常信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> XxxException</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do something:可能抛出异常信息的代码块</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> XxxException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="精确原则"><a href="#精确原则" class="headerlink" title="精确原则"></a>精确原则</h3><ol><li><strong>尽可能的减小 try 块</strong>——try 块不要包含太多的信息，仅包所需。</li><li><strong>catch 语句应当尽量指定具体的异常类型，不要一个Exception试图处理所有可能出现的异常</strong></li></ol><h3 id="不要做渣男，负点责"><a href="#不要做渣男，负点责" class="headerlink" title="不要做渣男，负点责"></a>不要做渣男，负点责</h3><ol><li><strong>既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃。</strong></li><li><strong>在异常处理模块中提供适量的错误原因信息，使其后续易于理解和阅读。</strong></li><li><strong>保证所有资源都被正确释放。</strong> ——充分运用finally关键词。或者使用 Java 提供的语法糖 try() catch</li></ol><h3 id="两不要"><a href="#两不要" class="headerlink" title="两不要"></a>两不要</h3><ol><li><strong>不要在 finally 块中处理返回值。</strong></li><li><strong>不要在构造函数中抛出异常。</strong></li></ol><h2 id="异常使用指南"><a href="#异常使用指南" class="headerlink" title="异常使用指南"></a>异常使用指南</h2><p>应该在下列情况下使用异常(From 《Think in java》)。</p><ol><li>在恰当的级别处理问题(在知道该如何处理异常的情况下才捕获异常)。</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事情尽量做完。然后把相同(不同)的异常重新抛到更高层。</li><li>终止程序。</li><li>进行简化。</li><li>让类库和程序更加安全。(这既是在为调试做短期投资，也是在为程序的健壮做长期投资)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 将所有的错误封装为一个对象，其根本父类为 &lt;code&gt;Throwable&lt;/code&gt;， &lt;code&gt;Throwable&lt;/code&gt;有两个子类：&lt;code&gt;Error&lt;/code&gt; 和 &lt;code&gt;Exception&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java的一些基本概念</title>
    <link href="https://muhouer.github.io/posts/d7d0bf4a/"/>
    <id>https://muhouer.github.io/posts/d7d0bf4a/</id>
    <published>2019-08-21T16:39:00.000Z</published>
    <updated>2019-08-21T17:02:40.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h2><h3 id="什么是面向过程？"><a href="#什么是面向过程？" class="headerlink" title="什么是面向过程？"></a>什么是面向过程？</h3><p>自顶而下的编程模式。占用资源相对低，速度相对快。</p><p>把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。</p><p>最典型的用法就是实现一个简单的算法，比如实现冒泡排序。</p><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p>将事务高度抽象化的编程模式。占用资源相对高，速度相对慢。</p><p>将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p><p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。</p><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h3><p>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><h3 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h3><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p><h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态(Polymorphism)"></a>多态(Polymorphism)</h3><p>所谓多态就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><p>最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p><h2 id="重载-amp-重写"><a href="#重载-amp-重写" class="headerlink" title="重载 &amp; 重写"></a>重载 &amp; 重写</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>重载是一个编译期概念，重写是一个运行期间概念。</li><li>重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。</li><li>重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法</li><li>因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）</li></ol><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数，是一种特殊的方法。 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。</p><p>构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。构造器的函数名称必须和它所属的类的名称相同。 它承担着初始化对象数据成员的任务。</p><p>如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数一般会把成员变量的值初始化为默认值，如int -&gt; 0，Integer -&gt; null。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java中共有三种变量，分别是类变量、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author Hollis</span><br><span class="line"> */</span><br><span class="line">public class Variables &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 类变量</span><br><span class="line">     */</span><br><span class="line">    private static int a;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 成员变量</span><br><span class="line">     */</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 局部变量</span><br><span class="line">     * @param c</span><br><span class="line">     */</span><br><span class="line">    public void test(int c)&#123;</span><br><span class="line">        int d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义的三个变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="public"><a href="#public" class="headerlink" title="public"></a><code>public</code></h3><p>表明该成员变量或者方法是对所有类或者对象都是可见的，所有类或者对象都可以直接访问。</p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a><code>protected</code></h3><p>表明成员变量或者方法对类自身以及同在一个包中的其他类可见，其他包下的类不可访问，除非是他的子类。</p><h3 id="default"><a href="#default" class="headerlink" title="default"></a><code>default</code></h3><p>表明该成员变量或者方法只有自己和其位于同一个包的内可见，其他包内的类不能访问，即便是它的子类。</p><h3 id="private"><a href="#private" class="headerlink" title="private"></a><code>private</code></h3><p>表明该成员变量或者方法是私有的，只有当前类对其具有访问权限，除此之外其他类或者对象都没有访问权限，子类也没有访问权限。</p><h2 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h2><p>5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”</p><h3 id="单一职责原则（Single-Resposibility-Principle）"><a href="#单一职责原则（Single-Resposibility-Principle）" class="headerlink" title="单一职责原则（Single-Resposibility Principle）"></a>单一职责原则（Single-Resposibility Principle）</h3><p>其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。</p><h3 id="开放封闭原则（Open-Closed-principle）"><a href="#开放封闭原则（Open-Closed-principle）" class="headerlink" title="开放封闭原则（Open-Closed principle）"></a>开放封闭原则（Open-Closed principle）</h3><p>其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。开放封闭原则主要体现在两个方面：</p><ol><li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li><li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。</li></ol><p>实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。</p><h3 id="里式替换原则（Liskov-Substitution-Principle）"><a href="#里式替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里式替换原则（Liskov-Substitution Principle）"></a>里式替换原则（Liskov-Substitution Principle）</h3><p>其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 里式替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了里式替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 里式替换原则是关于继承机制的设计原则，违反了里式替换原则就必然导致违反开放封闭原则。 里式替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。</p><h3 id="依赖倒置原则（Dependecy-Inversion-Principle）"><a href="#依赖倒置原则（Dependecy-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependecy-Inversion Principle）"></a>依赖倒置原则（Dependecy-Inversion Principle）</h3><p>其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。</p><h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface-Segregation Principle）"></a>接口隔离原则（Interface-Segregation Principle）</h3><p>其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象与面向过程&quot;&gt;&lt;a href=&quot;#面向对象与面向过程&quot; class=&quot;headerlink&quot; title=&quot;面向对象与面向过程&quot;&gt;&lt;/a&gt;面向对象与面向过程&lt;/h2&gt;&lt;h3 id=&quot;什么是面向过程？&quot;&gt;&lt;a href=&quot;#什么是面向过程？&quot; class=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基本概念" scheme="https://muhouer.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>理财杂记</title>
    <link href="https://muhouer.github.io/posts/847d5b8e/"/>
    <id>https://muhouer.github.io/posts/847d5b8e/</id>
    <published>2019-08-21T16:27:00.000Z</published>
    <updated>2019-09-06T14:12:10.751Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一直很乐观，一直很谨慎。这才是长期生存之道。</strong></p><h2 id="一盆冷水"><a href="#一盆冷水" class="headerlink" title="一盆冷水"></a>一盆冷水</h2><blockquote><p>在很多人的潜意识里：钱是脏的、钱就是性，是羞耻的、钱代表不安全、钱代表攻击、钱代表分离。</p></blockquote><h3 id="年轻人收入少，最好的投资是投资自己。"><a href="#年轻人收入少，最好的投资是投资自己。" class="headerlink" title="年轻人收入少，最好的投资是投资自己。"></a>年轻人收入少，最好的投资是投资自己。</h3><p>什么叫投资自己？什么叫让自己变得值钱？投资是一件带有明确目的性的东西，如果做事情没有目的性，那么不如不做。</p><p>如果做了没有达到目的，那就说明在浪费时间和金钱。变得值钱这件事情，更要有目的性，要有明确的KPI。</p><p>回过头来再看，各种让你学习烘焙旅游化妆穿衣的东西，能算是投资自己吗？<br>即使是所谓的考证，健身，读书，也得考虑一个回报率和执行力的问题。大多数人对于长期坚持考证这种事情，是坚持不下来的，人和人就是不一样的。办了健身房年卡，一年能去几次？去闲鱼看看那些便宜出的年卡就知道了。</p><p><strong>在没有足够数量的有效信息前，各种所谓的投资都是抓瞎。</strong></p><h3 id="依靠理财实现财务自由"><a href="#依靠理财实现财务自由" class="headerlink" title="依靠理财实现财务自由"></a>依靠理财实现财务自由</h3><p>如果说投资自己是欺负年轻人的话，那么依靠理财财务自由则是针对职场人士的春秋大梦。那些靠吃利息的人，绝大多数也都是通过其他行业完成了自己的资本积累，例如1000万。</p><p>理财这件事情说穿了就是把你已有的资金做一个增量，这显然是受限于你的本金的，人家1000万本金一年赚3%都有30万，你5万块钱一年15%也就7千5.</p><p><strong>很多人的问题不在于3%或者15%，而是在于1000万还是5万。</strong></p><p>而且投资其实一个技能，这个技能需要大量的时间积累和实战的，就和你做医生，程序员，工程师，老师一样，不是一蹴而就的，你一个普普通通在自己行业冒头都费劲的人，突然就靠理财财务自由了，这东西有点魔幻。</p><p>一开始就要把目的定下来，让自己舒服一点，但不求大富大贵。大富大贵的东西不要学理财，建议去学刑法。</p><h3 id="投资一定要跟着高手进行操作"><a href="#投资一定要跟着高手进行操作" class="headerlink" title="投资一定要跟着高手进行操作"></a>投资一定要跟着高手进行操作</h3><p>认真想想，你和高手的风险承受能力，信息获取能力，资金量级，心态，时间成本都是完全不一样的，你去学高手的操作模式是得有多么想不通。</p><p>人家高手加杠杆的同时还有另一批资金做风险对冲，你自己傻乎乎地跟着人家加杠杆进场一波就把自己玩儿炸掉。人家高手投资某个标的的时候往往有数据支撑或者内幕消息，你傻乎乎跟着投进去最后就是给高手接盘的。</p><p>高手的操作模式和普通人的操作根本不是一种东西，二者从目的性上就有本质的区别。</p><ol><li>开F1和骑自行车都是交通技术，但能一样么？</li><li>十以内加减法和微积分都是数学，你让小学生学微积分试试？</li></ol><p>不同的人，要有不同的投资模式，强行并线很容易出事故的。而且吧，专业人士操作的时效性要求很高，哪里有空和你比比？</p><p>我自己玩高频交易的时候，根本没空和人家废话，各种公式等着我配平，各种市场风险要在指标变化的第一时间做对冲，时刻要盯着自己的平仓线和保证金，哪里有心思还教人怎么玩儿？</p><p>有的人就是想赚点小钱，学什么杠杆，找死么。有的人心理承受能力就是差，那就去买银行理财，搞什么P2P。有的人天生就是只想投自己懂的公司，那就买股票，死也是个明白鬼。</p><p>普通人应该是有普通人的玩法。非得跟着高手操作的结果，很有可能是人家车都开到下一站了，你还在天上飘着呢。</p><h3 id="大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。"><a href="#大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。" class="headerlink" title="大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。"></a>大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。</h3><p>这话本身没错，但是要看对谁说。</p><p>对于已经挺有钱的人而言是对的，因为他们的时间本身就挺值钱，没有必要在细节上浪费。但是对于绝大多数时间不能直接变成钱的普通人而言，这句话是最毒的鸡汤。</p><p>对于普通人而言，买房买车买包买表这种大钱，大家都会本能性的谨慎，去收集信息，去权衡利弊，其实用不着和人讲谨慎，大家都知道要谨慎。反而是打车，是大量奶茶零食，是大量9块9包邮，是各种拼单凑单，才是普通人资金流血的最大问题所在。</p><p>电子支付的快速发展更加剧了这一问题，过去有一堆堆的现金摆在面前还会让人警醒一点，而现在年轻人手机一刷，感知上就弱了很多。甚至负债类消费已经流行到不需要感知的程度，二维码背后就是信用卡和透支产品，很多人都是一到要还卡的时候才傻了眼，平时根本没什么感觉。</p><p>而投资理财这件事情，我上面第二点说了，最重要的是先要有本金，哪怕是不多的本金，然后才是收益率。</p><p>如果不控制住这种弱感知的消费，管理不好自己的资金流，那么永远也没有本金可言，所谓的投资理财在一开始就完犊子了。</p><p><strong>资金流管理，是我觉得每个人都应该学的第一步。</strong></p><h2 id="我觉得还会涨"><a href="#我觉得还会涨" class="headerlink" title="我觉得还会涨"></a>我觉得还会涨</h2><img src="/images/201908240012.png" width="800px" height="300px" align="center"><p>出现负利率贷款，金毛大总统接连搞事，不确定因素太多了…… 如果回到一年前，我一定重仓黄金，然后把这件事忘记，一年半之后再卖掉。这个时候我也买了点，看看能不能赶上末班车，喝点汤。希望别打脸~</p><h2 id="理想情况"><a href="#理想情况" class="headerlink" title="理想情况"></a>理想情况</h2><ol><li>情况好，赚得多；情况不好，亏的少。</li><li>基金莫短炒。必须短炒的话，优先买场内基金，或者场外C类基金并持有7天以上。可以省一笔赎回费。</li><li>利率降低可以拉高所有资产的价格。但2%、3%这种低利率水平，资产没啥机会的，因为价格已经很高了。反倒是利率6%降低到3%的过程中，买资产大有可为，因为仅这一个变化就可以让资产价格翻倍。</li></ol><h2 id="现实情况"><a href="#现实情况" class="headerlink" title="现实情况"></a>现实情况</h2><ol><li>加盟商的目的不是帮你赚钱，而是从你手上赚钱，这一点非常重要。</li><li>餐饮业，成本是生命线，一切都和成本有关。</li><li>投资人也爱割投资人韭菜，大家五五开吧。</li><li>所谓高收益又能保本保息的并不符合投资常识，和常识对着干早晚要出事的。</li></ol><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>攒钱是年轻人改变命运的最低成本方案，没有之一，没有之一，没有之一。省钱+攒钱，只要坚持，路就会越走越宽。</p><p>酷是生活态度，不是消费态度。向命运宣战，可不是靠透支信用卡。</p><h3 id="消费主义是什么？"><a href="#消费主义是什么？" class="headerlink" title="消费主义是什么？"></a>消费主义是什么？</h3><p>简单来说，任何把让你掏钱的事情描绘的别有一番意义的事情，都是消费主义的一种体现。不是说买东西就是消费主义，而是让你通过买东西，去获得一种虚无的快感，这叫做消费主义。</p><p>典型的消费主义特质，就是把消费与个人社会标签捆绑在一起，让你为个人标签支付更多的金钱。简称你买什么，你就是什么。</p><p>只要你还在靠出卖自己的劳动力和时间获取收入，哪怕年薪百万是高级职业经理人，你依然是个穷人，别想着给自己贴什么高级标签，更别觉得那些所谓中产必买的东西对你有什么意义。哪有什么中产，中产就是消费主义鼓吹出来的谎言。</p><h3 id="什么叫有钱人？"><a href="#什么叫有钱人？" class="headerlink" title="什么叫有钱人？"></a>什么叫有钱人？</h3><p>不需要从事生产，光靠理财和资产的增值收入已经远远可以覆盖掉各种作妖的成本。拥有选择是否出卖时间的自由，想去哪里可以立即头等舱飞过去，不需要凑时间，也不需要找便宜票。</p><p>银行卡可自由动用资金（注意不是用于生产的资金）余额在8位数以上，不包含用于投资部分。达到这个基础标准的，才叫有钱人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一直很乐观，一直很谨慎。这才是长期生存之道。&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;一盆冷水&quot;&gt;&lt;a href=&quot;#一盆冷水&quot; class=&quot;headerlink&quot; title=&quot;一盆冷水&quot;&gt;&lt;/a&gt;一盆冷水&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;在很多人
      
    
    </summary>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>CodeReview最佳实践</title>
    <link href="https://muhouer.github.io/posts/eb547231/"/>
    <id>https://muhouer.github.io/posts/eb547231/</id>
    <published>2019-08-21T16:15:06.000Z</published>
    <updated>2019-08-21T16:25:18.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：宝玉<br>原文：<a href="https://www.cnblogs.com/dotey/p/11216430.html" target="_blank" rel="noopener">https://www.cnblogs.com/dotey/p/11216430.html</a></p></blockquote><p>我一直认为Code Review（代码审查）是软件开发中的最佳实践之一，可以有效提高整体代码质量，及时发现代码中可能存在的问题。包括像Google、微软这些公司，Code Review都是基本要求，代码合并之前必须要有人审查通过才行。</p><p>然而对于我观察到的大部分软件开发团队来说，认真做Code Review的很少，有的流于形式，有的可能根本就没有Code Review的环节，代码质量只依赖于事后的测试。也有些团队想做好代码审查，但不知道怎么做比较好。</p><p>网上关于如何做Code Review的文章已经有很多了，这里我结合自己的一些经验，也总结整理了一下Code Review的最佳实践，希望能对大家做好Code Review有所帮助。</p><h2 id="Code-Review有什么好处？"><a href="#Code-Review有什么好处？" class="headerlink" title="Code Review有什么好处？"></a>Code Review有什么好处？</h2><p>很多团队或个人不做Code Review，根源还是不觉得这是一件有意义的事情，不觉得有什么好处。这个问题要从几个角度来看。</p><h3 id="团队知识共享的角度"><a href="#团队知识共享的角度" class="headerlink" title="团队知识共享的角度"></a>团队知识共享的角度</h3><p>一个开发团队中，水平有高有低，每个人侧重的领域也有不同。怎么让高水平的帮助新人成长？怎么让大家都对自己侧重领域之外的知识保持了解？怎么能有人离职后其他人能快速接手？这些都是团队管理者关心的问题。</p><p>而代码审查，就是一个很好的知识共享的方式。通过代码审查，高手可以直接指出新手代码中的问题，新手可以马上从高手的反馈中学习到好的实践，得到更快的成长；通过代码审查，前端也可以去学习后端的代码，做功能模块A的可以去了解功能模块B的。</p><p>可能有些高手觉得给新手代码审查浪费时间，自己也没收获。其实不然，新人成长了，就可以更多的帮高手分担繁重的任务；代码审查中花时间，就少一些帮新人填坑擦屁股的时间；良好的沟通能力、发现问题的能力、帮助其他人成长，都是技术转管理或技术上更上一层楼必不可少的能力，而通过代码审查可以有效的去练习这些方面的能力。</p><h3 id="代码质量的角度"><a href="#代码质量的角度" class="headerlink" title="代码质量的角度"></a>代码质量的角度</h3><p>现实中的项目总是人手缺进度紧，所以被压缩的往往就是自动化测试和代码审查，结果影响代码质量，欠下技术债务，最后还是要加倍偿还。</p><p>也有人寄希望于开发后的人工测试，然而对于代码质量来说，很多问题通过测试是测试不出来的，只能通过代码审查。比如说代码的可读性可维护性，比如代码的结构，比如一些特定条件才触发的死循环、逻辑算法错误，还有一些安全上的漏洞也更容易通过代码审查发现和预防。</p><p>也有人觉得自己水平高就不需要代码审查了。对于高手来说，让别人审查自己的代码，可以让其他人学习到好的实践；在让其他人审查的同时，在给别人说明自己代码的时候，也等于自己对自己的代码进行了一次审查。这其实就跟我们上学时做数学题一样，真正能拿高分的往往是那些做完后还会认真检查的。</p><h3 id="团队规范的角度"><a href="#团队规范的角度" class="headerlink" title="团队规范的角度"></a>团队规范的角度</h3><p>每个团队都有自己的代码规范，有自己的基于架构设计的开发规范，然而时间一长，就会发现代码中出现很多不遵守代码规范的情况，有很多绕过架构设计的代码。比如难以理解和不规范的命名，比如三层架构里面UI层绕过业务逻辑层直接调用数据访问层代码。</p><p>如果这些违反规范的代码被纠正的晚了，后面再要修改就成本很高了，而且团队的规范也会慢慢的形同虚设。</p><p>通过代码审查，就可以及时的去发现和纠正这些问题，保证团队规范的执行。</p><p>关于代码审查的好处，还有很多，也不一一列举。还是希望能认识到Code Review和写自动化测试一样，都是属于磨刀不误砍柴工的工作，在上面投入一点点时间，未来会收获代码质量，会节约整体的开发时间。</p><h2 id="该怎么做？"><a href="#该怎么做？" class="headerlink" title="该怎么做？"></a>该怎么做？</h2><p>现在很多人都已经有意识到Code Review的重要性了，只是苦于不知道如何去实践，不知道怎么样算是好的Code Review实践。</p><h3 id="把Code-Review作为开发流程的必选项而不是可选项"><a href="#把Code-Review作为开发流程的必选项而不是可选项" class="headerlink" title="把Code Review作为开发流程的必选项而不是可选项"></a>把Code Review作为开发流程的必选项而不是可选项</h3><p>在很早以前，我就尝试过将代码审查作为代码流程的一部分，但只是一个可选项，没有Code Review也可以把代码合并到master。这样的结果就是想起来才会去做Code Review，去检查的时候已经有了太多的代码变更，审查起来非常困难，另外就算审查出问题，也很难得以修改。</p><p>我们现在对代码的审查则是作为开发流程的一个必选项，每次开发新功能或者修复Bug，开一个新的分支，分支要合并到master有两个必要条件：</p><ol><li>所有的自动化测试通过</li><li>有至少一个人Code Review通过，如果是新手的PR，还必须有资深程序员Code Review通过。</li></ol><p>这样把Code Review作为开发流程的一个必选项后，就很好的保证了代码在合并之前有过Code Review。而且这样合并前要求代码审查的流程，好处也很明显：</p><ol><li>由于每一次合并前都要做代码审查，这样一般一次审查的代码量也不会太大，对于审查者来说压力也不会太大。</li><li>如果在Code Review时发现问题，被审查者希望代码能尽快合并，也会积极的对审查出来的问题进行修改，不至于对审查结果太过抵触。</li></ol><p>如果你觉得Code Review难以推行，不妨先尝试着把Code Review变成你开发流程的一个必选项。</p><h3 id="把Code-Review变成一种开发文化而不仅仅是一种制度"><a href="#把Code-Review变成一种开发文化而不仅仅是一种制度" class="headerlink" title="把Code Review变成一种开发文化而不仅仅是一种制度"></a>把Code Review变成一种开发文化而不仅仅是一种制度</h3><p>把Code Review 作为开发流程的必选项后，不代表Code Review这件事就可以执行的很好，因为Code Review 的执行，很大部分程度上依赖于审查者的认真审查，以及被审查者的积极配合，两者缺一不可！</p><p>如果仅仅只是当作一个流程制度，那么就可能会流于形式。最终结果就是看起来有Code Review，但没有人认真审查，随便看下就通过了，或者发现问题也不愿意修改。</p><p>真要把Code Review这件事做好，必须让Code Review变成团队的一种文化，开发人员从心底接受这件事，并认真执行这件事。</p><p>要形成这样的文化，不那么容易，也没有想象的那么难，比如这些方面可以参考：</p><ol><li>首先，得让开发人员认识到Code Review这件事为自己、为团队带来的好处。</li><li>然后，得要有几个人做好表率作用，榜样的力量很重要。</li><li>还有，对于管理者来说，你激励什么，往往就会得到什么。</li><li>最后，像写自动化测试一样，把Code Review要作为开发任务的一部分，给审查者和被审查者都留出专门的时间去做这件事，不能光想着马儿跑得快又舍不得给马儿吃草。</li></ol><p>如何形成这样的文化，有心的话，还有很多方法可以尝试。只有真正让大家都认同和践行，才可能去做好Code Review这件事。</p><h2 id="一些Code-Review的经验技巧"><a href="#一些Code-Review的经验技巧" class="headerlink" title="一些Code Review的经验技巧"></a>一些Code Review的经验技巧</h2><p>在做好Code Review这件事上，还有一些经验技巧可以参考。</p><h3 id="选什么工具辅助做CODE-REVIEW？"><a href="#选什么工具辅助做CODE-REVIEW？" class="headerlink" title="选什么工具辅助做CODE REVIEW？"></a>选什么工具辅助做CODE REVIEW？</h3><p>现在很多源代码管理工具都自带Code Review工具，典型的像Github、Gitlab、微软的Azure DevOps，尤其是像Gitlab，还可以自己在本地搭建环境，根据自己的需要灵活配置。</p><h3 id="配合什么样的开发流程比较好？"><a href="#配合什么样的开发流程比较好？" class="headerlink" title="配合什么样的开发流程比较好？"></a>配合什么样的开发流程比较好？</h3><p>像Github Flow[1]这样基于分支开发的流程是特别适合搭配Code Review的。其实不管什么样的开发流程，关键点在于代码合并到master（主干）之前，要先做Code Review。</p><h3 id="真遇到紧急情况，来不及代码审查怎么办？"><a href="#真遇到紧急情况，来不及代码审查怎么办？" class="headerlink" title="真遇到紧急情况，来不及代码审查怎么办？"></a>真遇到紧急情况，来不及代码审查怎么办？</h3><p>虽然原则上，必须要Code Review才能合并，但有时候确实会存在一些紧急情况，比如说线上故障补丁，而又没有其他人在线，那么这种情况下，最好是在任务管理系统中，创建一个Ticket，用来后续跟踪，确保后续补上Code Review，并对Code Review结果有后续的代码更新。</p><h3 id="先设计再编码"><a href="#先设计再编码" class="headerlink" title="先设计再编码"></a>先设计再编码</h3><p>有些新人发现自己的代码提交PR（Pull Request）后，会收到一堆的Code Review意见，必须要做大量的改动。这多半是因为在开始做之前，没有做好设计，做出来后才发现问题很多。</p><p>建议在做一个新功能之前，写一个简单的设计文档，表达清楚自己的设计思路，找资深的先帮你做一下设计的审查，发现设计上的问题。设计上没问题了，再着手开发，那么到Review的时候，相对问题就会少很多。</p><h3 id="代码在提交CODE-REVIEW之前，作者要自己先REVIEW和测试一遍"><a href="#代码在提交CODE-REVIEW之前，作者要自己先REVIEW和测试一遍" class="headerlink" title="代码在提交CODE REVIEW之前，作者要自己先REVIEW和测试一遍"></a>代码在提交CODE REVIEW之前，作者要自己先REVIEW和测试一遍</h3><p>我在做代码审查的时候，有时候会发现一些非常明显的问题，有些甚至自己都没有测试过，就等着别人Code Review和测试帮助发现问题。这种依赖心理无论是对自己还是对团队都是很不负责任的。</p><p>一个好的开发人员，代码在提交Code Review之前，肯定是要自己先Review一遍，把该写的自动化测试代码写上，自己把基本的测试用例跑一遍的。</p><p>我对于团队提交的PR，有个要求就是要在PR的描述中增加截图或者录屏，就是为了通过截图或者录屏，确保提交PR的人自己是先测试过的。这也是一个有效的辅助手段。</p><h3 id="PR要小"><a href="#PR要小" class="headerlink" title="PR要小"></a>PR要小</h3><p>在做Code Review的时候，如果有大量的文件修改，那么Review起来是很困难的，但如果PR比较小，相对就比较容易Review，也容易发现代码中可能存在的问题。</p><p>所以在提交PR时，PR要小，如果是比较大的改动，那么最好分批提交，以减轻审查者的压力。</p><h3 id="对评论进行分级"><a href="#对评论进行分级" class="headerlink" title="对评论进行分级"></a>对评论进行分级</h3><p>在做Code Review时，需要针对审查出有问题的代码行添加评论，如果只是评论，有时候对于被审查者比较难甄别评论所代表的含义，是不是必须要修改。</p><p>建议可以对Review的评论进行分级，不同级别的结果可以打上不同的Tag，比如说：</p><ol><li>[blocker]: 在评论前面加上一个blocker标记，表示这个代码行的问题必须要修改</li><li>[optional]：在评论前面加上一个[optional]标记，表示这个代码行的问题可改可不改</li><li>[question]：在评论前面加上一个[question]标记，表示对这个代码行不理解，有问题需要问，被审查者需要针对问题进行回复澄清<br>类似这样的分级可以帮助被审查者直观了解Review结果，提高Review效率。</li></ol><p>评论要友好，避免负面词汇；有说不清楚的问题当面沟通</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Code Review是一种非常好的开发实践，如果你还没开始，不妨逐步实践起来；如果已经做了效果不好，不妨对照一下，看有没有把Code Review作为开发流程的必选项而不是可选项？有没有把Code Review变成一种开发文化而不仅仅是一种制度？</p><p>虽然评论是主要的Code Review沟通方式，但也不要过于依赖，有时候面对面的沟通效率更高，也容易消除误解。</p><p>另外文明用语，不要用一些负面的词汇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者：宝玉&lt;br&gt;原文：&lt;a href=&quot;https://www.cnblogs.com/dotey/p/11216430.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/do
      
    
    </summary>
    
    
  </entry>
  
</feed>

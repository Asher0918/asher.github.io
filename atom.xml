<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Muhouer</title>
  
  <subtitle>就是做个记录，先来5分钟的！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muhouer.github.io/"/>
  <updated>2019-08-18T05:59:02.828Z</updated>
  <id>https://muhouer.github.io/</id>
  
  <author>
    <name>Muhouer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashSet分析</title>
    <link href="https://muhouer.github.io/posts/88817346/"/>
    <id>https://muhouer.github.io/posts/88817346/</id>
    <published>2019-08-18T05:58:00.000Z</published>
    <updated>2019-08-18T05:59:02.828Z</updated>
    
    <content type="html"><![CDATA[<p><code>HashSet</code> 是一个不允许存储重复元素的集合，它的实现比较简单，只要理解了 <code>HashMap</code>，<code>HashSet</code> 基本就没什么问题。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>主要就两个变量:</p><ul><li><code>map</code> ：用于存放最终数据的。</li><li><code>PRESENT</code> ：是所有写入 map 的 <code>value</code> 值。</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数也很简单，利用 <code>HashMap</code> 初始化了 map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new set containing the elements in the specified</span></span><br><span class="line"><span class="comment"> * collection.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor</span></span><br><span class="line"><span class="comment"> * (0.75) and an initial capacity sufficient to contain the elements in</span></span><br><span class="line"><span class="comment"> * the specified collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash table</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的就是这个 <code>add()</code> 方法。 可以看出它是将存放的对象当做了 <code>HashMap</code> 的健，<code>value</code> 都是相同的 <code>PRESENT</code> 。由于 <code>HashMap</code> 的 <code>key</code> 是不能重复的，所以每当有重复的值写入到 <code>HashSet</code> 时，<code>value</code> 会被覆盖，但 <code>key</code> 不会受到影响，这样就保证了 <code>HashSet</code> 中只能存放不重复的元素。</p><h2 id="TreeSet-与-HashSet-的区别"><a href="#TreeSet-与-HashSet-的区别" class="headerlink" title="TreeSet 与 HashSet 的区别"></a>TreeSet 与 HashSet 的区别</h2><p>1、<code>TreeSet</code> 是二差树实现的，<code>Treeset</code>c中的数据是自动排好序的，不允许放入 null 值 2、<code>HashSet</code> 是哈希表实现的，<code>HashSet</code> 中的数据是无序的，可以放入 null，但只能放入一个 null，两者中的值都不能重复，就如数据库中唯一约束。</p><p>在 <code>HashSet</code> 中，基本的操作都是由 <code>HashMap</code> 底层实现的，因为 <code>HashSet</code> 底层是用 <code>HashMap</code> 存储数据的。当向<code>HashSet</code> 中添加元素的时候，首先计算元素的hashcode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。</p><p><code>TreeSet</code> 的底层是 <code>TreeMap</code> 的 keySet()，而 <code>TreeMap</code> 是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。</p><p><code>TreeMap</code> 是按key排序的，元素在插入 <code>TreeSet</code> 时 compareTo() 方法要被调用，所以 <code>TreeSet</code> 中的元素要实现Comparable 接口。<code>TreeSet</code> 作为一种Set，它不允许出现重复元素。<code>TreeSet</code> 是用 compareTo() 来判断重复元素的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>HashSet</code> 的原理比较简单，几乎全部借助于 <code>HashMap</code> 来实现的。即 <code>HashSet</code> 和 <code>HashMap</code> 是命运共同体，一荣俱荣，一损俱损。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;HashSet&lt;/code&gt; 是一个不允许存储重复元素的集合，它的实现比较简单，只要理解了 &lt;code&gt;HashMap&lt;/code&gt;，&lt;code&gt;HashSet&lt;/code&gt; 基本就没什么问题。&lt;/p&gt;&lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; 
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
      <category term="HashSet" scheme="https://muhouer.github.io/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList分析</title>
    <link href="https://muhouer.github.io/posts/5c1acfc0/"/>
    <id>https://muhouer.github.io/posts/5c1acfc0/</id>
    <published>2019-08-18T05:55:22.000Z</published>
    <updated>2019-08-18T05:55:45.850Z</updated>
    
    <content type="html"><![CDATA[<p><code>LinkedList</code> 底层是基于双向链表 <code>Deque</code> 实现的，也是实现了 <code>List</code> 接口，所以也拥有 List 的一些特点，出场率不高，了解一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>即类似如下形式：</p><p><code>first.prev == null &amp;&amp; first.next == a</code> &lt;——&gt; <code>a.prev = first&amp;&amp; a.next == last</code> &lt;——&gt; <code>last.prev == a &amp;&amp; last.next == null</code></p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>每次插入都是移动指针，和 <code>ArrayList</code> 的拷贝数组相比效率提升不少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>利用了双向链表的特性，使用空间来换取时间。如果索引值小于链表大小的一半，即 <code>index</code> 离链表头比较近，就从节点头部遍历，否则将从尾结点开始遍历。这就导致效率降低，特别是当 <code>index</code> 越接近 <code>size</code> 的中间值时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>LinkedList 插入，删除都是移动指针效率很高。</li><li>查找需要进行遍历查询，效率较低。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; 底层是基于双向链表 &lt;code&gt;Deque&lt;/code&gt; 实现的，也是实现了 &lt;code&gt;List&lt;/code&gt; 接口，所以也拥有 List 的一些特点，出场率不高，了解一下。&lt;/p&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashMap分析</title>
    <link href="https://muhouer.github.io/posts/9c86c04c/"/>
    <id>https://muhouer.github.io/posts/9c86c04c/</id>
    <published>2019-08-18T01:34:00.000Z</published>
    <updated>2019-08-18T06:07:55.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Map 这样的 <code>Key Value</code> 在软件开发中是非常经典的结构，常用于在内存中存放数据。Java 中最常用的 Map 有两种，首先是 HashMap ，其次是 ConcurrentHashMap 。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>从整个 HashMap 的声明可以看出它内部是基于<strong>数组</strong> + <strong>链表</strong>实现的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p><h3 id="基于-1-7"><a href="#基于-1-7" class="headerlink" title="基于 1.7"></a>基于 1.7</h3><p>HashMap 在 jdk1.7 中的数据结构图：<br><img src="/images/5cd1d2be77958.png" width="900px" height="600px" align="center"><br>首先来看 jdk1.7 中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//初始化桶大小，因为底层是数组，所以这是数组默认的大小。默认大小16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">//桶最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; <span class="comment">//真正存放数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;      <span class="comment">//存放key-value元素的个数</span></span><br><span class="line"><span class="keyword">int</span> threshold;           <span class="comment">//桶容量大小，可在初始化时显式指定，扩容判定threshold = capacity * loadFactor，默认为0.75 * 16 = 12</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;  <span class="comment">//负载因子，可在初始化时显式指定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个属性是在抽象类AbstractMap中定义的</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt;        keySet = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Map 在使用过程中不断的往里面存放数据，当数量达到了 threshold 就需要将当前容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。因此通常建议能<strong>提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗</strong>。</p></blockquote><p>根据代码可以看到其实真正存放数据的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p>这个数组，那么它又是如何定义的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry 是 HashMap 中的一个内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;     <span class="comment">// key，写入时的键</span></span><br><span class="line">    V value;         <span class="comment">// value，值</span></span><br><span class="line">    Entry&lt;K,V&gt; next; <span class="comment">// 用于实现链表结构，当有hash冲突，存储的下一个元素</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">// 当前 key 的 hashcode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> key;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">      V oldValue = value;</span><br><span class="line">      value = newValue;</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上即为 HashMap 的基本结构，接下来来看写入和获取方法：</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123; // 判断当前数组是否需要初始化。</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key == null) // 如果 key 为空，则 put 一个空值进去</span><br><span class="line">        return putForNullKey(value); // </span><br><span class="line">    int hash = hash(key); // 计算根据 key 计算出 hash 值------</span><br><span class="line">    int i = indexFor(hash, table.length); // 根据计算出的 hash 值定位出所在桶</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 如果桶是一个链表则，需要遍历判断</span><br><span class="line">        Object k;</span><br><span class="line">        // hash 值、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 桶是空的，说明当前位置没有数据存入</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i); // 新增一个 Entry 对象写入当前位置</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    // 初始容量是一个偶数，当 length-1 的时候，这个数的有效二进制位都是1。</span><br><span class="line">    // 只要保证了 h 的分散性就行。&amp;用来取mod运算，效率比%高。</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; // 判断是否需要扩容</span><br><span class="line">        resize(2 * table.length); // 两倍扩充</span><br><span class="line">        hash = (null != key) ? hash(key) : 0; // 当前的 key 重新 hash</span><br><span class="line">        bucketIndex = indexFor(hash, table.length); // 重新定位</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key); <span class="comment">// 根据 key 计算出 hash 值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; </span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123; <span class="comment">// 定位到具体的桶中</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">            <span class="keyword">return</span> e; <span class="comment">//  key 及 hash 值相等时候就返回对应的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回 null </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表死循环"><a href="#链表死循环" class="headerlink" title="链表死循环"></a>链表死循环</h4><p><a href="https://blog.csdn.net/xyh930929/article/details/84777301" target="_blank" rel="noopener">HashMap由并发引起的链表死循环</a></p><h3 id="基于-1-8"><a href="#基于-1-8" class="headerlink" title="基于 1.8"></a>基于 1.8</h3><p>HashMap 在 jdk1.7 的实现中有个明显缺点：</p><blockquote><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。</p></blockquote><p>因此 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 <code>O(logn)</code>。</p><p>话不多说，上🐎：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>和 1.7 大体上都差不多，还是有几个重要的区别：</p><ul><li><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</li><li><code>Entry</code> 修改为 <code>Node</code>。</li></ul><p>Node 的核心组成其实也是和 1.7 中的 Entry 一样，存放的都是 <code>key value hashcode next</code> 等数据。</p><h4 id="put-方法-1"><a href="#put-方法-1" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length; <span class="comment">// 当前桶为空，进行初始化（resize 中会判断是否进行初始化）</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 根据当前 key 的 hash 值定位到具体的桶中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 为空表明没有 Hash 冲突就直接在当前位置创建一个新桶</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 不为空，有 Hash 冲突</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p; <span class="comment">// 比较当前桶中的 key、key 的 hash 值与写入的 key 是否相等，相等就赋值给 e</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前桶为红黑树，那就要按照红黑树的方式写入数据</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果在遍历过程中找到 key 相同时直接退出遍历</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 存在相同的 key ，需要将值覆盖</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 判断是否需要进行扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="comment">// 将 key hash 之后取得所定位的桶</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断桶的第一个位置的 key 是否为查询的 key，是就直接返回 value。</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 红黑树</span></span><br><span class="line">                    <span class="comment">// 按照树的查找方式返回值</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">// 链表</span></span><br><span class="line">                    <span class="comment">// 按照链表的方式遍历匹配返回值</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 桶为空则直接返回 null </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>HashMap 在并发时可能出现的问题主要有三个方面：</p><ul><li><p>如果多个线程同时使用 put 方法添加元素，而且假设正好存在两个 put 的 key 发生了碰撞（根据 hash 值计算的 bucket 一样），那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程 put 的数据被覆盖。</p></li><li><p>如果多个线程同时检测到元素个数超过 threshold，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。</p></li></ul><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String key = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>强烈建议</code>使用第一种 EntrySet 进行遍历。第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。</p><blockquote><p>无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题）。</p></blockquote><p>因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 <code>java.util.concurrent</code> 包下，专门用于解决并发问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Map 这样的 &lt;code&gt;Key Value&lt;/code&gt; 在软件开发中是非常经典的结构，常用于在内存中存放数据。Java 中最常用的 M
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HashMap" scheme="https://muhouer.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>String分析</title>
    <link href="https://muhouer.github.io/posts/4a48cd1d/"/>
    <id>https://muhouer.github.io/posts/4a48cd1d/</id>
    <published>2019-08-18T01:31:00.000Z</published>
    <updated>2019-08-18T01:33:43.976Z</updated>
    
    <content type="html"><![CDATA[<p><code>String</code> 这个类是我们在写 Java 代码中用得最多的一个类，没有之一，今天我们就讲讲它。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>String</code> 并不是基本数据类型，而是一个对象，并且是不可变的对象。</p><p>查看源码就会发现 <code>String</code> 类为<code>final</code> 型的(当然也不可被继承)，而且通过查看 JDK 文档会发现几乎每一个修改 <code>String</code> 对象的操作，实际上都是创建了一个全新的 <code>String</code> 对象。</p><p><code>String</code> 类实现了 <code>Serializable</code>，<code>Comparable</code>，<code>CharSequence</code>接口，被 <code>final</code> 修饰。内部维护了一个字符数组。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">== <span class="comment">// 判断内容与地址是否相同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> <span class="comment">// 判断两个字符串内容是否相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> <span class="comment">// 忽略大小写，判断两个字符串内容是否相同，底层调用了regionMatches方法</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span> <span class="comment">// 判断字符序列和字符串内容是否相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span> <span class="comment">// 判断StringBuffer和字符串内容是否相同，实际上调用的是contentEquals方法</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> <span class="comment">// 按照字典大小比较两个字符串的大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span> <span class="comment">// 忽略大小写，按照字典大小比较两个字符串的大小，使用忽略大小写比较器</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断两个字符串部分内容是否相同，ignoreCase:是否忽略大小写，toffset:子字符串的偏移量，ooffset:参数字符串中子字符串的偏移量，len:比较的子字符串的长度</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 返回索引上的字符，索引从0开始</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> <span class="comment">// 从字符串开始检索字符(Unicode 码) ch，并返回第一次出现的位置，未出现返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch，<span class="keyword">int</span> fromIndex)</span> <span class="comment">// 从字符串的第fromIndex个字符开始检索字符(Unicode 码) ch，未出现返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> <span class="comment">// 从字符串检索字符(Unicode 码) ch最后一次出现的位置。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> <span class="comment">//从字符串的第fromIndex个字符检索字符(Unicode 码) ch最后一次出现的位置。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> <span class="comment">// 判断此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> <span class="comment">// 判断此字符串是否以指定前缀开始。</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> <span class="comment">// 判断此字符串是否以指定后缀结尾。</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串截取与替换"><a href="#字符串截取与替换" class="headerlink" title="字符串截取与替换"></a>字符串截取与替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> <span class="comment">// 返回一个新的字符串，是从beginIndex开始到length-1的串。</span></span></span><br><span class="line"><span class="function">String <span class="title">subString</span><span class="params">(<span class="keyword">int</span> beginIndex，<span class="keyword">int</span> endIndex)</span>------返回一个新的字符串，是从beginIndex开始到endIndex-1的串。</span></span><br><span class="line"><span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> <span class="comment">// 返回从beginIndex开始到endIndex-1的字符序列</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> <span class="comment">// 将字符串中的oldChar字符替换为newChar</span></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> <span class="comment">// 将字符串中的target字符序列替换为replacement序列</span></span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> <span class="comment">// 使用replacement替换第一个通过regex匹配到子串。</span></span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> <span class="comment">// 使用replacement替换所有通过regex匹配到子串。</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串其他常用方法"><a href="#字符串其他常用方法" class="headerlink" title="字符串其他常用方法"></a>字符串其他常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="comment">// 获取字符串长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="comment">// 判断字符串是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span> <span class="comment">// 判断字符串是否包含字符序列 s</span></span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span> <span class="comment">// 字符串拼接</span></span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span> <span class="comment">// 字符串去掉首尾空白</span></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">(Locale locale)</span> <span class="comment">// 字符串转大写</span></span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span> <span class="comment">// 字符串转小写</span></span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex)</span> <span class="comment">// 字符串分割</span></span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span> <span class="comment">// 字符串分割，多了结果阈值参数</span></span></span><br></pre></td></tr></table></figure><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>第一种方式是在常量池中直接拿对象，第二种是在堆内存空间创建一个新的对象。只要使用new方法，就需要创建新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Freya"</span>); <span class="comment">// 这句话创建了两个对象。</span></span><br></pre></td></tr></table></figure><p>首先，字符串“Freya”放入常量池，然后 new 了一个字符串“Freya”放入 Java 堆。字符串常量”Freya”在编译期就已经确定放入常量池，而 Java 堆上的”Freya”是在运行期初始化阶段才确定。然后 Java 栈中的 str 指向了 Java 堆中的 “Freya”。</p><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>字符串常量池是 JVM 实例全局共享的，全局只有一个。字符串常量池及到一个设计模式，叫“享元模式”，顾名思义 就是<strong>共享元素模式</strong>。也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素。</p><ul><li>直接使用双引号声明的 String 对象直接存储在字符串常量池。</li><li>不是双引号声明的，可以使用 <code>String.intern()</code> 方法，这是一个Native方法。如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"Freya"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String b = <span class="string">"Freya"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String c = <span class="keyword">new</span> String(<span class="string">"Freya"</span>);</span><br><span class="line">    String d = a.intern();</span><br><span class="line">    String e = <span class="string">"Freya"</span> + <span class="string">" 17"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String f = <span class="string">" 17"</span>;</span><br><span class="line">    String g = a + f; <span class="comment">//在堆上创建的新的对象</span></span><br><span class="line">    String h = <span class="string">"Freya 17"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line">    System.out.println(a == c); <span class="comment">//false</span></span><br><span class="line">    System.out.println(a == d); <span class="comment">//true</span></span><br><span class="line">    System.out.println(e == g); <span class="comment">//false</span></span><br><span class="line">    System.out.println(e == h); <span class="comment">//true</span></span><br><span class="line">    System.out.println(g == h); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变，可以使用StringBuilder或者StringBuffer。</p></blockquote><h2 id="String-对象的不可变性"><a href="#String-对象的不可变性" class="headerlink" title="String 对象的不可变性"></a>String 对象的不可变性</h2><p>打开 <code>String</code> 类源码，可以看到一句话:</p><blockquote><p>Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared.</p></blockquote><p>意思是 <code>String</code> 是个常量，创建之后就是不可变的。不可变的意思是不能改变对象内的成员变量，包括基本数据类型变量的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><h3 id="String-对象不可变性是如何实现的？"><a href="#String-对象不可变性是如何实现的？" class="headerlink" title="String 对象不可变性是如何实现的？"></a>String 对象不可变性是如何实现的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length); <span class="comment">// deep copy操作</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">     <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">        <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];</span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出：</p><ul><li>String 类被 final 修饰，不可继承。</li><li>String内部所有成员都设置为私有变量。</li><li>不存在value的setter方法。</li><li>将value和offset设置为final。</li><li>当传入可变数组value[]时，进行copy而不是直接将value[]复制给内部变量。</li><li>获取value时不是直接返回对象引用，而是返回对象的copy。</li></ul><h3 id="String-对象不可变性的优缺点"><a href="#String-对象不可变性的优缺点" class="headerlink" title="String 对象不可变性的优缺点"></a>String 对象不可变性的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p><strong>字符串常量池的需要</strong><br>字符串常量池可以将一些字符常量放在常量池中重复使用，避免每次都重新创建相同的对象、节省存储空间。但如果字符串是可变的，此时相同内容的String还指向常量池的同一个内存空间，当某个变量改变了该内存的值时，其他遍历的值也会发生改变。所以不符合常量池设计的初衷。</p></li><li><p><strong>线程安全考虑</strong><br>同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p></li><li><p><strong>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载</strong></p><p>譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</p></li><li><p><strong>支持hash映射和缓存</strong><br>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果有对String对象值改变的需求，那么会创建大量的String对象。</p><h2 id="String对象是否真的不可变"><a href="#String对象是否真的不可变" class="headerlink" title="String对象是否真的不可变"></a>String对象是否真的不可变</h2><p>虽然 String 对象将 value 设置为 final，并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>;</span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s); <span class="comment">//Hello World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">//Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="其他相关内容"><a href="#其他相关内容" class="headerlink" title="其他相关内容"></a>其他相关内容</h2><h3 id="substring-方法"><a href="#substring-方法" class="headerlink" title="substring 方法"></a>substring 方法</h3><p>在 JDK 1.6中，当调用 substring 方法的时候，会创建一个新的 String 对象，但是这个 String 的值仍然指向堆中的同一个字符数组。这两个对象中只有 count 和offset 的值是不同的。如果你有一个很长很长的字符串，但是当你使用 substring 进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 1.6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x.substring(x, y) + <span class="string">""</span></span><br></pre></td></tr></table></figure><p>以上问题在jdk 7+中得到解决。在jdk 7+ 中，substring方法会在堆内存中创建一个新的数组。其使用<code>new String</code>创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。</p><h3 id="String-valueOf和Integer-toString的区别"><a href="#String-valueOf和Integer-toString的区别" class="headerlink" title="String.valueOf和Integer.toString的区别"></a>String.valueOf和Integer.toString的区别</h3><p>我们有三种方式将一个int类型的变量变成呢过String类型，那么他们有什么区别？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">String i1 = <span class="string">""</span> + i; <span class="comment">//其实是String i1 = (new StringBuilder()).append(i).toString();，首先创建一个StringBuilder对象，然后再调用append方法，再调用toString方法。</span></span><br><span class="line">String i2 = String.valueOf(i); <span class="comment">//调用 Integer.toString(i)</span></span><br><span class="line">String i3 = Integer.toString(i);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;String&lt;/code&gt; 这个类是我们在写 Java 代码中用得最多的一个类，没有之一，今天我们就讲讲它。&lt;/p&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;co
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="String" scheme="https://muhouer.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList分析</title>
    <link href="https://muhouer.github.io/posts/b0d3e399/"/>
    <id>https://muhouer.github.io/posts/b0d3e399/</id>
    <published>2019-08-18T01:27:00.000Z</published>
    <updated>2019-08-18T01:33:09.325Z</updated>
    
    <content type="html"><![CDATA[<p><code>ArrayList</code> 实现于 <code>List</code>、<code>RandomAccess</code> 接口。可以插入空数据，也支持随机访问。</p><p><code>ArrayList</code> 相当于动态数据，其中最重要的两个属性分别是: <code>elementData</code> 数组，以及 <code>size</code> 大小。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 默认的初始化容量 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/** 空 ArrayList 实例共享的空数组实例 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/** 默认大小的空 ArrayList 实例共享的空数组实例，和 EMPTY_ELEMENTDATA 区分开 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 存储arraylist元素的数组缓冲区。</span></span><br><span class="line"><span class="comment"> * 任何使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空 ArrayList 实例，</span></span><br><span class="line"><span class="comment"> * 在首次添加元素时容量扩展到默认容量 DEFAULT_CAPACITY 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// 非私有以简化嵌套类访问</span></span><br><span class="line"><span class="comment">/** ArrayList包含的元素个数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123; <span class="comment">// 新建 initialCapacity 大小的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123; <span class="comment">// 采用 EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123; <span class="comment">// 采用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，和 EMPTY_ELEMENTDATA 区分开来</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-toArray-might-incorrectly-not-return-Object-see-6260652"><a href="#c-toArray-might-incorrectly-not-return-Object-see-6260652" class="headerlink" title="c.toArray might (incorrectly) not return Object[] (see 6260652)"></a>c.toArray might (incorrectly) not return Object[] (see 6260652)</h2><p>查看 <code>ArrayList(Collection&lt;? extends E&gt; c)</code> 构造函数时，有个注释 <strong>c.toArray might (incorrectly) not return Object[] (see 6260652)</strong>，具体什么意思呢？先看个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>));</span><br><span class="line">list.set(<span class="number">0</span>, <span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure><p>如果 ArrayList 的构造函数中没有类型检查的代码 <code>elementData.getClass() != Object[].class</code>，会导致其elementData 的实际类型是String[]，而不是 Object[]，所以当你将其中一个元素更换为 Object 元素时会报错，你可以试下如下代码，肯定会报 ArrayStoreException 的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>&#125;;</span><br><span class="line">arr[<span class="number">0</span>]=<span class="keyword">new</span> Object(); <span class="comment">// Causes ArrayStoreException,</span></span><br><span class="line">                     <span class="comment">// because you cannot put arbitrary Object into String[]</span></span><br></pre></td></tr></table></figure><p>主要问题出在 <code>Arrays.asList</code> 上面，<code>Arrays.asList</code> 返回的 ArrayList 实际上是内部类 ArrayList ，并不是我们经常使用的 <code>ArrayList</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>内部类 ArrayList 的 <code>toArray()</code> 使用的是 <code>clone</code> 方法，而我们经常使用的 <code>ArrayList</code> 的 <code>toArray()</code> 使用的是 <code>Arrays.copyOf()</code> 方法，具体差别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = <span class="keyword">new</span> ArrayList&lt;Object&gt;(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>)).toArray();</span><br><span class="line">System.out.println(arr.getClass()); <span class="comment">// class [Ljava.lang.Object; Object数组</span></span><br><span class="line">Object[] arr1 = Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>).toArray();</span><br><span class="line">System.out.println(arr1.getClass()); <span class="comment">// class [Ljava.lang.String; String 数组，操作不当会引起 ArrayStoreException</span></span><br></pre></td></tr></table></figure><p>关于 <code>Arrays.asList</code> 的一个坑 <a href="/posts/45d267df/" title="使用Java时的一些坑">使用Java时的一些坑</a></p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>在调用 <code>add()</code> 方法的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先进行扩容校验。</li><li>将插入的值放到尾部，并将 size + 1 。</li></ul><p>如果是调用 <code>add(index,e)</code> 在指定位置添加的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//复制，向后移动</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也是首先扩容校验。</li><li>接着对数据进行复制，目的是把 index 位置空出来放本次插入的数据，并将后面的数据向后移动一个位置。</li></ul><p>其实扩容最终调用的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是一个数组复制的过程。</p><p>由此可见 <code>ArrayList</code> 的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>由于 ArrayList 是基于动态数组实现的，所以并不是所有的空间都被使用。因此使用了 <code>transient</code> 修饰，可以防止被自动序列化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure><p>因此 ArrayList 自定义了序列化与反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="comment">//只序列化了被使用的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从实现中可以看出 ArrayList 只序列化了被使用的数据。</p><h2 id="ArrayList-VS-Vector"><a href="#ArrayList-VS-Vector" class="headerlink" title="ArrayList VS Vector"></a>ArrayList VS Vector</h2><p><code>Vector</code> 也是实现于 <code>List</code> 接口，底层数据结构和 <code>ArrayList</code> 类似，也是一个动态数组存放数据。不过是在 <code>add()</code> 方法的时候使用 <code>synchronized</code> 进行同步写数据，但是开销较大，所以 <code>Vector</code> 是一个同步容器并不是一个并发容器。</p><p>以下是 <code>add()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及指定位置插入数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 实现于 &lt;code&gt;List&lt;/code&gt;、&lt;code&gt;RandomAccess&lt;/code&gt; 接口。可以插入空数据，也支持随机访问。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 相当于动态数据，其中最重要的两个属
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ArrayList" scheme="https://muhouer.github.io/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式备忘</title>
    <link href="https://muhouer.github.io/posts/2c992fa9/"/>
    <id>https://muhouer.github.io/posts/2c992fa9/</id>
    <published>2019-08-17T15:54:00.000Z</published>
    <updated>2019-08-17T16:04:20.975Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子。</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式主要依赖于元字符. 元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>句号匹配任意单个字符除了换行符.</td></tr><tr><td>[ ]</td><td>字符种类. 匹配方括号内的任意字符.</td></tr><tr><td>[^ ]</td><td>否定的字符种类. 匹配除了方括号里的任意字符</td></tr><tr><td>*</td><td>匹配&gt;=0个重复的在*号之前的字符.</td></tr><tr><td>+</td><td>匹配&gt;=1个重复的+号前的字符.</td></tr><tr><td>?</td><td>标记?之前的字符为可选.</td></tr><tr><td>{n,m}</td><td>匹配num个大括号之前的字符 (n &lt;= num &lt;= m).</td></tr><tr><td>(xyz)</td><td>字符集, 匹配与 xyz 完全相等的字符串.</td></tr><tr><td>|</td><td>或运算符,匹配符号前或后的字符.</td></tr><tr><td>\</td><td>转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td></tr><tr><td>^</td><td>从开始行开始匹配.</td></tr><tr><td>$</td><td>从末端开始匹配.</td></tr></tbody></table><h2 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h2><p>正则表达式提供一些常用的字符集简写. 如下:</p><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>除换行符外的所有字符</td></tr><tr><td>\w</td><td>匹配所有字母数字, 等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td>\W</td><td>匹配所有非字母数字, 即符号, 等同于: <code>[^\w]</code></td></tr><tr><td>\d</td><td>匹配数字: <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配非数字: <code>[^\d]</code></td></tr><tr><td>\s</td><td>匹配所有空格字符, 等同于: <code>[\t\n\f\r\p{Z}]</code></td></tr><tr><td>\S</td><td>匹配所有非空格字符: <code>[^\s]</code></td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符</td></tr><tr><td>\p</td><td>匹配 CR/LF (等同于 <code>\r\n</code>)，用来匹配 DOS 行终止符</td></tr></tbody></table><h2 id="零宽度断言-前后预查"><a href="#零宽度断言-前后预查" class="headerlink" title="零宽度断言(前后预查)"></a>零宽度断言(前后预查)</h2><p>先行断言和后发断言都属于<strong>非捕获簇</strong>(不捕获文本 ，也不针对组合计进行计数). 先行断言用于判断所匹配的格式是否在另一个确定的格式之前, 匹配结果不包含该确定格式(仅作为约束).</p><p>例如, 我们想要获得所有跟在 <code>$</code> 符号后的数字, 我们可以使用正后发断言 <code>(?&lt;=\$)[0-9\.]*</code>. 这个表达式匹配 <code>$</code> 开头, 之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p><p>零宽度断言如下:</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>?=</td><td>正先行断言-存在</td></tr><tr><td>?!</td><td>负先行断言-排除</td></tr><tr><td>?&lt;=</td><td>正后发断言-存在</td></tr><tr><td>?&lt;!</td><td>负后发断言-排除</td></tr></tbody></table><h3 id="正先行断言"><a href="#正先行断言" class="headerlink" title="?=... 正先行断言"></a><code>?=...</code> 正先行断言</h3><p><code>?=...</code> 正先行断言, 表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式.</p><p>返回结果只包含满足匹配条件的第一部分表达式. 定义一个正先行断言要使用 <code>()</code>. 在括号内部使用一个问号和等号: <code>(?=...)</code>.</p><p>正先行断言的内容写在括号中的等号后面. 例如, 表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ,即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he(?=\sfat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h3 id="负先行断言"><a href="#负先行断言" class="headerlink" title="?!... 负先行断言"></a><code>?!...</code> 负先行断言</h3><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果, 筛选条件为 其后不跟随着断言中定义的格式. <code>正先行断言</code> 定义和 <code>负先行断言</code> 一样, 区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>.</p><p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>(空格)fat</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he(?!\sfat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h3 id="lt-正后发断言"><a href="#lt-正后发断言" class="headerlink" title="?&lt;= ... 正后发断言"></a><code>?&lt;= ...</code> 正后发断言</h3><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着断言中定义的格式. 例如, 表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(?&lt;=(T|t)he\s)(fat|mat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h3 id="lt-负后发断言"><a href="#lt-负后发断言" class="headerlink" title="?&lt;!... 负后发断言"></a><code>?&lt;!...</code> 负后发断言</h3><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟随着断言中定义的格式. 例如, 表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(?&lt;!(T|t)he\s)(cat)&quot; =&gt; The cat sat on cat.</span><br></pre></td></tr></table></figure><h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志也叫模式修正符, 因为它可以用来修改表达式的搜索结果. 这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写.</td></tr><tr><td>g</td><td>全局搜索.</td></tr><tr><td>m</td><td>多行的: 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始.</td></tr></tbody></table><h2 id="贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h2><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/(.*at)/&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/(.*?at)/&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>点击<a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">learn-regex</a>即可去查看更详细信息。</p><p><a href="https://jex.im/regulex/" target="_blank" rel="noopener">Regulex</a>是一个JavaScript 正则表达式解析和可视化网站。具体效果参看👇示例。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h3><p>只允许英文字母、数字、下划线、英文句号、以及中划线组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$</span><br></pre></td></tr></table></figure><img src="/images/201908171144.png" width="900px" height="300px" align="center"><h3 id="汉字"><a href="#汉字" class="headerlink" title="汉字"></a>汉字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[\u4e00-\u9fa5]&#123;0,&#125;$</span><br></pre></td></tr></table></figure><img src="/images/201908171151.png" width="900px" height="300px" align="center"><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br></pre></td></tr></table></figure><img src="/images/201908171153.png" width="900px" height="300px" align="center">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子。&lt;/p&gt;&lt;h2 id=&quot;元字符&quot;&gt;&lt;a href=&quot;#元字符&quot; class=&quot;headerlink&quot; title=&quot;元字符&quot;&gt;&lt;/a&gt;元字符&lt;/h2&gt;&lt;p&gt;正则表达式主要依赖于元字符
      
    
    </summary>
    
      <category term="备忘" scheme="https://muhouer.github.io/categories/%E5%A4%87%E5%BF%98/"/>
    
    
      <category term="正则表达式" scheme="https://muhouer.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>拾句-玩笑</title>
    <link href="https://muhouer.github.io/posts/25a3a536/"/>
    <id>https://muhouer.github.io/posts/25a3a536/</id>
    <published>2019-08-16T15:16:00.000Z</published>
    <updated>2019-08-16T15:19:54.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="001"><a href="#001" class="headerlink" title="001"></a>001</h3><hr><ol><li><strong>女大三抱金砖。女大三十送江山。女大三百送仙丹。</strong></li><li><strong>上帝是公平的，不是公的就是平的。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;001&quot;&gt;&lt;a href=&quot;#001&quot; class=&quot;headerlink&quot; title=&quot;001&quot;&gt;&lt;/a&gt;001&lt;/h3&gt;&lt;hr&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;女大三抱金砖。女大三十送江山。女大三百送仙丹。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="拾句" scheme="https://muhouer.github.io/categories/%E6%8B%BE%E5%8F%A5/"/>
    
    
      <category term="玩笑" scheme="https://muhouer.github.io/tags/%E7%8E%A9%E7%AC%91/"/>
    
  </entry>
  
  <entry>
    <title>一些名词</title>
    <link href="https://muhouer.github.io/posts/6bf34d15/"/>
    <id>https://muhouer.github.io/posts/6bf34d15/</id>
    <published>2019-08-12T13:45:00.000Z</published>
    <updated>2019-08-17T16:09:44.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="鞣酸"><a href="#鞣酸" class="headerlink" title="鞣酸"></a>鞣酸</h2><p>鞣酸系由五倍子中得到的一种鞣质。为黄色或淡棕色轻质无晶性粉末或鳞片；无臭，微有特殊气味，味极涩。溶于水及乙醇，易溶于甘油，几乎不溶于乙醚、氯仿或苯。其水溶液与铁盐溶液相遇变蓝黑色，加亚硫酸钠可延缓变色。在工业上，鞣酸被大量应用于鞣革与制造蓝墨水。鞣酸能使蛋白质凝固。人们把生猪皮、生牛皮用鞣酸进行化学处理，能使生皮中的可溶性蛋白质凝固。于是，本来放上几天就会发臭腐烂的生皮，变成了漂亮、干净、柔韧、经久耐用的皮革。</p><h2 id="选拔考试与诊断考试"><a href="#选拔考试与诊断考试" class="headerlink" title="选拔考试与诊断考试"></a>选拔考试与诊断考试</h2><p>选拔考试，类似于中考高考，你考多少分不重要，59分算高还是低无所谓，关键取决于别人考的怎么样，你考59分，别人都在58分以下，你就有机会读名校；你考59分，人家考95分，对不起，你就回家干活，这叫选拔考试。</p><p>除了中考高考以外，所有的考试都叫诊断考试（测验），即老师教了一个知识点，出一道题看看学生掌握得怎么样了。</p><h2 id="海姆立克急救法"><a href="#海姆立克急救法" class="headerlink" title="海姆立克急救法"></a>海姆立克急救法</h2><p>海姆立克教授是美国一位多年从事外科的医生。在临床实践中，他被大量的食物、异物窒息造成呼吸道梗阻致死的病例震惊了。在急救急诊中，医生常常采用拍打病人背部，或将手指伸进口腔咽喉去取的办法排除异物，其结果不仅无效反而使异物更深入呼吸道。他经过反复研究和多次的动物实验，终于发明了利用肺部残留气体，形成气流冲出异物的急救方法。1974年，他作了关于腹部冲击法解除气管异物的首次报告。</p><p>异物堵塞在呼吸道中的事情在我们的生活中并不少见，前段时间就出现了类似的案列。所以由于异物堵塞在呼吸道中引起的后果还是很严重的。海姆立克急救法也叫海姆里克腹部冲击法（Heimlich Maneuver），是美国医生海姆里克先生发明的，也称为海氏手技。</p><h3 id="成人"><a href="#成人" class="headerlink" title="成人"></a>成人</h3><p>如果是成人，救护者站在受害者身后，从背后抱住其腹部，双臂围环其腰腹部，一手握拳，拳心向内按压于受害人的肚脐和肋骨之间的部位；另一手成掌捂按在拳头之上，双手急速用力向里向上挤压，反复实施，直至阻塞物吐出为止。</p><h3 id="3岁以下孩子"><a href="#3岁以下孩子" class="headerlink" title="3岁以下孩子"></a>3岁以下孩子</h3><p>如果是3岁以下孩子，应该马上把孩子抱起来，一只手捏住孩子颧骨两侧，手臂贴着孩子的前胸，另一只手托住孩子后颈部，让其脸朝下，趴在救护人膝盖上。在孩子背上拍1-5次，并观察孩子是否将异物吐出。</p><h3 id="婴儿"><a href="#婴儿" class="headerlink" title="婴儿"></a>婴儿</h3><ol><li><strong>5次拍背法</strong>：将患者的身体扶于救护员的前臂上，头部朝下，救护员用手支撑伤病者头部及颈部；用另一手掌掌根在伤病者背部两肩胛骨之间拍击5次。</li><li><strong>5次压胸法</strong>：如果堵塞物仍未排除，实施5次压胸法。使患儿平卧，面向上，躺在坚硬的地面或床板上，抢救者跪下或立于其足侧,或取坐位，并使患儿骑在抢救者的两大腿上，面朝前。抢救者以两手的中指或食指，放在患儿胸廓下和脐上的腹部，快速向上重击压迫，但要刚中带柔。重复之，直至异物排出。</li></ol><h2 id="垃圾DNA"><a href="#垃圾DNA" class="headerlink" title="垃圾DNA"></a>垃圾DNA</h2><p>人类大约有95%的DNA并不编码蛋白质，另外5%的DNA可以分成大约十万个功能单位，它们被称为基因。</p><p>研究人员从对比结果中得到了一个惊人的模式：生物越复杂，垃圾DNA似乎就越重要。他们将酵母与更为复杂的蠕虫进行了比较，后者是一种多细胞生物，发现有40%的共有DNA没有被编码。随后，研究人员又将脊椎动物与昆虫进行了对比，这些生物比蠕虫更为复杂，结果发现，有超过66%的共有DNA包含有没有编码的DNA。</p><p>如果这些“垃圾DNA”序列能在电脑屏幕上展现出一个像素数组或一个简单的图像，那么，外星生物曾干预人类DNA的设想就极可能是真的。人类DNA可容纳“外星兴衰史”编码戴维斯称，人类的DNA编码足够容纳一部像样的小说，或者一段外星文明的兴盛和衰落简史。</p><p>垃圾DNA可以说是基因组的暗面，它将改变生物学的面貌，就像暗物质和暗能量改变宇宙学的面貌那样。它既不能给蛋白质编码、充当基因，也不能给RNA编码，也没有找到明显的与蛋白质等其他分子发生相互作用的迹象。当然，完全有可能它是行使了某种功能的，只不过是在“暗地下”进行，而我们还没有能力看到它行使功能的身影罢了。</p><p>这些同时存在于不同哺乳动物DNA序列当中的保守非基因序列的相似性，甚至比同源的编码蛋白质、或者是编码RNA的基因还强。对于其中同时在至少12种物种当中发现的保守非基因序列，如果比较它们的核苷酸排列差异的话，还不及它们的蛋白质编码序列的核苷酸排列差异的一半！</p><p>很多的“垃圾” DNA包含了回文结构，以此维持互补链之间的对称。在果蝇和家蚕里，对这些序列的分析表明，这些转座和散开的重复序列是高度非随机模式。这些模式反映出这些序列是在细胞调控之下，而不是无用或自私的垃圾DNA。 在关系很远的物种之间，例如大型偶蹄类哺乳动物和人，在主要组织相容性复合MHC-DRB基因里都有这些简单重复的(gt)n(ga)m DNA序列。如果这些序列真是垃圾，在数百万年的进化过程中就不可能保存下来。</p><p>另一个研究表明，DNA包含了大范围的不可解释模式。Eugene Stanley博士报道这些模式不是随机改变的结果。一个基因上的一个位置将影响到100万碱基之外的核苷酸，这真是让人难以置信。因而遗传学家Moran认为，L1在人类进化中扮演着重要角色——增加遗传多样性。在嗜酸粒细胞衍生神经毒素、嗜酸细胞阳离子蛋白、IgM重排基因的可变区域、α-球蛋白基因、微管蛋白基因、4-N-乙酰半乳糖氨基转移酶、醛缩酶B基因、乙醛还原酶基因k轻链基因等等,都有基因內增强作用的描述。</p><p>另一些研究证实非编码DNA作为沉默基因,对临近基因的转录起抑制作用。在成骨素基因、2-晶体蛋白基因、CD4基因、β-珠蛋白基因、神经胶质细胞粘连分子、神经元-神经胶质细胞粘连分子、血小板衍生的生长因子A链基因、肾素基因等等的研究中对此有描述。</p><h2 id="冒充者综合征"><a href="#冒充者综合征" class="headerlink" title="冒充者综合征"></a>冒充者综合征</h2><p>冒充者综合征是指有些人即使获得了一些成绩与成果，但却特别不自信，甚至认为这不是自己应得的，而是冒充那些真正厉害的人而得到的。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>大声说出这种 “冒名顶替” 的感受。</li><li>记下你的努力与成就。</li><li>设置合理的目标与期望。</li></ol><h2 id="劳伦斯魔咒"><a href="#劳伦斯魔咒" class="headerlink" title="劳伦斯魔咒"></a>劳伦斯魔咒</h2><p>1999年，经济学家劳伦斯总结出了一个“摩天大楼指数”。他发现，世界上所有的摩天大楼都与经济周期的波动有着紧密联系。摩天大厦的开工时间通常都是经济发展的鼎盛时期，而一旦大厦建成，经济危机便随之席卷而来。这一规律似乎屡试不爽，因此也被称为“劳伦斯魔咒”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;鞣酸&quot;&gt;&lt;a href=&quot;#鞣酸&quot; class=&quot;headerlink&quot; title=&quot;鞣酸&quot;&gt;&lt;/a&gt;鞣酸&lt;/h2&gt;&lt;p&gt;鞣酸系由五倍子中得到的一种鞣质。为黄色或淡棕色轻质无晶性粉末或鳞片；无臭，微有特殊气味，味极涩。溶于水及乙醇，易溶于甘油，几乎不溶于乙醚、氯
      
    
    </summary>
    
      <category term="日常记录" scheme="https://muhouer.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="名词" scheme="https://muhouer.github.io/tags/%E5%90%8D%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>如何优化缓存中百万级并发的key</title>
    <link href="https://muhouer.github.io/posts/2bc946e8/"/>
    <id>https://muhouer.github.io/posts/2bc946e8/</id>
    <published>2019-08-09T14:53:35.000Z</published>
    <updated>2019-08-09T15:15:30.491Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这个问题实际上就是热点key问题，其实热点key问题说来也很简单，就是瞬间有几十万上百万，甚至更大的请求去访问redis上某个固定的key，从而压垮缓存服务的情情况。<br>其实生活中也是有不少这样的例子，比如XX明星结婚。那么关于XX明星的Key就会瞬间增大，就会出现热点数据问题。</p><blockquote><p>PS:hot key和big key问题，大家一定要有所了解，非常重要。</p></blockquote><h2 id="热点Key问题"><a href="#热点Key问题" class="headerlink" title="热点Key问题"></a>热点Key问题</h2><p>上面提到，所谓热点key问题就是，突然有几十万甚至更大的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到Redis单实例瓶颈（一般是10W OPS级别），或者物理网卡上限，从而导致这台redis的服务器Hold不住。</p><p>那接下来这个key的请求，就会压垮你的服务。</p><h3 id="怎么发现热key"><a href="#怎么发现热key" class="headerlink" title="怎么发现热key"></a>怎么发现热key</h3><h4 id="方法一-凭借业务经验，进行预估哪些是热key"><a href="#方法一-凭借业务经验，进行预估哪些是热key" class="headerlink" title="方法一:凭借业务经验，进行预估哪些是热key"></a>方法一:凭借业务经验，进行预估哪些是热key</h4><p>其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。</p><h4 id="方法二-在客户端进行收集"><a href="#方法二-在客户端进行收集" class="headerlink" title="方法二:在客户端进行收集"></a>方法二:在客户端进行收集</h4><p>这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。</p><h4 id="方法三-在Proxy层做收集"><a href="#方法三-在Proxy层做收集" class="headerlink" title="方法三:在Proxy层做收集"></a>方法三:在Proxy层做收集</h4><p>有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。</p><p><img src="/images/201908091100.png" alt="upload successful"></p><h4 id="方法四-用redis自带命令"><a href="#方法四-用redis自带命令" class="headerlink" title="方法四:用redis自带命令"></a>方法四:用redis自带命令</h4><p>(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。</p><p>(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。</p><h4 id="方法五-自己抓包评估"><a href="#方法五-自己抓包评估" class="headerlink" title="方法五:自己抓包评估"></a>方法五:自己抓包评估</h4><p>Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。</p><p>以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>目前业内的方案有两种：</p><h3 id="二级缓存（推荐）"><a href="#二级缓存（推荐）" class="headerlink" title="二级缓存（推荐）"></a>二级缓存（推荐）</h3><p>比如利用ehcache，或者guava-cache，或者一个HashMap或者List都可以。在你发现热key以后，把热key加载到JVM中（可以是堆内，也可以是堆外）。针对这种热key请求，会直接从JVM中取，而不会走到redis层。</p><p>假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。现在假设，你的应用层有10台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有10000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。</p><h3 id="备份热点key"><a href="#备份热点key" class="headerlink" title="备份热点key"></a>备份热点key</h3><p>这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。<br>假设redis的集群数量为N，步骤如下图所示：<br><img src="/images/201908091101.png" alt="upload successful"></p><p>说明: 不一定是2N，你想取4N，8N都可以，看要求。伪代码如下:</p><p>说明：这种方案有一个很明显的缺点，就是缓存的维护代价非常大。假设有100个备份KEY，那么在删除或者更新时，也需要更新100个KEY，所以这种方案不是很推荐。<br>业内方案</p><p>OK，其实看完上面的内容，大家可能会有一个疑问。</p><h3 id="自动发信热点key，程序自动处理"><a href="#自动发信热点key，程序自动处理" class="headerlink" title="自动发信热点key，程序自动处理"></a>自动发信热点key，程序自动处理</h3><p>有办法在项目运行过程中，自动发现热点key，然后程序自动处理么？<br>嗯，好问题，那我们来讲讲业内怎么做的。其实只有两步：</p><ol><li>监控热点key</li><li>通知系统做处理</li></ol><p>正巧，前几天有赞出了一篇《有赞透明多级缓存解决方案（TMC）》，里头也有提到热点key问题，我们刚好借此说明。</p><p>(1) 监控热点key<br>在监控热点key方面，有赞用的是方式二：在客户端进行收集。</p><p>在<a href="https://segmentfault.com/a/1190000017142556?utm_source=tag-newest" target="_blank" rel="noopener">《有赞透明多级缓存解决方案（TMC）》</a>中有一句话提到</p><blockquote><p>TMC 对原生jedis包的JedisPool和Jedis类做了改造，在JedisPool初始化过程中集成TMC“热点发现”+“本地缓存”功能Hermes-SDK包的初始化逻辑。<br>也就说人家改写了jedis原生的jar包，加入了Hermes-SDK包。</p></blockquote><p>那Hermes-SDK包用来干嘛？OK，就是做热点发现和本地缓存。</p><p>从监控的角度看，该包对于Jedis-Client的每次key值访问请求，Hermes-SDK 都会通过其通信模块将key访问事件异步上报给Hermes服务端集群，以便其根据上报数据进行“热点探测”。</p><p>当然，这只是其中一种方式，有的公司在监控方面用的是方式五: 自己抓包评估。具体是这么做的，先利用flink搭建一套流式计算系统。然后自己写一个抓包程序抓redis监听端口的数据，抓到数据后往kafka里丢。</p><p>接下来，流式计算系统消费kafka里的数据，进行数据统计即可，也能达到监控热key的目的。</p><p>(2) 通知系统做处理<br>在这个角度，有赞用的是上面的解决方案一:利用二级缓存进行处理。<br>有赞在监控到热key后，Hermes服务端集群会通过各种手段通知各业务系统里的Hermes-SDK，告诉他们:”老弟，这个key是热key，记得做本地缓存。”</p><p>于是Hermes-SDK就会将该key缓存在本地，对于后面的请求。Hermes-SDK发现这个是一个热key，直接从本地中拿，而不会去访问集群。</p><p>除了这种通知方式以外。我们也可以这么做，比如你的流式计算系统监控到热key了，往zookeeper里头的某个节点里写。然后你的业务系统监听该节点，发现节点数据变化了，就代表发现热key。最后往本地缓存里写，也是可以的。</p><p>通知方式各种各样，大家可以自由发挥。本文只是提供一个思路。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望通过本文，大家明白如何处理生产上遇到的热key问题。</p><footer><strong>孤独烟</strong><cite><a href="https://mp.weixin.qq.com/s/cipWMjkBprbuRxZEb3a3vQ" target="_blank" rel="noopener">如何优化缓存中百万级并发的key</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;这个问题实际上就是热点key问题，其实热点key问题说来也很简单，就是瞬间有几十万上百万，甚至更大的请求去访问red
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Java时的一些坑</title>
    <link href="https://muhouer.github.io/posts/45d267df/"/>
    <id>https://muhouer.github.io/posts/45d267df/</id>
    <published>2019-08-09T14:27:00.000Z</published>
    <updated>2019-08-09T14:46:16.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Arrays-asList-存在的坑"><a href="#Arrays-asList-存在的坑" class="headerlink" title="Arrays.asList 存在的坑"></a>Arrays.asList 存在的坑</h3><p>阿里巴巴java开发规范说到使用工具类<code>Arrays.asList()</code>方法把数组转换成集合时，不能使用其修改集合相关的方法，它的<code>add</code>/<code>remove</code>/<code>clear</code>方法会抛出<code>UnsupportedOperationException</code>。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;F&quot;, &quot;r&quot;, &quot;e&quot;, &quot;y&quot;, &quot;a&quot;);</span><br><span class="line">//    list.clear();</span><br><span class="line">//    list.remove(&quot;a&quot;);</span><br><span class="line">      list.add(&quot;h&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上三个方法中任何一个都会报以下异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:148)</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:108)</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>点进去<code>Arrays.asList</code>，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SafeVarargs</span><br><span class="line">@SuppressWarnings(&quot;varargs&quot;)</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class="line">    return new ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>ArrayList</code> 并不是我们平时用的<code>ArrayList</code>。而是<code>Arrays</code>里面的一个内部类。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private static final long serialVersionUID = -2764017481108945198L;</span><br><span class="line">    private final E[] a;</span><br><span class="line"></span><br><span class="line">    ArrayList(E[] array) &#123;</span><br><span class="line">        a = Objects.requireNonNull(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return a.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object[] toArray() &#123;</span><br><span class="line">        return a.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        int size = size();</span><br><span class="line">        if (a.length &lt; size)</span><br><span class="line">            return Arrays.copyOf(this.a, size,</span><br><span class="line">                                 (Class&lt;? extends T[]&gt;) a.getClass());</span><br><span class="line">        System.arraycopy(this.a, 0, a, 0, size);</span><br><span class="line">        if (a.length &gt; size)</span><br><span class="line">            a[size] = null;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        return a[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E set(int index, E element) &#123;</span><br><span class="line">        E oldValue = a[index];</span><br><span class="line">        a[index] = element;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        E[] a = this.a;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; a.length; i++)</span><br><span class="line">                if (a[i] == null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; a.length; i++)</span><br><span class="line">                if (o.equals(a[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return indexOf(o) != -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliterator(a, Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void forEach(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        for (E e : a) &#123;</span><br><span class="line">            action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        E[] a = this.a;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = operator.apply(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">        Arrays.sort(a, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个内部类没有<code>add</code>，<code>clear</code>，<code>remove</code>方法，所以抛出的异常其实来自于<code>AbstractList</code>。点进去就会发现抛出异常的地方，clear底层也会调用到remove所以也会抛出异常。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h4><p><code>Arrays.asList()</code>底层其实还是数组。如果使用了<code>Arrays.asList()</code>的话，最好不要使用其集合的操作方法。如果想要使用，<code>List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;F&quot;, &quot;r&quot;, &quot;e&quot;, &quot;y&quot;, &quot;a&quot;))</code>可以在外面这样包一层真正的ArrayList。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Arrays-asList-存在的坑&quot;&gt;&lt;a href=&quot;#Arrays-asList-存在的坑&quot; class=&quot;headerlink&quot; title=&quot;Arrays.asList 存在的坑&quot;&gt;&lt;/a&gt;Arrays.asList 存在的坑&lt;/h3&gt;&lt;p&gt;阿里巴巴ja
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>一些金融概念</title>
    <link href="https://muhouer.github.io/posts/6b8c9691/"/>
    <id>https://muhouer.github.io/posts/6b8c9691/</id>
    <published>2019-08-09T14:11:00.000Z</published>
    <updated>2019-08-11T04:36:38.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Q-什么是戴维斯双击和戴维斯双杀？"><a href="#Q-什么是戴维斯双击和戴维斯双杀？" class="headerlink" title="Q: 什么是戴维斯双击和戴维斯双杀？"></a>Q: 什么是戴维斯双击和戴维斯双杀？</h3><ol><li>戴维斯双击: 在景气周期里，上市公司的业绩和估值同步上升。</li><li>戴维斯双杀: 在不景气周期里，上市公司的业绩和估值同步下降。</li></ol><h3 id="Q-什么是LOF基金？"><a href="#Q-什么是LOF基金？" class="headerlink" title="Q: 什么是LOF基金？"></a>Q: 什么是LOF基金？</h3><p>LOF基金（Listed Open-Ended Fund），也称为“上市型开放式基金”。投资者既可以通过一级市场开放式基金账户申购与赎回基金份额，也可以在证券交易所二级市场买卖基金。不过，投资者如果是通过一级市场开放式基金账户申购的基金份额，想要在交易所二级市场卖出，则须办理转托管手续；同样，如果是在交易所二级市场买进的基金份额，想要在一级市场赎回，也要办理转托管手续。</p><h3 id="Q-关于熊市大跌"><a href="#Q-关于熊市大跌" class="headerlink" title="Q: 关于熊市大跌"></a>Q: 关于熊市大跌</h3><p>“在过去70多年历史上发生的40次股市暴跌中，即使其中39次我提前预测到，而且在暴跌前卖掉了所有的股票，我最后也会后悔万分的。因为即使是跌幅最大的那次股灾，股价最终也涨回来了，而且涨得更高。”——基金经理，彼得林奇</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Q-什么是戴维斯双击和戴维斯双杀？&quot;&gt;&lt;a href=&quot;#Q-什么是戴维斯双击和戴维斯双杀？&quot; class=&quot;headerlink&quot; title=&quot;Q: 什么是戴维斯双击和戴维斯双杀？&quot;&gt;&lt;/a&gt;Q: 什么是戴维斯双击和戴维斯双杀？&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;戴维斯
      
    
    </summary>
    
      <category term="理财" scheme="https://muhouer.github.io/categories/%E7%90%86%E8%B4%A2/"/>
    
    
      <category term="金融概念" scheme="https://muhouer.github.io/tags/%E9%87%91%E8%9E%8D%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>拾句系列</title>
    <link href="https://muhouer.github.io/posts/53e650a7/"/>
    <id>https://muhouer.github.io/posts/53e650a7/</id>
    <published>2019-08-09T14:02:00.000Z</published>
    <updated>2019-08-09T14:09:30.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拾句系列1"><a href="#拾句系列1" class="headerlink" title="拾句系列1"></a>拾句系列1</h2><p>拾句系列主要记录平常生活和工作中遇到的一些句子，当时有点感触，特此记录一下。记录还会继续，不过，随着时间的流逝，可能也会删除一部分或做一些修改。</p><ol><li><a href="/posts/922764cc/" title="拾句-惊艳">拾句-惊艳</a></li><li><a href="/posts/497a5083/" title="拾句-爱">拾句-爱</a></li><li><a href="/posts/60ae6d78/" title="拾句-丧">拾句-丧</a></li><li><a href="/posts/4be8e193/" title="拾句-开解自己">拾句-开解自己</a></li><li><a href="/posts/70b9f430/" title="拾句-乐评">拾句-乐评</a></li><li><a href="/posts/a9bf165e/" title="拾句-现实">拾句-现实</a></li><li><a href="/posts/ef52fadf/" title="拾句-思考">拾句-思考</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;拾句系列1&quot;&gt;&lt;a href=&quot;#拾句系列1&quot; class=&quot;headerlink&quot; title=&quot;拾句系列1&quot;&gt;&lt;/a&gt;拾句系列1&lt;/h2&gt;&lt;p&gt;拾句系列主要记录平常生活和工作中遇到的一些句子，当时有点感触，特此记录一下。记录还会继续，不过，随着时间的流逝，可能
      
    
    </summary>
    
      <category term="拾句" scheme="https://muhouer.github.io/categories/%E6%8B%BE%E5%8F%A5/"/>
    
    
      <category term="汇总" scheme="https://muhouer.github.io/tags/%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>拾句-思考</title>
    <link href="https://muhouer.github.io/posts/ef52fadf/"/>
    <id>https://muhouer.github.io/posts/ef52fadf/</id>
    <published>2019-08-09T13:58:00.000Z</published>
    <updated>2019-08-17T16:12:32.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="001"><a href="#001" class="headerlink" title="001"></a>001</h3><hr><ol><li><strong>相比欧洲几个发达国家，美国在可物理感知的很多细节上都可以用粗砺来形容，但这是由美国的宏大以及持续变化的特性所决定的。相反，美国那不可见的核心是高度精致的， state-of-the-art.</strong>——饭否</li><li><strong>经营一段感情需要付出足够的时间和精力，而把握住一个稍纵即逝的机会，同样需要拿出全力以赴的姿态，否则，我们很有可能因为错失这一步，而错失整个向上发展的机会。</strong></li><li><strong>和身边的95后聊天，他们不约而同地提到未来希望能实现两点：财务自由、做自己喜欢的事。我问他们，什么是你们喜欢的事？然后就冷场了。</strong>——乐鼠老人</li><li><strong>某先森处于职业艰难时期，压力极大，拼尽全力。但他说，现在我做的工作是我从大一开始就梦寐以求的工作。那就好。</strong>——Rena518</li><li><strong>并不是说鸿蒙OS现在有多强大多完善多牛逼，而是鸿蒙OS的想象空间太大了，是真正的星辰大海。</strong></li><li><strong>家庭所灌输的理念，将在个体成长过程中不断地重复和强化，以致于成为一种集体信念。</strong></li><li><strong>被社会所远离的群体/人，露出真实身份时遭遇到的往往是恐慌和排斥。</strong></li><li><strong>只要不要脸，遍地是金钱。</strong></li><li><strong>刘邦此人好坏暂且不说，就这份心性，的确少有。厚黑也罢凉薄也罢，舍得二字在他这里解释的再清楚不过。</strong></li></ol><hr><h3 id="002"><a href="#002" class="headerlink" title="002"></a>002</h3><ol><li>*<em>Some youngster has signs said “make love, not war”, trouble is they don’t look like they were capable doing either. *</em>——里根</li><li><strong>Freedom is not free.</strong></li><li><strong>War is an ugly thing, but not the ugliest of things: the decayed and degraded state of moral and patriotic feeling which thinks that nothing is worth a war, is much worse.</strong>——约翰·斯图尔特·密尔</li><li><strong>问题来了：什么是所谓的“标准密码”呢？</strong></li><li><strong>人类是地球的“超级病毒”，而地球正在启动对人类的免疫反应。正如《血疫》中所说的那样，大自然有自我平衡的手段，它可能在试图除掉人类这种寄生生物的感染。</strong></li><li><strong>从长度来看，至少有三种较长的周期，中的是人一辈子可以经历若干轮的，长的是人一辈子大概正好经历一轮，超长的是人一辈子只能经历一个完整周期中的某个片断。</strong></li><li><strong>当他完成了自己的和解，也就完成了和世人的和解。</strong></li><li><strong>最牛逼的商业决策不能算小账，考虑投入产出比时不能受限于局部的所谓理性，因为它最后不仅影响你这个公司能赚多少钱，而且影响你这个国家的钱能值多少钱。</strong>——饭否</li><li><strong>格特鲁德·斯泰因（Gertrude Stein）临死前的问题：“答案是什么？”——她没有得到任何回答，然后又问道：“既然这样，问题是什么？”</strong></li></ol><hr><h3 id="003"><a href="#003" class="headerlink" title="003"></a>003</h3><hr><ol><li><strong>演化生物学诞生于1859年，以达尔文的《物种起源》发表为标志。但是，为什么长久以来把演化生物学应用到医学和其他与人类有关的科学中的进展如此迟缓？</strong></li><li><strong>1941年，所有这种细菌都可以被青霉素杀死。到1944年，已经出现了一些突变株能分解青霉素。到今天，95%的葡萄球菌都对青霉素有一定程度的耐药性。</strong></li><li><strong>对公众进行善意的道德劝诫即便受到欢迎，也很少有人会当真。要使人们为了公众利益合作，必须让不合作者付出代价。</strong>——迈特·瑞德利（Matt Ridley）和鲍比·娄（Bobbi Low）</li><li><strong>医学史反复证明，最容易染上致命性病原体的地方，不是妓院，也不是拥挤的血汗工厂，而是医院。</strong></li><li><strong>伪装（mimic）种和模型（model）种之间的一场竞赛：伪装种变得更像模型种，而模型种则变得尽可能与伪装种有区别。</strong></li><li><strong>很少接触毒素，那么一旦遭遇正常剂量的毒素，我们可能会措手不及。</strong></li><li><strong>在零星的知识岛屿周围，还是茫茫无际的未知海域。</strong></li><li><strong>我们遵循那些看似没有什么道理可言的文化习俗可能是十分明智的。</strong></li><li><strong>许多减肥食谱的原理就是：在只有少数几种食物供应时，我们吃得要比品种丰富时少一些。</strong></li></ol><hr><h3 id="004"><a href="#004" class="headerlink" title="004"></a>004</h3><hr><ol><li><strong>生活真正残酷的地方，不在于它的正面角色没有故事中那么好，而是它的反派角色并没有故事中那么坏。</strong></li><li><strong>思想上的完美主义者，大多是思想上的巨人，行动上的矮子，如果你是个完美主义者，至少要先跨出第一步。</strong></li><li><strong>认识了一个大牌投资公司里蛮不错的年轻人，他说将来如果出来创业，他会同时注册三个实体：第一个拍电影，第二个搞社区，第三个才是做投资。不要阿猫阿狗之类的案子都投，只投那些将来值得拍成电影的公司。</strong>——饭否</li><li><strong>正所谓“尽人事，待天命”。你是否已经用尽了全部力量？</strong></li><li><strong>一本科幻小说。主要情节是人类可以控制局部时间流速，为了生产更多粮食，在一个封闭的空间里使时间加速来生产粮食，结果里边的生物开始加速进化影响人类。</strong></li><li><strong>假设一年有<code>365</code>天，每天比前一天进步<code>1/365</code>，一年后就从 <code>1</code> 变成 <code>2.714567482021973</code>，十年后就会从 <code>1</code> 变成<code>21727.333146076744</code>，后者大概是前者的 <code>8004</code> 倍。这大概是我能想到的“你总是高估一年内可以做的事，也总是低估十年内能做到的事。”的数字化解释。</strong>——Muhouer</li><li><strong>“祖国终将选择那些选择了祖国的人”。</strong>——《如何在人生的马拉松中跑好清华这一程》，电机系教授于歆杰在清华2019级本科生开学典礼上的发言</li><li><strong>比「牺牲哪个人」或「牺牲哪个群体」更残酷的问题是「牺牲哪代人」？</strong></li><li><strong>失利不仅是一个结果，还是一个过程。</strong></li></ol><hr><h3 id="005"><a href="#005" class="headerlink" title="005"></a>005</h3><hr><ol><li><strong>机会与灾难总是相伴而生，有人把机会做成了灾难，也有人把灾难做成了机会。</strong></li><li><strong>生活的进程总是靠两类事件不断积累起来的——可控事件和不可控事件。而所谓规划，就是把精力的大部分聚焦于可控的部分，把这部分做好；而所谓成功，无非就是在这个基础上加上不可控因素的运气。</strong></li><li><strong>电话，邮件，现场约见，沙雕话术就是四个漏斗，每一层都过滤掉智商正常的人，最后留下的就是欠教育的。</strong></li><li><strong>人一旦起了贪念，智商就会被按在地上摩擦，不管智商再高也没用，贪心属于降维打击。</strong></li><li><strong>风险和收益从来就不成正比。时间和时间是不平等的。</strong></li><li><strong>我认识一个人，他每做一件小事都像抓住最后一根救命稻草，有一天我回头看他，嚯，好家伙，他已经怀抱着一棵让我仰望的苍天大树了！</strong></li><li><strong>科技行业有一个常识，你无法凭借同样的东西打败对手，取代安卓的也不是另外一个安卓。</strong></li><li><strong>在汉字里，十是10，廿是20，卅是30。如果“卅”字添上一横，就成了“丗”，表示30年。“丗”字还有另一个写法——“世”，一世就是30年。所以古人说恍如隔世，其实是如隔30年，即便在“车、马、邮件都慢”的从前，30年的变化也足以让人恍然。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;001&quot;&gt;&lt;a href=&quot;#001&quot; class=&quot;headerlink&quot; title=&quot;001&quot;&gt;&lt;/a&gt;001&lt;/h3&gt;&lt;hr&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;相比欧洲几个发达国家，美国在可物理感知的很多细节上都可以用粗砺来形容，但这是由美国的宏大以及持续变
      
    
    </summary>
    
      <category term="拾句" scheme="https://muhouer.github.io/categories/%E6%8B%BE%E5%8F%A5/"/>
    
    
      <category term="思考" scheme="https://muhouer.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>堆内存和栈内存</title>
    <link href="https://muhouer.github.io/posts/e896e76f/"/>
    <id>https://muhouer.github.io/posts/e896e76f/</id>
    <published>2019-08-07T15:12:00.000Z</published>
    <updated>2019-08-08T15:18:48.773Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Java</code>中，您会看到大量关于堆内存和栈内存的引用，<code>Java</code>把内存分成两种，一种叫做栈内存，一种叫做堆内存。</p><h2 id="Java-堆内存-Heap-Memory"><a href="#Java-堆内存-Heap-Memory" class="headerlink" title="Java 堆内存(Heap Memory)"></a>Java 堆内存(Heap Memory)</h2><p><code>Java</code>运行时会在堆内存中将内存分配给对象和子类。每当我们创建任何对象时，它总是在堆空间中创建的。</p><p>垃圾收集在堆内存上运行，以释放没有任何引用的对象使用的内存。堆空间中创建的任何对象都具有全局访问权限，可以从应用程序的任何位置引用。</p><h2 id="Java-栈内存-Stack-Memory"><a href="#Java-栈内存-Stack-Memory" class="headerlink" title="Java 栈内存(Stack Memory)"></a>Java 栈内存(Stack Memory)</h2><p>Java栈内存用于执行线程。它们包含短期存活的方法的特定值，以及堆中方法对其他对象的引用。</p><p>栈内存总是按后进先出顺序引用。每当调用一个方法时，都会在栈内存中创建一个新块，以便该方法保存本地基元值以及该方法对其他对象的引用。</p><p>一旦方法结束，该块就不再使用，就可用于下一个方法。与堆内存相比，栈内存非常小。</p><h2 id="Java-程序中的堆内存和栈内存"><a href="#Java-程序中的堆内存和栈内存" class="headerlink" title="Java 程序中的堆内存和栈内存"></a>Java 程序中的堆内存和栈内存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Line 1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// Line 2</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object(); <span class="comment">// Line 3</span></span><br><span class="line">        Memory mem = <span class="keyword">new</span> Memory(); <span class="comment">// Line 4</span></span><br><span class="line">        mem.foo(obj); <span class="comment">// Line 5</span></span><br><span class="line">    &#125; <span class="comment">// Line 9</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123; <span class="comment">// Line 6</span></span><br><span class="line">        String str = param.toString(); <span class="comment">//// Line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125; <span class="comment">// Line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了上述程序的堆栈内存的引用</p><p><img src="https://cdn.journaldev.com/wp-content/uploads/2014/08/Java-Heap-Stack-Memory.png" alt="img"></p><p>程序执行的过程如下：</p><ul><li>一旦程序开始运行，它将会加载所有运行时类到堆内存，第1行发现了main方法，Java Runtime 创建了栈内存给main方法线程使用。</li><li>第2行，我们创建了int型本地变量，它被创建并存储在栈内存的main方法里。</li><li>第3行，我们创建一个对象，它创建在堆内存，栈内存保存它的引用。Memory 对象类似。</li><li>第5行，我们调用foo方法，在栈内存头部创建一个内存块给foo方法使用，既然Java通过值传递，第6行，对象的新引用将在foo方法的栈内存块内创建。</li><li>第7行，创建了字符串，它将会进入堆中的字符串常量池，foo方法的栈空间内将创建一个它的引用。</li><li>foo方法在第8行终止。栈中分配的内存块将会被释放。</li><li>在第9行，main方法终止，分配给main方法的栈内存将会被销毁。同时，程序也在这一行结束，因此 Java Runtime将会释放所有内存，然后结束程序的执行。</li></ul><h2 id="堆内存和栈内存的区别"><a href="#堆内存和栈内存的区别" class="headerlink" title="堆内存和栈内存的区别"></a>堆内存和栈内存的区别</h2><ol><li>应用程序的所有地方都会使用堆内存，而只有线程的执行会使用栈内存。</li><li>当一个对象创建时，它存放在堆内存中，引用放在栈内存中。栈内存只包含本地原始变量和引用变量。</li><li>存放在堆内存的对象是全局的，而栈内存中的不能被其他线程获取。</li><li>栈中的内存管理是以后进先出的方式完成的，而堆内存中的内存管理更复杂，因为它是全局使用的。堆内存分为新生代、老年代等，更多信息可以参考Java 垃圾回收。</li><li>栈内存是短暂存在的，而堆内存从应用程序执行的开始到结束都是存在的。</li><li>我们可以使用<code>-Xms</code>和<code>-Xmx</code>来定义堆内存启动时的大小和内存最大值。可以使用<code>-Xss</code>去定义栈内存大小。</li><li>当栈内存被填满的时候，将会抛出 <code>java.lang.StackOverFlowError</code>，然而，当堆内存被填满的时候，它会抛出 <code>java.lang.OutOfMemoryError: Java Heap Space</code> 错误。</li><li>和堆内存大小相比，栈内存大小非常小。由于内存分配（LIFO）的简单性，与堆内存相比，栈内存非常快。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;中，您会看到大量关于堆内存和栈内存的引用，&lt;code&gt;Java&lt;/code&gt;把内存分成两种，一种叫做栈内存，一种叫做堆内存。&lt;/p&gt;&lt;h2 id=&quot;Java-堆内存-Heap-Memory&quot;&gt;&lt;a href=&quot;#Java-堆内存-Heap
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="堆栈内存" scheme="https://muhouer.github.io/tags/%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型与内存管理</title>
    <link href="https://muhouer.github.io/posts/1f8d140b/"/>
    <id>https://muhouer.github.io/posts/1f8d140b/</id>
    <published>2019-08-06T15:06:00.000Z</published>
    <updated>2019-08-08T15:22:40.009Z</updated>
    
    <content type="html"><![CDATA[<p>如果您想弄清楚<code>Java</code>垃圾回收的的工作原理，那么理解<code>JVM</code>内存模型以及<code>Java</code>内存管理非常重要。 今天我们将探讨一下<code>Java</code>中的内存管理、<code>JVM</code>内存的组成以及如何监控和进行垃圾回收调优。</p><h2 id="Java（JVM）内存模型"><a href="#Java（JVM）内存模型" class="headerlink" title="Java（JVM）内存模型"></a>Java（JVM）内存模型</h2><p><img src="https://cdn.journaldev.com/wp-content/uploads/2014/05/Java-Memory-Model-450x186.png" alt="Java Memory Model, JVM Memory Model, Memory Management in Java, Java Memory Management"></p><p>正如上图所示，<code>JVM</code>内存划分为多个不同部分。 从广义上讲，<code>JVM</code>堆内存内存在物理上分为两部分——新生代(<strong>Young Generation</strong>)和老年代(<strong>Old Generation</strong>)。</p><h2 id="Java-内存管理——年轻代"><a href="#Java-内存管理——年轻代" class="headerlink" title="Java 内存管理——年轻代"></a>Java 内存管理——年轻代</h2><p>年轻代是创建新对象的地方。 当年轻代被填满时，将会进行垃圾回收，称为<code>Minor GC</code>。 <code>Young Generation</code>分为三个部分——<code>Eden</code>内存空间和两个<code>Survivor</code>内存空间。</p><p>关于新生代(<strong>Young Generation</strong>)的要点：</p><ul><li>大多数新创建的对象都位于<code>Eden</code>内存空间中。</li><li>当<code>Eden</code>空间填满对象时，执行<code>Minor GC</code>并将所有幸存者对象移动到其中一个<code>Survivor</code>内存空间。</li><li><code>Minor GC</code>还会检查幸存者对象并将其移动到其他<code>Survivor</code>内存空间。 所以，在同一时间内，总有一个<code>Survivor</code>内存空间是空的。</li><li>在多次<code>GC</code>循环后幸存的对象将被移动到老年代(<strong>Old Generation</strong>)。 通常，新生代(<strong>Young Generation</strong>)对象达到设定的年龄阈值后才有资格晋升到老年代(<strong>Old Generation</strong>)。</li></ul><h2 id="Java-内存管理——老年代"><a href="#Java-内存管理——老年代" class="headerlink" title="Java 内存管理——老年代"></a>Java 内存管理——老年代</h2><p>老年代(<strong>Old Generation</strong>)包含在多次<code>Minor GC</code>循环之后长期存在并存活下来的对象。通常，当老年代(<strong>Old Generation</strong>)被填满后，也会执行垃圾回收，称为<code>Major GC</code>，通常花费时间较长。</p><h3 id="停顿-Stop-the-World-Event"><a href="#停顿-Stop-the-World-Event" class="headerlink" title="停顿(Stop the World Event)"></a>停顿(Stop the World Event)</h3><p>所有垃圾回收都是“<strong>Stop the World</strong>”事件，因为所有应用程序线程都会停止，直到操作完成。由于新生代(<strong>Young Generation</strong>)主要保存短暂存活的对象，因此<code>Minor GC</code>非常快，应用程序不会受此影响。</p><p>然而，<code>Major GC</code>需要花费很长时间，因为它会检查所有活动对象。 <code>Major GC</code>应该最小化，因为它会使您的应用程序在垃圾回收期间没有响应。 因此，如果您有响应式应用程序而且进行了大量<code>Major GC</code>，您会注意到超时错误。</p><p>垃圾收集器进行垃圾回收时持续的时间取决于采用的垃圾回收策略。为了避免高响应应用程序中的超时，很有必要去监控、调整垃圾收集器。</p><h3 id="Java-内存模型——永久代"><a href="#Java-内存模型——永久代" class="headerlink" title="Java 内存模型——永久代"></a>Java 内存模型——永久代</h3><p>永久代(<strong>Permanent Generation</strong>或<strong>Perm Gen</strong>)包含<code>JVM</code>描述应用程序中类和方法所需的应用程序元数据。 请注意，<strong>Perm Gen</strong>不是<code>Java</code>堆内存的一部分。</p><p><strong>Perm Gen</strong>在运行时，由<code>JVM</code>根据应用程序使用的类填充。 <strong>Perm Gen</strong>还包含Java SE库中的类和方法。 <strong>Perm Gen</strong>中的对象在完全垃圾回收(<strong>full garbage collection</strong>)中将会被回收。</p><h3 id="Java-内存模型——方法区"><a href="#Java-内存模型——方法区" class="headerlink" title="Java 内存模型——方法区"></a>Java 内存模型——方法区</h3><p>方法区(<strong>Method Area</strong>)属于<strong>Perm Gen</strong>一部分，用于存储类结构(运行时常量和静态变量)以及方法和构造函数的代码。</p><h3 id="Java-内存模型——内存池"><a href="#Java-内存模型——内存池" class="headerlink" title="Java 内存模型——内存池"></a>Java 内存模型——内存池</h3><p>内存池(<strong>Memory Pool</strong>)由<code>JVM</code>内存管理器创建，支持创建不可变对象( <strong>immutable object</strong>)池。比如 <code>String</code>池。 内存池可以属于<code>Java</code>堆内存或<strong>Perm Gen</strong>，具体取决于<code>JVM</code>内存管理器实现。</p><h3 id="Java-内存模型——运行时常量池"><a href="#Java-内存模型——运行时常量池" class="headerlink" title="Java 内存模型——运行时常量池"></a>Java 内存模型——运行时常量池</h3><p>运行时常量池(<strong>Runtime constant pool</strong>)是类中常量池的每类运行时表示形式。它包含类运行时常量和静态方法。 运行时常量池是方法区的一部分。</p><h3 id="Java-内存模型——栈内存"><a href="#Java-内存模型——栈内存" class="headerlink" title="Java 内存模型——栈内存"></a>Java 内存模型——栈内存</h3><p>Java栈内存(<strong>Stack Memory</strong>)用于执行线程。 它们包含方法特定的值，这些值是短暂存活的，并且引用了堆内存中被方法引用的其他对象。 <a href="/posts/e896e76f/" title="堆内存和栈内存">堆内存和栈内存</a></p><h2 id="Java-内存管理——Java-堆内存开关"><a href="#Java-内存管理——Java-堆内存开关" class="headerlink" title="Java 内存管理——Java 堆内存开关"></a>Java 内存管理——Java 堆内存开关</h2><p>Java提供了许多内存开关，我们可以用来设置内存大小和它们的比率。一些常用的内存开关是：</p><table><thead><tr><th align="left">VM SWITCH</th><th align="left">VM SWITCH DESCRIPTION</th></tr></thead><tbody><tr><td align="left">-Xms</td><td align="left">在 JVM 启动时设置初始堆内存大小。</td></tr><tr><td align="left">-Xmx</td><td align="left">设置堆内存空间大小的最大值。</td></tr><tr><td align="left">-Xmn</td><td align="left">设置新生代内存空间大小，剩下的空间大小就是老年代的内存空间大小。</td></tr><tr><td align="left">-XX:PermGen</td><td align="left">设置永久代初始内存空间大小</td></tr><tr><td align="left">-XX:MaxPermGen</td><td align="left">设置永久代内存空间大小的最大值。</td></tr><tr><td align="left">-XX:SurvivorRatio</td><td align="left">设置<code>Eden</code>内存空间和<code>Survivor</code>内存空间的比例，例如，如果新生代的空间大小是10M，而-XX:SurvivorRatio=2，那么<code>Eden</code>内存空间大小为5M，两个<code>Survivor</code>内存空间大小将分别为2.5M。-XX:SurvivorRatio 默认值为8。</td></tr><tr><td align="left">-XX:NewRatio</td><td align="left">设置老年代和新生代空间大小的比例。 默认值为 2.</td></tr></tbody></table><p>大多数情况下，上面的选项足够使用了，但是如果您想使用其他选项，可以参考<a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">JVM 选项</a>。</p><h2 id="Java-内存管理——垃圾回收"><a href="#Java-内存管理——垃圾回收" class="headerlink" title="Java 内存管理——垃圾回收"></a>Java 内存管理——垃圾回收</h2><p><code>Java</code>垃圾收集是从内存中标识、删除未使用对象以及释放空间的过程。 <code>Java</code>编程语言的特色之一是自动垃圾回收，与其他编程语言(如C)不同，它们的内存需要手动分配和释放。</p><p>垃圾收集器(<strong>Garbage Collector</strong>)是在后台运行的程序(守护线程)，它检查内存中的所有对象，并找出程序所有未被引用的对象。 然后删除所有未被引用的对象，并释放空间以分配给其他对象。</p><p>垃圾回收的一个简单实现可以分为三步：</p><ol><li><strong>标记</strong>——这是垃圾回收的第一步，将识别出哪些对象正在使用，哪些对象没有在使用。</li><li><strong>普通删除</strong>——垃圾收集器将删除未被使用的对象，然后回收内存空间分配给其他对象使用。</li><li><strong>压缩删除</strong>——为了获得更好的性能，在删除未被使用的对象后，可以将所有幸存的对象移动到一起。 这会提高给新对象分配内存时的性能。</li></ol><p>标记-删除方法的缺点</p><ol><li>它效率不高，因为大多数新创建的对象都将被闲置</li><li>在多个垃圾收集周期中使用的对象很有可能在未来的垃圾收集周期中继续使用。</li></ol><p>这是因为堆内存分为新生代(<strong>Young Generation</strong>)和老年代(<strong>Old Generation</strong>)，<code>Java</code>垃圾回收是分代的。 上文中已经解释过如何根据<code>Minor GC</code>和<code>Major GC</code>扫描对象并将其从一个空间移动到另一个空间。</p><h2 id="Java-内存管理——垃圾回收的类型"><a href="#Java-内存管理——垃圾回收的类型" class="headerlink" title="Java 内存管理——垃圾回收的类型"></a>Java 内存管理——垃圾回收的类型</h2><p>在应用程序中我们可以使用5种垃圾回收类型，我只需要调整<code>JVM</code>开关即可为我们的应用程序选择垃圾回收策略。</p><ol><li><strong>Serial GC (-XX:+UseSerialGC)</strong>: <strong>Serial GC</strong>使用简单的标记 - 清除 - 整理(<strong>mark-sweep-compact</strong>)方法用于新生代和老年代的垃圾回收，即<code>Minor GC</code>和<code>Major GC</code>。<strong>Serial GC</strong>在客户端机中非常有用，例如我们的应用程序比较独立，而且CPU比较小。 它适用于内存占用少的小型应用程序。</li><li><strong>Parallel GC (-XX:+UseParallelGC)</strong>: <strong>Parallel GC</strong>与<strong>Serial GC</strong>相同，不同的是<strong>Parallel GC</strong>使用N(N是系统中的CPU核心数)个线程进行新生代的垃圾回收。 我们可以使用<code>-XX：ParallelGCThreads = n</code>JVM 选项来控制线程数。并行垃圾收集器也称为吞吐量收集器，因为它使用多个 CPU 来提升 GC 性能。 <strong>Parallel GC</strong>使用单个线程进行老年代的垃圾回收。</li><li><strong>Parallel Old GC (-XX:+UseParallelOldGC)</strong>: 和<strong>Parallel GC</strong>相同，不同的是它采用多线程进行老年代和新生代的垃圾回收。</li><li><strong>Concurrent Mark Sweep (CMS) Collector (-XX:+UseConcMarkSweepGC)</strong>: CMS收集器也称为并发低暂停收集器。 在老年代进行垃圾回收时，CMS收集器尝试通过与应用程序线程同时执行大多数垃圾收集工作来最小化由于垃圾收集而导致的暂停。<br>新生代的CMS收集器与并行收集器使用相同的算法。 此垃圾收集器适用于我们无法忍受暂停时间过长的响应式应用程序。 我们可以使用<code>-XX:ParallelCMSThreads=n</code>JVM选项调整CMS收集器中的线程数 。</li><li><strong>G1 Garbage Collector (-XX:+UseG1GC)</strong>: <strong>Garbage First</strong> 或<strong>G1</strong>垃圾收集器从 Java 7 开始支持，它的目标是取代<strong>CMS收集器</strong>。 <strong>G1</strong>收集器是并行，并发和增量压缩的低暂停垃圾收集器。<strong>G1</strong>收集器不像其他收集器那样工作，并且没有新生代和老年代的概念。 它将堆空间划分为多个大小相等的堆区域。 当进行垃圾回收时，它首先收集具有较少实时数据的区域，因此称为“<strong>Garbage First</strong>”。 您可以在<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/G1.html" target="_blank" rel="noopener">Oracle Garbage-First Collector 文档</a>中找到有关它的更多详细信息。</li></ol><h2 id="Java-内存管理——Java-垃圾回收监控"><a href="#Java-内存管理——Java-垃圾回收监控" class="headerlink" title="Java 内存管理——Java 垃圾回收监控"></a>Java 内存管理——Java 垃圾回收监控</h2><p>我们可以使用Java命令行以及UI工具来监视应用程序的垃圾收集活动。</p><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>我们可以使用<code>jstat</code>命令行工具来监控<code>JVM</code> 内存和垃圾收集活动。 它适配标准<code>JDK</code>，因此您无需执行任何其他操作即可使用它。</p><p>在使用<code>jstat</code>命令之前，你需要知道 Java 应用的进程id。你可以使用<code>ps -ef | grep java</code>命令来获取进程id。假如我的进程id是9582，那么我就可以使用<code>jstat -gc 9582 1000</code>来查看垃圾回收的信息。命令中最后一个参数是每个输出之间的时间间隔，因此它将每1秒打印一次内存和垃圾收集数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstat -gc 9582 1000</span></span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">1024.0 1024.0  0.0    0.0    8192.0   7933.3   42108.0    23401.3   20480.0 19990.9    157    0.274  40      1.381    1.654</span><br><span class="line">1024.0 1024.0  0.0    0.0    8192.0   8026.5   42108.0    23401.3   20480.0 19990.9    157    0.274  40      1.381    1.654</span><br><span class="line">1024.0 1024.0  0.0    0.0    8192.0   8030.0   42108.0    23401.3   20480.0 19990.9    157    0.274  40      1.381    1.654</span><br><span class="line">1024.0 1024.0  0.0    0.0    8192.0   8122.2   42108.0    23401.3   20480.0 19990.9    157    0.274  40      1.381    1.654</span><br><span class="line">1024.0 1024.0  0.0    0.0    8192.0   8171.2   42108.0    23401.3   20480.0 19990.9    157    0.274  40      1.381    1.654</span><br><span class="line">1024.0 1024.0  48.7   0.0    8192.0   106.7    42108.0    23401.3   20480.0 19990.9    158    0.275  40      1.381    1.656</span><br><span class="line">1024.0 1024.0  48.7   0.0    8192.0   145.8    42108.0    23401.3   20480.0 19990.9    158    0.275  40      1.381    1.656</span><br></pre></td></tr></table></figure><p>每一列的含义如下：</p><ul><li><strong>S0C and S1C</strong>: Survivor0 和 Survivor1当前的内存大小，以 KB 计。</li><li><strong>S0U and S1U</strong>: Survivor0 和 Survivor1当前已使用的内存大小，以 KB 计。注意其中一个 survivor 一直是空的。</li><li><strong>EC and EU</strong>: Eden 区当前的内存大小和 Eden 区当前已使用的内存大小，以 KB 计。注意 EU 的大小会一直增大直到接近EC的大小，此时会执行Minor GC，然后EU 的大小就降低了。</li><li><strong>OC and OU</strong>: 老年代当前的大小和已使用的大小，以 KB 计。</li><li><strong>PC and PU</strong>: 永久代当前的大小和已使用的大小，以 KB 计。</li><li><strong>YGC and YGCT</strong>: YGC 代表在新生代 GC 发生的次数；YGCT 代表新生代执行GC的累计时间。注意，这两个值都在同一行中增加，因为 Minor GC 会使得 EU 值下降。</li><li><strong>FGC and FGCT</strong>: FGC 代表 Full GC 发生的次数；FGCT Full GC 发生的累计时间。 注意，与新生代 GC 相比， Full GC 花费时间太长。</li><li><strong>GCT</strong>: GC 操作的总累计时间。注意，它是 YGCT 和 FGCT 列值的总和。</li></ul><p><code>jstat</code>的优点是它也可以在没有 GUI 的远程服务器上执行。请注意，根据<code>-xmn10m</code>jvm选项的限制，S0C、S1C和EC的总和为10M。</p><h3 id="可视化的-Java-VisualVM"><a href="#可视化的-Java-VisualVM" class="headerlink" title="可视化的 Java VisualVM"></a>可视化的 Java VisualVM</h3><p>如果您想在GUI中看到内存和GC操作，那么可以使用<code>jvisualvm</code>工具。Java VisualVM也是JDK的一部分，不需要单独下载。</p><p>只需在终端中运行<code>jvisualvm</code>命令即可启动Java VisualVM应用程序。启动后，您需要从tools -&gt; plugins 选项安装VisualGC插件，如下图所示。</p><p><img src="https://cdn.journaldev.com/wp-content/uploads/2014/05/VisualVM-Visual-GC-Plugin-450x271.png" alt="VisualVM-Visual-GC-Plugin"></p><p>安装完VisualGC之后，只需打开左侧列中的应用程序，然后转到VisualGC部分。您将得到一个JVM内存和垃圾收集细节的映像，如下图所示。</p><p><img src="https://cdn.journaldev.com/wp-content/uploads/2014/05/Serial-GC-VisualGC-450x271.png" alt="Serial-GC-VisualGC"></p><h2 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h2><p>Java垃圾回收调优应该是提高应用程序吞吐量的最后选项，只有当GC时间较长导致应用程序超时时，才看到性能下降。</p><p>假如你在日志中看到<code>java.lang.OutOfMemoryError: PermGen space</code>错误，你可以通过<code>-XX:PermGen和-XX:MaxPermGen</code>来监控和提供永久代内存。你也可以使用<code>-XX:+CMSClassUnloadingEnabled</code>，然后观察在CMS 垃圾收集器的性能。</p><p>假如你看到很多 Full GC 操作，你可以提高老年代内存大小。</p><p>总的来说，垃圾回收调优需要花费大量的精力和时间，而且没有硬性和快速的规则。您需要尝试不同的选项并进行比较，从中找出最适合您的选项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果您想弄清楚&lt;code&gt;Java&lt;/code&gt;垃圾回收的的工作原理，那么理解&lt;code&gt;JVM&lt;/code&gt;内存模型以及&lt;code&gt;Java&lt;/code&gt;内存管理非常重要。 今天我们将探讨一下&lt;code&gt;Java&lt;/code&gt;中的内存管理、&lt;code&gt;JVM&lt;/code&gt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java内存模型" scheme="https://muhouer.github.io/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis进阶教程</title>
    <link href="https://muhouer.github.io/posts/c275b75f/"/>
    <id>https://muhouer.github.io/posts/c275b75f/</id>
    <published>2019-08-05T16:29:00.000Z</published>
    <updated>2019-08-05T17:33:59.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-数据备份与恢复"><a href="#Redis-数据备份与恢复" class="headerlink" title="Redis 数据备份与恢复"></a>Redis 数据备份与恢复</h2><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p>Redis <code>save</code> 命令用于创建当前数据库的备份。该命令将在 redis 安装目录中创建dump.rdb文件。</p><p>创建 redis 备份文件也可以使用命令 <code>bgsave</code>，该命令在后台执行。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>save</code></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; save </span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用<code>config</code>命令，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) &quot;dir&quot;</span><br><span class="line">2) &quot;/usr/local/redis-5.0.5/src&quot;</span><br></pre></td></tr></table></figure><h2 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h2><p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。</p><p>默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><code>auth password</code></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; config set requirepass &quot;redis&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h2 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h2><p>Redis 性能测试是通过同时执行多个命令实现的。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p><code>redis-benchmark [option] [option value]</code></p><p>注意：该命令是在 redis 的目录下执行的，而不是 redis<br>客户端的内部指令。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>同时执行 10000 个请求来检测性能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-benchmark -n 10000 -q</span><br><span class="line">PING_INLINE: 104166.66 requests per second</span><br><span class="line">PING_BULK: 106382.98 requests per second</span><br><span class="line">SET: 105263.16 requests per second</span><br><span class="line">GET: 105263.16 requests per second</span><br><span class="line">INCR: 103092.78 requests per second</span><br><span class="line">LPUSH: 106382.98 requests per second</span><br><span class="line">RPUSH: 105263.16 requests per second</span><br><span class="line">LPOP: 108695.65 requests per second</span><br><span class="line">RPOP: 102040.82 requests per second</span><br><span class="line">SADD: 106382.98 requests per second</span><br><span class="line">HSET: 107526.88 requests per second</span><br><span class="line">SPOP: 97087.38 requests per second</span><br><span class="line">LPUSH (needed to benchmark LRANGE): 101010.10 requests per second</span><br><span class="line">LRANGE_100 (first 100 elements): 106382.98 requests per second</span><br><span class="line">LRANGE_300 (first 300 elements): 109890.11 requests per second</span><br><span class="line">LRANGE_500 (first 450 elements): 107526.88 requests per second</span><br><span class="line">LRANGE_600 (first 600 elements): 99009.90 requests per second</span><br><span class="line">MSET (10 keys): 101010.10 requests per second</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">序号</th><th align="left">选项</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>-h</strong></td><td align="left">指定服务器主机名</td><td align="left">127.0.0.1</td></tr><tr><td align="left">2</td><td align="left"><strong>-p</strong></td><td align="left">指定服务器端口</td><td align="left">6379</td></tr><tr><td align="left">3</td><td align="left"><strong>-s</strong></td><td align="left">指定服务器 socket</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"><strong>-c</strong></td><td align="left">指定并发连接数</td><td align="left">50</td></tr><tr><td align="left">5</td><td align="left"><strong>-n</strong></td><td align="left">指定请求数</td><td align="left">10000</td></tr><tr><td align="left">6</td><td align="left"><strong>-d</strong></td><td align="left">以字节的形式指定 SET/GET 值的数据大小</td><td align="left">2</td></tr><tr><td align="left">7</td><td align="left"><strong>-k</strong></td><td align="left">1=keep alive 0=reconnect</td><td align="left">1</td></tr><tr><td align="left">8</td><td align="left"><strong>-r</strong></td><td align="left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left"><strong>-P</strong></td><td align="left">通过管道传输<code>&lt;numreq&gt;</code>请求</td><td align="left">1</td></tr><tr><td align="left">10</td><td align="left"><strong>-q</strong></td><td align="left">强制退出 redis。仅显示 query/sec 值</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left"><strong>–csv</strong></td><td align="left">以 CSV 格式输出</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left"><strong>-l</strong></td><td align="left">生成循环，永久执行测试</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left"><strong>-t</strong></td><td align="left">仅运行以逗号分隔的测试命令列表。</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left"><strong>-I</strong></td><td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td><td align="left"></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q</span><br><span class="line">SET: 104166.66 requests per second</span><br><span class="line">LPUSH: 105263.16 requests per second</span><br></pre></td></tr></table></figure><p>以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。</p><h2 id="Redis-客户端连接"><a href="#Redis-客户端连接" class="headerlink" title="Redis 客户端连接"></a>Redis 客户端连接</h2><p>Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：</p><ol><li>首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。</li><li>然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法</li><li>然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送</li></ol><p>Socket编程中，TCP_NODELAY选项是用来控制是否开启Nagle算法，该算法是为了提高较慢的广域网传输效率，减小小分组的报文个数，完整描述：</p><blockquote><p>该算法要求一个TCP连接上最多只能有一个未被确认的小分组，在该小分组的确认到来之前，不能发送其他小分组。</p></blockquote><h3 id="最大连接数"><a href="#最大连接数" class="headerlink" title="最大连接数"></a>最大连接数</h3><p>在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。</p><p>maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxclients</span><br><span class="line">1) "maxclients"</span><br><span class="line">2) "10000"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-server --maxclients 100000 <span class="comment"># 在服务启动时设置最大连接数为 100000</span></span></span><br></pre></td></tr></table></figure><h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h3><table><thead><tr><th align="left">序号</th><th align="left">命令</th><th align="left">描述</th><th>可用版本</th><th>时间复杂度</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>client list</strong></td><td align="left">以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据。返回的信息含义参见</td><td>&gt;=2.4.0</td><td>O(N)， N 为连接到服务器的客户端数量。</td></tr><tr><td align="left">2</td><td align="left"><strong>client setname</strong></td><td align="left">1. 为当前连接分配一个名字。这个名字会显示在<code>client list</code>命令的结果中， 用于识别当前正在与服务器进行连接的客户端。获取通过<code>client setname</code> 命令设置的服务名称。<br>2. 名字使用 Redis 的字符串类型来保存， 最大可以占用 512 MB 。<br>3. 另外， 为了避免和<code>client list</code>命令的输出格式发生冲突， 名字里不允许使用空格。<br>4. 要移除一个连接的名字， 可以将连接的名字设为空字符串 <code>&quot;&quot;</code> 。<br>5. 新创建的连接默认是没有名字的。在 Redis 应用程序发生连接泄漏时，为连接设置名字是一种很好的 debug 手段。</td><td>&gt;=2.6.9</td><td>O(1)</td></tr><tr><td align="left">3</td><td align="left"><strong>client getname</strong></td><td align="left">返回<code>client getname</code>命令为连接设置的名字。因为新创建的连接默认是没有名字的， 对于没有名字的连接， <code>client getname</code>返回空白回复。</td><td>&gt;=2.6.9</td><td>O(1)</td></tr><tr><td align="left">4</td><td align="left"><strong>client pause</strong></td><td align="left">挂起客户端连接，指定挂起的时间以毫秒计</td><td>&gt;=2.9.5</td><td>O(1)</td></tr><tr><td align="left">5</td><td align="left"><strong>client kill</strong></td><td align="left">当指定的客户端存在，且被成功关闭时，返回 OK 。关闭地址为 <code>ip:port</code> 的客户端。<code>ip:port</code> 应该和<code>client-list)</code>命令输出的其中一行匹配。因为 Redis 使用单线程设计，所以当 Redis 正在执行命令的时候，不会有客户端被断开连接。</td><td>&gt;=2.4.0</td><td>O(N) ， N 为已连接的客户端数量。</td></tr><tr><td align="left">6</td><td align="left"><strong>client id</strong></td><td align="left">返回当前连接的id</td><td>&gt;=5.0.0</td><td>O(1)</td></tr></tbody></table><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client getname</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; client setname freya-connection</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; client getname</span><br><span class="line">"freya-connection"</span><br><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=7 addr=127.0.0.1:56661 fd=8 name= age=265815 idle=261969 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribe</span><br><span class="line">id=1012 addr=127.0.0.1:51537 fd=9 name=freya-connection age=647 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client setname    # 只用空格是不行的！</span><br><span class="line">(error) ERR Unknown subcommand or wrong number of arguments for 'setname'. Try CLIENT HELP</span><br><span class="line">127.0.0.1:6379&gt; client setname ""  # 必须双引号显示包围</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; client getname</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=7 addr=127.0.0.1:56661 fd=8 name= age=265951 idle=262105 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribe</span><br><span class="line">id=1012 addr=127.0.0.1:51537 fd=9 name= age=783 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="Redis-client-list-命令返回值"><a href="#Redis-client-list-命令返回值" class="headerlink" title="Redis client list 命令返回值"></a>Redis <code>client list</code> 命令返回值</h4><p>命令返回多行字符串，这些字符串按以下形式被格式化：</p><ol><li>每个已连接客户端对应一行（以 LF 分割）</li><li>每行字符串由一系列 <strong>属性=值</strong> 形式的域组成，每个域之间以空格分开</li></ol><p>以下是域的含义：</p><table><thead><tr><th>域</th><th>含义</th></tr></thead><tbody><tr><td><code>addr</code></td><td>客户端的地址和端口</td></tr><tr><td><code>fd</code></td><td>套接字所使用的文件描述符</td></tr><tr><td><code>age</code></td><td>以秒计算的已连接时长</td></tr><tr><td><code>idle</code></td><td>以秒计算的空闲时长</td></tr><tr><td><code>flags</code></td><td>客户端flag(见下表)</td></tr><tr><td><code>db</code></td><td>该客户端正在使用的数据库ID</td></tr><tr><td><code>sub</code></td><td>已订阅频道的数量</td></tr><tr><td><code>psub</code></td><td>已订阅模式的数量</td></tr><tr><td><code>multi</code></td><td>在事务中被执行的命令数量</td></tr><tr><td><code>qbuf</code></td><td>查询缓存的长度(0 表示没有查询在等待)</td></tr><tr><td><code>qbuf-free</code></td><td>查询缓存的剩余空间(0 表示没有剩余空间)</td></tr><tr><td><code>obl</code></td><td>输出缓存的长度</td></tr><tr><td><code>oll</code></td><td>输出列表的长度(当输出缓存没有剩余空间时，回复被入队到这个队列里)</td></tr><tr><td><code>omem</code></td><td>输出缓存的内存占用量</td></tr><tr><td><code>events</code></td><td>文件描述符事件(见下文)</td></tr><tr><td><code>cmd</code></td><td>最近一次执行的命令</td></tr></tbody></table><p>客户端 flag 可以由以下部分组成：</p><table><thead><tr><th>域</th><th>含义</th></tr></thead><tbody><tr><td><code>O</code></td><td>客户端是 monitor 模式下的附属节点 (slave)</td></tr><tr><td><code>S</code></td><td>客户端是一般模式下 (normal) 的附属节点</td></tr><tr><td><code>M</code></td><td>客户端是主节点 (master)</td></tr><tr><td><code>x</code></td><td>小写<code>x</code>，客户端正在执行事务</td></tr><tr><td><code>b</code></td><td>客户端正在等待阻塞事件</td></tr><tr><td><code>i</code></td><td>客户端正在等待 VM I/O 操作 (已废弃)</td></tr><tr><td><code>d</code></td><td>一个受监控 (watched) 的键已被修改， <code>exec</code>命令将失败</td></tr><tr><td><code>c</code></td><td>在将回复完整写出来之后，关闭连接</td></tr><tr><td><code>u</code></td><td>客户端未被阻塞 (unblocked)</td></tr><tr><td><code>A</code></td><td>尽可能快地关闭连接</td></tr><tr><td><code>N</code></td><td>未设置任何 flag</td></tr></tbody></table><p>文件描述符事件</p><table><thead><tr><th>文件描述符事件</th><th>含义</th></tr></thead><tbody><tr><td><code>r</code></td><td>客户端套接字（在事件 loop 中）是可读的（readable）</td></tr><tr><td><code>w</code></td><td>客户端套接字（在事件 loop 中）是可写的（writeable）</td></tr></tbody></table><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>为了 debug 的需要，经常会对域进行添加和删除，一个安全的 Redis 客户端应该可以对 CLIENT LIST 的输出进行相应的处理（parse），比如忽略不存在的域，跳过未知域，诸如此类。</p><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=7 addr=127.0.0.1:56661 fd=8 name= age=150289 idle=146443 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribe</span><br><span class="line">id=10 addr=127.0.0.1:64043 fd=9 name= age=525 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client</span><br></pre></td></tr></table></figure><h2 id="Redis-管道技术"><a href="#Redis-管道技术" class="headerlink" title="Redis 管道技术"></a>Redis 管道技术</h2><p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：</p><ol><li>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。</li><li>服务端处理命令，并将结果返回给客户端。</li></ol><p>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ (echo -en &quot;auth pwd\r\n PING\r\n SET freya redis\r\nGET freya\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n&quot;; sleep 10) | nc localhost 6379</span><br><span class="line">+OK</span><br><span class="line">+PONG</span><br><span class="line">+OK</span><br><span class="line">$5</span><br><span class="line">redis</span><br><span class="line">:1</span><br><span class="line">:2</span><br><span class="line">:3</span><br></pre></td></tr></table></figure><p>以上命令采用<code>auth pwd</code>授权，采用<code>PING</code>命令查看redis服务是否可用， 之后我们设置了 freya 的值为 redis，然后我们获取 freya 的值并使得 visitor 自增 3 次。</p><h3 id="管道技术的优势"><a href="#管道技术的优势" class="headerlink" title="管道技术的优势"></a>管道技术的优势</h3><p>管道技术最显著的优势是提高了 redis 服务的性能。</p><h2 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis 分区"></a>Redis 分区</h2><p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p><h3 id="分区的优势"><a href="#分区的优势" class="headerlink" title="分区的优势"></a>分区的优势</h3><ol><li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li><li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。<h3 id="分区的不足"><a href="#分区的不足" class="headerlink" title="分区的不足"></a>分区的不足</h3></li><li>涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li><li>涉及多个key的redis事务不能使用。</li><li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li><li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。</li></ol><h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><p>Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。</p><h4 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h4><p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。<br>比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。<br>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各种对象的映射表，通常对Redis来说并非是好的方法。</p><h4 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h4><p>另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：</p><ol><li>用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。</li><li>对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</li></ol><h2 id="Java-使用-Redis"><a href="#Java-使用-Redis" class="headerlink" title="Java 使用 Redis"></a>Java 使用 Redis</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>开始在 Java 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 Java redis 驱动，且你的机器上能正常使用 Java。</p><h3 id="连接到-redis-服务"><a href="#连接到-redis-服务" class="headerlink" title="连接到 redis 服务"></a>连接到 redis 服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">public class RedisTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 连接本地的 Redis 服务</span><br><span class="line">        Jedis jedis = new Jedis(&quot;localhost&quot;)；</span><br><span class="line">        //验证密码</span><br><span class="line">        jedis.auth(&quot;redis&quot;);</span><br><span class="line">        // 查看服务是否运行</span><br><span class="line">        System.out.println(&quot;服务正在运行: &quot; + jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-数据备份与恢复&quot;&gt;&lt;a href=&quot;#Redis-数据备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;Redis 数据备份与恢复&quot;&gt;&lt;/a&gt;Redis 数据备份与恢复&lt;/h2&gt;&lt;h3 id=&quot;数据备份&quot;&gt;&lt;a href=&quot;#数据备份&quot;
      
    
    </summary>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/Redis/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Redis/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="进阶教程" scheme="https://muhouer.github.io/tags/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令5</title>
    <link href="https://muhouer.github.io/posts/e33ec7a3/"/>
    <id>https://muhouer.github.io/posts/e33ec7a3/</id>
    <published>2019-08-04T08:49:00.000Z</published>
    <updated>2019-08-05T17:17:13.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-服务器命令"><a href="#Redis-服务器命令" class="headerlink" title="Redis 服务器命令"></a>Redis 服务器命令</h2><p>Redis 服务器命令主要是用于管理 redis 服务。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>如何获取 redis 服务器的统计信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"># Server</span><br><span class="line">redis_version:5.0.5</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:6d3bf9e511543b78</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Darwin 18.6.0 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:kqueue</span><br><span class="line">atomicvar_api:atomic-builtin</span><br><span class="line">gcc_version:4.2.1</span><br><span class="line">process_id:65254</span><br><span class="line">run_id:3d46ae00173412623b99d81100173246db224357</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:497757</span><br><span class="line">uptime_in_days:5</span><br><span class="line">hz:10</span><br><span class="line">configured_hz:10</span><br><span class="line">lru_clock:4627403</span><br><span class="line">executable:/Users/asher/Desktop/redis-5.0.5/src/./redis-server</span><br><span class="line">config_file:</span><br><span class="line"></span><br><span class="line"># Clients</span><br><span class="line">connected_clients:2</span><br><span class="line">client_recent_max_input_buffer:2</span><br><span class="line">client_recent_max_output_buffer:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">used_memory:1070656</span><br><span class="line">used_memory_human:1.02M</span><br><span class="line">used_memory_rss:1712128</span><br><span class="line">used_memory_rss_human:1.63M</span><br><span class="line">used_memory_peak:1070656</span><br><span class="line">used_memory_peak_human:1.02M</span><br><span class="line">used_memory_peak_perc:100.03%</span><br><span class="line">used_memory_overhead:1054744</span><br><span class="line">used_memory_startup:987824</span><br><span class="line">used_memory_dataset:15912</span><br><span class="line">used_memory_dataset_perc:19.21%</span><br><span class="line">allocator_allocated:1024592</span><br><span class="line">allocator_active:1674240</span><br><span class="line">allocator_resident:1674240</span><br><span class="line">total_system_memory:8589934592</span><br><span class="line">total_system_memory_human:8.00G</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line">used_memory_scripts:0</span><br><span class="line">used_memory_scripts_human:0B</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line">allocator_frag_ratio:1.63</span><br><span class="line">allocator_frag_bytes:649648</span><br><span class="line">allocator_rss_ratio:1.00</span><br><span class="line">allocator_rss_bytes:0</span><br><span class="line">rss_overhead_ratio:1.02</span><br><span class="line">rss_overhead_bytes:37888</span><br><span class="line">mem_fragmentation_ratio:1.67</span><br><span class="line">mem_fragmentation_bytes:687536</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:66616</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line">mem_allocator:libc</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br><span class="line"></span><br><span class="line"># Persistence</span><br><span class="line">loading:0</span><br><span class="line">rdb_changes_since_last_save:0</span><br><span class="line">rdb_bgsave_in_progress:0</span><br><span class="line">rdb_last_save_time:1564893311</span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:0</span><br><span class="line">rdb_current_bgsave_time_sec:-1</span><br><span class="line">rdb_last_cow_size:0</span><br><span class="line">aof_enabled:0</span><br><span class="line">aof_rewrite_in_progress:0</span><br><span class="line">aof_rewrite_scheduled:0</span><br><span class="line">aof_last_rewrite_time_sec:-1</span><br><span class="line">aof_current_rewrite_time_sec:-1</span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line">aof_last_cow_size:0</span><br><span class="line"></span><br><span class="line"># Stats</span><br><span class="line">total_connections_received:8</span><br><span class="line">total_commands_processed:214</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">total_net_input_bytes:9198</span><br><span class="line">total_net_output_bytes:101508</span><br><span class="line">instantaneous_input_kbps:0.00</span><br><span class="line">instantaneous_output_kbps:0.00</span><br><span class="line">rejected_connections:0</span><br><span class="line">sync_full:0</span><br><span class="line">sync_partial_ok:0</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:0</span><br><span class="line">expired_stale_perc:0.00</span><br><span class="line">expired_time_cap_reached_count:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:66</span><br><span class="line">keyspace_misses:7</span><br><span class="line">pubsub_channels:1</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:966</span><br><span class="line">migrate_cached_sockets:0</span><br><span class="line">slave_expires_tracked_keys:0</span><br><span class="line">active_defrag_hits:0</span><br><span class="line">active_defrag_misses:0</span><br><span class="line">active_defrag_key_hits:0</span><br><span class="line">active_defrag_key_misses:0</span><br><span class="line"></span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:b65a8be1272fab6dfd7b73b0c51e75d06e370c79</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line"># CPU</span><br><span class="line">used_cpu_sys:36.666434</span><br><span class="line">used_cpu_user:23.420130</span><br><span class="line">used_cpu_sys_children:0.044782</span><br><span class="line">used_cpu_user_children:0.009325</span><br><span class="line"></span><br><span class="line"># Cluster</span><br><span class="line">cluster_enabled:0</span><br><span class="line"></span><br><span class="line"># Keyspace</span><br><span class="line">db0:keys=6,expires=0,avg_ttl=0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-time-命令"><a href="#Redis-time-命令" class="headerlink" title="Redis time 命令"></a>Redis <code>time</code> 命令</h3><p>用于返回当前服务器时间。可用版本 &gt;= 2.6.0</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>time</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒数。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; time </span><br><span class="line">1) &quot;1564908791&quot;</span><br><span class="line">2) &quot;483839&quot;</span><br></pre></td></tr></table></figure><h3 id="Redis-lastsave-命令"><a href="#Redis-lastsave-命令" class="headerlink" title="Redis lastsave 命令"></a>Redis <code>lastsave</code> 命令</h3><p>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。可用版本 &gt;= 1.0.0</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>lastsave</code></p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>一个 UNIX 时间戳。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lastsave </span><br><span class="line">(integer) 1564893311</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-服务器命令&quot;&gt;&lt;a href=&quot;#Redis-服务器命令&quot; class=&quot;headerlink&quot; title=&quot;Redis 服务器命令&quot;&gt;&lt;/a&gt;Redis 服务器命令&lt;/h2&gt;&lt;p&gt;Redis 服务器命令主要是用于管理 redis 服务。&lt;/p&gt;&lt;h
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
      <category term="Redis命令" scheme="https://muhouer.github.io/tags/Redis%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>奇闻异事</title>
    <link href="https://muhouer.github.io/posts/a0f75295/"/>
    <id>https://muhouer.github.io/posts/a0f75295/</id>
    <published>2019-08-02T17:15:00.000Z</published>
    <updated>2019-08-16T15:28:05.307Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>为什么饮料瓶上要写「此瓶仅用于灌装本产品，请勿重复使用」？</strong></li></ol><blockquote><p>这些都是有人用血泪证明出来的。<br>举个栗子，知道现在为什么沐浴露上面标注:请勿吞食吗？<br>因为以前在美国，有一个人，专门钻法律空子的那种，有一天忽然想到，这个沐浴露上面没有标注不能吞食，发财的机会来了，然后就喝了，送到医院洗了胃，告了卖沐浴露的公司，他们公司赔了几个亿。。。。所以以后的沐浴露标的都有请勿吞食。不过刚才我看了海飞丝没有备注，请勿模仿，因为在我国，食品安全只赔十倍。也就几百块。不要模仿。</p><footer><strong>知乎仙授</strong><cite><a href="https://www.zhihu.com/question/325657727/answer/694367466" target="_blank" rel="noopener">为什么饮料瓶上要写「此瓶仅用于灌装本产品，请勿重复使用」？</a></cite></footer></blockquote><ol start="2"><li><strong>为什么录取通知书要用EMS？</strong></li></ol><blockquote><p>国内快递只有邮政EMS可以全国范围内无差别覆盖的投送，用顺风的话，你家住在江浙沪好办，你家住在祖国某个边疆偏远山区，顺风就傻眼了。并且邮政可以去一些别的快递送不到的地方（部队等）。</p><footer><strong>知乎夏东</strong><cite><a href="https://www.zhihu.com/question/33891578/answer/62693462" target="_blank" rel="noopener">为什么录取通知书要用EMS？</a></cite></footer></blockquote><ol start="3"><li><strong>排位为什么要选不一样的英雄</strong></li></ol><blockquote><p>相同的英雄，相同的技能，如果一旦出现经济等级差，那逆转几乎是不可能的。不仅如此，即便是相同水平的玩家，在使用相同英雄博弈的时候也会因为种种原因失误，一旦被单杀，这种耻辱是很难让己方队友接受的，会有种“你看人家的李白”这种冷嘲热讽，被单杀的队友也会很沮丧，甚至怄气，进而产生消极游戏心理。这可能造成初级玩家对游戏的热忱程度大打折扣。</p><footer><strong>佚名</strong><cite><a href="https://pvp.qq.com" target="_blank" rel="noopener">排位为什么要选不一样的英雄</a></cite></footer></blockquote><ol start="4"><li><strong>人间大炮一级准备</strong>——出自《恐龙特急克塞号》,是消灭变异怪物的必杀武器。</li></ol><p>下图是金毛大总统2015年还没当总统时候发的，之后就……</p><p><img src="/images/Shooting_Donald_Trump.png" alt="upload successful"></p><ol start="5"><li><strong>玄幻小说里面，为什么主角在得罪大势力之后，大势力明知他是天才，却总是只派出境界比他只高一线的狗腿子去追杀，结果屡屡让他惊险地跨境界反杀呢？</strong></li></ol><blockquote><p>对于那些大势力而言，敢动他们的天才见过太多，而事实每次都证明对付这种人，境界仅高一线就足够了，遇上一个就兴师动众一番，非常不值。</p></blockquote><ol start="6"><li><strong>为什么手机最后 1% 的电量有时很耐用？</strong></li></ol><blockquote><p>工程师头发都掉光了也没办法，只好产品和UI的同学上喽。</p><p>工程师：现在估计还有10%的电了，现在外界挺冷的，我也拿不准电池还有多少电了。</p><p>产品：让用户赶紧充电去啊</p><p>UI：我马上让它显示只剩1%</p><p>用户：我靠，1%了，充电</p><footer><strong>知乎李明阳</strong><cite><a href="https://www.zhihu.com/question/340065364/answer/785233060" target="_blank" rel="noopener">为什么手机最后 1% 的电量有时很耐用？</a></cite></footer></blockquote><ol start="7"><li><strong>自行车是怎么保持平衡的？</strong></li></ol><blockquote><p>自行车，从一开始就不是依托缜密的物理学、数学理论公式设计出来的。</p><p>它的诞生，完全依靠人类的生活经验！</p><p>不过存在即合理，自行车不仅存在了快两个世纪，而且还不断 “ 进化 ”，到现在已经可以不借助人力自己保持平衡了，如此神奇的现象，肯定应该有个能用来解释它的科学依据吧？</p><p>于是乎，科学家们开始倒回去反推它的设计原理，结果发现，诶？这玩意儿玄学了，居然没法儿用现有的科学理论去解释！</p><footer><strong>差评君</strong><cite><a href="https://mp.weixin.qq.com/s/Z7c5lJJhnG_Hvq-aSnHxDw" target="_blank" rel="noopener">自行车是怎么保持平衡的？</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;&lt;li&gt;&lt;strong&gt;为什么饮料瓶上要写「此瓶仅用于灌装本产品，请勿重复使用」？&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;这些都是有人用血泪证明出来的。&lt;br&gt;举个栗子，知道现在为什么沐浴露上面标注:请勿吞食吗？&lt;br&gt;因为以前在美国，有一个人
      
    
    </summary>
    
      <category term="记录" scheme="https://muhouer.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="角度" scheme="https://muhouer.github.io/categories/%E8%AE%B0%E5%BD%95/%E8%A7%92%E5%BA%A6/"/>
    
    
      <category term="另类观点" scheme="https://muhouer.github.io/tags/%E5%8F%A6%E7%B1%BB%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令3</title>
    <link href="https://muhouer.github.io/posts/a5d6296/"/>
    <id>https://muhouer.github.io/posts/a5d6296/</id>
    <published>2019-08-02T16:10:00.000Z</published>
    <updated>2019-08-04T14:54:45.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-集合-Set-命令"><a href="#Redis-集合-Set-命令" class="headerlink" title="Redis 集合(Set)命令"></a>Redis 集合(Set)命令</h2><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<br>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。<br>集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set mysql</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd redis</span><br><span class="line">(error) ERR wrong number of arguments for &apos;sadd&apos; command</span><br><span class="line">127.0.0.1:6379&gt; smembers set</span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-Sadd-命令"><a href="#Redis-Sadd-命令" class="headerlink" title="Redis Sadd 命令"></a>Redis Sadd 命令</h3><p>将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。<br>假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。可用版本 &gt;= 1.0.0</p><ol><li>当集合 key 不是集合类型时，返回一个错误。</li><li>在Redis2.4版本以前， SADD 只接受单个成员值。</li></ol><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>sadd key value1... valuen</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>被添加到集合中的新元素的数量，不包括被忽略的元素。</p><h3 id="srandmember-key-count-命令"><a href="#srandmember-key-count-命令" class="headerlink" title="srandmember key [count] 命令"></a><code>srandmember key [count]</code> 命令</h3><p>如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。该操作和<code>spop</code>相似，但<code>spop</code>将随机元素从集合中移除并返回，而 <code>srandmember</code>则仅仅返回随机元素，而不对集合进行任何改动。可用版本 &gt;= 1.0.0</p><p>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</p><ol><li>如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。</li><li>如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h4><p>只提供 key 参数时为 O(1)。如果提供了 count 参数，那么为 O(N)，N 为返回数组的元素个数。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>只提供 key 参数时，返回一个元素；如果集合为空，返回 nil 。如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><table><thead><tr><th>命令</th><th>含义</th><th>可用版本</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>scard key</code></td><td>返回集合 <code>key</code> 的基数(集合中元素的数量)。当 <code>key</code> 不存在时，返回 <code>0</code> 。</td><td>&gt;=1.0.0</td><td>O(1)</td></tr><tr><td><code>sdiff key [key...]</code></td><td>返回一个集合的全部成员，该集合是所有给定集合之间的差集。不存在的 <code>key</code> 被视为空集。差集的结果来自前面的 FIRST_KEY ,而不是后面的 OTHER_KEY1，也不是整个 FIRST_KEY OTHER_KEY1..OTHER_KEYN 的差集。</td><td>&gt;=1.0.0</td><td>O(N)， N 是所有给定集合的成员数量之和。</td></tr><tr><td><code>sdiffstore destination key [key...]</code></td><td>这个命令的作用和<code>sdiff</code>类似，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 <code>destination</code> 集合已经存在，则将其覆盖。<code>destination</code> 可以是 <code>key</code> 本身。</td><td>&gt;=1.0.0</td><td>O(N)， N 是所有给定集合的成员数量之和。</td></tr><tr><td><code>sinter key [key ...]</code></td><td>返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 <code>key</code> 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</td><td>&gt;=1.0.0</td><td>O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</td></tr><tr><td><code>sinterstore destination key [key ...]</code></td><td>这个命令的作用和<code>sinter</code>类似，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 <code>destination</code> 集合已经存在，则将其覆盖。<code>destination</code> 可以是 <code>key</code> 本身。</td><td>&gt;=1.0.0</td><td>O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</td></tr><tr><td><code>sismember key member</code></td><td>判断 <code>member</code> 元素是否集合 <code>key</code> 的成员。如果 <code>member</code> 元素是集合的成员，返回 <code>1</code> 。如果 <code>member</code> 元素不是集合的成员，或 <code>key</code> 不存在，返回 <code>0</code> 。</td><td>&gt;= 1.0.0</td><td>O(1)</td></tr><tr><td><code>smembers key</code></td><td>返回集合 <code>key</code> 中的所有成员。不存在的 <code>key</code> 被视为空集合。</td><td>&gt;= 1.0.0</td><td>O(N)，N 为集合的基数</td></tr><tr><td><code>smove source destination member</code></td><td>将 <code>member</code> 元素从 <code>source</code> 集合移动到 <code>destination</code> 集合。原子性操作。如果 <code>source</code> 集合不存在或不包含指定的 <code>member</code> 元素，则 <code>smove</code>命令不执行任何操作，仅返回 <code>0</code> 。否则， <code>member</code> 元素从 <code>source</code> 集合中被移除，并添加到 <code>destination</code> 集合中去。</td><td>&gt;= 1.0.0</td><td>O(1)</td></tr><tr><td><code>spop key</code></td><td>移除并返回集合中的一个随机元素。当 <code>key</code> 不存在或 <code>key</code> 是空集时，返回 <code>nil</code> 。如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 <code>srandmember</code>命令。</td><td>&gt;= 1.0.0</td><td>O(1)</td></tr><tr><td><code>srem key member [member...]</code></td><td>移除集合 <code>key</code> 中的一个或多个 <code>member</code> 元素，不存在的 <code>member</code> 元素会被忽略。当 <code>key</code> 不是集合类型，返回一个错误。在 Redis 2.4 版本以前，<code>srem</code>只接受单个 <code>member</code> 值。</td><td>&gt;= 1.0.0</td><td>O(n)，n为给定member元素的数量</td></tr><tr><td><code>sunion key [key ...]</code></td><td>返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 <code>key</code> 被视为空集。</td><td>&gt;= 1.0.0</td><td>O(N)， N 是所有给定集合的成员数量之和。</td></tr><tr><td><code>sunionstore dest key [key ...]</code></td><td>这个命令的作用和<code>sinter</code>类似，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 <code>destination</code> 集合已经存在，则将其覆盖。<code>destination</code> 可以是 <code>key</code> 本身。</td><td>&gt;=1.0.0</td><td>O(N * M)， <code>N</code> 是所有给定集合的成员数量之和。</td></tr><tr><td><code>sscan key cursor [MATCH pattern] [COUNT count]</code></td><td>和 <code>scan</code> 、<code>hscan</code>、<code>zscan</code>一样，看不太明白。回头用到再看。</td><td></td><td></td></tr></tbody></table><h2 id="Redis-有序集合-sorted-set-命令"><a href="#Redis-有序集合-sorted-set-命令" class="headerlink" title="Redis 有序集合(sorted set)命令"></a>Redis 有序集合(sorted set)命令</h2><p>Redis 有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd sset 1 redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd sset 2 mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd sset 3 mysql</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd sset 3 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zadd sset 4 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange sset 0 10 withscores</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;mongodb&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;mysql&quot;</span><br></pre></td></tr></table></figure><h3 id="zadd-命令"><a href="#zadd-命令" class="headerlink" title="zadd 命令"></a><code>zadd</code> 命令</h3><p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p><p>如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。</p><ol><li><p>score 值可以是整数值或双精度浮点数。</p></li><li><p>如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</p></li><li><p>当 key 存在但不是有序集类型时，返回一个错误。</p></li></ol><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>zadd key score member [[score member] [score member] ...]</code></p><h4 id="可用版本："><a href="#可用版本：" class="headerlink" title="可用版本："></a>可用版本：</h4><p>可用版本&gt;= 1.2.0 。在 Redis 2.4 版本以前， <code>zadd</code>每次只能添加一个元素。</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h4><p>O(M*log(N))，N 是有序集的基数，M 为成功添加的新成员的数量。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值:"></a>返回值:</h4><p>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p><h3 id="zrange-命令"><a href="#zrange-命令" class="headerlink" title="zrange 命令"></a><code>zrange</code> 命令</h3><p>返回有序集 key 中，指定区间内的成员。可用版本 &gt;= 1.2.0</p><p>其中成员的位置按 score 值递增(从小到大)来排序。</p><p>具有相同 score 值的成员按字典序(lexicographical order )来排列。</p><p>如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE 命令。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p><code>zrange key start stop [WITHSCORES]</code></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。</li><li>你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</li><li>超出范围的下标并不会引起错误。比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。</li><li>另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</li><li>可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。</li><li>客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</li></ol><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</p><h3 id="zrangebyscore-命令"><a href="#zrangebyscore-命令" class="headerlink" title="zrangebyscore 命令"></a><code>zrangebyscore</code> 命令</h3><p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。可用版本 &gt;= 1.0.5</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p><code>zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</code></p><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。</p><p>可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</p><p>可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。该选项自 Redis 2.0 版本起可用。</p><h4 id="区间及无限"><a href="#区间及无限" class="headerlink" title="区间及无限"></a>区间及无限</h4><p>min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。</p><p>默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。<br>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore zset (1 5</span><br></pre></td></tr></table></figure><p>返回所有符合条件 1 &lt; score &lt;= 5 的成员，而</p><p><code>zrangebyscore zset (5 (10</code><br>则返回所有符合条件 5 &lt; score &lt; 10 的成员。</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。</p><h3 id="zremrangebyrank-命令"><a href="#zremrangebyrank-命令" class="headerlink" title="zremrangebyrank 命令"></a><code>zremrangebyrank</code> 命令</h3><p>移除有序集 key 中，指定排名(rank)区间内的所有成员。返回被移除成员的数量。</p><p>区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。</p><p>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。<br>你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><p><code>zremrangebyrank key start stop</code></p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><h3 id="zremrangebyscore-命令"><a href="#zremrangebyscore-命令" class="headerlink" title="zremrangebyscore 命令"></a><code>zremrangebyscore</code> 命令</h3><p>移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。返回被移除成员的数量。可用版本 &gt;= 1.2.0</p><p>自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 <code>zrangebyscore</code> 命令。</p><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><p><code>zremrangebyscore key min max</code></p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><h3 id="zrevrange-命令"><a href="#zrevrange-命令" class="headerlink" title="zrevrange 命令"></a><code>zrevrange</code> 命令</h3><p>返回有序集 key 中，指定区间内的成员。可用版本 &gt;= 1.2.0</p><p>其中成员的位置按 score 值递减(从大到小)来排列。<br>具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。</p><p>除了成员按 score 值递减的次序排列这一点外， <code>zrevrange</code>命令的其他方面和<code>zrange</code>命令一样。</p><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><p><code>zrevrange key start stop [WITHSCORES]</code></p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</p><h3 id="zunionstore-命令"><a href="#zunionstore-命令" class="headerlink" title="zunionstore 命令"></a><code>zunionstore</code> 命令</h3><p>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。返回保存到 destination 的结果集的基数。可用版本 &gt;= 2.0.0</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和 。</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><p><code>zunionstore destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></p><h4 id="WEIGHTS-选项"><a href="#WEIGHTS-选项" class="headerlink" title="WEIGHTS 选项"></a>WEIGHTS 选项</h4><p>使用 WEIGHTS 选项，你可以为 每个给定有序集分别指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。</p><p>如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</p><h4 id="AGGREGATE-选项"><a href="#AGGREGATE-选项" class="headerlink" title="AGGREGATE 选项"></a>AGGREGATE 选项</h4><p>使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。</p><p>默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之和作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。</p><h3 id="zinterstore-命令"><a href="#zinterstore-命令" class="headerlink" title="zinterstore 命令"></a><code>zinterstore</code> 命令</h3><p>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。返回保存到 destination 的结果集的基数。可用版本 &gt;= 2.0.0</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.</p><p>关于 WEIGHTS 和 AGGREGATE 选项的描述，参见<code>zinterstore</code>命令。</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N<em>K)+O(M</em>log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。</p><h3 id="其他命令-1"><a href="#其他命令-1" class="headerlink" title="其他命令"></a>其他命令</h3><table><thead><tr><th>命令</th><th>含义</th><th>可用版本</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>zcard key</code></td><td>返回有序集 <code>key</code> 的基数。当 <code>key</code> 存在且是有序集类型时，返回有序集的基数。当 <code>key</code> 不存在时，返回 <code>0</code> 。</td><td>&gt;=1.2.0</td><td>O(1)</td></tr><tr><td><code>zcount key min max</code></td><td>返回有序集 <code>key</code> 中， <code>score</code> 值在 <code>min</code> 和 <code>max</code> 之间(默认包括 <code>score</code> 值等于 <code>min</code> 或 <code>max</code> )的成员的数量。</td><td>&gt;=2.0.0</td><td>O(log(N)+M)， N 为有序集的基数， M 为值在 min 和 max 之间的元素的数量。</td></tr><tr><td><code>zincrby key increment member</code></td><td>为有序集 <code>key</code> 的成员 <code>member</code> 的 <code>score</code> 值加上增量 <code>increment</code> 。可以通过传递一个负数值 <code>increment</code> ，让 <code>score</code> 减去相应的值。当 <code>key</code> 不存在，或 <code>member</code> 不是 <code>key</code> 的成员时， <code>zincrby key increment member</code> 等同于 <code>zadd key increment member</code> 。当 <code>key</code> 不是有序集类型时，返回一个错误。<code>score</code> 值可以是整数值或双精度浮点数。</td><td>&gt;=1.2.0</td><td>O(log(N))</td></tr><tr><td><code>zrank key member</code></td><td>返回有序集 <code>key</code> 中成员 <code>member</code> 的排名。如果 <code>member</code> 不是有序集 <code>key</code> 的成员，返回 <code>nil</code> 。其中有序集成员按 <code>score</code> 值递增(从小到大)顺序排列。排名以 <code>0</code> 为底，也就是说， <code>score</code> 值最小的成员排名为 <code>0</code> 。</td><td>&gt;=2.0.0</td><td>O(log(N))</td></tr><tr><td><code>zrem key member [member ...]</code></td><td>移除有序集 <code>key</code> 中的一个或多个成员，不存在的成员将被忽略。f返回被成功移除的成员的数量，不包括被忽略的成员。当 <code>key</code> 存在但不是有序集类型时，返回一个错误。在 Redis 2.4 版本以前，<code>zrem</code>每次只能删除一个元素。</td><td>&gt;=1.2.0</td><td>O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。</td></tr><tr><td><code>zrevrank key member</code></td><td>返回有序集 <code>key</code> 中成员 <code>member</code> 的排名。其中有序集成员按 <code>score</code> 值递减(从大到小)排序。排名以 <code>0</code> 为底，也就是说， <code>score</code> 值最大的成员排名为 <code>0</code> 。</td><td>&gt;=2.0.0</td><td>O(log(N))</td></tr><tr><td><code>zscore key member</code></td><td>返回有序集 <code>key</code> 中，成员 <code>member</code> 的 <code>score</code> 值，以字符串形式表示。如果 <code>member</code> 元素不是有序集 <code>key</code> 的成员，或 <code>key</code> 不存在，返回 <code>nil</code> 。</td><td>&gt;=1.2.0</td><td>O(1)</td></tr><tr><td><code>zrevrangebyscore key max min [withscores] [limit offset count]</code></td><td>返回有序集 <code>key</code> 中， <code>score</code> 值介于 <code>max</code> 和 <code>min</code> 之间(默认包括等于 <code>max</code> 或 <code>min</code> )的所有的成员。有序集成员按 <code>score</code> 值递减(从大到小)的次序排列。具有相同 <code>score</code> 值的成员按字典序的逆序(<a href="http://en.wikipedia.org/wiki/Lexicographical_order" target="_blank" rel="noopener">reverse lexicographical order</a> )排列。除了成员按 <code>score</code> 值递减的次序排列这一点外，<code>zrevrangebyscore</code> 命令的其他方面和 <code>zrangebyscore</code>命令一样。</td><td>&gt;=2.2.0</td><td>O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-集合-Set-命令&quot;&gt;&lt;a href=&quot;#Redis-集合-Set-命令&quot; class=&quot;headerlink&quot; title=&quot;Redis 集合(Set)命令&quot;&gt;&lt;/a&gt;Redis 集合(Set)命令&lt;/h2&gt;&lt;p&gt;Redis 的 Set 是 Stri
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
      <category term="Redis命令" scheme="https://muhouer.github.io/tags/Redis%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令4</title>
    <link href="https://muhouer.github.io/posts/9439f735/"/>
    <id>https://muhouer.github.io/posts/9439f735/</id>
    <published>2019-08-02T16:10:00.000Z</published>
    <updated>2019-08-02T17:12:57.594Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍 Redis 发布订阅、事务、脚本、连接四个方面的命令。</p><h2 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。一个频道也可以被多个客户端订阅。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>创建了订阅频道名为 redisChat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe redisChat</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure><p>重新开启个 redis 客户端，然后在同一个频道 redisChat 发布消息，订阅者就能接收到消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish redisChat &quot;Redis is a great caching technique&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe redisChat</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) &quot;Redis is a great caching technique&quot;</span><br></pre></td></tr></table></figure><h3 id="Redis-psubscribe命令"><a href="#Redis-psubscribe命令" class="headerlink" title="Redis psubscribe命令"></a>Redis <code>psubscribe</code>命令</h3><p>订阅一个或多个符合给定模式的频道。可用版本 &gt;= 2.0.0</p><p>每个模式以 * 作为匹配符，比如 redis* 匹配所有以 redis 开头的频道( redis.news 、 redis.blog等等)。</p><p><code>punsubscribe</code> 命令用于退订所有给定模式的频道。与 <code>psubscribe</code> 类似。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>psubscribe pattern [pattern ...]</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>接收到的信息。</p><h3 id="Redis-subscribe命令"><a href="#Redis-subscribe命令" class="headerlink" title="Redis subscribe命令"></a>Redis <code>subscribe</code>命令</h3><p>用于订阅给定的一个或多个频道的信息。可用版本 &gt;= 2.0.0</p><p><code>unsubscribe</code> 命令用于退订所有给定模式的频道。与 <code>subscribe</code> 类似。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>subscribe channel [channel ...]</code></p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>接收到的信息</p><h3 id="Redis-publish命令"><a href="#Redis-publish命令" class="headerlink" title="Redis publish命令"></a>Redis <code>publish</code>命令</h3><p>用于将信息发送到指定的频道。可用版本 &gt;= 2.0.0</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p><code>publish channel message</code></p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>接收到信息的订阅者数量。</p><h3 id="Redis-pubsub命令"><a href="#Redis-pubsub命令" class="headerlink" title="Redis pubsub命令"></a>Redis <code>pubsub</code>命令</h3><p><code>pubsub</code>是一个查看订阅与发布系统状态的内省命令，它由数个不同格式的子命令组成。可用版本 &gt;= 2.8.0</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p><code>pubsub &lt;subcommand&gt; [argument [argument ...]]</code></p><h4 id="channels-子命令"><a href="#channels-子命令" class="headerlink" title="channels 子命令"></a><code>channels</code> 子命令</h4><p>列出当前的活跃频道。活跃频道指的是那些至少有一个订阅者的频道，订阅模式的客户端不计算在内。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><p><code>pubsub channels [pattern]</code></p><p>pattern 参数是可选的，如果不给出 pattern 参数，那么列出订阅与发布系统中的所有活跃频道。如果给出 pattern 参数，那么只列出和给定模式 pattern 相匹配的那些活跃频道。</p><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>O(N) ， N 为活跃频道的数量（对于长度较短的频道和模式来说，将进行模式匹配的复杂度视为常数）。</p><h5 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h5><p>一个由活跃频道组成的列表。</p><h4 id="numsub-子命令"><a href="#numsub-子命令" class="headerlink" title="numsub 子命令"></a><code>numsub</code> 子命令</h4><p>返回给定频道的订阅者数量， 订阅模式的客户端不计算在内。</p><h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><p><code>pubsub numsub [channel-1 ... channel-N]</code></p><h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>O(N)， N 为给定频道的数量。</p><h5 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h5><p>一个多条批量回复(Multi-bulk reply)，回复中包含给定的频道，以及频道的订阅者数量。 格式为：频道 channel-1，channel-1 的订阅者数量，频道 channel-2，channel-2 的订阅者数量，诸如此类。 回复中频道的排列顺序和执行命令时给定频道的排列顺序一致。不给定任何频道而直接调用这个命令也是可以的，在这种情况下，命令只返回一个空列表。</p><h4 id="numpat-子命令"><a href="#numpat-子命令" class="headerlink" title="numpat 子命令"></a><code>numpat</code> 子命令</h4><p>返回订阅模式的数量。这个命令返回的不是订阅模式的客户端的数量，而是客户端订阅的所有模式的数量总和。当有多个客户端订阅相同的模式时，相同的订阅也被计算在内</p><h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><p><code>pubsub numpat</code></p><h5 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h5><p>O(1) 。</p><h5 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h5><p>一个整数回复（Integer reply）。</p><h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ol><li>批量操作在发送<code>exec</code>命令前被放入队列缓存。</li><li>收到<code>exec</code>命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ol><p>一个事务从开始到执行会经历三个阶段：开始事务-&gt;命令入队。-&gt;执行事务。</p><h3 id="Redis-multi与exec命令"><a href="#Redis-multi与exec命令" class="headerlink" title="Redis multi与exec命令"></a>Redis <code>multi</code>与<code>exec</code>命令</h3><p>用于标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由<code>exec</code>命令原子性(atomic)地执行。可用版本 &gt;= 1.2.0</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><p><code>multi</code></p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr user_id</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr user_id</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr user_id</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 2</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) PONG</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-discard命令"><a href="#Redis-discard命令" class="headerlink" title="Redis discard命令"></a>Redis <code>discard</code>命令</h3><p>用于取消事务，放弃执行事务块内的所有命令。可用版本 &gt;= 2.0.0</p><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><p><code>discard</code></p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr user_id</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr user_id</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(error) ERR EXEC without MULTI</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-watch命令"><a href="#Redis-watch命令" class="headerlink" title="Redis watch命令"></a>Redis <code>watch</code>命令</h3><p>用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。可用版本 &gt;= 2.2.0</p><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><p><code>watch key [key ...]</code></p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h3 id="Redis-unwatch-命令"><a href="#Redis-unwatch-命令" class="headerlink" title="Redis unwatch 命令"></a>Redis <code>unwatch</code> 命令</h3><p>用于取消<code>watch</code>命令对所有 key 的监视。可用版本 &gt;= 2.2.0</p><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><p>redis Unwatch 命令基本语法如下：<br>redis 127.0.0.1:6379&gt; UNWATCH</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h2 id="Redis-脚本"><a href="#Redis-脚本" class="headerlink" title="Redis 脚本"></a>Redis 脚本</h2><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p><h3 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h3><p><code>EVAL script numkeys key [key ...] arg [arg ...]</code></p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EVAL &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;first&quot;</span><br><span class="line">4) &quot;second&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-eval-命令"><a href="#Redis-eval-命令" class="headerlink" title="Redis eval 命令"></a>Redis <code>eval</code> 命令</h3><p>使用 Lua 解释器执行脚本。可用版本 &gt;= 2.6.0</p><h4 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h4><p><code>EVAL script numkeys key [key ...] arg [arg ...]</code></p><h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h4><p>script： 参数是一段 Lua 5.1 脚本程序。脚本不必(也不应该)定义为一个 Lua 函数。</p><p>numkeys： 用于指定键名参数的个数。</p><p>key [key …]： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p><p>arg [arg …]： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p><h3 id="Redis-evalsha-命令"><a href="#Redis-evalsha-命令" class="headerlink" title="Redis evalsha 命令"></a>Redis <code>evalsha</code> 命令</h3><p>根据给定的 sha1 校验码，执行缓存在服务器中的脚本。可用版本 &gt;= 2.6.0</p><p>将脚本缓存到服务器的操作可以通过<code>SCRIPT LOAD</code>命令进行。<br>这个命令的其他地方，比如参数的传入方式，都和 <code>EVAL</code> 命令一样。</p><h4 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h4><p><code>EVALSHA sha1 numkeys key [key ...] arg [arg ...]</code></p><h4 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h4><p>sha1 ： 通过<code>SCRIPT LOAD</code>生成的 sha1 校验码。</p><p>numkeys： 用于指定键名参数的个数。</p><p>key [key …]： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p><p>arg [arg …]： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCRIPT LOAD &quot;return &apos;hello freya&apos;&quot;</span><br><span class="line">&quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;</span><br><span class="line">127.0.0.1:6379&gt; evalsha &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot; 0</span><br><span class="line">&quot;hello freya&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-script-exists-命令"><a href="#Redis-script-exists-命令" class="headerlink" title="Redis script exists 命令"></a>Redis <code>script exists</code> 命令</h3><p>用于校验指定的脚本是否已经被保存在缓存当中。可用版本 &gt;= 2.6.0</p><h4 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h4><p><code>SCRIPT EXISTS sha1 [sha1 ...]</code></p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>一个列表，包含 0 和 1 ，前者表示脚本不存在于缓存，后者表示脚本已经在缓存里面了。</p><p>列表中的元素和给定的 SHA1 校验和保持对应关系，比如列表的第三个元素的值就表示第三个 SHA1 校验和所指定的脚本在缓存中的状态。</p><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCRIPT LOAD &quot;return &apos;hello freya&apos;&quot;</span><br><span class="line">&quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;</span><br><span class="line">127.0.0.1:6379&gt; script exists &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;</span><br><span class="line">1) (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; script flush</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; script exists &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;</span><br><span class="line">1) (integer) 0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis-script-kill-命令"><a href="#Redis-script-kill-命令" class="headerlink" title="Redis script kill 命令"></a>Redis <code>script kill</code> 命令</h3><p>用于杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。可用版本 &gt;= 2.6.0</p><p>这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限循环的脚本。</p><p><code>script kill</code>执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从<code>EVAL</code>命令的阻塞当中退出，并收到一个错误作为返回值。</p><h4 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h4><p><code>script kill</code></p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK</p><h2 id="Redis-连接"><a href="#Redis-连接" class="headerlink" title="Redis 连接"></a>Redis 连接</h2><p>Redis 连接命令主要是用于连接 redis 服务。</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth &quot;password&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="Redis-auth-命令"><a href="#Redis-auth-命令" class="headerlink" title="Redis auth 命令"></a>Redis <code>auth</code> 命令</h3><p>用于检测给定的密码和配置文件中的密码是否相符。可用版本 &gt;= 1.0.0</p><h4 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h4><p><code>auth pwd</code></p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>密码匹配时返回 OK ，否则返回一个错误。</p><h3 id="Redis-echo-命令"><a href="#Redis-echo-命令" class="headerlink" title="Redis echo 命令"></a>Redis <code>echo</code> 命令</h3><p>用于打印给定的字符串。可用版本 &gt;= 1.0.0</p><h4 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h4><p><code>echo message</code></p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>返回字符串本身。</p><h3 id="Redis-Quit-命令"><a href="#Redis-Quit-命令" class="headerlink" title="Redis Quit 命令"></a>Redis Quit 命令</h3><p>用于关闭与当前客户端与redis服务的连接。可用版本 &gt;= 1.0.0</p><p>一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; quit</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="Redis-select-命令"><a href="#Redis-select-命令" class="headerlink" title="Redis select 命令"></a>Redis <code>select</code> 命令</h3><p>用于切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。可用版本 &gt;= 1.0.0</p><h4 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h4><p><code>select index</code></p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要介绍 Redis 发布订阅、事务、脚本、连接四个方面的命令。&lt;/p&gt;&lt;h2 id=&quot;Redis-发布订阅&quot;&gt;&lt;a href=&quot;#Redis-发布订阅&quot; class=&quot;headerlink&quot; title=&quot;Redis 发布订阅&quot;&gt;&lt;/a&gt;Redis 发布订阅&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/Redis/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Redis/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis命令" scheme="https://muhouer.github.io/tags/Redis%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>

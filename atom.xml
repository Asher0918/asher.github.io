<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Muhouer</title>
  
  <subtitle>就是做个记录，先来5分钟的！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muhouer.github.io/"/>
  <updated>2019-08-20T16:52:25.353Z</updated>
  <id>https://muhouer.github.io/</id>
  
  <author>
    <name>Muhouer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>枚举类型</title>
    <link href="https://muhouer.github.io/posts/4502a76f/"/>
    <id>https://muhouer.github.io/posts/4502a76f/</id>
    <published>2019-08-20T16:44:00.000Z</published>
    <updated>2019-08-20T16:52:25.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>枚举类型（<code>enum type</code>）是指由一组固定的常量组成合法的类型。<code>Java</code> 中由关键字 <code>enum</code> 来定义一个枚举类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">    SPRING, SUMMER, AUTUMN, WINER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句定义：</p><ol><li>使用关键字 <code>enum</code></li><li>类型名称，比如这里的<code>Season</code></li><li>枚举中的属性必须放在最前面，一般使用大写字母表示</li><li>枚举可以单独定义在一个文件中，也可以嵌在其它<code>Java</code>类中</li><li>枚举可以实现一个或多个接口（Interface）</li><li>可以和 java 类一样定义方法 ，枚举中的构造方法必须是私有的。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 <code>javap</code> 进行反编译可以看到 <code>public final class Season extends Enum</code>，也就是说当我们使用 <code>enum</code> 来定义一个枚举类型的时候，编译器会自动帮我们创建一个 <code>final</code> 类型且继承自 <code>Enum</code> 的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Season</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Season</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season SPRING;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season SUMMER;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season AUTUMN;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season WINER;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.muhouer.algorithm.Season[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.muhouer.algorithm.<span class="function">Season <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些特殊方法"><a href="#一些特殊方法" class="headerlink" title="一些特殊方法"></a>一些特殊方法</h2><ol><li><p>Java 枚举值比较用 <code>==</code> 和 <code>equals()</code> 方法效果是一样的。因为枚举 Enum 类的 <code>equals()</code> 方法的实现就是使用 <code>==</code> ；</p></li><li><p>Enum 的 <code>compareTo()</code>方法实际上比较的是 Enum 的 ordinal 顺序大小；</p></li><li><p>Enum 在 <code>switch</code> 中比较的是 Enum 的 ordinal 值；</p></li><li><p>Enum 的 <code>name()</code>方法和 <code>toString()</code> 方法效果一样，返回的都是 Enum 的 name 值。</p></li></ol><h2 id="序列化及线程安全"><a href="#序列化及线程安全" class="headerlink" title="序列化及线程安全"></a>序列化及线程安全</h2><p>为了保证枚举类型像 Java 规范中规定的那样，每一个枚举类型极其定义的枚举变量在 JVM 中都是唯一的，在枚举类型的序列化和反序列化上，Java 做了特殊的规定:</p><blockquote><p>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.</p></blockquote><p>大概意思就是说，在序列化的时候 Java 仅仅是将枚举对象的 name 属性输出到结果中，反序列化的时候则是通过java.lang.Enum 的 <code>valueOf()</code> 方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了 <code>writeObject</code>、<code>readObject</code>、<code>readObjectNoData</code>、<code>writeReplace</code> 和 <code>readResolve</code> 等方法。 我们看一下这个<code>valueOf()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String name)</span> </span>&#123;</span><br><span class="line">    T result = enumType.enumConstantDirectory().get(name); <span class="comment">// 获取枚举类型的枚举常量字典</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 找到即返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) <span class="comment">// 否则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Map&lt;String, T&gt; enumConstantDirectory = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a map from simple name to enum constant.  This package-private</span></span><br><span class="line"><span class="comment"> * method is used internally by Enum to implement</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)&#125;</span></span><br><span class="line"><span class="comment"> * efficiently.  Note that the map is returned by this method is</span></span><br><span class="line"><span class="comment"> * created lazily on first use.  Typically it won't ever get created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Map&lt;String, T&gt; <span class="title">enumConstantDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enumConstantDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        T[] universe = getEnumConstantsShared();  <span class="comment">// 反射的方式调用枚举类型的 values() 静态方法</span></span><br><span class="line">        <span class="keyword">if</span> (universe == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                getName() + <span class="string">" is not an enum type"</span>);</span><br><span class="line">        Map&lt;String, T&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span> * universe.length);</span><br><span class="line">        <span class="keyword">for</span> (T constant : universe)</span><br><span class="line">            m.put(((Enum&lt;?&gt;)constant).name(), constant); <span class="comment">// 填充 enumConstantDirectory</span></span><br><span class="line">        enumConstantDirectory = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enumConstantDirectory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从👆可以看出，JVM 对枚举类型序列化有保证。</p><p>枚举类型是一个 final 类型的继承自 Enum 的类，所以枚举类型不能被继承，而且这个类中的属性和方法都是static 类型的。当一个 Java 类第一次被真正使用到的时候静态资源初始化、Java 类的加载和初始化过程都是线程安全的。所以，<strong>创建一个enum类型是线程安全的</strong>。</p><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>在StakcOverflow中，有一个关于<a href="https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java" target="_blank" rel="noopener">在 Java 中哪种写单例的方式最好</a>的讨论。</p><p>Joshua Bloch大神在《Effective Java》中明确表达过的观点：</p><blockquote><p>使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</p></blockquote><p>使用枚举实现单例的好处：</p><ol><li><p>枚举单例写法简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程安全：枚举实现的单例是天生线程安全的。</p></li><li><p>反序列化不会破坏单例。</p><blockquote><p>普通的 Java 类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。所以，即使单例中构造函数是私有的，也会被反射给破坏掉。由于反序列化后的对象是重新 new 出来的，所以这就破坏了单例。</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;枚举类型（&lt;code&gt;enum type&lt;/code&gt;）是指由一组固定的常量组成合法的类型。&lt;code&gt;Java&lt;/code&gt; 中由关键字 
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="枚举类型" scheme="https://muhouer.github.io/tags/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>杂记-天秀</title>
    <link href="https://muhouer.github.io/posts/ff247979/"/>
    <id>https://muhouer.github.io/posts/ff247979/</id>
    <published>2019-08-20T15:06:47.000Z</published>
    <updated>2019-08-20T16:44:49.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。"><a href="#在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。" class="headerlink" title="在一个8×8的国际象棋棋盘上, 显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。"></a>在一个8×8的国际象棋棋盘上, 显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。</h2><h3 id="问：如果将对角线上的两个方格挖掉-那剩下来的62个格子还能用31张骨牌覆盖住吗？"><a href="#问：如果将对角线上的两个方格挖掉-那剩下来的62个格子还能用31张骨牌覆盖住吗？" class="headerlink" title="问：如果将对角线上的两个方格挖掉, 那剩下来的62个格子还能用31张骨牌覆盖住吗？"></a>问：如果将对角线上的两个方格挖掉, 那剩下来的62个格子还能用31张骨牌覆盖住吗？</h3><img src="/images/201908201107.png" width="500px" height="500px" align="center"><p>答：每一张骨牌在棋盘上必是覆盖住两个相邻方格, 一白一黑。挖掉两个角之后只有 32 黑 30 白, 于是就不存在这样一种能用31个骨牌覆盖的方法。</p><h3 id="问：任意切掉一个一白一黑的格子就一定可以吗？"><a href="#问：任意切掉一个一白一黑的格子就一定可以吗？" class="headerlink" title="问：任意切掉一个一白一黑的格子就一定可以吗？"></a>问：任意切掉一个一白一黑的格子就一定可以吗？</h3><img src="/images/201908201108.png" width="500px" height="500px" align="center"><p>答：可以。粗黑线条将整个棋盘转变为一条首尾相连、黑白格相间的封闭路线。从这棋盘上切掉任何两个颜色不同的方格, 会让这个封闭线路变成两段线路, 当然如果切掉的方格是相连的, 那就是一条线路。显然, 在任何线路中, 两种颜色的格子数量都是偶数，故分别都可以被若干张骨牌覆盖。从而整个棋盘一定可以被31张骨牌完全覆盖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。&quot;&gt;&lt;a href=&quot;#在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。&quot; class=&quot;headerlink&quot; title=&quot;在一个8
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>杂记-科学与方法</title>
    <link href="https://muhouer.github.io/posts/b549d39b/"/>
    <id>https://muhouer.github.io/posts/b549d39b/</id>
    <published>2019-08-20T14:40:00.000Z</published>
    <updated>2019-08-20T14:44:59.797Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>假如在那里居住着智者，这些智者毫无好奇心，避免一切过度行为，那么他们不会死于疾病，而确实将死于无聊。</p></li><li><p>法则一经确立，我们首先就要寻找这个法则具有最大失效机遇的情况。我们应该达到的目的主要不在于弄清相似和差异，而是要认出隐藏在表观偏离下的类似性。</p></li><li><p>科学家研究自然，并非因为它有用处；他研究它，是因为他喜欢它，他之所以喜欢它，是因为它是美的。如果自然不美，它就不值得了解；如果自然不值得了解，生命也就不值得活着。</p></li><li><p>假如没有能够在事实中选择、分辨在哪些事实背后隐藏某种东西，以及识别什么正在隐藏着的精神，假如没有在未加工的事实下察觉事实精髓的精神，事实也许是毫无成果的。</p></li><li><p>事实的重要性用它产生的效益来衡量，也就是说，用它容许我们节省的思维数量来衡量。思维经济是我们应该对准的目标，因此提供仿效的模型还是不够的。需要使我们之后的人能够省却这些模型，不去重复已做出的论据，而用几句话概括它。</p></li><li><p>我们应该经常力图去做的，可以说是定性地解决问题；也就是说，力图去了解表示未知函数的曲线的一般形状。依然要寻找问题的定量的解。</p></li><li><p>往往发生这种情况：不完美的解把我们引向比较完美的解。有时，级数收敛过慢，以致计算无法实际进行。我们仅仅得以证明问题的可能性。</p></li><li><p>偶然性仅仅是我们无知的度量。按照定义，偶然发生的现象就是我们不知道其规律的现象。</p></li><li><p>对称性的最小欠缺将使它稍微倾斜到一侧或另一侧，而且如果它倾斜了，不管倾斜得多么小，它必将完全倾向那一侧。</p></li><li><p>我不可能预见我推动的指针将停在何处，这就是我的心紧张地跳动，期望一切都交好运的缘由。原因上的差别是难以觉察的，而结果上的差别对我来说却是至关重要的，由于它就是我的整个赌注。</p></li><li><p>我们忽路了这样一些情况,这些情况乍看起来似乎完全是在我们预见之外发生的，人们从来也没有梦想到把任何影响归咎于它，不过与我们的预期相反，它最终却起着重要的作用。</p></li><li><p>我们不知道偶然误差由什么引起的，而且正因为我们不知道，我们才意识到它们服从高斯定律。</p></li><li><p>不是严格的证明微不足道。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;&lt;li&gt;&lt;p&gt;假如在那里居住着智者，这些智者毫无好奇心，避免一切过度行为，那么他们不会死于疾病，而确实将死于无聊。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;法则一经确立，我们首先就要寻找这个法则具有最大失效机遇的情况。我们应该达到的目的主要不在于弄清相似和差异，而是要认出隐藏在表观
      
    
    </summary>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="科学与方法" scheme="https://muhouer.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>证明杂记</title>
    <link href="https://muhouer.github.io/posts/c1a19f3f/"/>
    <id>https://muhouer.github.io/posts/c1a19f3f/</id>
    <published>2019-08-18T06:22:00.000Z</published>
    <updated>2019-08-18T15:42:58.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何证明-0-99999……-1"><a href="#如何证明-0-99999……-1" class="headerlink" title="如何证明 0.99999…… = 1"></a>如何证明 <code>0.99999…… = 1</code></h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><code>1/3 = 0.33333……</code> ==&gt; <code>1 = 0.99999……</code></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><code>10 * 0.99999…… = 9.9999……</code><br>两边各减去一个 <code>0.99999……</code> ==&gt; <code>9 * 0.99999…… = 9</code> ==&gt; <code>0.99999…… = 1</code></p><h2 id="有趣的-PI-和-E"><a href="#有趣的-PI-和-E" class="headerlink" title="有趣的 PI 和 E"></a>有趣的 <code>PI</code> 和 <code>E</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.pow(Math.PI, 4) + Math.pow(Math.PI, 5)</span><br><span class="line">403.4287758192838</span><br><span class="line">&gt; Math.pow(Math.E, 6)</span><br><span class="line">403.428793492735</span><br></pre></td></tr></table></figure><p><code>PI^4 + PI^5 约等于 E^6</code> 可以精确到小数点后四位。<br>紧跟这个精度之后的是 <code>PI^146 + PI^152 约等于 E^174</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.pow(Math.PI, 146) + Math.pow(Math.PI, 152)</span><br><span class="line">3.6917488742520865e+75</span><br><span class="line">&gt; Math.pow(Math.E, 174)</span><br><span class="line">3.6918143295804325e+75</span><br></pre></td></tr></table></figure><p>神奇！神奇！神奇！<br>有趣！有趣！有趣！</p><h2 id="时间复利"><a href="#时间复利" class="headerlink" title="时间复利"></a>时间复利</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.pow((1+1/365), 365)</span><br><span class="line">2.714567482021973</span><br><span class="line">&gt; Math.pow((1+1/365), 365*10)</span><br><span class="line">21727.333146076744</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何证明-0-99999……-1&quot;&gt;&lt;a href=&quot;#如何证明-0-99999……-1&quot; class=&quot;headerlink&quot; title=&quot;如何证明 0.99999…… = 1&quot;&gt;&lt;/a&gt;如何证明 &lt;code&gt;0.99999…… = 1&lt;/code&gt;&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数学" scheme="https://muhouer.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>HashSet分析</title>
    <link href="https://muhouer.github.io/posts/88817346/"/>
    <id>https://muhouer.github.io/posts/88817346/</id>
    <published>2019-08-18T05:58:00.000Z</published>
    <updated>2019-08-20T16:46:43.638Z</updated>
    
    <content type="html"><![CDATA[<p><code>HashSet</code> 是一个不允许存储重复元素的集合，它的实现比较简单，只要理解了 <code>HashMap</code>，<code>HashSet</code> 基本就没什么问题。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>主要就两个变量:</p><ul><li><code>map</code> ：用于存放最终数据的。</li><li><code>PRESENT</code> ：是所有写入 map 的 <code>value</code> 值。</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数也很简单，利用 <code>HashMap</code> 初始化了 map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new set containing the elements in the specified</span></span><br><span class="line"><span class="comment"> * collection.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor</span></span><br><span class="line"><span class="comment"> * (0.75) and an initial capacity sufficient to contain the elements in</span></span><br><span class="line"><span class="comment"> * the specified collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash table</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的就是这个 <code>add()</code> 方法。 可以看出它是将存放的对象当做了 <code>HashMap</code> 的健，<code>value</code> 都是相同的 <code>PRESENT</code> 。由于 <code>HashMap</code> 的 <code>key</code> 是不能重复的，所以每当有重复的值写入到 <code>HashSet</code> 时，<code>value</code> 会被覆盖，但 <code>key</code> 不会受到影响，这样就保证了 <code>HashSet</code> 中只能存放不重复的元素。</p><h2 id="TreeSet-与-HashSet-的区别"><a href="#TreeSet-与-HashSet-的区别" class="headerlink" title="TreeSet 与 HashSet 的区别"></a>TreeSet 与 HashSet 的区别</h2><p>1、<code>TreeSet</code> 是二差树实现的，<code>Treeset</code>c中的数据是自动排好序的，不允许放入 null 值 2、<code>HashSet</code> 是哈希表实现的，<code>HashSet</code> 中的数据是无序的，可以放入 null，但只能放入一个 null，两者中的值都不能重复，就如数据库中唯一约束。</p><p>在 <code>HashSet</code> 中，基本的操作都是由 <code>HashMap</code> 底层实现的，因为 <code>HashSet</code> 底层是用 <code>HashMap</code> 存储数据的。当向<code>HashSet</code> 中添加元素的时候，首先计算元素的hashcode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。</p><p><code>TreeSet</code> 的底层是 <code>TreeMap</code> 的 keySet()，而 <code>TreeMap</code> 是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。</p><p><code>TreeMap</code> 是按key排序的，元素在插入 <code>TreeSet</code> 时 compareTo() 方法要被调用，所以 <code>TreeSet</code> 中的元素要实现Comparable 接口。<code>TreeSet</code> 作为一种Set，它不允许出现重复元素。<code>TreeSet</code> 是用 compareTo() 来判断重复元素的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>HashSet</code> 的原理比较简单，几乎全部借助于 <code>HashMap</code> 来实现的。即 <code>HashSet</code> 和 <code>HashMap</code> 是命运共同体，一荣俱荣，一损俱损。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;HashSet&lt;/code&gt; 是一个不允许存储重复元素的集合，它的实现比较简单，只要理解了 &lt;code&gt;HashMap&lt;/code&gt;，&lt;code&gt;HashSet&lt;/code&gt; 基本就没什么问题。&lt;/p&gt;&lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; 
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HashSet" scheme="https://muhouer.github.io/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList分析</title>
    <link href="https://muhouer.github.io/posts/5c1acfc0/"/>
    <id>https://muhouer.github.io/posts/5c1acfc0/</id>
    <published>2019-08-18T05:55:00.000Z</published>
    <updated>2019-08-20T16:46:27.303Z</updated>
    
    <content type="html"><![CDATA[<p><code>LinkedList</code> 底层是基于双向链表 <code>Deque</code> 实现的，也是实现了 <code>List</code> 接口，所以也拥有 List 的一些特点，出场率不高，了解一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>即类似如下形式：</p><p><code>first.prev == null &amp;&amp; first.next == a</code> &lt;——&gt; <code>a.prev = first&amp;&amp; a.next == last</code> &lt;——&gt; <code>last.prev == a &amp;&amp; last.next == null</code></p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>每次插入都是移动指针，和 <code>ArrayList</code> 的拷贝数组相比效率提升不少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>利用了双向链表的特性，使用空间来换取时间。如果索引值小于链表大小的一半，即 <code>index</code> 离链表头比较近，就从节点头部遍历，否则将从尾结点开始遍历。这就导致效率降低，特别是当 <code>index</code> 越接近 <code>size</code> 的中间值时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>LinkedList 插入，删除都是移动指针效率很高。</li><li>查找需要进行遍历查询，效率较低。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; 底层是基于双向链表 &lt;code&gt;Deque&lt;/code&gt; 实现的，也是实现了 &lt;code&gt;List&lt;/code&gt; 接口，所以也拥有 List 的一些特点，出场率不高，了解一下。&lt;/p&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="LinkedList" scheme="https://muhouer.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>HashMap分析</title>
    <link href="https://muhouer.github.io/posts/9c86c04c/"/>
    <id>https://muhouer.github.io/posts/9c86c04c/</id>
    <published>2019-08-18T01:34:00.000Z</published>
    <updated>2019-08-18T06:07:55.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Map 这样的 <code>Key Value</code> 在软件开发中是非常经典的结构，常用于在内存中存放数据。Java 中最常用的 Map 有两种，首先是 HashMap ，其次是 ConcurrentHashMap 。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>从整个 HashMap 的声明可以看出它内部是基于<strong>数组</strong> + <strong>链表</strong>实现的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p><h3 id="基于-1-7"><a href="#基于-1-7" class="headerlink" title="基于 1.7"></a>基于 1.7</h3><p>HashMap 在 jdk1.7 中的数据结构图：<br><img src="/images/5cd1d2be77958.png" width="900px" height="600px" align="center"><br>首先来看 jdk1.7 中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//初始化桶大小，因为底层是数组，所以这是数组默认的大小。默认大小16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">//桶最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; <span class="comment">//真正存放数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;      <span class="comment">//存放key-value元素的个数</span></span><br><span class="line"><span class="keyword">int</span> threshold;           <span class="comment">//桶容量大小，可在初始化时显式指定，扩容判定threshold = capacity * loadFactor，默认为0.75 * 16 = 12</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;  <span class="comment">//负载因子，可在初始化时显式指定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个属性是在抽象类AbstractMap中定义的</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt;        keySet = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Map 在使用过程中不断的往里面存放数据，当数量达到了 threshold 就需要将当前容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。因此通常建议能<strong>提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗</strong>。</p></blockquote><p>根据代码可以看到其实真正存放数据的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p>这个数组，那么它又是如何定义的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry 是 HashMap 中的一个内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;     <span class="comment">// key，写入时的键</span></span><br><span class="line">    V value;         <span class="comment">// value，值</span></span><br><span class="line">    Entry&lt;K,V&gt; next; <span class="comment">// 用于实现链表结构，当有hash冲突，存储的下一个元素</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">// 当前 key 的 hashcode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> key;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">      V oldValue = value;</span><br><span class="line">      value = newValue;</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上即为 HashMap 的基本结构，接下来来看写入和获取方法：</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123; // 判断当前数组是否需要初始化。</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key == null) // 如果 key 为空，则 put 一个空值进去</span><br><span class="line">        return putForNullKey(value); // </span><br><span class="line">    int hash = hash(key); // 计算根据 key 计算出 hash 值------</span><br><span class="line">    int i = indexFor(hash, table.length); // 根据计算出的 hash 值定位出所在桶</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 如果桶是一个链表则，需要遍历判断</span><br><span class="line">        Object k;</span><br><span class="line">        // hash 值、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 桶是空的，说明当前位置没有数据存入</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i); // 新增一个 Entry 对象写入当前位置</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    // 初始容量是一个偶数，当 length-1 的时候，这个数的有效二进制位都是1。</span><br><span class="line">    // 只要保证了 h 的分散性就行。&amp;用来取mod运算，效率比%高。</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; // 判断是否需要扩容</span><br><span class="line">        resize(2 * table.length); // 两倍扩充</span><br><span class="line">        hash = (null != key) ? hash(key) : 0; // 当前的 key 重新 hash</span><br><span class="line">        bucketIndex = indexFor(hash, table.length); // 重新定位</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key); <span class="comment">// 根据 key 计算出 hash 值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; </span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123; <span class="comment">// 定位到具体的桶中</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">            <span class="keyword">return</span> e; <span class="comment">//  key 及 hash 值相等时候就返回对应的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回 null </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表死循环"><a href="#链表死循环" class="headerlink" title="链表死循环"></a>链表死循环</h4><p><a href="https://blog.csdn.net/xyh930929/article/details/84777301" target="_blank" rel="noopener">HashMap由并发引起的链表死循环</a></p><h3 id="基于-1-8"><a href="#基于-1-8" class="headerlink" title="基于 1.8"></a>基于 1.8</h3><p>HashMap 在 jdk1.7 的实现中有个明显缺点：</p><blockquote><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。</p></blockquote><p>因此 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 <code>O(logn)</code>。</p><p>话不多说，上🐎：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>和 1.7 大体上都差不多，还是有几个重要的区别：</p><ul><li><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</li><li><code>Entry</code> 修改为 <code>Node</code>。</li></ul><p>Node 的核心组成其实也是和 1.7 中的 Entry 一样，存放的都是 <code>key value hashcode next</code> 等数据。</p><h4 id="put-方法-1"><a href="#put-方法-1" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length; <span class="comment">// 当前桶为空，进行初始化（resize 中会判断是否进行初始化）</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 根据当前 key 的 hash 值定位到具体的桶中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 为空表明没有 Hash 冲突就直接在当前位置创建一个新桶</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 不为空，有 Hash 冲突</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p; <span class="comment">// 比较当前桶中的 key、key 的 hash 值与写入的 key 是否相等，相等就赋值给 e</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前桶为红黑树，那就要按照红黑树的方式写入数据</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果在遍历过程中找到 key 相同时直接退出遍历</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 存在相同的 key ，需要将值覆盖</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 判断是否需要进行扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="comment">// 将 key hash 之后取得所定位的桶</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断桶的第一个位置的 key 是否为查询的 key，是就直接返回 value。</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 红黑树</span></span><br><span class="line">                    <span class="comment">// 按照树的查找方式返回值</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">// 链表</span></span><br><span class="line">                    <span class="comment">// 按照链表的方式遍历匹配返回值</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 桶为空则直接返回 null </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>HashMap 在并发时可能出现的问题主要有三个方面：</p><ul><li><p>如果多个线程同时使用 put 方法添加元素，而且假设正好存在两个 put 的 key 发生了碰撞（根据 hash 值计算的 bucket 一样），那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程 put 的数据被覆盖。</p></li><li><p>如果多个线程同时检测到元素个数超过 threshold，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。</p></li></ul><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String key = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>强烈建议</code>使用第一种 EntrySet 进行遍历。第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。</p><blockquote><p>无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题）。</p></blockquote><p>因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 <code>java.util.concurrent</code> 包下，专门用于解决并发问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Map 这样的 &lt;code&gt;Key Value&lt;/code&gt; 在软件开发中是非常经典的结构，常用于在内存中存放数据。Java 中最常用的 M
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HashMap" scheme="https://muhouer.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>String分析</title>
    <link href="https://muhouer.github.io/posts/4a48cd1d/"/>
    <id>https://muhouer.github.io/posts/4a48cd1d/</id>
    <published>2019-08-18T01:31:00.000Z</published>
    <updated>2019-08-18T01:33:43.976Z</updated>
    
    <content type="html"><![CDATA[<p><code>String</code> 这个类是我们在写 Java 代码中用得最多的一个类，没有之一，今天我们就讲讲它。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>String</code> 并不是基本数据类型，而是一个对象，并且是不可变的对象。</p><p>查看源码就会发现 <code>String</code> 类为<code>final</code> 型的(当然也不可被继承)，而且通过查看 JDK 文档会发现几乎每一个修改 <code>String</code> 对象的操作，实际上都是创建了一个全新的 <code>String</code> 对象。</p><p><code>String</code> 类实现了 <code>Serializable</code>，<code>Comparable</code>，<code>CharSequence</code>接口，被 <code>final</code> 修饰。内部维护了一个字符数组。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">== <span class="comment">// 判断内容与地址是否相同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> <span class="comment">// 判断两个字符串内容是否相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> <span class="comment">// 忽略大小写，判断两个字符串内容是否相同，底层调用了regionMatches方法</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span> <span class="comment">// 判断字符序列和字符串内容是否相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span> <span class="comment">// 判断StringBuffer和字符串内容是否相同，实际上调用的是contentEquals方法</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> <span class="comment">// 按照字典大小比较两个字符串的大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span> <span class="comment">// 忽略大小写，按照字典大小比较两个字符串的大小，使用忽略大小写比较器</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断两个字符串部分内容是否相同，ignoreCase:是否忽略大小写，toffset:子字符串的偏移量，ooffset:参数字符串中子字符串的偏移量，len:比较的子字符串的长度</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 返回索引上的字符，索引从0开始</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> <span class="comment">// 从字符串开始检索字符(Unicode 码) ch，并返回第一次出现的位置，未出现返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch，<span class="keyword">int</span> fromIndex)</span> <span class="comment">// 从字符串的第fromIndex个字符开始检索字符(Unicode 码) ch，未出现返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> <span class="comment">// 从字符串检索字符(Unicode 码) ch最后一次出现的位置。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> <span class="comment">//从字符串的第fromIndex个字符检索字符(Unicode 码) ch最后一次出现的位置。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> <span class="comment">// 判断此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> <span class="comment">// 判断此字符串是否以指定前缀开始。</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> <span class="comment">// 判断此字符串是否以指定后缀结尾。</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串截取与替换"><a href="#字符串截取与替换" class="headerlink" title="字符串截取与替换"></a>字符串截取与替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> <span class="comment">// 返回一个新的字符串，是从beginIndex开始到length-1的串。</span></span></span><br><span class="line"><span class="function">String <span class="title">subString</span><span class="params">(<span class="keyword">int</span> beginIndex，<span class="keyword">int</span> endIndex)</span>------返回一个新的字符串，是从beginIndex开始到endIndex-1的串。</span></span><br><span class="line"><span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> <span class="comment">// 返回从beginIndex开始到endIndex-1的字符序列</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> <span class="comment">// 将字符串中的oldChar字符替换为newChar</span></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> <span class="comment">// 将字符串中的target字符序列替换为replacement序列</span></span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> <span class="comment">// 使用replacement替换第一个通过regex匹配到子串。</span></span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> <span class="comment">// 使用replacement替换所有通过regex匹配到子串。</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串其他常用方法"><a href="#字符串其他常用方法" class="headerlink" title="字符串其他常用方法"></a>字符串其他常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="comment">// 获取字符串长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="comment">// 判断字符串是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span> <span class="comment">// 判断字符串是否包含字符序列 s</span></span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span> <span class="comment">// 字符串拼接</span></span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span> <span class="comment">// 字符串去掉首尾空白</span></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">(Locale locale)</span> <span class="comment">// 字符串转大写</span></span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span> <span class="comment">// 字符串转小写</span></span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex)</span> <span class="comment">// 字符串分割</span></span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span> <span class="comment">// 字符串分割，多了结果阈值参数</span></span></span><br></pre></td></tr></table></figure><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>第一种方式是在常量池中直接拿对象，第二种是在堆内存空间创建一个新的对象。只要使用new方法，就需要创建新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Freya"</span>); <span class="comment">// 这句话创建了两个对象。</span></span><br></pre></td></tr></table></figure><p>首先，字符串“Freya”放入常量池，然后 new 了一个字符串“Freya”放入 Java 堆。字符串常量”Freya”在编译期就已经确定放入常量池，而 Java 堆上的”Freya”是在运行期初始化阶段才确定。然后 Java 栈中的 str 指向了 Java 堆中的 “Freya”。</p><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>字符串常量池是 JVM 实例全局共享的，全局只有一个。字符串常量池及到一个设计模式，叫“享元模式”，顾名思义 就是<strong>共享元素模式</strong>。也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素。</p><ul><li>直接使用双引号声明的 String 对象直接存储在字符串常量池。</li><li>不是双引号声明的，可以使用 <code>String.intern()</code> 方法，这是一个Native方法。如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"Freya"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String b = <span class="string">"Freya"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String c = <span class="keyword">new</span> String(<span class="string">"Freya"</span>);</span><br><span class="line">    String d = a.intern();</span><br><span class="line">    String e = <span class="string">"Freya"</span> + <span class="string">" 17"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String f = <span class="string">" 17"</span>;</span><br><span class="line">    String g = a + f; <span class="comment">//在堆上创建的新的对象</span></span><br><span class="line">    String h = <span class="string">"Freya 17"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line">    System.out.println(a == c); <span class="comment">//false</span></span><br><span class="line">    System.out.println(a == d); <span class="comment">//true</span></span><br><span class="line">    System.out.println(e == g); <span class="comment">//false</span></span><br><span class="line">    System.out.println(e == h); <span class="comment">//true</span></span><br><span class="line">    System.out.println(g == h); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变，可以使用StringBuilder或者StringBuffer。</p></blockquote><h2 id="String-对象的不可变性"><a href="#String-对象的不可变性" class="headerlink" title="String 对象的不可变性"></a>String 对象的不可变性</h2><p>打开 <code>String</code> 类源码，可以看到一句话:</p><blockquote><p>Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared.</p></blockquote><p>意思是 <code>String</code> 是个常量，创建之后就是不可变的。不可变的意思是不能改变对象内的成员变量，包括基本数据类型变量的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><h3 id="String-对象不可变性是如何实现的？"><a href="#String-对象不可变性是如何实现的？" class="headerlink" title="String 对象不可变性是如何实现的？"></a>String 对象不可变性是如何实现的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length); <span class="comment">// deep copy操作</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">     <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">        <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];</span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出：</p><ul><li>String 类被 final 修饰，不可继承。</li><li>String内部所有成员都设置为私有变量。</li><li>不存在value的setter方法。</li><li>将value和offset设置为final。</li><li>当传入可变数组value[]时，进行copy而不是直接将value[]复制给内部变量。</li><li>获取value时不是直接返回对象引用，而是返回对象的copy。</li></ul><h3 id="String-对象不可变性的优缺点"><a href="#String-对象不可变性的优缺点" class="headerlink" title="String 对象不可变性的优缺点"></a>String 对象不可变性的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p><strong>字符串常量池的需要</strong><br>字符串常量池可以将一些字符常量放在常量池中重复使用，避免每次都重新创建相同的对象、节省存储空间。但如果字符串是可变的，此时相同内容的String还指向常量池的同一个内存空间，当某个变量改变了该内存的值时，其他遍历的值也会发生改变。所以不符合常量池设计的初衷。</p></li><li><p><strong>线程安全考虑</strong><br>同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p></li><li><p><strong>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载</strong></p><p>譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</p></li><li><p><strong>支持hash映射和缓存</strong><br>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果有对String对象值改变的需求，那么会创建大量的String对象。</p><h2 id="String对象是否真的不可变"><a href="#String对象是否真的不可变" class="headerlink" title="String对象是否真的不可变"></a>String对象是否真的不可变</h2><p>虽然 String 对象将 value 设置为 final，并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>;</span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s); <span class="comment">//Hello World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">//Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="其他相关内容"><a href="#其他相关内容" class="headerlink" title="其他相关内容"></a>其他相关内容</h2><h3 id="substring-方法"><a href="#substring-方法" class="headerlink" title="substring 方法"></a>substring 方法</h3><p>在 JDK 1.6中，当调用 substring 方法的时候，会创建一个新的 String 对象，但是这个 String 的值仍然指向堆中的同一个字符数组。这两个对象中只有 count 和offset 的值是不同的。如果你有一个很长很长的字符串，但是当你使用 substring 进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 1.6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x.substring(x, y) + <span class="string">""</span></span><br></pre></td></tr></table></figure><p>以上问题在jdk 7+中得到解决。在jdk 7+ 中，substring方法会在堆内存中创建一个新的数组。其使用<code>new String</code>创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。</p><h3 id="String-valueOf和Integer-toString的区别"><a href="#String-valueOf和Integer-toString的区别" class="headerlink" title="String.valueOf和Integer.toString的区别"></a>String.valueOf和Integer.toString的区别</h3><p>我们有三种方式将一个int类型的变量变成呢过String类型，那么他们有什么区别？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">String i1 = <span class="string">""</span> + i; <span class="comment">//其实是String i1 = (new StringBuilder()).append(i).toString();，首先创建一个StringBuilder对象，然后再调用append方法，再调用toString方法。</span></span><br><span class="line">String i2 = String.valueOf(i); <span class="comment">//调用 Integer.toString(i)</span></span><br><span class="line">String i3 = Integer.toString(i);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;String&lt;/code&gt; 这个类是我们在写 Java 代码中用得最多的一个类，没有之一，今天我们就讲讲它。&lt;/p&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;co
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="String" scheme="https://muhouer.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList分析</title>
    <link href="https://muhouer.github.io/posts/b0d3e399/"/>
    <id>https://muhouer.github.io/posts/b0d3e399/</id>
    <published>2019-08-18T01:27:00.000Z</published>
    <updated>2019-08-18T01:33:09.325Z</updated>
    
    <content type="html"><![CDATA[<p><code>ArrayList</code> 实现于 <code>List</code>、<code>RandomAccess</code> 接口。可以插入空数据，也支持随机访问。</p><p><code>ArrayList</code> 相当于动态数据，其中最重要的两个属性分别是: <code>elementData</code> 数组，以及 <code>size</code> 大小。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 默认的初始化容量 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/** 空 ArrayList 实例共享的空数组实例 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/** 默认大小的空 ArrayList 实例共享的空数组实例，和 EMPTY_ELEMENTDATA 区分开 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 存储arraylist元素的数组缓冲区。</span></span><br><span class="line"><span class="comment"> * 任何使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空 ArrayList 实例，</span></span><br><span class="line"><span class="comment"> * 在首次添加元素时容量扩展到默认容量 DEFAULT_CAPACITY 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// 非私有以简化嵌套类访问</span></span><br><span class="line"><span class="comment">/** ArrayList包含的元素个数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123; <span class="comment">// 新建 initialCapacity 大小的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123; <span class="comment">// 采用 EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123; <span class="comment">// 采用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，和 EMPTY_ELEMENTDATA 区分开来</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-toArray-might-incorrectly-not-return-Object-see-6260652"><a href="#c-toArray-might-incorrectly-not-return-Object-see-6260652" class="headerlink" title="c.toArray might (incorrectly) not return Object[] (see 6260652)"></a>c.toArray might (incorrectly) not return Object[] (see 6260652)</h2><p>查看 <code>ArrayList(Collection&lt;? extends E&gt; c)</code> 构造函数时，有个注释 <strong>c.toArray might (incorrectly) not return Object[] (see 6260652)</strong>，具体什么意思呢？先看个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>));</span><br><span class="line">list.set(<span class="number">0</span>, <span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure><p>如果 ArrayList 的构造函数中没有类型检查的代码 <code>elementData.getClass() != Object[].class</code>，会导致其elementData 的实际类型是String[]，而不是 Object[]，所以当你将其中一个元素更换为 Object 元素时会报错，你可以试下如下代码，肯定会报 ArrayStoreException 的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>&#125;;</span><br><span class="line">arr[<span class="number">0</span>]=<span class="keyword">new</span> Object(); <span class="comment">// Causes ArrayStoreException,</span></span><br><span class="line">                     <span class="comment">// because you cannot put arbitrary Object into String[]</span></span><br></pre></td></tr></table></figure><p>主要问题出在 <code>Arrays.asList</code> 上面，<code>Arrays.asList</code> 返回的 ArrayList 实际上是内部类 ArrayList ，并不是我们经常使用的 <code>ArrayList</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>内部类 ArrayList 的 <code>toArray()</code> 使用的是 <code>clone</code> 方法，而我们经常使用的 <code>ArrayList</code> 的 <code>toArray()</code> 使用的是 <code>Arrays.copyOf()</code> 方法，具体差别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = <span class="keyword">new</span> ArrayList&lt;Object&gt;(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>)).toArray();</span><br><span class="line">System.out.println(arr.getClass()); <span class="comment">// class [Ljava.lang.Object; Object数组</span></span><br><span class="line">Object[] arr1 = Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>).toArray();</span><br><span class="line">System.out.println(arr1.getClass()); <span class="comment">// class [Ljava.lang.String; String 数组，操作不当会引起 ArrayStoreException</span></span><br></pre></td></tr></table></figure><p>关于 <code>Arrays.asList</code> 的一个坑 <a href="/posts/45d267df/" title="使用Java时的一些坑">使用Java时的一些坑</a></p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>在调用 <code>add()</code> 方法的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先进行扩容校验。</li><li>将插入的值放到尾部，并将 size + 1 。</li></ul><p>如果是调用 <code>add(index,e)</code> 在指定位置添加的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//复制，向后移动</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也是首先扩容校验。</li><li>接着对数据进行复制，目的是把 index 位置空出来放本次插入的数据，并将后面的数据向后移动一个位置。</li></ul><p>其实扩容最终调用的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是一个数组复制的过程。</p><p>由此可见 <code>ArrayList</code> 的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>由于 ArrayList 是基于动态数组实现的，所以并不是所有的空间都被使用。因此使用了 <code>transient</code> 修饰，可以防止被自动序列化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure><p>因此 ArrayList 自定义了序列化与反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="comment">//只序列化了被使用的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从实现中可以看出 ArrayList 只序列化了被使用的数据。</p><h2 id="ArrayList-VS-Vector"><a href="#ArrayList-VS-Vector" class="headerlink" title="ArrayList VS Vector"></a>ArrayList VS Vector</h2><p><code>Vector</code> 也是实现于 <code>List</code> 接口，底层数据结构和 <code>ArrayList</code> 类似，也是一个动态数组存放数据。不过是在 <code>add()</code> 方法的时候使用 <code>synchronized</code> 进行同步写数据，但是开销较大，所以 <code>Vector</code> 是一个同步容器并不是一个并发容器。</p><p>以下是 <code>add()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及指定位置插入数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 实现于 &lt;code&gt;List&lt;/code&gt;、&lt;code&gt;RandomAccess&lt;/code&gt; 接口。可以插入空数据，也支持随机访问。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 相当于动态数据，其中最重要的两个属
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ArrayList" scheme="https://muhouer.github.io/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式备忘</title>
    <link href="https://muhouer.github.io/posts/2c992fa9/"/>
    <id>https://muhouer.github.io/posts/2c992fa9/</id>
    <published>2019-08-17T15:54:00.000Z</published>
    <updated>2019-08-17T16:04:20.975Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子。</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式主要依赖于元字符. 元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>句号匹配任意单个字符除了换行符.</td></tr><tr><td>[ ]</td><td>字符种类. 匹配方括号内的任意字符.</td></tr><tr><td>[^ ]</td><td>否定的字符种类. 匹配除了方括号里的任意字符</td></tr><tr><td>*</td><td>匹配&gt;=0个重复的在*号之前的字符.</td></tr><tr><td>+</td><td>匹配&gt;=1个重复的+号前的字符.</td></tr><tr><td>?</td><td>标记?之前的字符为可选.</td></tr><tr><td>{n,m}</td><td>匹配num个大括号之前的字符 (n &lt;= num &lt;= m).</td></tr><tr><td>(xyz)</td><td>字符集, 匹配与 xyz 完全相等的字符串.</td></tr><tr><td>|</td><td>或运算符,匹配符号前或后的字符.</td></tr><tr><td>\</td><td>转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td></tr><tr><td>^</td><td>从开始行开始匹配.</td></tr><tr><td>$</td><td>从末端开始匹配.</td></tr></tbody></table><h2 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h2><p>正则表达式提供一些常用的字符集简写. 如下:</p><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>除换行符外的所有字符</td></tr><tr><td>\w</td><td>匹配所有字母数字, 等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td>\W</td><td>匹配所有非字母数字, 即符号, 等同于: <code>[^\w]</code></td></tr><tr><td>\d</td><td>匹配数字: <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配非数字: <code>[^\d]</code></td></tr><tr><td>\s</td><td>匹配所有空格字符, 等同于: <code>[\t\n\f\r\p{Z}]</code></td></tr><tr><td>\S</td><td>匹配所有非空格字符: <code>[^\s]</code></td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符</td></tr><tr><td>\p</td><td>匹配 CR/LF (等同于 <code>\r\n</code>)，用来匹配 DOS 行终止符</td></tr></tbody></table><h2 id="零宽度断言-前后预查"><a href="#零宽度断言-前后预查" class="headerlink" title="零宽度断言(前后预查)"></a>零宽度断言(前后预查)</h2><p>先行断言和后发断言都属于<strong>非捕获簇</strong>(不捕获文本 ，也不针对组合计进行计数). 先行断言用于判断所匹配的格式是否在另一个确定的格式之前, 匹配结果不包含该确定格式(仅作为约束).</p><p>例如, 我们想要获得所有跟在 <code>$</code> 符号后的数字, 我们可以使用正后发断言 <code>(?&lt;=\$)[0-9\.]*</code>. 这个表达式匹配 <code>$</code> 开头, 之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p><p>零宽度断言如下:</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>?=</td><td>正先行断言-存在</td></tr><tr><td>?!</td><td>负先行断言-排除</td></tr><tr><td>?&lt;=</td><td>正后发断言-存在</td></tr><tr><td>?&lt;!</td><td>负后发断言-排除</td></tr></tbody></table><h3 id="正先行断言"><a href="#正先行断言" class="headerlink" title="?=... 正先行断言"></a><code>?=...</code> 正先行断言</h3><p><code>?=...</code> 正先行断言, 表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式.</p><p>返回结果只包含满足匹配条件的第一部分表达式. 定义一个正先行断言要使用 <code>()</code>. 在括号内部使用一个问号和等号: <code>(?=...)</code>.</p><p>正先行断言的内容写在括号中的等号后面. 例如, 表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ,即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he(?=\sfat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h3 id="负先行断言"><a href="#负先行断言" class="headerlink" title="?!... 负先行断言"></a><code>?!...</code> 负先行断言</h3><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果, 筛选条件为 其后不跟随着断言中定义的格式. <code>正先行断言</code> 定义和 <code>负先行断言</code> 一样, 区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>.</p><p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>(空格)fat</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he(?!\sfat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h3 id="lt-正后发断言"><a href="#lt-正后发断言" class="headerlink" title="?&lt;= ... 正后发断言"></a><code>?&lt;= ...</code> 正后发断言</h3><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着断言中定义的格式. 例如, 表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(?&lt;=(T|t)he\s)(fat|mat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h3 id="lt-负后发断言"><a href="#lt-负后发断言" class="headerlink" title="?&lt;!... 负后发断言"></a><code>?&lt;!...</code> 负后发断言</h3><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟随着断言中定义的格式. 例如, 表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(?&lt;!(T|t)he\s)(cat)&quot; =&gt; The cat sat on cat.</span><br></pre></td></tr></table></figure><h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志也叫模式修正符, 因为它可以用来修改表达式的搜索结果. 这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写.</td></tr><tr><td>g</td><td>全局搜索.</td></tr><tr><td>m</td><td>多行的: 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始.</td></tr></tbody></table><h2 id="贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h2><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/(.*at)/&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/(.*?at)/&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>点击<a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">learn-regex</a>即可去查看更详细信息。</p><p><a href="https://jex.im/regulex/" target="_blank" rel="noopener">Regulex</a>是一个JavaScript 正则表达式解析和可视化网站。具体效果参看👇示例。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h3><p>只允许英文字母、数字、下划线、英文句号、以及中划线组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$</span><br></pre></td></tr></table></figure><img src="/images/201908171144.png" width="900px" height="300px" align="center"><h3 id="汉字"><a href="#汉字" class="headerlink" title="汉字"></a>汉字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[\u4e00-\u9fa5]&#123;0,&#125;$</span><br></pre></td></tr></table></figure><img src="/images/201908171151.png" width="900px" height="300px" align="center"><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br></pre></td></tr></table></figure><img src="/images/201908171153.png" width="900px" height="300px" align="center">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子。&lt;/p&gt;&lt;h2 id=&quot;元字符&quot;&gt;&lt;a href=&quot;#元字符&quot; class=&quot;headerlink&quot; title=&quot;元字符&quot;&gt;&lt;/a&gt;元字符&lt;/h2&gt;&lt;p&gt;正则表达式主要依赖于元字符
      
    
    </summary>
    
      <category term="备忘" scheme="https://muhouer.github.io/categories/%E5%A4%87%E5%BF%98/"/>
    
    
      <category term="正则表达式" scheme="https://muhouer.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>拾句-玩笑</title>
    <link href="https://muhouer.github.io/posts/25a3a536/"/>
    <id>https://muhouer.github.io/posts/25a3a536/</id>
    <published>2019-08-16T15:16:00.000Z</published>
    <updated>2019-08-16T15:19:54.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="001"><a href="#001" class="headerlink" title="001"></a>001</h3><hr><ol><li><strong>女大三抱金砖。女大三十送江山。女大三百送仙丹。</strong></li><li><strong>上帝是公平的，不是公的就是平的。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;001&quot;&gt;&lt;a href=&quot;#001&quot; class=&quot;headerlink&quot; title=&quot;001&quot;&gt;&lt;/a&gt;001&lt;/h3&gt;&lt;hr&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;女大三抱金砖。女大三十送江山。女大三百送仙丹。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="拾句" scheme="https://muhouer.github.io/categories/%E6%8B%BE%E5%8F%A5/"/>
    
    
      <category term="玩笑" scheme="https://muhouer.github.io/tags/%E7%8E%A9%E7%AC%91/"/>
    
  </entry>
  
  <entry>
    <title>一些名词</title>
    <link href="https://muhouer.github.io/posts/6bf34d15/"/>
    <id>https://muhouer.github.io/posts/6bf34d15/</id>
    <published>2019-08-12T13:45:00.000Z</published>
    <updated>2019-08-19T15:55:05.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="鞣酸"><a href="#鞣酸" class="headerlink" title="鞣酸"></a>鞣酸</h2><p>鞣酸系由五倍子中得到的一种鞣质。为黄色或淡棕色轻质无晶性粉末或鳞片；无臭，微有特殊气味，味极涩。溶于水及乙醇，易溶于甘油，几乎不溶于乙醚、氯仿或苯。其水溶液与铁盐溶液相遇变蓝黑色，加亚硫酸钠可延缓变色。在工业上，鞣酸被大量应用于鞣革与制造蓝墨水。鞣酸能使蛋白质凝固。人们把生猪皮、生牛皮用鞣酸进行化学处理，能使生皮中的可溶性蛋白质凝固。于是，本来放上几天就会发臭腐烂的生皮，变成了漂亮、干净、柔韧、经久耐用的皮革。</p><h2 id="选拔考试与诊断考试"><a href="#选拔考试与诊断考试" class="headerlink" title="选拔考试与诊断考试"></a>选拔考试与诊断考试</h2><p>选拔考试，类似于中考高考，你考多少分不重要，59分算高还是低无所谓，关键取决于别人考的怎么样，你考59分，别人都在58分以下，你就有机会读名校；你考59分，人家考95分，对不起，你就回家干活，这叫选拔考试。</p><p>除了中考高考以外，所有的考试都叫诊断考试（测验），即老师教了一个知识点，出一道题看看学生掌握得怎么样了。</p><h2 id="海姆立克急救法"><a href="#海姆立克急救法" class="headerlink" title="海姆立克急救法"></a>海姆立克急救法</h2><p>海姆立克教授是美国一位多年从事外科的医生。在临床实践中，他被大量的食物、异物窒息造成呼吸道梗阻致死的病例震惊了。在急救急诊中，医生常常采用拍打病人背部，或将手指伸进口腔咽喉去取的办法排除异物，其结果不仅无效反而使异物更深入呼吸道。他经过反复研究和多次的动物实验，终于发明了利用肺部残留气体，形成气流冲出异物的急救方法。1974年，他作了关于腹部冲击法解除气管异物的首次报告。</p><p>异物堵塞在呼吸道中的事情在我们的生活中并不少见，前段时间就出现了类似的案列。所以由于异物堵塞在呼吸道中引起的后果还是很严重的。海姆立克急救法也叫海姆里克腹部冲击法（Heimlich Maneuver），是美国医生海姆里克先生发明的，也称为海氏手技。</p><h3 id="成人"><a href="#成人" class="headerlink" title="成人"></a>成人</h3><p>如果是成人，救护者站在受害者身后，从背后抱住其腹部，双臂围环其腰腹部，一手握拳，拳心向内按压于受害人的肚脐和肋骨之间的部位；另一手成掌捂按在拳头之上，双手急速用力向里向上挤压，反复实施，直至阻塞物吐出为止。</p><h3 id="3岁以下孩子"><a href="#3岁以下孩子" class="headerlink" title="3岁以下孩子"></a>3岁以下孩子</h3><p>如果是3岁以下孩子，应该马上把孩子抱起来，一只手捏住孩子颧骨两侧，手臂贴着孩子的前胸，另一只手托住孩子后颈部，让其脸朝下，趴在救护人膝盖上。在孩子背上拍1-5次，并观察孩子是否将异物吐出。</p><h3 id="婴儿"><a href="#婴儿" class="headerlink" title="婴儿"></a>婴儿</h3><ol><li><strong>5次拍背法</strong>：将患者的身体扶于救护员的前臂上，头部朝下，救护员用手支撑伤病者头部及颈部；用另一手掌掌根在伤病者背部两肩胛骨之间拍击5次。</li><li><strong>5次压胸法</strong>：如果堵塞物仍未排除，实施5次压胸法。使患儿平卧，面向上，躺在坚硬的地面或床板上，抢救者跪下或立于其足侧,或取坐位，并使患儿骑在抢救者的两大腿上，面朝前。抢救者以两手的中指或食指，放在患儿胸廓下和脐上的腹部，快速向上重击压迫，但要刚中带柔。重复之，直至异物排出。</li></ol><h2 id="垃圾DNA"><a href="#垃圾DNA" class="headerlink" title="垃圾DNA"></a>垃圾DNA</h2><p>人类大约有95%的DNA并不编码蛋白质，另外5%的DNA可以分成大约十万个功能单位，它们被称为基因。</p><p>研究人员从对比结果中得到了一个惊人的模式：生物越复杂，垃圾DNA似乎就越重要。他们将酵母与更为复杂的蠕虫进行了比较，后者是一种多细胞生物，发现有40%的共有DNA没有被编码。随后，研究人员又将脊椎动物与昆虫进行了对比，这些生物比蠕虫更为复杂，结果发现，有超过66%的共有DNA包含有没有编码的DNA。</p><p>如果这些“垃圾DNA”序列能在电脑屏幕上展现出一个像素数组或一个简单的图像，那么，外星生物曾干预人类DNA的设想就极可能是真的。人类DNA可容纳“外星兴衰史”编码戴维斯称，人类的DNA编码足够容纳一部像样的小说，或者一段外星文明的兴盛和衰落简史。</p><p>垃圾DNA可以说是基因组的暗面，它将改变生物学的面貌，就像暗物质和暗能量改变宇宙学的面貌那样。它既不能给蛋白质编码、充当基因，也不能给RNA编码，也没有找到明显的与蛋白质等其他分子发生相互作用的迹象。当然，完全有可能它是行使了某种功能的，只不过是在“暗地下”进行，而我们还没有能力看到它行使功能的身影罢了。</p><p>这些同时存在于不同哺乳动物DNA序列当中的保守非基因序列的相似性，甚至比同源的编码蛋白质、或者是编码RNA的基因还强。对于其中同时在至少12种物种当中发现的保守非基因序列，如果比较它们的核苷酸排列差异的话，还不及它们的蛋白质编码序列的核苷酸排列差异的一半！</p><p>很多的“垃圾” DNA包含了回文结构，以此维持互补链之间的对称。在果蝇和家蚕里，对这些序列的分析表明，这些转座和散开的重复序列是高度非随机模式。这些模式反映出这些序列是在细胞调控之下，而不是无用或自私的垃圾DNA。 在关系很远的物种之间，例如大型偶蹄类哺乳动物和人，在主要组织相容性复合MHC-DRB基因里都有这些简单重复的(gt)n(ga)m DNA序列。如果这些序列真是垃圾，在数百万年的进化过程中就不可能保存下来。</p><p>另一个研究表明，DNA包含了大范围的不可解释模式。Eugene Stanley博士报道这些模式不是随机改变的结果。一个基因上的一个位置将影响到100万碱基之外的核苷酸，这真是让人难以置信。因而遗传学家Moran认为，L1在人类进化中扮演着重要角色——增加遗传多样性。在嗜酸粒细胞衍生神经毒素、嗜酸细胞阳离子蛋白、IgM重排基因的可变区域、α-球蛋白基因、微管蛋白基因、4-N-乙酰半乳糖氨基转移酶、醛缩酶B基因、乙醛还原酶基因k轻链基因等等,都有基因內增强作用的描述。</p><p>另一些研究证实非编码DNA作为沉默基因,对临近基因的转录起抑制作用。在成骨素基因、2-晶体蛋白基因、CD4基因、β-珠蛋白基因、神经胶质细胞粘连分子、神经元-神经胶质细胞粘连分子、血小板衍生的生长因子A链基因、肾素基因等等的研究中对此有描述。</p><h2 id="冒充者综合征"><a href="#冒充者综合征" class="headerlink" title="冒充者综合征"></a>冒充者综合征</h2><p>冒充者综合征是指有些人即使获得了一些成绩与成果，但却特别不自信，甚至认为这不是自己应得的，而是冒充那些真正厉害的人而得到的。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>大声说出这种 “冒名顶替” 的感受。</li><li>记下你的努力与成就。</li><li>设置合理的目标与期望。</li></ol><h2 id="劳伦斯魔咒"><a href="#劳伦斯魔咒" class="headerlink" title="劳伦斯魔咒"></a>劳伦斯魔咒</h2><p>1999年，经济学家劳伦斯总结出了一个“摩天大楼指数”。他发现，世界上所有的摩天大楼都与经济周期的波动有着紧密联系。摩天大厦的开工时间通常都是经济发展的鼎盛时期，而一旦大厦建成，经济危机便随之席卷而来。这一规律似乎屡试不爽，因此也被称为“劳伦斯魔咒”。</p><h2 id="双盲试验"><a href="#双盲试验" class="headerlink" title="双盲试验"></a>双盲试验</h2><p>在试验过程中，测验者与被测验者都不知道被测者所属的组别（实验组或对照组），分析者在分析资料时，通常也不知道正在分析的资料属于哪一组。旨在消除可能出现在实验者和参与者意识当中的主观偏差和个人偏好。在大多数情况下，双盲实验要求达到非常高的科学严格程度。</p><h2 id="泡文化"><a href="#泡文化" class="headerlink" title="泡文化"></a>泡文化</h2><p>中国社会是一个人情社会，中国有一个很出名的词，就是「泡」。泡吧、泡妞，好兄弟「泡」在一起等等。「泡」这个字的偏旁是三滴水，这三滴水分别是时间、金钱和感情。中国人办事喜欢吃饭，需要先跟他们「泡」在一起,而且这仅仅是一个开始，说明你的事情有了可能性。有时候，只是为了见见，就跑很远的路去和对方一起吃一顿饭。没有别的目的，就是为了取悦对方，让他高兴，这样沟通才顺畅。</p><h2 id="达克效应"><a href="#达克效应" class="headerlink" title="达克效应"></a>达克效应</h2><p>达克效应（D-Keffect），全称为邓宁-克鲁格效应（Dunning-Krugereffect），指的是能力欠缺的人在自己欠考虑的决定的基础上得出错误结论。 通俗点解释，就是谢博德博士说的：“总有一些人认为自己什么都懂，或者低估自己不懂的事情。”</p><p>这个效应是由社会心理学家邓宁和克鲁格联合发现的，他们通过对人们阅读、驾驶、下棋或打网球等各种技能的研究发现： 在幽默感、文字能力和逻辑能力上最欠缺的那部分人总是高估自己，当他们实际得分只有12%时，却认为自己的得分在60%以上。</p><h2 id="认知失调"><a href="#认知失调" class="headerlink" title="认知失调"></a>认知失调</h2><p>谢博德博士在演讲中说了一个故事：2017年飓风哈维登陆美国得克萨斯州休斯顿市，3天之内降雨50英寸，整个城市都陷入了一片汪洋之中。</p><p>但在飓风登录前一周，谢博德博士就已经反复提醒休斯顿市民：根据观察，这次飓风到来可能会造成40到50英寸的降雨量。即便如此，市民们依然无所作为，并在一周后迎来了洪灾，造成了重大损失。为什么会这样？休斯顿当地虽然经常下雨，但之前全年的降雨量也才34英寸。谢博德博士所预言的“短时间内降雨40到50英寸”，已经超过了休斯顿市民能够理解的范围——几天之内就下完一整年的雨？这怎么可能！因为和自己过去的经验发生冲突，所以休斯顿市民说得最多的一句话就是：我看到了预警，但没想到真的会这么糟糕。</p><p>这就是谢博德博士说的“认知失调”：新信息与已有的信念相矛盾，无法理解现有经验外的事物的时候，会让人产生失调的感觉，这种感觉会驱使一个人去寻找合理化的解释，让自己的认知达到一致。休斯顿的市民就是这样，他们面对无法理解的新信息，就去找一个合理化的解释，觉得灾情不会那么糟糕，忽视科学家的警告，最后造成重大损失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;鞣酸&quot;&gt;&lt;a href=&quot;#鞣酸&quot; class=&quot;headerlink&quot; title=&quot;鞣酸&quot;&gt;&lt;/a&gt;鞣酸&lt;/h2&gt;&lt;p&gt;鞣酸系由五倍子中得到的一种鞣质。为黄色或淡棕色轻质无晶性粉末或鳞片；无臭，微有特殊气味，味极涩。溶于水及乙醇，易溶于甘油，几乎不溶于乙醚、氯
      
    
    </summary>
    
      <category term="日常记录" scheme="https://muhouer.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="名词" scheme="https://muhouer.github.io/tags/%E5%90%8D%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>如何优化缓存中百万级并发的key</title>
    <link href="https://muhouer.github.io/posts/2bc946e8/"/>
    <id>https://muhouer.github.io/posts/2bc946e8/</id>
    <published>2019-08-09T14:53:35.000Z</published>
    <updated>2019-08-09T15:15:30.491Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这个问题实际上就是热点key问题，其实热点key问题说来也很简单，就是瞬间有几十万上百万，甚至更大的请求去访问redis上某个固定的key，从而压垮缓存服务的情情况。<br>其实生活中也是有不少这样的例子，比如XX明星结婚。那么关于XX明星的Key就会瞬间增大，就会出现热点数据问题。</p><blockquote><p>PS:hot key和big key问题，大家一定要有所了解，非常重要。</p></blockquote><h2 id="热点Key问题"><a href="#热点Key问题" class="headerlink" title="热点Key问题"></a>热点Key问题</h2><p>上面提到，所谓热点key问题就是，突然有几十万甚至更大的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到Redis单实例瓶颈（一般是10W OPS级别），或者物理网卡上限，从而导致这台redis的服务器Hold不住。</p><p>那接下来这个key的请求，就会压垮你的服务。</p><h3 id="怎么发现热key"><a href="#怎么发现热key" class="headerlink" title="怎么发现热key"></a>怎么发现热key</h3><h4 id="方法一-凭借业务经验，进行预估哪些是热key"><a href="#方法一-凭借业务经验，进行预估哪些是热key" class="headerlink" title="方法一:凭借业务经验，进行预估哪些是热key"></a>方法一:凭借业务经验，进行预估哪些是热key</h4><p>其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。</p><h4 id="方法二-在客户端进行收集"><a href="#方法二-在客户端进行收集" class="headerlink" title="方法二:在客户端进行收集"></a>方法二:在客户端进行收集</h4><p>这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。</p><h4 id="方法三-在Proxy层做收集"><a href="#方法三-在Proxy层做收集" class="headerlink" title="方法三:在Proxy层做收集"></a>方法三:在Proxy层做收集</h4><p>有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。</p><p><img src="/images/201908091100.png" alt="upload successful"></p><h4 id="方法四-用redis自带命令"><a href="#方法四-用redis自带命令" class="headerlink" title="方法四:用redis自带命令"></a>方法四:用redis自带命令</h4><p>(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。</p><p>(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。</p><h4 id="方法五-自己抓包评估"><a href="#方法五-自己抓包评估" class="headerlink" title="方法五:自己抓包评估"></a>方法五:自己抓包评估</h4><p>Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。</p><p>以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>目前业内的方案有两种：</p><h3 id="二级缓存（推荐）"><a href="#二级缓存（推荐）" class="headerlink" title="二级缓存（推荐）"></a>二级缓存（推荐）</h3><p>比如利用ehcache，或者guava-cache，或者一个HashMap或者List都可以。在你发现热key以后，把热key加载到JVM中（可以是堆内，也可以是堆外）。针对这种热key请求，会直接从JVM中取，而不会走到redis层。</p><p>假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。现在假设，你的应用层有10台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有10000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。</p><h3 id="备份热点key"><a href="#备份热点key" class="headerlink" title="备份热点key"></a>备份热点key</h3><p>这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。<br>假设redis的集群数量为N，步骤如下图所示：<br><img src="/images/201908091101.png" alt="upload successful"></p><p>说明: 不一定是2N，你想取4N，8N都可以，看要求。伪代码如下:</p><p>说明：这种方案有一个很明显的缺点，就是缓存的维护代价非常大。假设有100个备份KEY，那么在删除或者更新时，也需要更新100个KEY，所以这种方案不是很推荐。<br>业内方案</p><p>OK，其实看完上面的内容，大家可能会有一个疑问。</p><h3 id="自动发信热点key，程序自动处理"><a href="#自动发信热点key，程序自动处理" class="headerlink" title="自动发信热点key，程序自动处理"></a>自动发信热点key，程序自动处理</h3><p>有办法在项目运行过程中，自动发现热点key，然后程序自动处理么？<br>嗯，好问题，那我们来讲讲业内怎么做的。其实只有两步：</p><ol><li>监控热点key</li><li>通知系统做处理</li></ol><p>正巧，前几天有赞出了一篇《有赞透明多级缓存解决方案（TMC）》，里头也有提到热点key问题，我们刚好借此说明。</p><p>(1) 监控热点key<br>在监控热点key方面，有赞用的是方式二：在客户端进行收集。</p><p>在<a href="https://segmentfault.com/a/1190000017142556?utm_source=tag-newest" target="_blank" rel="noopener">《有赞透明多级缓存解决方案（TMC）》</a>中有一句话提到</p><blockquote><p>TMC 对原生jedis包的JedisPool和Jedis类做了改造，在JedisPool初始化过程中集成TMC“热点发现”+“本地缓存”功能Hermes-SDK包的初始化逻辑。<br>也就说人家改写了jedis原生的jar包，加入了Hermes-SDK包。</p></blockquote><p>那Hermes-SDK包用来干嘛？OK，就是做热点发现和本地缓存。</p><p>从监控的角度看，该包对于Jedis-Client的每次key值访问请求，Hermes-SDK 都会通过其通信模块将key访问事件异步上报给Hermes服务端集群，以便其根据上报数据进行“热点探测”。</p><p>当然，这只是其中一种方式，有的公司在监控方面用的是方式五: 自己抓包评估。具体是这么做的，先利用flink搭建一套流式计算系统。然后自己写一个抓包程序抓redis监听端口的数据，抓到数据后往kafka里丢。</p><p>接下来，流式计算系统消费kafka里的数据，进行数据统计即可，也能达到监控热key的目的。</p><p>(2) 通知系统做处理<br>在这个角度，有赞用的是上面的解决方案一:利用二级缓存进行处理。<br>有赞在监控到热key后，Hermes服务端集群会通过各种手段通知各业务系统里的Hermes-SDK，告诉他们:”老弟，这个key是热key，记得做本地缓存。”</p><p>于是Hermes-SDK就会将该key缓存在本地，对于后面的请求。Hermes-SDK发现这个是一个热key，直接从本地中拿，而不会去访问集群。</p><p>除了这种通知方式以外。我们也可以这么做，比如你的流式计算系统监控到热key了，往zookeeper里头的某个节点里写。然后你的业务系统监听该节点，发现节点数据变化了，就代表发现热key。最后往本地缓存里写，也是可以的。</p><p>通知方式各种各样，大家可以自由发挥。本文只是提供一个思路。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望通过本文，大家明白如何处理生产上遇到的热key问题。</p><footer><strong>孤独烟</strong><cite><a href="https://mp.weixin.qq.com/s/cipWMjkBprbuRxZEb3a3vQ" target="_blank" rel="noopener">如何优化缓存中百万级并发的key</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;这个问题实际上就是热点key问题，其实热点key问题说来也很简单，就是瞬间有几十万上百万，甚至更大的请求去访问red
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Java时的一些坑</title>
    <link href="https://muhouer.github.io/posts/45d267df/"/>
    <id>https://muhouer.github.io/posts/45d267df/</id>
    <published>2019-08-09T14:27:00.000Z</published>
    <updated>2019-08-09T14:46:16.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Arrays-asList-存在的坑"><a href="#Arrays-asList-存在的坑" class="headerlink" title="Arrays.asList 存在的坑"></a>Arrays.asList 存在的坑</h3><p>阿里巴巴java开发规范说到使用工具类<code>Arrays.asList()</code>方法把数组转换成集合时，不能使用其修改集合相关的方法，它的<code>add</code>/<code>remove</code>/<code>clear</code>方法会抛出<code>UnsupportedOperationException</code>。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;F&quot;, &quot;r&quot;, &quot;e&quot;, &quot;y&quot;, &quot;a&quot;);</span><br><span class="line">//    list.clear();</span><br><span class="line">//    list.remove(&quot;a&quot;);</span><br><span class="line">      list.add(&quot;h&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上三个方法中任何一个都会报以下异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:148)</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:108)</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>点进去<code>Arrays.asList</code>，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SafeVarargs</span><br><span class="line">@SuppressWarnings(&quot;varargs&quot;)</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class="line">    return new ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>ArrayList</code> 并不是我们平时用的<code>ArrayList</code>。而是<code>Arrays</code>里面的一个内部类。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private static final long serialVersionUID = -2764017481108945198L;</span><br><span class="line">    private final E[] a;</span><br><span class="line"></span><br><span class="line">    ArrayList(E[] array) &#123;</span><br><span class="line">        a = Objects.requireNonNull(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return a.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object[] toArray() &#123;</span><br><span class="line">        return a.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        int size = size();</span><br><span class="line">        if (a.length &lt; size)</span><br><span class="line">            return Arrays.copyOf(this.a, size,</span><br><span class="line">                                 (Class&lt;? extends T[]&gt;) a.getClass());</span><br><span class="line">        System.arraycopy(this.a, 0, a, 0, size);</span><br><span class="line">        if (a.length &gt; size)</span><br><span class="line">            a[size] = null;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        return a[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E set(int index, E element) &#123;</span><br><span class="line">        E oldValue = a[index];</span><br><span class="line">        a[index] = element;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        E[] a = this.a;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; a.length; i++)</span><br><span class="line">                if (a[i] == null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; a.length; i++)</span><br><span class="line">                if (o.equals(a[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return indexOf(o) != -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliterator(a, Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void forEach(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        for (E e : a) &#123;</span><br><span class="line">            action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        E[] a = this.a;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = operator.apply(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">        Arrays.sort(a, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个内部类没有<code>add</code>，<code>clear</code>，<code>remove</code>方法，所以抛出的异常其实来自于<code>AbstractList</code>。点进去就会发现抛出异常的地方，clear底层也会调用到remove所以也会抛出异常。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h4><p><code>Arrays.asList()</code>底层其实还是数组。如果使用了<code>Arrays.asList()</code>的话，最好不要使用其集合的操作方法。如果想要使用，<code>List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;F&quot;, &quot;r&quot;, &quot;e&quot;, &quot;y&quot;, &quot;a&quot;))</code>可以在外面这样包一层真正的ArrayList。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Arrays-asList-存在的坑&quot;&gt;&lt;a href=&quot;#Arrays-asList-存在的坑&quot; class=&quot;headerlink&quot; title=&quot;Arrays.asList 存在的坑&quot;&gt;&lt;/a&gt;Arrays.asList 存在的坑&lt;/h3&gt;&lt;p&gt;阿里巴巴ja
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>一些金融概念</title>
    <link href="https://muhouer.github.io/posts/6b8c9691/"/>
    <id>https://muhouer.github.io/posts/6b8c9691/</id>
    <published>2019-08-09T14:11:00.000Z</published>
    <updated>2019-08-11T04:36:38.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Q-什么是戴维斯双击和戴维斯双杀？"><a href="#Q-什么是戴维斯双击和戴维斯双杀？" class="headerlink" title="Q: 什么是戴维斯双击和戴维斯双杀？"></a>Q: 什么是戴维斯双击和戴维斯双杀？</h3><ol><li>戴维斯双击: 在景气周期里，上市公司的业绩和估值同步上升。</li><li>戴维斯双杀: 在不景气周期里，上市公司的业绩和估值同步下降。</li></ol><h3 id="Q-什么是LOF基金？"><a href="#Q-什么是LOF基金？" class="headerlink" title="Q: 什么是LOF基金？"></a>Q: 什么是LOF基金？</h3><p>LOF基金（Listed Open-Ended Fund），也称为“上市型开放式基金”。投资者既可以通过一级市场开放式基金账户申购与赎回基金份额，也可以在证券交易所二级市场买卖基金。不过，投资者如果是通过一级市场开放式基金账户申购的基金份额，想要在交易所二级市场卖出，则须办理转托管手续；同样，如果是在交易所二级市场买进的基金份额，想要在一级市场赎回，也要办理转托管手续。</p><h3 id="Q-关于熊市大跌"><a href="#Q-关于熊市大跌" class="headerlink" title="Q: 关于熊市大跌"></a>Q: 关于熊市大跌</h3><p>“在过去70多年历史上发生的40次股市暴跌中，即使其中39次我提前预测到，而且在暴跌前卖掉了所有的股票，我最后也会后悔万分的。因为即使是跌幅最大的那次股灾，股价最终也涨回来了，而且涨得更高。”——基金经理，彼得林奇</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Q-什么是戴维斯双击和戴维斯双杀？&quot;&gt;&lt;a href=&quot;#Q-什么是戴维斯双击和戴维斯双杀？&quot; class=&quot;headerlink&quot; title=&quot;Q: 什么是戴维斯双击和戴维斯双杀？&quot;&gt;&lt;/a&gt;Q: 什么是戴维斯双击和戴维斯双杀？&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;戴维斯
      
    
    </summary>
    
      <category term="理财" scheme="https://muhouer.github.io/categories/%E7%90%86%E8%B4%A2/"/>
    
    
      <category term="金融概念" scheme="https://muhouer.github.io/tags/%E9%87%91%E8%9E%8D%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>拾句系列</title>
    <link href="https://muhouer.github.io/posts/53e650a7/"/>
    <id>https://muhouer.github.io/posts/53e650a7/</id>
    <published>2019-08-09T14:02:00.000Z</published>
    <updated>2019-08-09T14:09:30.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拾句系列1"><a href="#拾句系列1" class="headerlink" title="拾句系列1"></a>拾句系列1</h2><p>拾句系列主要记录平常生活和工作中遇到的一些句子，当时有点感触，特此记录一下。记录还会继续，不过，随着时间的流逝，可能也会删除一部分或做一些修改。</p><ol><li><a href="/posts/922764cc/" title="拾句-惊艳">拾句-惊艳</a></li><li><a href="/posts/497a5083/" title="拾句-爱">拾句-爱</a></li><li><a href="/posts/60ae6d78/" title="拾句-丧">拾句-丧</a></li><li><a href="/posts/4be8e193/" title="拾句-开解自己">拾句-开解自己</a></li><li><a href="/posts/70b9f430/" title="拾句-乐评">拾句-乐评</a></li><li><a href="/posts/a9bf165e/" title="拾句-现实">拾句-现实</a></li><li><a href="/posts/ef52fadf/" title="拾句-思考">拾句-思考</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;拾句系列1&quot;&gt;&lt;a href=&quot;#拾句系列1&quot; class=&quot;headerlink&quot; title=&quot;拾句系列1&quot;&gt;&lt;/a&gt;拾句系列1&lt;/h2&gt;&lt;p&gt;拾句系列主要记录平常生活和工作中遇到的一些句子，当时有点感触，特此记录一下。记录还会继续，不过，随着时间的流逝，可能
      
    
    </summary>
    
      <category term="拾句" scheme="https://muhouer.github.io/categories/%E6%8B%BE%E5%8F%A5/"/>
    
    
      <category term="汇总" scheme="https://muhouer.github.io/tags/%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>拾句-思考</title>
    <link href="https://muhouer.github.io/posts/ef52fadf/"/>
    <id>https://muhouer.github.io/posts/ef52fadf/</id>
    <published>2019-08-09T13:58:00.000Z</published>
    <updated>2019-08-19T15:53:57.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="001"><a href="#001" class="headerlink" title="001"></a>001</h3><hr><ol><li><strong>相比欧洲几个发达国家，美国在可物理感知的很多细节上都可以用粗砺来形容，但这是由美国的宏大以及持续变化的特性所决定的。相反，美国那不可见的核心是高度精致的， state-of-the-art.</strong>——饭否</li><li><strong>经营一段感情需要付出足够的时间和精力，而把握住一个稍纵即逝的机会，同样需要拿出全力以赴的姿态，否则，我们很有可能因为错失这一步，而错失整个向上发展的机会。</strong></li><li><strong>和身边的95后聊天，他们不约而同地提到未来希望能实现两点：财务自由、做自己喜欢的事。我问他们，什么是你们喜欢的事？然后就冷场了。</strong>——乐鼠老人</li><li><strong>某先森处于职业艰难时期，压力极大，拼尽全力。但他说，现在我做的工作是我从大一开始就梦寐以求的工作。那就好。</strong>——Rena518</li><li><strong>并不是说鸿蒙OS现在有多强大多完善多牛逼，而是鸿蒙OS的想象空间太大了，是真正的星辰大海。</strong></li><li><strong>家庭所灌输的理念，将在个体成长过程中不断地重复和强化，以致于成为一种集体信念。</strong></li><li><strong>被社会所远离的群体/人，露出真实身份时遭遇到的往往是恐慌和排斥。</strong></li><li><strong>只要不要脸，遍地是金钱。</strong></li><li><strong>刘邦此人好坏暂且不说，就这份心性，的确少有。厚黑也罢凉薄也罢，舍得二字在他这里解释的再清楚不过。</strong></li></ol><hr><h3 id="002"><a href="#002" class="headerlink" title="002"></a>002</h3><ol><li>*<em>Some youngster has signs said “make love, not war”, trouble is they don’t look like they were capable doing either. *</em>——里根</li><li><strong>Freedom is not free.</strong></li><li><strong>War is an ugly thing, but not the ugliest of things: the decayed and degraded state of moral and patriotic feeling which thinks that nothing is worth a war, is much worse.</strong>——约翰·斯图尔特·密尔</li><li><strong>问题来了：什么是所谓的“标准密码”呢？</strong></li><li><strong>人类是地球的“超级病毒”，而地球正在启动对人类的免疫反应。正如《血疫》中所说的那样，大自然有自我平衡的手段，它可能在试图除掉人类这种寄生生物的感染。</strong></li><li><strong>从长度来看，至少有三种较长的周期，中的是人一辈子可以经历若干轮的，长的是人一辈子大概正好经历一轮，超长的是人一辈子只能经历一个完整周期中的某个片断。</strong></li><li><strong>当他完成了自己的和解，也就完成了和世人的和解。</strong></li><li><strong>最牛逼的商业决策不能算小账，考虑投入产出比时不能受限于局部的所谓理性，因为它最后不仅影响你这个公司能赚多少钱，而且影响你这个国家的钱能值多少钱。</strong>——饭否</li><li><strong>格特鲁德·斯泰因（Gertrude Stein）临死前的问题：“答案是什么？”——她没有得到任何回答，然后又问道：“既然这样，问题是什么？”</strong></li></ol><hr><h3 id="003"><a href="#003" class="headerlink" title="003"></a>003</h3><hr><ol><li><strong>演化生物学诞生于1859年，以达尔文的《物种起源》发表为标志。但是，为什么长久以来把演化生物学应用到医学和其他与人类有关的科学中的进展如此迟缓？</strong></li><li><strong>1941年，所有这种细菌都可以被青霉素杀死。到1944年，已经出现了一些突变株能分解青霉素。到今天，95%的葡萄球菌都对青霉素有一定程度的耐药性。</strong></li><li><strong>对公众进行善意的道德劝诫即便受到欢迎，也很少有人会当真。要使人们为了公众利益合作，必须让不合作者付出代价。</strong>——迈特·瑞德利（Matt Ridley）和鲍比·娄（Bobbi Low）</li><li><strong>医学史反复证明，最容易染上致命性病原体的地方，不是妓院，也不是拥挤的血汗工厂，而是医院。</strong></li><li><strong>伪装（mimic）种和模型（model）种之间的一场竞赛：伪装种变得更像模型种，而模型种则变得尽可能与伪装种有区别。</strong></li><li><strong>很少接触毒素，那么一旦遭遇正常剂量的毒素，我们可能会措手不及。</strong></li><li><strong>在零星的知识岛屿周围，还是茫茫无际的未知海域。</strong></li><li><strong>我们遵循那些看似没有什么道理可言的文化习俗可能是十分明智的。</strong></li><li><strong>许多减肥食谱的原理就是：在只有少数几种食物供应时，我们吃得要比品种丰富时少一些。</strong></li></ol><hr><h3 id="004"><a href="#004" class="headerlink" title="004"></a>004</h3><hr><ol><li><strong>生活真正残酷的地方，不在于它的正面角色没有故事中那么好，而是它的反派角色并没有故事中那么坏。</strong></li><li><strong>思想上的完美主义者，大多是思想上的巨人，行动上的矮子，如果你是个完美主义者，至少要先跨出第一步。</strong></li><li><strong>认识了一个大牌投资公司里蛮不错的年轻人，他说将来如果出来创业，他会同时注册三个实体：第一个拍电影，第二个搞社区，第三个才是做投资。不要阿猫阿狗之类的案子都投，只投那些将来值得拍成电影的公司。</strong>——饭否</li><li><strong>正所谓“尽人事，待天命”。你是否已经用尽了全部力量？</strong></li><li><strong>一本科幻小说。主要情节是人类可以控制局部时间流速，为了生产更多粮食，在一个封闭的空间里使时间加速来生产粮食，结果里边的生物开始加速进化影响人类。</strong></li><li><strong>假设一年有<code>365</code>天，每天比前一天进步<code>1/365</code>，一年后就从 <code>1</code> 变成 <code>2.714567482021973</code>，十年后就会从 <code>1</code> 变成<code>21727.333146076744</code>，后者大概是前者的 <code>8004</code> 倍。这大概是我能想到的“你总是高估一年内可以做的事，也总是低估十年内能做到的事。”的数字化解释。</strong>——Muhouer</li><li><strong>“祖国终将选择那些选择了祖国的人”。</strong>——《如何在人生的马拉松中跑好清华这一程》，电机系教授于歆杰在清华2019级本科生开学典礼上的发言</li><li><strong>比「牺牲哪个人」或「牺牲哪个群体」更残酷的问题是「牺牲哪代人」？</strong></li><li><strong>失利不仅是一个结果，还是一个过程。</strong></li></ol><hr><h3 id="005"><a href="#005" class="headerlink" title="005"></a>005</h3><hr><ol><li><strong>机会与灾难总是相伴而生，有人把机会做成了灾难，也有人把灾难做成了机会。</strong></li><li><strong>生活的进程总是靠两类事件不断积累起来的——可控事件和不可控事件。而所谓规划，就是把精力的大部分聚焦于可控的部分，把这部分做好；而所谓成功，无非就是在这个基础上加上不可控因素的运气。</strong></li><li><strong>电话，邮件，现场约见，沙雕话术就是四个漏斗，每一层都过滤掉智商正常的人，最后留下的就是欠教育的。</strong></li><li><strong>人一旦起了贪念，智商就会被按在地上摩擦，不管智商再高也没用，贪心属于降维打击。</strong></li><li><strong>风险和收益从来就不成正比。时间和时间是不平等的。</strong></li><li><strong>我认识一个人，他每做一件小事都像抓住最后一根救命稻草，有一天我回头看他，嚯，好家伙，他已经怀抱着一棵让我仰望的苍天大树了！</strong></li><li><strong>科技行业有一个常识，你无法凭借同样的东西打败对手，取代安卓的也不是另外一个安卓。</strong></li><li><strong>在汉字里，十是10，廿是20，卅是30。如果“卅”字添上一横，就成了“丗”，表示30年。“丗”字还有另一个写法——“世”，一世就是30年。所以古人说恍如隔世，其实是如隔30年，即便在“车、马、邮件都慢”的从前，30年的变化也足以让人恍然。</strong></li><li><strong>我非常反对婚姻里，把爱人当亲人。我的亲人只有父母和女儿，而我的妻子，就是我的爱人，这个一直都不会变。</strong>——黄磊</li><li><strong>将爱情变为亲情，是阴险的潜意识诡计。</strong></li></ol><hr><h3 id="006"><a href="#006" class="headerlink" title="006"></a>006</h3><hr><ol><li><strong>数据不会骗人，但是看到数据得到的结论会骗人。正确的前提，错误的断言，依然会是无效的推论。</strong></li><li><strong>当数据涉及人们的选择时（比如当人们选择上大学、结婚或者要孩子时），就会出现“自选择偏差”。在这种情况下，对于做出不同选择的人进行比较的做法是靠不住的。</strong></li><li><strong>户枢不蠹，流水不腐。</strong></li><li><strong>户枢流水，不确永生。</strong></li><li><strong>刷剧时常伴随着：社交孤立、吃垃圾食品、缺乏运动和睡眠，疯狂刷剧对大脑的影响与赌博相似</strong>——兰德尔·怀特</li><li><strong>我们的谦卑、沉默曾助长了偏见和歧视的存在。</strong></li><li><strong>很多人没有自信，其实是在逃避责任，人生那些该吃的苦，他不想吃，他一定要天地许诺他一个轻松的富足人生，否则就是天地不对，要死给它看。天地会怎么回应？应该是：你爱哭就哭，爱死就死。其实天地不仁，永远按规律运行，连回应都不会给你。</strong>——连岳</li><li><strong>这个世界的大部分地带是灰色的，不存在一个简单答案。不应该有复杂的问题，也不应该有简单的答案。</strong></li><li><strong>全球廉价服饰每年的流行款式其实都是在抄袭位于顶端的时尚，时尚界的顶端引领着潮流，普通人认为自己的衣着远离这些顶端，但事实上，早被这些顶端所决定。我们的思想观念何尝不是如此呢？</strong>——饭否</li></ol><hr><h3 id="007"><a href="#007" class="headerlink" title="007"></a>007</h3><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;001&quot;&gt;&lt;a href=&quot;#001&quot; class=&quot;headerlink&quot; title=&quot;001&quot;&gt;&lt;/a&gt;001&lt;/h3&gt;&lt;hr&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;相比欧洲几个发达国家，美国在可物理感知的很多细节上都可以用粗砺来形容，但这是由美国的宏大以及持续变
      
    
    </summary>
    
      <category term="拾句" scheme="https://muhouer.github.io/categories/%E6%8B%BE%E5%8F%A5/"/>
    
    
      <category term="思考" scheme="https://muhouer.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>堆内存和栈内存</title>
    <link href="https://muhouer.github.io/posts/e896e76f/"/>
    <id>https://muhouer.github.io/posts/e896e76f/</id>
    <published>2019-08-07T15:12:00.000Z</published>
    <updated>2019-08-08T15:18:48.773Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Java</code>中，您会看到大量关于堆内存和栈内存的引用，<code>Java</code>把内存分成两种，一种叫做栈内存，一种叫做堆内存。</p><h2 id="Java-堆内存-Heap-Memory"><a href="#Java-堆内存-Heap-Memory" class="headerlink" title="Java 堆内存(Heap Memory)"></a>Java 堆内存(Heap Memory)</h2><p><code>Java</code>运行时会在堆内存中将内存分配给对象和子类。每当我们创建任何对象时，它总是在堆空间中创建的。</p><p>垃圾收集在堆内存上运行，以释放没有任何引用的对象使用的内存。堆空间中创建的任何对象都具有全局访问权限，可以从应用程序的任何位置引用。</p><h2 id="Java-栈内存-Stack-Memory"><a href="#Java-栈内存-Stack-Memory" class="headerlink" title="Java 栈内存(Stack Memory)"></a>Java 栈内存(Stack Memory)</h2><p>Java栈内存用于执行线程。它们包含短期存活的方法的特定值，以及堆中方法对其他对象的引用。</p><p>栈内存总是按后进先出顺序引用。每当调用一个方法时，都会在栈内存中创建一个新块，以便该方法保存本地基元值以及该方法对其他对象的引用。</p><p>一旦方法结束，该块就不再使用，就可用于下一个方法。与堆内存相比，栈内存非常小。</p><h2 id="Java-程序中的堆内存和栈内存"><a href="#Java-程序中的堆内存和栈内存" class="headerlink" title="Java 程序中的堆内存和栈内存"></a>Java 程序中的堆内存和栈内存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Line 1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// Line 2</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object(); <span class="comment">// Line 3</span></span><br><span class="line">        Memory mem = <span class="keyword">new</span> Memory(); <span class="comment">// Line 4</span></span><br><span class="line">        mem.foo(obj); <span class="comment">// Line 5</span></span><br><span class="line">    &#125; <span class="comment">// Line 9</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123; <span class="comment">// Line 6</span></span><br><span class="line">        String str = param.toString(); <span class="comment">//// Line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125; <span class="comment">// Line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了上述程序的堆栈内存的引用</p><p><img src="https://cdn.journaldev.com/wp-content/uploads/2014/08/Java-Heap-Stack-Memory.png" alt="img"></p><p>程序执行的过程如下：</p><ul><li>一旦程序开始运行，它将会加载所有运行时类到堆内存，第1行发现了main方法，Java Runtime 创建了栈内存给main方法线程使用。</li><li>第2行，我们创建了int型本地变量，它被创建并存储在栈内存的main方法里。</li><li>第3行，我们创建一个对象，它创建在堆内存，栈内存保存它的引用。Memory 对象类似。</li><li>第5行，我们调用foo方法，在栈内存头部创建一个内存块给foo方法使用，既然Java通过值传递，第6行，对象的新引用将在foo方法的栈内存块内创建。</li><li>第7行，创建了字符串，它将会进入堆中的字符串常量池，foo方法的栈空间内将创建一个它的引用。</li><li>foo方法在第8行终止。栈中分配的内存块将会被释放。</li><li>在第9行，main方法终止，分配给main方法的栈内存将会被销毁。同时，程序也在这一行结束，因此 Java Runtime将会释放所有内存，然后结束程序的执行。</li></ul><h2 id="堆内存和栈内存的区别"><a href="#堆内存和栈内存的区别" class="headerlink" title="堆内存和栈内存的区别"></a>堆内存和栈内存的区别</h2><ol><li>应用程序的所有地方都会使用堆内存，而只有线程的执行会使用栈内存。</li><li>当一个对象创建时，它存放在堆内存中，引用放在栈内存中。栈内存只包含本地原始变量和引用变量。</li><li>存放在堆内存的对象是全局的，而栈内存中的不能被其他线程获取。</li><li>栈中的内存管理是以后进先出的方式完成的，而堆内存中的内存管理更复杂，因为它是全局使用的。堆内存分为新生代、老年代等，更多信息可以参考Java 垃圾回收。</li><li>栈内存是短暂存在的，而堆内存从应用程序执行的开始到结束都是存在的。</li><li>我们可以使用<code>-Xms</code>和<code>-Xmx</code>来定义堆内存启动时的大小和内存最大值。可以使用<code>-Xss</code>去定义栈内存大小。</li><li>当栈内存被填满的时候，将会抛出 <code>java.lang.StackOverFlowError</code>，然而，当堆内存被填满的时候，它会抛出 <code>java.lang.OutOfMemoryError: Java Heap Space</code> 错误。</li><li>和堆内存大小相比，栈内存大小非常小。由于内存分配（LIFO）的简单性，与堆内存相比，栈内存非常快。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;中，您会看到大量关于堆内存和栈内存的引用，&lt;code&gt;Java&lt;/code&gt;把内存分成两种，一种叫做栈内存，一种叫做堆内存。&lt;/p&gt;&lt;h2 id=&quot;Java-堆内存-Heap-Memory&quot;&gt;&lt;a href=&quot;#Java-堆内存-Heap
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="堆栈内存" scheme="https://muhouer.github.io/tags/%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型与内存管理</title>
    <link href="https://muhouer.github.io/posts/1f8d140b/"/>
    <id>https://muhouer.github.io/posts/1f8d140b/</id>
    <published>2019-08-06T15:06:00.000Z</published>
    <updated>2019-08-08T15:22:40.009Z</updated>
    
    <content type="html"><![CDATA[<p>如果您想弄清楚<code>Java</code>垃圾回收的的工作原理，那么理解<code>JVM</code>内存模型以及<code>Java</code>内存管理非常重要。 今天我们将探讨一下<code>Java</code>中的内存管理、<code>JVM</code>内存的组成以及如何监控和进行垃圾回收调优。</p><h2 id="Java（JVM）内存模型"><a href="#Java（JVM）内存模型" class="headerlink" title="Java（JVM）内存模型"></a>Java（JVM）内存模型</h2><p><img src="https://cdn.journaldev.com/wp-content/uploads/2014/05/Java-Memory-Model-450x186.png" alt="Java Memory Model, JVM Memory Model, Memory Management in Java, Java Memory Management"></p><p>正如上图所示，<code>JVM</code>内存划分为多个不同部分。 从广义上讲，<code>JVM</code>堆内存内存在物理上分为两部分——新生代(<strong>Young Generation</strong>)和老年代(<strong>Old Generation</strong>)。</p><h2 id="Java-内存管理——年轻代"><a href="#Java-内存管理——年轻代" class="headerlink" title="Java 内存管理——年轻代"></a>Java 内存管理——年轻代</h2><p>年轻代是创建新对象的地方。 当年轻代被填满时，将会进行垃圾回收，称为<code>Minor GC</code>。 <code>Young Generation</code>分为三个部分——<code>Eden</code>内存空间和两个<code>Survivor</code>内存空间。</p><p>关于新生代(<strong>Young Generation</strong>)的要点：</p><ul><li>大多数新创建的对象都位于<code>Eden</code>内存空间中。</li><li>当<code>Eden</code>空间填满对象时，执行<code>Minor GC</code>并将所有幸存者对象移动到其中一个<code>Survivor</code>内存空间。</li><li><code>Minor GC</code>还会检查幸存者对象并将其移动到其他<code>Survivor</code>内存空间。 所以，在同一时间内，总有一个<code>Survivor</code>内存空间是空的。</li><li>在多次<code>GC</code>循环后幸存的对象将被移动到老年代(<strong>Old Generation</strong>)。 通常，新生代(<strong>Young Generation</strong>)对象达到设定的年龄阈值后才有资格晋升到老年代(<strong>Old Generation</strong>)。</li></ul><h2 id="Java-内存管理——老年代"><a href="#Java-内存管理——老年代" class="headerlink" title="Java 内存管理——老年代"></a>Java 内存管理——老年代</h2><p>老年代(<strong>Old Generation</strong>)包含在多次<code>Minor GC</code>循环之后长期存在并存活下来的对象。通常，当老年代(<strong>Old Generation</strong>)被填满后，也会执行垃圾回收，称为<code>Major GC</code>，通常花费时间较长。</p><h3 id="停顿-Stop-the-World-Event"><a href="#停顿-Stop-the-World-Event" class="headerlink" title="停顿(Stop the World Event)"></a>停顿(Stop the World Event)</h3><p>所有垃圾回收都是“<strong>Stop the World</strong>”事件，因为所有应用程序线程都会停止，直到操作完成。由于新生代(<strong>Young Generation</strong>)主要保存短暂存活的对象，因此<code>Minor GC</code>非常快，应用程序不会受此影响。</p><p>然而，<code>Major GC</code>需要花费很长时间，因为它会检查所有活动对象。 <code>Major GC</code>应该最小化，因为它会使您的应用程序在垃圾回收期间没有响应。 因此，如果您有响应式应用程序而且进行了大量<code>Major GC</code>，您会注意到超时错误。</p><p>垃圾收集器进行垃圾回收时持续的时间取决于采用的垃圾回收策略。为了避免高响应应用程序中的超时，很有必要去监控、调整垃圾收集器。</p><h3 id="Java-内存模型——永久代"><a href="#Java-内存模型——永久代" class="headerlink" title="Java 内存模型——永久代"></a>Java 内存模型——永久代</h3><p>永久代(<strong>Permanent Generation</strong>或<strong>Perm Gen</strong>)包含<code>JVM</code>描述应用程序中类和方法所需的应用程序元数据。 请注意，<strong>Perm Gen</strong>不是<code>Java</code>堆内存的一部分。</p><p><strong>Perm Gen</strong>在运行时，由<code>JVM</code>根据应用程序使用的类填充。 <strong>Perm Gen</strong>还包含Java SE库中的类和方法。 <strong>Perm Gen</strong>中的对象在完全垃圾回收(<strong>full garbage collection</strong>)中将会被回收。</p><h3 id="Java-内存模型——方法区"><a href="#Java-内存模型——方法区" class="headerlink" title="Java 内存模型——方法区"></a>Java 内存模型——方法区</h3><p>方法区(<strong>Method Area</strong>)属于<strong>Perm Gen</strong>一部分，用于存储类结构(运行时常量和静态变量)以及方法和构造函数的代码。</p><h3 id="Java-内存模型——内存池"><a href="#Java-内存模型——内存池" class="headerlink" title="Java 内存模型——内存池"></a>Java 内存模型——内存池</h3><p>内存池(<strong>Memory Pool</strong>)由<code>JVM</code>内存管理器创建，支持创建不可变对象( <strong>immutable object</strong>)池。比如 <code>String</code>池。 内存池可以属于<code>Java</code>堆内存或<strong>Perm Gen</strong>，具体取决于<code>JVM</code>内存管理器实现。</p><h3 id="Java-内存模型——运行时常量池"><a href="#Java-内存模型——运行时常量池" class="headerlink" title="Java 内存模型——运行时常量池"></a>Java 内存模型——运行时常量池</h3><p>运行时常量池(<strong>Runtime constant pool</strong>)是类中常量池的每类运行时表示形式。它包含类运行时常量和静态方法。 运行时常量池是方法区的一部分。</p><h3 id="Java-内存模型——栈内存"><a href="#Java-内存模型——栈内存" class="headerlink" title="Java 内存模型——栈内存"></a>Java 内存模型——栈内存</h3><p>Java栈内存(<strong>Stack Memory</strong>)用于执行线程。 它们包含方法特定的值，这些值是短暂存活的，并且引用了堆内存中被方法引用的其他对象。 <a href="/posts/e896e76f/" title="堆内存和栈内存">堆内存和栈内存</a></p><h2 id="Java-内存管理——Java-堆内存开关"><a href="#Java-内存管理——Java-堆内存开关" class="headerlink" title="Java 内存管理——Java 堆内存开关"></a>Java 内存管理——Java 堆内存开关</h2><p>Java提供了许多内存开关，我们可以用来设置内存大小和它们的比率。一些常用的内存开关是：</p><table><thead><tr><th align="left">VM SWITCH</th><th align="left">VM SWITCH DESCRIPTION</th></tr></thead><tbody><tr><td align="left">-Xms</td><td align="left">在 JVM 启动时设置初始堆内存大小。</td></tr><tr><td align="left">-Xmx</td><td align="left">设置堆内存空间大小的最大值。</td></tr><tr><td align="left">-Xmn</td><td align="left">设置新生代内存空间大小，剩下的空间大小就是老年代的内存空间大小。</td></tr><tr><td align="left">-XX:PermGen</td><td align="left">设置永久代初始内存空间大小</td></tr><tr><td align="left">-XX:MaxPermGen</td><td align="left">设置永久代内存空间大小的最大值。</td></tr><tr><td align="left">-XX:SurvivorRatio</td><td align="left">设置<code>Eden</code>内存空间和<code>Survivor</code>内存空间的比例，例如，如果新生代的空间大小是10M，而-XX:SurvivorRatio=2，那么<code>Eden</code>内存空间大小为5M，两个<code>Survivor</code>内存空间大小将分别为2.5M。-XX:SurvivorRatio 默认值为8。</td></tr><tr><td align="left">-XX:NewRatio</td><td align="left">设置老年代和新生代空间大小的比例。 默认值为 2.</td></tr></tbody></table><p>大多数情况下，上面的选项足够使用了，但是如果您想使用其他选项，可以参考<a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">JVM 选项</a>。</p><h2 id="Java-内存管理——垃圾回收"><a href="#Java-内存管理——垃圾回收" class="headerlink" title="Java 内存管理——垃圾回收"></a>Java 内存管理——垃圾回收</h2><p><code>Java</code>垃圾收集是从内存中标识、删除未使用对象以及释放空间的过程。 <code>Java</code>编程语言的特色之一是自动垃圾回收，与其他编程语言(如C)不同，它们的内存需要手动分配和释放。</p><p>垃圾收集器(<strong>Garbage Collector</strong>)是在后台运行的程序(守护线程)，它检查内存中的所有对象，并找出程序所有未被引用的对象。 然后删除所有未被引用的对象，并释放空间以分配给其他对象。</p><p>垃圾回收的一个简单实现可以分为三步：</p><ol><li><strong>标记</strong>——这是垃圾回收的第一步，将识别出哪些对象正在使用，哪些对象没有在使用。</li><li><strong>普通删除</strong>——垃圾收集器将删除未被使用的对象，然后回收内存空间分配给其他对象使用。</li><li><strong>压缩删除</strong>——为了获得更好的性能，在删除未被使用的对象后，可以将所有幸存的对象移动到一起。 这会提高给新对象分配内存时的性能。</li></ol><p>标记-删除方法的缺点</p><ol><li>它效率不高，因为大多数新创建的对象都将被闲置</li><li>在多个垃圾收集周期中使用的对象很有可能在未来的垃圾收集周期中继续使用。</li></ol><p>这是因为堆内存分为新生代(<strong>Young Generation</strong>)和老年代(<strong>Old Generation</strong>)，<code>Java</code>垃圾回收是分代的。 上文中已经解释过如何根据<code>Minor GC</code>和<code>Major GC</code>扫描对象并将其从一个空间移动到另一个空间。</p><h2 id="Java-内存管理——垃圾回收的类型"><a href="#Java-内存管理——垃圾回收的类型" class="headerlink" title="Java 内存管理——垃圾回收的类型"></a>Java 内存管理——垃圾回收的类型</h2><p>在应用程序中我们可以使用5种垃圾回收类型，我只需要调整<code>JVM</code>开关即可为我们的应用程序选择垃圾回收策略。</p><ol><li><strong>Serial GC (-XX:+UseSerialGC)</strong>: <strong>Serial GC</strong>使用简单的标记 - 清除 - 整理(<strong>mark-sweep-compact</strong>)方法用于新生代和老年代的垃圾回收，即<code>Minor GC</code>和<code>Major GC</code>。<strong>Serial GC</strong>在客户端机中非常有用，例如我们的应用程序比较独立，而且CPU比较小。 它适用于内存占用少的小型应用程序。</li><li><strong>Parallel GC (-XX:+UseParallelGC)</strong>: <strong>Parallel GC</strong>与<strong>Serial GC</strong>相同，不同的是<strong>Parallel GC</strong>使用N(N是系统中的CPU核心数)个线程进行新生代的垃圾回收。 我们可以使用<code>-XX：ParallelGCThreads = n</code>JVM 选项来控制线程数。并行垃圾收集器也称为吞吐量收集器，因为它使用多个 CPU 来提升 GC 性能。 <strong>Parallel GC</strong>使用单个线程进行老年代的垃圾回收。</li><li><strong>Parallel Old GC (-XX:+UseParallelOldGC)</strong>: 和<strong>Parallel GC</strong>相同，不同的是它采用多线程进行老年代和新生代的垃圾回收。</li><li><strong>Concurrent Mark Sweep (CMS) Collector (-XX:+UseConcMarkSweepGC)</strong>: CMS收集器也称为并发低暂停收集器。 在老年代进行垃圾回收时，CMS收集器尝试通过与应用程序线程同时执行大多数垃圾收集工作来最小化由于垃圾收集而导致的暂停。<br>新生代的CMS收集器与并行收集器使用相同的算法。 此垃圾收集器适用于我们无法忍受暂停时间过长的响应式应用程序。 我们可以使用<code>-XX:ParallelCMSThreads=n</code>JVM选项调整CMS收集器中的线程数 。</li><li><strong>G1 Garbage Collector (-XX:+UseG1GC)</strong>: <strong>Garbage First</strong> 或<strong>G1</strong>垃圾收集器从 Java 7 开始支持，它的目标是取代<strong>CMS收集器</strong>。 <strong>G1</strong>收集器是并行，并发和增量压缩的低暂停垃圾收集器。<strong>G1</strong>收集器不像其他收集器那样工作，并且没有新生代和老年代的概念。 它将堆空间划分为多个大小相等的堆区域。 当进行垃圾回收时，它首先收集具有较少实时数据的区域，因此称为“<strong>Garbage First</strong>”。 您可以在<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/G1.html" target="_blank" rel="noopener">Oracle Garbage-First Collector 文档</a>中找到有关它的更多详细信息。</li></ol><h2 id="Java-内存管理——Java-垃圾回收监控"><a href="#Java-内存管理——Java-垃圾回收监控" class="headerlink" title="Java 内存管理——Java 垃圾回收监控"></a>Java 内存管理——Java 垃圾回收监控</h2><p>我们可以使用Java命令行以及UI工具来监视应用程序的垃圾收集活动。</p><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>我们可以使用<code>jstat</code>命令行工具来监控<code>JVM</code> 内存和垃圾收集活动。 它适配标准<code>JDK</code>，因此您无需执行任何其他操作即可使用它。</p><p>在使用<code>jstat</code>命令之前，你需要知道 Java 应用的进程id。你可以使用<code>ps -ef | grep java</code>命令来获取进程id。假如我的进程id是9582，那么我就可以使用<code>jstat -gc 9582 1000</code>来查看垃圾回收的信息。命令中最后一个参数是每个输出之间的时间间隔，因此它将每1秒打印一次内存和垃圾收集数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstat -gc 9582 1000</span></span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">1024.0 1024.0  0.0    0.0    8192.0   7933.3   42108.0    23401.3   20480.0 19990.9    157    0.274  40      1.381    1.654</span><br><span class="line">1024.0 1024.0  0.0    0.0    8192.0   8026.5   42108.0    23401.3   20480.0 19990.9    157    0.274  40      1.381    1.654</span><br><span class="line">1024.0 1024.0  0.0    0.0    8192.0   8030.0   42108.0    23401.3   20480.0 19990.9    157    0.274  40      1.381    1.654</span><br><span class="line">1024.0 1024.0  0.0    0.0    8192.0   8122.2   42108.0    23401.3   20480.0 19990.9    157    0.274  40      1.381    1.654</span><br><span class="line">1024.0 1024.0  0.0    0.0    8192.0   8171.2   42108.0    23401.3   20480.0 19990.9    157    0.274  40      1.381    1.654</span><br><span class="line">1024.0 1024.0  48.7   0.0    8192.0   106.7    42108.0    23401.3   20480.0 19990.9    158    0.275  40      1.381    1.656</span><br><span class="line">1024.0 1024.0  48.7   0.0    8192.0   145.8    42108.0    23401.3   20480.0 19990.9    158    0.275  40      1.381    1.656</span><br></pre></td></tr></table></figure><p>每一列的含义如下：</p><ul><li><strong>S0C and S1C</strong>: Survivor0 和 Survivor1当前的内存大小，以 KB 计。</li><li><strong>S0U and S1U</strong>: Survivor0 和 Survivor1当前已使用的内存大小，以 KB 计。注意其中一个 survivor 一直是空的。</li><li><strong>EC and EU</strong>: Eden 区当前的内存大小和 Eden 区当前已使用的内存大小，以 KB 计。注意 EU 的大小会一直增大直到接近EC的大小，此时会执行Minor GC，然后EU 的大小就降低了。</li><li><strong>OC and OU</strong>: 老年代当前的大小和已使用的大小，以 KB 计。</li><li><strong>PC and PU</strong>: 永久代当前的大小和已使用的大小，以 KB 计。</li><li><strong>YGC and YGCT</strong>: YGC 代表在新生代 GC 发生的次数；YGCT 代表新生代执行GC的累计时间。注意，这两个值都在同一行中增加，因为 Minor GC 会使得 EU 值下降。</li><li><strong>FGC and FGCT</strong>: FGC 代表 Full GC 发生的次数；FGCT Full GC 发生的累计时间。 注意，与新生代 GC 相比， Full GC 花费时间太长。</li><li><strong>GCT</strong>: GC 操作的总累计时间。注意，它是 YGCT 和 FGCT 列值的总和。</li></ul><p><code>jstat</code>的优点是它也可以在没有 GUI 的远程服务器上执行。请注意，根据<code>-xmn10m</code>jvm选项的限制，S0C、S1C和EC的总和为10M。</p><h3 id="可视化的-Java-VisualVM"><a href="#可视化的-Java-VisualVM" class="headerlink" title="可视化的 Java VisualVM"></a>可视化的 Java VisualVM</h3><p>如果您想在GUI中看到内存和GC操作，那么可以使用<code>jvisualvm</code>工具。Java VisualVM也是JDK的一部分，不需要单独下载。</p><p>只需在终端中运行<code>jvisualvm</code>命令即可启动Java VisualVM应用程序。启动后，您需要从tools -&gt; plugins 选项安装VisualGC插件，如下图所示。</p><p><img src="https://cdn.journaldev.com/wp-content/uploads/2014/05/VisualVM-Visual-GC-Plugin-450x271.png" alt="VisualVM-Visual-GC-Plugin"></p><p>安装完VisualGC之后，只需打开左侧列中的应用程序，然后转到VisualGC部分。您将得到一个JVM内存和垃圾收集细节的映像，如下图所示。</p><p><img src="https://cdn.journaldev.com/wp-content/uploads/2014/05/Serial-GC-VisualGC-450x271.png" alt="Serial-GC-VisualGC"></p><h2 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h2><p>Java垃圾回收调优应该是提高应用程序吞吐量的最后选项，只有当GC时间较长导致应用程序超时时，才看到性能下降。</p><p>假如你在日志中看到<code>java.lang.OutOfMemoryError: PermGen space</code>错误，你可以通过<code>-XX:PermGen和-XX:MaxPermGen</code>来监控和提供永久代内存。你也可以使用<code>-XX:+CMSClassUnloadingEnabled</code>，然后观察在CMS 垃圾收集器的性能。</p><p>假如你看到很多 Full GC 操作，你可以提高老年代内存大小。</p><p>总的来说，垃圾回收调优需要花费大量的精力和时间，而且没有硬性和快速的规则。您需要尝试不同的选项并进行比较，从中找出最适合您的选项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果您想弄清楚&lt;code&gt;Java&lt;/code&gt;垃圾回收的的工作原理，那么理解&lt;code&gt;JVM&lt;/code&gt;内存模型以及&lt;code&gt;Java&lt;/code&gt;内存管理非常重要。 今天我们将探讨一下&lt;code&gt;Java&lt;/code&gt;中的内存管理、&lt;code&gt;JVM&lt;/code&gt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java内存模型" scheme="https://muhouer.github.io/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis进阶教程</title>
    <link href="https://muhouer.github.io/posts/c275b75f/"/>
    <id>https://muhouer.github.io/posts/c275b75f/</id>
    <published>2019-08-05T16:29:00.000Z</published>
    <updated>2019-08-05T17:33:59.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-数据备份与恢复"><a href="#Redis-数据备份与恢复" class="headerlink" title="Redis 数据备份与恢复"></a>Redis 数据备份与恢复</h2><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p>Redis <code>save</code> 命令用于创建当前数据库的备份。该命令将在 redis 安装目录中创建dump.rdb文件。</p><p>创建 redis 备份文件也可以使用命令 <code>bgsave</code>，该命令在后台执行。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>save</code></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; save </span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用<code>config</code>命令，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) &quot;dir&quot;</span><br><span class="line">2) &quot;/usr/local/redis-5.0.5/src&quot;</span><br></pre></td></tr></table></figure><h2 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h2><p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。</p><p>默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><code>auth password</code></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; config set requirepass &quot;redis&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h2 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h2><p>Redis 性能测试是通过同时执行多个命令实现的。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p><code>redis-benchmark [option] [option value]</code></p><p>注意：该命令是在 redis 的目录下执行的，而不是 redis<br>客户端的内部指令。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>同时执行 10000 个请求来检测性能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-benchmark -n 10000 -q</span><br><span class="line">PING_INLINE: 104166.66 requests per second</span><br><span class="line">PING_BULK: 106382.98 requests per second</span><br><span class="line">SET: 105263.16 requests per second</span><br><span class="line">GET: 105263.16 requests per second</span><br><span class="line">INCR: 103092.78 requests per second</span><br><span class="line">LPUSH: 106382.98 requests per second</span><br><span class="line">RPUSH: 105263.16 requests per second</span><br><span class="line">LPOP: 108695.65 requests per second</span><br><span class="line">RPOP: 102040.82 requests per second</span><br><span class="line">SADD: 106382.98 requests per second</span><br><span class="line">HSET: 107526.88 requests per second</span><br><span class="line">SPOP: 97087.38 requests per second</span><br><span class="line">LPUSH (needed to benchmark LRANGE): 101010.10 requests per second</span><br><span class="line">LRANGE_100 (first 100 elements): 106382.98 requests per second</span><br><span class="line">LRANGE_300 (first 300 elements): 109890.11 requests per second</span><br><span class="line">LRANGE_500 (first 450 elements): 107526.88 requests per second</span><br><span class="line">LRANGE_600 (first 600 elements): 99009.90 requests per second</span><br><span class="line">MSET (10 keys): 101010.10 requests per second</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">序号</th><th align="left">选项</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>-h</strong></td><td align="left">指定服务器主机名</td><td align="left">127.0.0.1</td></tr><tr><td align="left">2</td><td align="left"><strong>-p</strong></td><td align="left">指定服务器端口</td><td align="left">6379</td></tr><tr><td align="left">3</td><td align="left"><strong>-s</strong></td><td align="left">指定服务器 socket</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"><strong>-c</strong></td><td align="left">指定并发连接数</td><td align="left">50</td></tr><tr><td align="left">5</td><td align="left"><strong>-n</strong></td><td align="left">指定请求数</td><td align="left">10000</td></tr><tr><td align="left">6</td><td align="left"><strong>-d</strong></td><td align="left">以字节的形式指定 SET/GET 值的数据大小</td><td align="left">2</td></tr><tr><td align="left">7</td><td align="left"><strong>-k</strong></td><td align="left">1=keep alive 0=reconnect</td><td align="left">1</td></tr><tr><td align="left">8</td><td align="left"><strong>-r</strong></td><td align="left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left"><strong>-P</strong></td><td align="left">通过管道传输<code>&lt;numreq&gt;</code>请求</td><td align="left">1</td></tr><tr><td align="left">10</td><td align="left"><strong>-q</strong></td><td align="left">强制退出 redis。仅显示 query/sec 值</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left"><strong>–csv</strong></td><td align="left">以 CSV 格式输出</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left"><strong>-l</strong></td><td align="left">生成循环，永久执行测试</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left"><strong>-t</strong></td><td align="left">仅运行以逗号分隔的测试命令列表。</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left"><strong>-I</strong></td><td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td><td align="left"></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q</span><br><span class="line">SET: 104166.66 requests per second</span><br><span class="line">LPUSH: 105263.16 requests per second</span><br></pre></td></tr></table></figure><p>以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。</p><h2 id="Redis-客户端连接"><a href="#Redis-客户端连接" class="headerlink" title="Redis 客户端连接"></a>Redis 客户端连接</h2><p>Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：</p><ol><li>首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。</li><li>然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法</li><li>然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送</li></ol><p>Socket编程中，TCP_NODELAY选项是用来控制是否开启Nagle算法，该算法是为了提高较慢的广域网传输效率，减小小分组的报文个数，完整描述：</p><blockquote><p>该算法要求一个TCP连接上最多只能有一个未被确认的小分组，在该小分组的确认到来之前，不能发送其他小分组。</p></blockquote><h3 id="最大连接数"><a href="#最大连接数" class="headerlink" title="最大连接数"></a>最大连接数</h3><p>在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。</p><p>maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxclients</span><br><span class="line">1) "maxclients"</span><br><span class="line">2) "10000"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-server --maxclients 100000 <span class="comment"># 在服务启动时设置最大连接数为 100000</span></span></span><br></pre></td></tr></table></figure><h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h3><table><thead><tr><th align="left">序号</th><th align="left">命令</th><th align="left">描述</th><th>可用版本</th><th>时间复杂度</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>client list</strong></td><td align="left">以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据。返回的信息含义参见</td><td>&gt;=2.4.0</td><td>O(N)， N 为连接到服务器的客户端数量。</td></tr><tr><td align="left">2</td><td align="left"><strong>client setname</strong></td><td align="left">1. 为当前连接分配一个名字。这个名字会显示在<code>client list</code>命令的结果中， 用于识别当前正在与服务器进行连接的客户端。获取通过<code>client setname</code> 命令设置的服务名称。<br>2. 名字使用 Redis 的字符串类型来保存， 最大可以占用 512 MB 。<br>3. 另外， 为了避免和<code>client list</code>命令的输出格式发生冲突， 名字里不允许使用空格。<br>4. 要移除一个连接的名字， 可以将连接的名字设为空字符串 <code>&quot;&quot;</code> 。<br>5. 新创建的连接默认是没有名字的。在 Redis 应用程序发生连接泄漏时，为连接设置名字是一种很好的 debug 手段。</td><td>&gt;=2.6.9</td><td>O(1)</td></tr><tr><td align="left">3</td><td align="left"><strong>client getname</strong></td><td align="left">返回<code>client getname</code>命令为连接设置的名字。因为新创建的连接默认是没有名字的， 对于没有名字的连接， <code>client getname</code>返回空白回复。</td><td>&gt;=2.6.9</td><td>O(1)</td></tr><tr><td align="left">4</td><td align="left"><strong>client pause</strong></td><td align="left">挂起客户端连接，指定挂起的时间以毫秒计</td><td>&gt;=2.9.5</td><td>O(1)</td></tr><tr><td align="left">5</td><td align="left"><strong>client kill</strong></td><td align="left">当指定的客户端存在，且被成功关闭时，返回 OK 。关闭地址为 <code>ip:port</code> 的客户端。<code>ip:port</code> 应该和<code>client-list)</code>命令输出的其中一行匹配。因为 Redis 使用单线程设计，所以当 Redis 正在执行命令的时候，不会有客户端被断开连接。</td><td>&gt;=2.4.0</td><td>O(N) ， N 为已连接的客户端数量。</td></tr><tr><td align="left">6</td><td align="left"><strong>client id</strong></td><td align="left">返回当前连接的id</td><td>&gt;=5.0.0</td><td>O(1)</td></tr></tbody></table><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client getname</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; client setname freya-connection</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; client getname</span><br><span class="line">"freya-connection"</span><br><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=7 addr=127.0.0.1:56661 fd=8 name= age=265815 idle=261969 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribe</span><br><span class="line">id=1012 addr=127.0.0.1:51537 fd=9 name=freya-connection age=647 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client setname    # 只用空格是不行的！</span><br><span class="line">(error) ERR Unknown subcommand or wrong number of arguments for 'setname'. Try CLIENT HELP</span><br><span class="line">127.0.0.1:6379&gt; client setname ""  # 必须双引号显示包围</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; client getname</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=7 addr=127.0.0.1:56661 fd=8 name= age=265951 idle=262105 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribe</span><br><span class="line">id=1012 addr=127.0.0.1:51537 fd=9 name= age=783 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="Redis-client-list-命令返回值"><a href="#Redis-client-list-命令返回值" class="headerlink" title="Redis client list 命令返回值"></a>Redis <code>client list</code> 命令返回值</h4><p>命令返回多行字符串，这些字符串按以下形式被格式化：</p><ol><li>每个已连接客户端对应一行（以 LF 分割）</li><li>每行字符串由一系列 <strong>属性=值</strong> 形式的域组成，每个域之间以空格分开</li></ol><p>以下是域的含义：</p><table><thead><tr><th>域</th><th>含义</th></tr></thead><tbody><tr><td><code>addr</code></td><td>客户端的地址和端口</td></tr><tr><td><code>fd</code></td><td>套接字所使用的文件描述符</td></tr><tr><td><code>age</code></td><td>以秒计算的已连接时长</td></tr><tr><td><code>idle</code></td><td>以秒计算的空闲时长</td></tr><tr><td><code>flags</code></td><td>客户端flag(见下表)</td></tr><tr><td><code>db</code></td><td>该客户端正在使用的数据库ID</td></tr><tr><td><code>sub</code></td><td>已订阅频道的数量</td></tr><tr><td><code>psub</code></td><td>已订阅模式的数量</td></tr><tr><td><code>multi</code></td><td>在事务中被执行的命令数量</td></tr><tr><td><code>qbuf</code></td><td>查询缓存的长度(0 表示没有查询在等待)</td></tr><tr><td><code>qbuf-free</code></td><td>查询缓存的剩余空间(0 表示没有剩余空间)</td></tr><tr><td><code>obl</code></td><td>输出缓存的长度</td></tr><tr><td><code>oll</code></td><td>输出列表的长度(当输出缓存没有剩余空间时，回复被入队到这个队列里)</td></tr><tr><td><code>omem</code></td><td>输出缓存的内存占用量</td></tr><tr><td><code>events</code></td><td>文件描述符事件(见下文)</td></tr><tr><td><code>cmd</code></td><td>最近一次执行的命令</td></tr></tbody></table><p>客户端 flag 可以由以下部分组成：</p><table><thead><tr><th>域</th><th>含义</th></tr></thead><tbody><tr><td><code>O</code></td><td>客户端是 monitor 模式下的附属节点 (slave)</td></tr><tr><td><code>S</code></td><td>客户端是一般模式下 (normal) 的附属节点</td></tr><tr><td><code>M</code></td><td>客户端是主节点 (master)</td></tr><tr><td><code>x</code></td><td>小写<code>x</code>，客户端正在执行事务</td></tr><tr><td><code>b</code></td><td>客户端正在等待阻塞事件</td></tr><tr><td><code>i</code></td><td>客户端正在等待 VM I/O 操作 (已废弃)</td></tr><tr><td><code>d</code></td><td>一个受监控 (watched) 的键已被修改， <code>exec</code>命令将失败</td></tr><tr><td><code>c</code></td><td>在将回复完整写出来之后，关闭连接</td></tr><tr><td><code>u</code></td><td>客户端未被阻塞 (unblocked)</td></tr><tr><td><code>A</code></td><td>尽可能快地关闭连接</td></tr><tr><td><code>N</code></td><td>未设置任何 flag</td></tr></tbody></table><p>文件描述符事件</p><table><thead><tr><th>文件描述符事件</th><th>含义</th></tr></thead><tbody><tr><td><code>r</code></td><td>客户端套接字（在事件 loop 中）是可读的（readable）</td></tr><tr><td><code>w</code></td><td>客户端套接字（在事件 loop 中）是可写的（writeable）</td></tr></tbody></table><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>为了 debug 的需要，经常会对域进行添加和删除，一个安全的 Redis 客户端应该可以对 CLIENT LIST 的输出进行相应的处理（parse），比如忽略不存在的域，跳过未知域，诸如此类。</p><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=7 addr=127.0.0.1:56661 fd=8 name= age=150289 idle=146443 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribe</span><br><span class="line">id=10 addr=127.0.0.1:64043 fd=9 name= age=525 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client</span><br></pre></td></tr></table></figure><h2 id="Redis-管道技术"><a href="#Redis-管道技术" class="headerlink" title="Redis 管道技术"></a>Redis 管道技术</h2><p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：</p><ol><li>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。</li><li>服务端处理命令，并将结果返回给客户端。</li></ol><p>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ (echo -en &quot;auth pwd\r\n PING\r\n SET freya redis\r\nGET freya\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n&quot;; sleep 10) | nc localhost 6379</span><br><span class="line">+OK</span><br><span class="line">+PONG</span><br><span class="line">+OK</span><br><span class="line">$5</span><br><span class="line">redis</span><br><span class="line">:1</span><br><span class="line">:2</span><br><span class="line">:3</span><br></pre></td></tr></table></figure><p>以上命令采用<code>auth pwd</code>授权，采用<code>PING</code>命令查看redis服务是否可用， 之后我们设置了 freya 的值为 redis，然后我们获取 freya 的值并使得 visitor 自增 3 次。</p><h3 id="管道技术的优势"><a href="#管道技术的优势" class="headerlink" title="管道技术的优势"></a>管道技术的优势</h3><p>管道技术最显著的优势是提高了 redis 服务的性能。</p><h2 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis 分区"></a>Redis 分区</h2><p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p><h3 id="分区的优势"><a href="#分区的优势" class="headerlink" title="分区的优势"></a>分区的优势</h3><ol><li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li><li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。<h3 id="分区的不足"><a href="#分区的不足" class="headerlink" title="分区的不足"></a>分区的不足</h3></li><li>涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li><li>涉及多个key的redis事务不能使用。</li><li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li><li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。</li></ol><h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><p>Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。</p><h4 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h4><p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。<br>比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。<br>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各种对象的映射表，通常对Redis来说并非是好的方法。</p><h4 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h4><p>另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：</p><ol><li>用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。</li><li>对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</li></ol><h2 id="Java-使用-Redis"><a href="#Java-使用-Redis" class="headerlink" title="Java 使用 Redis"></a>Java 使用 Redis</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>开始在 Java 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 Java redis 驱动，且你的机器上能正常使用 Java。</p><h3 id="连接到-redis-服务"><a href="#连接到-redis-服务" class="headerlink" title="连接到 redis 服务"></a>连接到 redis 服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">public class RedisTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 连接本地的 Redis 服务</span><br><span class="line">        Jedis jedis = new Jedis(&quot;localhost&quot;)；</span><br><span class="line">        //验证密码</span><br><span class="line">        jedis.auth(&quot;redis&quot;);</span><br><span class="line">        // 查看服务是否运行</span><br><span class="line">        System.out.println(&quot;服务正在运行: &quot; + jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-数据备份与恢复&quot;&gt;&lt;a href=&quot;#Redis-数据备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;Redis 数据备份与恢复&quot;&gt;&lt;/a&gt;Redis 数据备份与恢复&lt;/h2&gt;&lt;h3 id=&quot;数据备份&quot;&gt;&lt;a href=&quot;#数据备份&quot;
      
    
    </summary>
    
      <category term="Redis" scheme="https://muhouer.github.io/categories/Redis/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Redis/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="进阶教程" scheme="https://muhouer.github.io/tags/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>

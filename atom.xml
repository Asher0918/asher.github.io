<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Muhouer</title>
  
  <subtitle>开始记录只需5分钟!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muhouer.github.io/"/>
  <updated>2019-09-22T17:03:43.217Z</updated>
  <id>https://muhouer.github.io/</id>
  
  <author>
    <name>Muhouer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DNS协议介绍</title>
    <link href="https://muhouer.github.io/posts/13c9dbc5/"/>
    <id>https://muhouer.github.io/posts/13c9dbc5/</id>
    <published>2019-09-22T17:03:00.000Z</published>
    <updated>2019-09-22T17:03:43.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>DNS 协议</strong>也就是在做 DNS 解析时，客户端与服务端之间的通信协议。<strong>DNS 协议</strong>建立在 UDP 或 TCP 协议之上，默认使用 53 号端口。客户端默认通过 UDP 协议进行通讯，但是由于广域网中不适合传输过大的 UDP 数据包，因此规定当报文长度超过了 512 字节时，应转换为使用 TCP 协议进行数据传输。详见 <a href="https://www.ietf.org/rfc/rfc1035.txt" target="_blank" rel="noopener">RFC1035 4.MESSAGES</a> 部分。</p><ul><li>客户端认为 UDP 响应包长度可能超过 512 字节，主动使用 TCP 协议；</li><li>客户端使用 UDP 协议发送 DNS 请求，服务端发现响应报文超过了 512 字节，在截断的 UDP 响应报文中将 TC 设置为 1 ，以通知客户端该报文已经被截断，客户端收到之后再发起一次 TCP 请求。</li></ul><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>整个报文的格式如下，包括了五部分组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|        Header       | 报文头，定义了报文是请求还是应答、错误码以及其它的一些标志位</span><br><span class="line">+---------------------+</span><br><span class="line">|       Question      | 查询请求，包括查询类型(QTYPE)、查询类(QCLASS) 以及查询的域名(QNAME)</span><br><span class="line">+---------------------+</span><br><span class="line">|        Answer       | 应答资源记录(RRs)</span><br><span class="line">+---------------------+</span><br><span class="line">|      Authority      | 授权资源记录(RRs)</span><br><span class="line">+---------------------+</span><br><span class="line">|      Additional     | 附加信息资源记录(RRs)</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h2 id="报文头"><a href="#报文头" class="headerlink" title="报文头"></a>报文头</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                1  1  1  1  1  1</span><br><span class="line">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                      ID                       |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    QDCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    ANCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    NSCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                    ARCOUNT                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></pre></td></tr></table></figure><p>字段含义如下:</p><table><thead><tr><th align="center">字段</th><th>备注</th></tr></thead><tbody><tr><td align="center">ID</td><td>16Bits ，用于生成任何类型的查询。响应报文会原样带回，用于客户端区分不同的请求应答。</td></tr><tr><td align="center">QR</td><td>1Bits，请求 (0 Question) ，应答 (1 Response)。</td></tr><tr><td align="center">Opcode</td><td>4Bits，设置查询的种类，0 标准查询 QUERY、1 反向查询 IQUERY、2 服务器状态查询 STATUS、3~15 保留。响应报文会原样带回。</td></tr><tr><td align="center">AA</td><td>1Bits，授权应答(AuthoritativeAnswer)，响应报文生效，用于标示服务器响应报文是否为授权服务器返回的结果，可能是在本地 Cache 的缓存。</td></tr><tr><td align="center">TC</td><td>1Bits，截断(TrunCation)，报文因为超过了允许的长度，导致被截断。</td></tr><tr><td align="center">RD</td><td>1Bits，用于请求中，期望使用递归查询。</td></tr><tr><td align="center">RA</td><td>1Bits，用于响应中，如果服务器支持递归查询则设置为 1 ，否则设置为 0 。</td></tr><tr><td align="center">RCODE</td><td>4Bits，应答码(ResponseCode)，会在响应报文中设置。含义如下：<br>0 没有错误；<br>1 报文格式错误(Format Error)，服务器解析请求报文时报错；<br>2 服务器失败(Server Failure)，因为服务器的原因导致没办法处理这个请求；<br>3 名字错误(Name Error)，只对授权域名解析服务器有意义，解析的域名不存在；<br>4 没有实现(Not Implemented)，域名服务器不支持查询类型；<br>5 拒绝(Refused)，由于服务器设置的策略拒绝给出应答，通常是安全的配置；<br>6-15 保留值，暂未使用。</td></tr><tr><td align="center">QDCOUNT</td><td>无符号16位整数，表示报文请求段中的问题记录数。</td></tr><tr><td align="center">ANCOUNT</td><td>无符号16位整数，表示报文回答段中的回答记录数。</td></tr><tr><td align="center">NSCOUNT</td><td>无符号16位整数，表示报文授权段中的授权记录数。</td></tr><tr><td align="center">ARCOUNT</td><td>无符号16位整数，表示报文附加段中的附加记录数。</td></tr></tbody></table><blockquote><p>为加快 DNS 的查询速度，一般会在服务端缓存一段时间，所以有可能 DNS 会返回缓存在 Cache 中的内容，那么此时就会将 AA 响应设置为 0 ，也就是是这里显示的 Non-authoritative answer 。</p></blockquote><h2 id="查询请求"><a href="#查询请求" class="headerlink" title="查询请求"></a>查询请求</h2><p>用来标识，查询的请求参数，同时需要在头中设置 <code>QDCOUNT</code> 这个字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                                1  1  1  1  1  1</span><br><span class="line">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                                               |</span><br><span class="line">/                     QNAME                     /</span><br><span class="line">/                                               /</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                     QTYPE                     |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="line">|                     QCLASS                    |</span><br><span class="line">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></pre></td></tr></table></figure><p>字段含义如下:</p><table><thead><tr><th>字段</th><th align="left">注释</th></tr></thead><tbody><tr><td>QNAME</td><td align="left">域名被表示为标签序列，每个标签包含一个字节表示后续字符串长度，以及这个字符串，以0长度和空字符串来表示域名结束。请注意，此字段可能是奇数个字节，不需要进行边界填充对齐。</td></tr><tr><td>QTYPE</td><td align="left">2个字节，表示查询类型，取值可以为任何可用的类型值，以及通配码来表示所有的资源记录。</td></tr><tr><td>QCLASS</td><td align="left">2个字节，表示查询的协议类，比如，IN代表Internet</td></tr></tbody></table><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="递归查询-VS-迭代查询"><a href="#递归查询-VS-迭代查询" class="headerlink" title="递归查询 VS. 迭代查询"></a>递归查询 VS. 迭代查询</h3><p>在递归查询模式下，DNS 服务器在接收到客户机请求时，必须使用一个准确的查询结果回复客户机。也就意味着，如果 DNS 服务器本地没有缓存所查询的 DNS 信息，那么该服务器会询问其它服务器，并将返回的查询结果提交给客户机。</p><p>而在使用迭代查询时，DNS 服务器会向客户机提供其它能够解析查询请求的 DNS 服务器地址。也就是说，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台 DNS 服务器地址，客户机需要再向这台 DNS 服务器提交请求，依次循环直到返回查询的结果为止。</p><p>也就是说，关键的区别是由谁去查询最终的结果。</p><h3 id="DDoS"><a href="#DDoS" class="headerlink" title="DDoS"></a>DDoS</h3><p>发送大量的 DNS 递归查询会消耗服务端的一定资源，所以，只需要将发送的报文设置一个 RD 标志位即可。</p><p>当发送垃圾查询时，例如不存在的域名，必然会导致查询很慢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;DNS 协议&lt;/strong&gt;也就是在做 DNS 解析时，客户端与服务端之间的通信协议。&lt;strong&gt;DNS 协议&lt;/st
      
    
    </summary>
    
      <category term="通信协议" scheme="https://muhouer.github.io/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="DNS" scheme="https://muhouer.github.io/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>为什么数据库设计中要使用long来替换Date类型</title>
    <link href="https://muhouer.github.io/posts/c0f0d722/"/>
    <id>https://muhouer.github.io/posts/c0f0d722/</id>
    <published>2019-09-22T15:38:00.000Z</published>
    <updated>2019-09-22T15:41:06.287Z</updated>
    
    <content type="html"><![CDATA[<p>对数据库中的记录进行操作的时候，牵涉到对时间数据的处理，比如创建时间、修改时间等，一般使用 long 类型代替 <code>Date</code> 、<code>Timestamp</code>。比如 Mybatis 的池连接类 <code>PooledConnection</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> checkoutTimestamp; <span class="comment">// 检查时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> createdTimestamp; <span class="comment">// 创建时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastUsedTimestamp; <span class="comment">// 最后一次使用时间戳</span></span><br></pre></td></tr></table></figure><h2 id="MySQL、SQL-Server中的表示时间的类型"><a href="#MySQL、SQL-Server中的表示时间的类型" class="headerlink" title="MySQL、SQL Server中的表示时间的类型"></a>MySQL、SQL Server中的表示时间的类型</h2><p><strong>Date</strong>——日期。格式：YYYY-MM-DD。占用三个字节。</p><p><strong>Datetime</strong>——日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS。<code>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</code>，占用8个字节。适合用来记录数据的原始的创建时间。</p><p><strong>Timestamp</strong>——日期+时间，使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS。占用4个字节，<code>&#39;1970-01-01 00:00:01&#39; UTC ~ &#39;2038-01-09 03:14:07&#39; UTC</code>，适合用来记录数据的最后修改时间，只要更改记录中其他字段的值，timestamp字段的值都会被自动更新。</p><p><strong>bigint</strong>——表示从-2^63 (-9,223,372,036,854,775,808) 到 2^63-1 (9,223,372,036,854,775,807)，占用8个字节。</p><h2 id="Java-中表示时间的类型"><a href="#Java-中表示时间的类型" class="headerlink" title="Java 中表示时间的类型"></a>Java 中表示时间的类型</h2><p>Java 中对时间处理的类比较混乱，处理时间的类有：<code>java.util.Date</code>、<code>java.sql.Date</code> 、<code>java.sql.Time</code> 、<code>java.sql.Timestamp</code>、<code>java.util.Calendar</code> 、<code>java.util.TimeZone</code>。使用过程中存在以下问题：</p><ol><li>获取当前时间时，各个地区在同一个时间点会有不同的时间表示。</li><li>将 <code>java.util.Date</code> 转为 <code>java.sql.Date</code> 时候，日期的时分秒会被去掉，数据的精度发生了变化。而 JDBC 中定义接口时候，用的是 <code>java.sql.Date</code>，而我们常常用到的 Date 都是 <code>java.util.Date</code>，这往往导致一些转换过程中发生误差。</li><li><code>java.sql.Date</code>在JDBC接口中使用，如果对其进行修改，JDBC 接口规范也要改，那么将引发各个数据库厂商对数据库驱动也要改，这是不可接受的。</li><li><code>java.sql.Timestamp</code> 类，它保持了日期数据原有的精度。可以实现和 <code>java.util.Date</code> 的无损转换。但是 Timestamp 这个类在一些预定义SQL中常常会出问题。</li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>将 Date 类型转换为 long 类型。这样一来：</p><ol><li>有利于计算时间差</li><li>方便 Java 与数据库之间的传输</li><li>通过 <code>long now = System.currentTimeMillis()</code> 获得当前时间的 long 类型 也可以通过 <code>Date date1=new Date()</code> 来获得当前时间，再用 <code>long time = date.getTime()</code> 将其转化为 long类型。然后在数据库中的相应字段设置类型为 bigint 即可，在数据库中取得数据后，可以在转为相应的时间格式。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对数据库中的记录进行操作的时候，牵涉到对时间数据的处理，比如创建时间、修改时间等，一般使用 long 类型代替 &lt;code&gt;Date&lt;/code&gt; 、&lt;code&gt;Timestamp&lt;/code&gt;。比如 Mybatis 的池连接类 &lt;code&gt;PooledConnection
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>抽象队列与阻塞队列解析</title>
    <link href="https://muhouer.github.io/posts/ee5f9e9d/"/>
    <id>https://muhouer.github.io/posts/ee5f9e9d/</id>
    <published>2019-09-17T15:11:19.000Z</published>
    <updated>2019-09-17T15:11:50.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象队列"><a href="#抽象队列" class="headerlink" title="抽象队列"></a>抽象队列</h2><p><code>AbstractQueue</code> 是个抽象类，继承 <code>AbstractCollection</code>，实现 <code>Queue</code> 接口。其中 <code>AbstractCollection</code> 也是个抽象类，实现了 <code>Collection</code> 接口。所以 <code>AbstractQueue</code> 实现了集合的方法，和常用的 <code>ArrayList</code> 等类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 被子类使用的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractQueue</code> 还实现 <code>Queue</code> 接口，<code>Queue</code> 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 将元素 e 插入队列尾部，插入成功返回 true。如果在超出 JVM 限制的时候用 add 方法会抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素 e 插入队列尾部，插入成功返回 true。如果在超出 JVM 限制的时候用 offer 方法会返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检索并移除此队列的头，队列为空则抛出 NoSuchElementException</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检索并移除此队列的头，队列为空则返回 null</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检索但不移除此队列的头，队列为空则抛出 NoSuchElementException</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检索但不移除此队列的头，队列为空则返回 null</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractQueue</code> 在实现 <code>add(E e)</code> 方法时，调用 <code>offer(E e)</code> 添加失败则抛出异常 <code>IllegalStateException(&quot;Queue full&quot;)</code>。实现 <code>remove()</code> 方法时，调用 <code>poll()</code> 方法返回 null 则抛出异常 <code>NoSuchElementException()</code>。实现 <code>element()</code> 方法时，调用 <code>peek()</code> 方法返回 null 则抛出异常 <code>NoSuchElementException()</code>。</p><p>除了以上方法外，<code>AbstractQueue</code> 还实现了 <code>clear()</code> 、<code>addAll(Collection&lt;? extends E&gt; c)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空队列元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (poll() != <span class="keyword">null</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将集合中的元素全部加到队列，全部添加成功则返回 true。</span></span><br><span class="line"><span class="comment">// 如果集合为 null，则抛出空指针异常。如果集合和当前队列是一个，则抛出 IllegalArgumentException 异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>在 JUC 中，<code>BlockingQueue</code> 很好的解决了多线程中如何高效安全“传输”数据的问题，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。</p><p>接口中定义的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 将元素 e 插入队列尾部，参见 `Queue` 接口的 add 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将元素 e 插入队列尾部，参见 `Queue` 接口的 offer 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将指定的元素插队列尾部，当空间不可用时会等待。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将指定的元素插队列尾部，当空间不可用时会等待，直到超时。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 遍历并移除队列头部元素，如果队列为空则阻塞直至有元素可移除。</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// take() 的超时版本</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回此队列在理想情况下（在没有内存或资源约束的情况下）可以不阻塞地接受的元素的数目</span></span><br><span class="line">    <span class="comment">// 如果没有内在限制，则返回&#123;@code integer.max_value&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 检索并移除此队列的头，参见 `Queue` 接口的 remove 方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含，参见 Collection 接口的 contains 方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中移除所有可用元素并将它们添加到给定集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中移除指定数量的可用元素并将它们添加到给定集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;抽象队列&quot;&gt;&lt;a href=&quot;#抽象队列&quot; class=&quot;headerlink&quot; title=&quot;抽象队列&quot;&gt;&lt;/a&gt;抽象队列&lt;/h2&gt;&lt;p&gt;&lt;code&gt;AbstractQueue&lt;/code&gt; 是个抽象类，继承 &lt;code&gt;AbstractCollection&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ArrayBlockingQueue解析</title>
    <link href="https://muhouer.github.io/posts/c7003c14/"/>
    <id>https://muhouer.github.io/posts/c7003c14/</id>
    <published>2019-09-17T15:07:00.000Z</published>
    <updated>2019-09-17T15:12:35.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ArrayBlockingQueue</code> 是采用数组实现的有界阻塞线程安全队列。如果向已满的队列继续塞入元素，将导致当前的线程阻塞。如果向空队列获取元素，那么将导致当前线程阻塞。</p><p><code>ArrayBlockingQueue</code> 继承 <code>AbstractQueue</code> 类，实现 <code>BlockingQueue</code> 和 <code>Serializable</code>接口，关于 <code>AbstractQueue</code> 和 <code>BlockingQueue</code> 的内容可以参考 <a href="/posts/ee5f9e9d/" title="抽象队列与阻塞队列解析">抽象队列与阻塞队列解析</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><img src="/images/ArrayBlockingQueue.png" width="800px" height="300px" align="center"><p><code>ArrayBlockingQueue</code> 有两个内部类，分别为 <code>Itrs</code> 和 <code>Itr</code>。其中 <code>Itrs</code> 内部类 <code>Node</code> 继承 <code>WeakReference</code> 类。<code>Itr</code> 实现了 <code>Iterator</code> 接口</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>实现简单的生产者消费者模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Food&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生产者</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Food food = <span class="keyword">new</span> Food();</span><br><span class="line">      food.setName(<span class="string">"Apple"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        queue.put(food);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" provider : "</span> + food);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消费者</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Food food = queue.take();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" consumer : "</span> + food);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 食物</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Food &#123;name:"</span> + name + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> ArrayBlockingQueueTest().new Producer()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> ArrayBlockingQueueTest().new Consumer()).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> ArrayBlockingQueueTest().new Consumer()).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一次执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">4</span> provider : Food &#123;name:Apple&#125;</span><br><span class="line">Thread-<span class="number">3</span> provider : Food &#123;name:Apple&#125;</span><br><span class="line">Thread-<span class="number">5</span> consumer : Food &#123;name:Apple&#125;</span><br><span class="line">Thread-<span class="number">2</span> provider : Food &#123;name:Apple&#125;</span><br><span class="line">Thread-<span class="number">0</span> provider : Food &#123;name:Apple&#125;</span><br><span class="line">Thread-<span class="number">6</span> consumer : Food &#123;name:Apple&#125;</span><br></pre></td></tr></table></figure><h2 id="类结构源码分析"><a href="#类结构源码分析" class="headerlink" title="类结构源码分析"></a>类结构源码分析</h2><h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>可重入锁的内容可以参考 <a href="/posts/b376c662/" title="ReentrantLock解析">ReentrantLock解析</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 存放队列元素的数组 */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 取元素的下标索引 */</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 存元素的下标索引 */</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列中元素的数量 */</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 数据访问的重入锁 */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 取元素的等待队列条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 存元素的等待队列条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前活动迭代器的共享状态，如果已知不存在，则为空。允许队列操作更新迭代器状态。*/</span></span><br><span class="line"><span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>构造器有三种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化阻塞队列容量，默认是采用不公平重入锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 capacity 初始化阻塞队列容量，fair 初始化重入锁的公平与否</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ArrayBlockingQueue(int capacity, boolean fair) 基础上，将集合中元素加到阻塞队列中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 采用 ArrayBlockingQueue(int capacity, boolean fair) 初始化阻塞队列</span></span><br><span class="line">    <span class="keyword">this</span>(capacity, fair);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 锁仅用于可见性，而不是相互排斥</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                checkNotNull(e); <span class="comment">// 检查非空</span></span><br><span class="line">                items[i++] = e; <span class="comment">// 将元素加入阻塞队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新队列中元素的数量</span></span><br><span class="line">        count = i;</span><br><span class="line">        <span class="comment">// 更新存元素的下标索引，i 和 capacity 相等，则从 0 开始重新计</span></span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类源码分析"><a href="#内部类源码分析" class="headerlink" title="内部类源码分析"></a>内部类源码分析</h2><h3 id="Itrs内部类"><a href="#Itrs内部类" class="headerlink" title="Itrs内部类"></a>Itrs内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Itrs</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 弱迭代器引用的链接列表节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Itr</span>&gt; </span>&#123;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(Itr iterator, Node next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(iterator);</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** takeIndex 环绕到0的次数*/</span></span><br><span class="line">    <span class="keyword">int</span> cycles = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 弱迭代器引用的链接列表头节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/** 用于删除过时的迭代器 */</span></span><br><span class="line">    <span class="keyword">private</span> Node sweeper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 短扫频探头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHORT_SWEEP_PROBES = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 长扫频探头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LONG_SWEEP_PROBES = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    Itrs(Itr initial) &#123;</span><br><span class="line">        register(initial);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 清理迭代器，查找并删除过时的迭代器。仅从迭代线程调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeSweeping</span><span class="params">(<span class="keyword">boolean</span> tryHarder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        <span class="comment">// assert head != null;</span></span><br><span class="line">        <span class="keyword">int</span> probes = tryHarder ? LONG_SWEEP_PROBES : SHORT_SWEEP_PROBES;</span><br><span class="line">        Node o, p;</span><br><span class="line">        <span class="keyword">final</span> Node sweeper = <span class="keyword">this</span>.sweeper;</span><br><span class="line">        <span class="keyword">boolean</span> passedGo;   <span class="comment">// to limit search to one full sweep</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sweeper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            o = <span class="keyword">null</span>;</span><br><span class="line">            p = head;</span><br><span class="line">            passedGo = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = sweeper;</span><br><span class="line">            p = o.next;</span><br><span class="line">            passedGo = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; probes &gt; <span class="number">0</span>; probes--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (passedGo)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                o = <span class="keyword">null</span>;</span><br><span class="line">                p = head;</span><br><span class="line">                passedGo = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Itr it = p.get();</span><br><span class="line">            <span class="keyword">final</span> Node next = p.next;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="keyword">null</span> || it.isDetached()) &#123;</span><br><span class="line">                <span class="comment">// found a discarded/exhausted iterator</span></span><br><span class="line">                probes = LONG_SWEEP_PROBES; <span class="comment">// "try harder"</span></span><br><span class="line">                <span class="comment">// unlink p</span></span><br><span class="line">                p.clear();</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head = next;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// We've run out of iterators to track; retire</span></span><br><span class="line">                        itrs = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    o.next = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                o = p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sweeper = (p == <span class="keyword">null</span>) ? <span class="keyword">null</span> : o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新迭代器添加到跟踪迭代器的链接列表中。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Itr itr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        head = <span class="keyword">new</span> Node(itr, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有迭代器，并删除任何已过时的迭代器。takeIndex 环绕到0时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">takeIndexWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        cycles++;</span><br><span class="line">        <span class="keyword">for</span> (Node o = <span class="keyword">null</span>, p = head; p != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Itr it = p.get();</span><br><span class="line">            <span class="keyword">final</span> Node next = p.next;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="keyword">null</span> || it.takeIndexWrapped()) &#123;</span><br><span class="line">                <span class="comment">// unlink p</span></span><br><span class="line">                <span class="comment">// assert it == null || it.isDetached();</span></span><br><span class="line">                p.clear();</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">                    head = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    o.next = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                o = p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)   <span class="comment">// no more iterators to track</span></span><br><span class="line">            itrs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当迭代器被移除时调用，通知所有迭代器，并删除已过时的迭代器。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removedAt</span><span class="params">(<span class="keyword">int</span> removedIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node o = <span class="keyword">null</span>, p = head; p != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Itr it = p.get();</span><br><span class="line">            <span class="keyword">final</span> Node next = p.next;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="keyword">null</span> || it.removedAt(removedIndex)) &#123;</span><br><span class="line">                <span class="comment">// unlink p</span></span><br><span class="line">                <span class="comment">// assert it == null || it.isDetached();</span></span><br><span class="line">                p.clear();</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">                    head = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    o.next = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                o = p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)   <span class="comment">// no more iterators to track</span></span><br><span class="line">            itrs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列为空时调用，通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">queueIsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        <span class="keyword">for</span> (Node p = head; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">            Itr it = p.get();</span><br><span class="line">            <span class="keyword">if</span> (it != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.clear();</span><br><span class="line">                it.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        itrs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每当元素（在 takeIndex 处）退出队列时调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">elementDequeued</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            queueIsEmpty();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (takeIndex == <span class="number">0</span>)</span><br><span class="line">            takeIndexWrapped();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Itr-内部类"><a href="#Itr-内部类" class="headerlink" title="Itr 内部类"></a>Itr 内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** 游标，下一个next节点对应的下标，到达putIndex结束的位置为NONE */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">        <span class="comment">/** next节点的元素值 */</span></span><br><span class="line">        <span class="keyword">private</span> E nextItem;</span><br><span class="line">        <span class="comment">/** next节点的索引 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">        <span class="comment">/** 上一个节点的元素值 */</span></span><br><span class="line">        <span class="keyword">private</span> E lastItem;</span><br><span class="line">        <span class="comment">/** 上一个节点的索引 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> lastRet;</span><br><span class="line">        <span class="comment">/** 记录 takeIndex */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> prevTakeIndex;</span><br><span class="line">        <span class="comment">/** 记录cycles */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> prevCycles;</span><br><span class="line">        <span class="comment">/** 元素不可用或未定义时的特殊索引值 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NONE = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 元素非调用 this.remove() 被移除元素的索引值 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REMOVED = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/** detached 模式特殊的 prevTakeIndex 值 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DETACHED = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            lastRet = NONE;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// assert itrs == null;</span></span><br><span class="line">                    cursor = NONE;</span><br><span class="line">                    nextIndex = NONE;</span><br><span class="line">                    prevTakeIndex = DETACHED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> takeIndex = ArrayBlockingQueue.<span class="keyword">this</span>.takeIndex;</span><br><span class="line">                    prevTakeIndex = takeIndex;</span><br><span class="line">                    nextItem = itemAt(nextIndex = takeIndex);</span><br><span class="line">                    cursor = incCursor(takeIndex);</span><br><span class="line">                    <span class="keyword">if</span> (itrs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        itrs = <span class="keyword">new</span> Itrs(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 在 itrs 中注册 this</span></span><br><span class="line">                        itrs.register(<span class="keyword">this</span>); <span class="comment">// in this order</span></span><br><span class="line">                        <span class="comment">// 清理迭代器，查找并删除过时的迭代器。</span></span><br><span class="line">                        itrs.doSomeSweeping(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    prevCycles = itrs.cycles;</span><br><span class="line">                    <span class="comment">// assert takeIndex &gt;= 0;</span></span><br><span class="line">                    <span class="comment">// assert prevTakeIndex == takeIndex;</span></span><br><span class="line">                    <span class="comment">// assert nextIndex &gt;= 0;</span></span><br><span class="line">                    <span class="comment">// assert nextItem != null;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否是 detached 模式</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isDetached</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">return</span> prevTakeIndex &lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 游标处理</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incCursor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">if</span> (++index == items.length)</span><br><span class="line">                <span class="comment">// 从 0 开始</span></span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (index == putIndex)</span><br><span class="line">                <span class="comment">// takeIndex == putIndex</span></span><br><span class="line">                index = NONE;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验索引是否有效</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">invalidated</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> prevTakeIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">long</span> dequeues, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> distance = index - prevTakeIndex;</span><br><span class="line">            <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">                distance += length;</span><br><span class="line">            <span class="comment">// 下标距离的prevTakeIndex元素数量 和 出队元素数量 比较</span></span><br><span class="line">            <span class="keyword">return</span> dequeues &gt; distance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整索引，合并自上次对此迭代器执行操作以来的所有出列。</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incorporateDequeues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="comment">// assert itrs != null;</span></span><br><span class="line">            <span class="comment">// assert !isDetached();</span></span><br><span class="line">            <span class="comment">// assert count &gt; 0;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> cycles = itrs.cycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> takeIndex = ArrayBlockingQueue.<span class="keyword">this</span>.takeIndex;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevCycles = <span class="keyword">this</span>.prevCycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevTakeIndex = <span class="keyword">this</span>.prevTakeIndex;</span><br><span class="line">            <span class="comment">// cycles和takeIndex存在不一致，需要修正</span></span><br><span class="line">            <span class="keyword">if</span> (cycles != prevCycles || takeIndex != prevTakeIndex) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> len = items.length;</span><br><span class="line">                <span class="comment">// 计算出队元素的数量</span></span><br><span class="line">                <span class="keyword">long</span> dequeues = (cycles - prevCycles) * len</span><br><span class="line">                    + (takeIndex - prevTakeIndex);</span><br><span class="line">                <span class="comment">// 校验下标合法性</span></span><br><span class="line">                <span class="keyword">if</span> (invalidated(lastRet, prevTakeIndex, dequeues, len))</span><br><span class="line">                    lastRet = REMOVED;</span><br><span class="line">                <span class="keyword">if</span> (invalidated(nextIndex, prevTakeIndex, dequeues, len))</span><br><span class="line">                    nextIndex = REMOVED;</span><br><span class="line">                <span class="keyword">if</span> (invalidated(cursor, prevTakeIndex, dequeues, len))</span><br><span class="line">                    cursor = takeIndex;</span><br><span class="line">                <span class="comment">// 进入detach模式</span></span><br><span class="line">                <span class="keyword">if</span> (cursor &lt; <span class="number">0</span> &amp;&amp; nextIndex &lt; <span class="number">0</span> &amp;&amp; lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                    detach();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.prevCycles = cycles;</span><br><span class="line">                    <span class="keyword">this</span>.prevTakeIndex = takeIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改detach的标志字段，并且启动itrs的清理逻辑。</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Switch to detached mode</span></span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="comment">// assert cursor == NONE;</span></span><br><span class="line">            <span class="comment">// assert nextIndex &lt; 0;</span></span><br><span class="line">            <span class="comment">// assert lastRet &lt; 0 || nextItem == null;</span></span><br><span class="line">            <span class="comment">// assert lastRet &lt; 0 ^ lastItem != null;</span></span><br><span class="line">            <span class="keyword">if</span> (prevTakeIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// assert itrs != null;</span></span><br><span class="line">                prevTakeIndex = DETACHED;</span><br><span class="line">                <span class="comment">// try to unlink from itrs (but not too hard)</span></span><br><span class="line">                itrs.doSomeSweeping(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器的 hasNext 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            <span class="keyword">if</span> (nextItem != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            noNext(); <span class="comment">// 对于没有下一个节点的迭代器，需要修正下标属性并进入detach模式。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修正下标属性并进入detach模式</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">noNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// assert cursor == NONE;</span></span><br><span class="line">                <span class="comment">// assert nextIndex == NONE;</span></span><br><span class="line">                <span class="keyword">if</span> (!isDetached()) &#123;</span><br><span class="line">                    <span class="comment">// assert lastRet &gt;= 0;</span></span><br><span class="line">                    incorporateDequeues(); <span class="comment">// might update lastRet</span></span><br><span class="line">                    <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        lastItem = itemAt(lastRet);</span><br><span class="line">                        <span class="comment">// assert lastItem != null;</span></span><br><span class="line">                        detach();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// assert isDetached();</span></span><br><span class="line">                <span class="comment">// assert lastRet &lt; 0 ^ lastItem != null;</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器的 next() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            <span class="keyword">final</span> E x = nextItem;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isDetached())</span><br><span class="line">                    incorporateDequeues();</span><br><span class="line">                <span class="comment">// assert nextIndex != NONE;</span></span><br><span class="line">                <span class="comment">// assert lastItem == null;</span></span><br><span class="line">                lastRet = nextIndex;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">                <span class="keyword">if</span> (cursor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    nextItem = itemAt(nextIndex = cursor);</span><br><span class="line">                    <span class="comment">// assert nextItem != null;</span></span><br><span class="line">                    <span class="keyword">this</span>.cursor = incCursor(cursor);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextIndex = NONE;</span><br><span class="line">                    nextItem = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器的 remove() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isDetached())</span><br><span class="line">                    incorporateDequeues(); <span class="comment">// might update lastRet or detach</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> lastRet = <span class="keyword">this</span>.lastRet;</span><br><span class="line">                <span class="keyword">this</span>.lastRet = NONE;</span><br><span class="line">                <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isDetached())</span><br><span class="line">                        removeAt(lastRet);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">final</span> E lastItem = <span class="keyword">this</span>.lastItem;</span><br><span class="line">                        <span class="comment">// assert lastItem != null;</span></span><br><span class="line">                        <span class="keyword">this</span>.lastItem = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (itemAt(lastRet) == lastItem)</span><br><span class="line">                            removeAt(lastRet);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastRet == NONE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                <span class="comment">// else lastRet == REMOVED and the last returned element was</span></span><br><span class="line">                <span class="comment">// previously asynchronously removed via an operation other</span></span><br><span class="line">                <span class="comment">// than this.remove(), so nothing to do.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cursor &lt; <span class="number">0</span> &amp;&amp; nextIndex &lt; <span class="number">0</span>)</span><br><span class="line">                    detach();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="comment">// assert lastRet == NONE;</span></span><br><span class="line">                <span class="comment">// assert lastItem == null;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知迭代器队列为空，或队列已无望地落在后面</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            cursor = NONE;</span><br><span class="line">            <span class="keyword">if</span> (nextIndex &gt;= <span class="number">0</span>)</span><br><span class="line">                nextIndex = REMOVED;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                lastRet = REMOVED;</span><br><span class="line">                lastItem = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prevTakeIndex = DETACHED;</span><br><span class="line">            <span class="comment">// Don't set nextItem to null because we must continue to be</span></span><br><span class="line">            <span class="comment">// able to return it on next().</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Caller will unlink from itrs when convenient.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> prevTakeIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> distance = index - prevTakeIndex;</span><br><span class="line">            <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">                distance += length;</span><br><span class="line">            <span class="keyword">return</span> distance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有队列移除takeIndex下标处元素的方法, 都会调用迭代器的removeAt方法，以通知其修正下标索引值。</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">removedAt</span><span class="params">(<span class="keyword">int</span> removedIndex)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">if</span> (isDetached())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> cycles = itrs.cycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> takeIndex = ArrayBlockingQueue.<span class="keyword">this</span>.takeIndex;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevCycles = <span class="keyword">this</span>.prevCycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevTakeIndex = <span class="keyword">this</span>.prevTakeIndex;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> len = items.length;</span><br><span class="line">            <span class="keyword">int</span> cycleDiff = cycles - prevCycles;</span><br><span class="line">            <span class="keyword">if</span> (removedIndex &lt; takeIndex)</span><br><span class="line">                cycleDiff++;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> removedDistance =</span><br><span class="line">                (cycleDiff * len) + (removedIndex - prevTakeIndex);</span><br><span class="line">            <span class="comment">// assert removedDistance &gt;= 0;</span></span><br><span class="line">            <span class="keyword">int</span> cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">            <span class="keyword">if</span> (cursor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = distance(cursor, prevTakeIndex, len);</span><br><span class="line">                <span class="keyword">if</span> (x == removedDistance) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cursor == putIndex)</span><br><span class="line">                        <span class="keyword">this</span>.cursor = cursor = NONE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance) &#123;</span><br><span class="line">                    <span class="comment">// assert cursor != prevTakeIndex;</span></span><br><span class="line">                    <span class="keyword">this</span>.cursor = cursor = dec(cursor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> lastRet = <span class="keyword">this</span>.lastRet;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = distance(lastRet, prevTakeIndex, len);</span><br><span class="line">                <span class="keyword">if</span> (x == removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.lastRet = lastRet = REMOVED;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.lastRet = lastRet = dec(lastRet);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nextIndex = <span class="keyword">this</span>.nextIndex;</span><br><span class="line">            <span class="keyword">if</span> (nextIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = distance(nextIndex, prevTakeIndex, len);</span><br><span class="line">                <span class="keyword">if</span> (x == removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.nextIndex = nextIndex = REMOVED;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.nextIndex = nextIndex = dec(nextIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cursor &lt; <span class="number">0</span> &amp;&amp; nextIndex &lt; <span class="number">0</span> &amp;&amp; lastRet &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.prevTakeIndex = DETACHED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// takeIndex每次循环到0时会调用该方法。</span></span><br><span class="line">        <span class="comment">// cycle计数增加，遍历链表检查并清理过期的无效节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">takeIndexWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">if</span> (isDetached())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (itrs.cycles - prevCycles &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// All the elements that existed at the time of the last</span></span><br><span class="line">                <span class="comment">// operation are gone, so abandon further iteration.</span></span><br><span class="line">                shutdown();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         /** 取消调试注释. */</span></span><br><span class="line"><span class="comment">//         public String toString() &#123;</span></span><br><span class="line"><span class="comment">//             return ("cursor=" + cursor + " " +</span></span><br><span class="line"><span class="comment">//                     "nextIndex=" + nextIndex + " " +</span></span><br><span class="line"><span class="comment">//                     "lastRet=" + lastRet + " " +</span></span><br><span class="line"><span class="comment">//                     "nextItem=" + nextItem + " " +</span></span><br><span class="line"><span class="comment">//                     "lastItem=" + lastItem + " " +</span></span><br><span class="line"><span class="comment">//                     "prevCycles=" + prevCycles + " " +</span></span><br><span class="line"><span class="comment">//                     "prevTakeIndex=" + prevTakeIndex + " " +</span></span><br><span class="line"><span class="comment">//                     "size()=" + size() + " " +</span></span><br><span class="line"><span class="comment">//                     "remainingCapacity()=" + remainingCapacity());</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入detach模式的关键有3种情况：</p><ol><li>cursor == putIndex，这时候 cursor = NONE</li><li>空队列</li><li>cycle - preCycles &gt; 1</li></ol><h2 id="常用操作源码分析"><a href="#常用操作源码分析" class="headerlink" title="常用操作源码分析"></a>常用操作源码分析</h2><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用抽象队列的 add 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素 e 插入队列尾部，不感知中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e); <span class="comment">// 检查元素 e 是否为空</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 加锁，不感知中断</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="comment">// 队列满了，返回 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 入队，返回 true</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素 e 插入队列尾部，如果队列慢了则一直等待，感知中断。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e); <span class="comment">// 检查元素 e 是否为空</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 加锁，感知中断</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">// 队列满了，等待</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// put(E e) 超时版本，如果入队成功，则返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 加锁，感知中断</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// notFull 的超时等待</span></span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历并移除队列头部元素，不感知中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 出队：队列为空则返回 null。</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历并移除队列头部元素，感知中断。如果队列为空则一直等待。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 加锁，感知中断</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 队列为空，等待</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 出队：遍历并移除队列头部元素，并返回头部元素</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take() 的超时版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// notEmpty 的超时等待</span></span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出队：遍历并移除队列头部元素，并返回头部元素</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组中下标索引 takeIndex 对应的元素，不进行弹出。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// 队列为空返回 null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队列中移除元素，不感知中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列非空</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                    <span class="comment">// takeIndex 对应的元素和 o 一致则移除 takeIndex 对应的元素，返回 true</span></span><br><span class="line">                    removeAt(i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    <span class="comment">// ++i 和数组长度相等，i 从 0 开始计</span></span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex); <span class="comment">// i == putIndex 则终止循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = count;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                items[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">            takeIndex = putIndex;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。</span></span><br><span class="line">                itrs.queueIsEmpty();</span><br><span class="line">            <span class="comment">// 查询是否有因为给定条件 notFull 正在等待的线程</span></span><br><span class="line">            <span class="keyword">for</span> (; k &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); k--)</span><br><span class="line">                <span class="comment">// 唤醒因为给定条件 notFull 正在等待的线程</span></span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueIsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="keyword">for</span> (Node p = head; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">        Itr it = p.get();</span><br><span class="line">        <span class="keyword">if</span> (it != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.clear();</span><br><span class="line">            it.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head = <span class="keyword">null</span>;</span><br><span class="line">    itrs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转数组"><a href="#转数组" class="headerlink" title="转数组"></a>转数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将队列转成 Object 数组</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] a;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="keyword">this</span>.count;</span><br><span class="line">        a = <span class="keyword">new</span> Object[count];</span><br><span class="line">        <span class="keyword">int</span> n = items.length - takeIndex;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= n) <span class="comment">// putIndex 大于等于 takeIndex</span></span><br><span class="line">            System.arraycopy(items, takeIndex, a, <span class="number">0</span>, count);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// putIndex 小于 takeIndex</span></span><br><span class="line">            System.arraycopy(items, takeIndex, a, <span class="number">0</span>, n);</span><br><span class="line">            System.arraycopy(items, <span class="number">0</span>, a, n, count - n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列转成泛型数组</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; count)</span><br><span class="line">            <span class="comment">// 泛型数组 a 长度不够，重新创建一个长度为 count 的数组</span></span><br><span class="line">            <span class="comment">// 注意：泛型数组不能通过 T[] a = new T[count] 方式进行创建，只能通过反射进行创建</span></span><br><span class="line">            a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                a.getClass().getComponentType(), count);</span><br><span class="line">        <span class="keyword">int</span> n = items.length - takeIndex;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= n) <span class="comment">// putIndex 大于等于 takeIndex</span></span><br><span class="line">            System.arraycopy(items, takeIndex, a, <span class="number">0</span>, count);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// putIndex 小于 takeIndex</span></span><br><span class="line">            System.arraycopy(items, takeIndex, a, <span class="number">0</span>, n);</span><br><span class="line">            System.arraycopy(items, <span class="number">0</span>, a, n, count - n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; count) <span class="comment">// 泛型数组 a 长度大于阻塞队列元素个数， 则第 count 位清空</span></span><br><span class="line">            a[count] = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取阻塞队列元素数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取阻塞队列剩余容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.length - count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断阻塞队列是否包含元素 o</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">// 处理类似 remove 方法</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(items[i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString 方法，结果类似 [e1.toString(), e2.toString()……]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = count;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = takeIndex; ; ) &#123;</span><br><span class="line">            Object e = items[i];</span><br><span class="line">            sb.append(e == <span class="keyword">this</span> ? <span class="string">"(this Collection)"</span> : e);</span><br><span class="line">            <span class="keyword">if</span> (--k == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> sb.append(<span class="string">']'</span>).toString();</span><br><span class="line">            sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">            <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><h3 id="将队列元素添加到集合"><a href="#将队列元素添加到集合" class="headerlink" title="将队列元素添加到集合"></a>将队列元素添加到集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将队列元素添加到集合 c，最大数量为 Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> drainTo(c, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列元素添加到集合 c，最大数量为 maxElements</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">    checkNotNull(c); <span class="comment">// 检查集合是否非null</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>) <span class="comment">// c 是当前队列本身</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 取 maxElements 和队列元素数量最小值</span></span><br><span class="line">        <span class="keyword">int</span> n = Math.min(maxElements, count);</span><br><span class="line">        <span class="keyword">int</span> take = takeIndex;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">// 从队列中循环取出元素并加入集合 c 中</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                E x = (E) items[take];</span><br><span class="line">                c.add(x);</span><br><span class="line">                items[take] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (++take == items.length)</span><br><span class="line">                    take = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 恢复不变量，即使调用 c.add() 抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count -= i; <span class="comment">// 移除并成功添加到集合后，队列剩余元素数量</span></span><br><span class="line">                takeIndex = take; <span class="comment">// 更新 takeIndex</span></span><br><span class="line">                <span class="keyword">if</span> (itrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                        <span class="comment">// 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。</span></span><br><span class="line">                        itrs.queueIsEmpty();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; take) <span class="comment">// 移除并成功添加到集合的元素个数大于 take</span></span><br><span class="line">                        <span class="comment">// 每当 takeIndex 为0时调用。通知所有迭代器，并删除任何已过时的迭代器。</span></span><br><span class="line">                        itrs.takeIndexWrapped(); <span class="comment">// 参考内部类 Itrs 的 takeIndexWrapped 实现</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 查询是否有因为给定条件 notFull 正在等待的线程</span></span><br><span class="line">                <span class="keyword">for</span> (; i &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); i--)</span><br><span class="line">                    <span class="comment">// 唤醒因为给定条件 notFull 正在等待的线程</span></span><br><span class="line">                    notFull.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队与入队"><a href="#出队与入队" class="headerlink" title="出队与入队"></a>出队与入队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 唤醒因为给定条件 notEmpty 正在等待的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 唤醒因为给定条件 notFull 正在等待的线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elementDequeued</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。</span></span><br><span class="line">        queueIsEmpty();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (takeIndex == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 通知所有迭代器，并删除任何已过时的迭代器。</span></span><br><span class="line">        takeIndexWrapped();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分割迭代器"><a href="#分割迭代器" class="headerlink" title="分割迭代器"></a>分割迭代器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk8新增，可用来并行遍历元素的一个迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有序、非空、线程安全</span></span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator</span><br><span class="line">        (<span class="keyword">this</span>, Spliterator.ORDERED | Spliterator.NONNULL |</span><br><span class="line">         Spliterator.CONCURRENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ArrayBlockingQueue</code> 采用数组实现的有界阻塞线程安全队列，是规定大小的 <code>BlockingQueue</code>，其构造必须指定大小。其所含的对象是 FIFO 顺序排序的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt; 是采用数组实现的有界阻塞线程安全队列。如果向已满的队列继续塞入元素，将导致当
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ArrayBlockingQueue" scheme="https://muhouer.github.io/tags/ArrayBlockingQueue/"/>
    
  </entry>
  
  <entry>
    <title>StampedLock</title>
    <link href="https://muhouer.github.io/posts/ab957bc5/"/>
    <id>https://muhouer.github.io/posts/ab957bc5/</id>
    <published>2019-09-16T13:04:00.000Z</published>
    <updated>2019-09-16T13:12:44.665Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>读写锁如果使用不当，容易出现“饥饿”问题，比如在读线程非常多，写线程非常少的情况下，很容易导致写线程“饥饿”。虽然公平策略在一定程度上可以缓解这个问题，但是鱼与熊掌不可兼得，公平策略是以牺牲系统吞吐量为代价的。</p><p>于是<code>StampedLock</code> 类应运而生，在 JDK1.8 时引入，是对读写锁 <code>ReentrantReadWriteLock</code> 的增强，该类提供了一些功能，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，可以更细粒度控制并发。</p><p>不过该类的设计初衷是作为一个内部工具类，用于辅助开发其它线程安全组件。用得好，该类可以提升系统性能，用不好，容易产生死锁和其它莫名其妙的问题。</p><h2 id="StampedLock-类结构"><a href="#StampedLock-类结构" class="headerlink" title="StampedLock 类结构"></a>StampedLock 类结构</h2><p><code>StampedLock</code> 类结构如下：</p><img src="/images/StampedLock.png" width="800px" height="500px" align="center"><p><code>StampedLock</code> 的内部类包括四个，分别为 <code>WriteLockView</code>、<code>ReadLockView</code>、<code>ReadWriteLockView</code> 以及 <code>WNode</code>。</p><h3 id="StampedLock-底层实现"><a href="#StampedLock-底层实现" class="headerlink" title="StampedLock 底层实现"></a>StampedLock 底层实现</h3><p><code>StampedLock</code> 虽然不像其它锁一样定义了内部类来实现 AQS 框架，但是 <code>StampedLock</code> 的基本实现思路还是利用 CLH 队列进行线程的管理，通过同步状态值来表示锁的状态和类型。</p><p><code>StampedLock</code> 把读分为了悲观读和乐观读，悲观读就等价于 <code>ReadWriteLock</code> 的读，而乐观读在一个线程写共享变量时，不会被阻塞，乐观读是不加锁的。</p><p><code>StampedLock</code> 内部定义了很多常量，定义这些常量的根本目的和 <code>ReentrantReadWriteLock</code> 一样，对同步状态值按位切分，以通过位运算对State进行操作</p><blockquote><p>对于 StampedLock 来说，写锁被占用的标志是第8位为1，读锁使用0-7位，正常情况下读锁数目为1-126，超过126时，使用一个名为的 readerOverflow int整型保存超出数。</p></blockquote><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLock</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6001602636862214147L</span>;</span><br><span class="line">    <span class="comment">/** CPU 核数，用于控制自旋次数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">/** 尝试获取锁失败次数超过该值，则将其加入等待队列 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">6</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 等待队列首节点自旋获取锁失败次数超过该值，会继续阻塞 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">10</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 等待队列首节点再次阻塞之前的最大尝试次数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">16</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 等待自旋锁溢出时的 yield 周期 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OVERFLOW_YIELD_RATE = <span class="number">7</span>; <span class="comment">// must be power 2 - 1</span></span><br><span class="line">    <span class="comment">/** 在读锁数量溢出之前的 bit 位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LG_READERS = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁状态和标记操作的位常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RUNIT = <span class="number">1L</span>; <span class="comment">// 一单位读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WBIT  = <span class="number">1L</span> &lt;&lt; LG_READERS; <span class="comment">// 写状态标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RBITS = WBIT - <span class="number">1L</span>; <span class="comment">// 读状态标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RFULL = RBITS - <span class="number">1L</span>; <span class="comment">// 读锁的最大数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABITS = RBITS | WBIT; <span class="comment">// 用于获取读写状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SBITS = ~RBITS; <span class="comment">// note overlap with ABITS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁状态初始值，避免初始化为失败值 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ORIGIN = WBIT &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消获取方法返回的特殊值，以便调用方可以抛出 InterruptedException</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> INTERRUPTED = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点状态值，和顺序有关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITING   = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的模式，使用 int 而不是 boolean，方便计算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RMODE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WMODE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait nodes */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> WNode prev;</span><br><span class="line">        <span class="keyword">volatile</span> WNode next;</span><br><span class="line">        <span class="keyword">volatile</span> WNode cowait;    <span class="comment">// list of linked readers</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;   <span class="comment">// non-null while possibly parked</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> status;      <span class="comment">// 0, WAITING, or CANCELLED</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode;           <span class="comment">// RMODE or WMODE</span></span><br><span class="line">        WNode(<span class="keyword">int</span> m, WNode p) &#123; mode = m; prev = p; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** CLH 队列的头节点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode whead;</span><br><span class="line">    <span class="comment">/** CLH 队列的尾节点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode wtail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视图</span></span><br><span class="line">    <span class="keyword">transient</span> ReadLockView readLockView;</span><br><span class="line">    <span class="keyword">transient</span> WriteLockView writeLockView;</span><br><span class="line">    <span class="keyword">transient</span> ReadWriteLockView readWriteLockView;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 锁状态 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line">    <span class="comment">/** 读锁饱和时的额外读锁计数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> readerOverflow;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 StampedLock，初始是 unlocked 状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StampedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state = ORIGIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种锁视图"><a href="#三种锁视图" class="headerlink" title="三种锁视图"></a>三种锁视图</h3><p>三种锁视图分别为读锁视图、写锁视图、读写锁(悲观读)视图。这些视图其实是对 <code>StamedLock</code> 方法的封装，便于习惯了 <code>ReentrantReadWriteLock</code> 的用户使用。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读锁视图</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLockView</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非独占获取锁，如果需要会阻塞到可用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; readLock(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        readLockInterruptibly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> tryReadLock() != <span class="number">0L</span>; &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁，带超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryReadLock(time, unit) != <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无标识释放锁 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; unstampedUnlockRead(); &#125;</span><br><span class="line">    <span class="comment">// 不支持 Condition</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写锁视图</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLockView</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; writeLock(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        writeLockInterruptibly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> tryWriteLock() != <span class="number">0L</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryWriteLock(time, unit) != <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; unstampedUnlockWrite(); &#125;</span><br><span class="line">    <span class="comment">// 不支持 Condition</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读写锁(悲观读)视图</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockView</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lock <span class="title">readLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> asReadLock(); &#125;</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> asWriteLock(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReadWriteLock</code> 方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lock <span class="title">asReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReadLockView v;</span><br><span class="line">    <span class="keyword">return</span> ((v = readLockView) != <span class="keyword">null</span> ? v :</span><br><span class="line">            (readLockView = <span class="keyword">new</span> ReadLockView()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回写锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lock <span class="title">asWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WriteLockView v;</span><br><span class="line">    <span class="keyword">return</span> ((v = writeLockView) != <span class="keyword">null</span> ? v :</span><br><span class="line">            (writeLockView = <span class="keyword">new</span> WriteLockView()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>在使用 <code>StampedLock</code> 的时候，建议这样操作：<strong>乐观读时，如果有写操作修改了共享变量则升级乐观读为悲观读锁</strong>，因为这样可用避免乐观读反复的循环等待写锁的释放，造成 CPU 资源的浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// an exclusively locked method</span></span><br><span class="line">    <span class="keyword">long</span> stamp = sl.writeLock();  <span class="comment">//获取写锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      x += deltaX;</span><br><span class="line">      y += deltaY;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      sl.unlockWrite(stamp); <span class="comment">//释放写锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">    <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//乐观读</span></span><br><span class="line">    <span class="keyword">double</span> currentX = x, currentY = y;</span><br><span class="line">    <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">//判断共享变量是否已经被其他线程写过</span></span><br><span class="line">       stamp = sl.readLock();  <span class="comment">//如果被写过则升级为悲观读锁</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         currentX = x;</span><br><span class="line">         currentY = y;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          sl.unlockRead(stamp); <span class="comment">//释放悲观读锁</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">    <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">    <span class="keyword">long</span> stamp = sl.readLock(); <span class="comment">//获取读锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);  <span class="comment">//升级为写锁</span></span><br><span class="line">        <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">          stamp = ws;</span><br><span class="line">          x = newX;</span><br><span class="line">          y = newY;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          sl.unlockRead(stamp);</span><br><span class="line">          stamp = sl.writeLock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      sl.unlock(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StampedLock-获取锁和释放锁的实现"><a href="#StampedLock-获取锁和释放锁的实现" class="headerlink" title="StampedLock 获取锁和释放锁的实现"></a>StampedLock 获取锁和释放锁的实现</h2><p><code>StampedLock</code> 在获取锁和乐观读时，都会返回一个 stamp，解锁时需要传入这个 stamp，在乐观读时是用来验证共享变量是否被其他线程写过。</p><p><code>StampedLock</code> 中，等待队列的结点要比AQS中简单些，仅仅三种状态。</p><ol><li>初始状态</li><li>等待中</li><li>取消</li></ol><h3 id="获取写锁"><a href="#获取写锁" class="headerlink" title="获取写锁"></a>获取写锁</h3><p>写锁(独占锁)，如果获取失败则进入阻塞队列，不响应中断。返回非 0 代表成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, next;  <span class="comment">// bypass acquireWrite in fully unlocked case only</span></span><br><span class="line">    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT)) ?</span><br><span class="line">            next : acquireWrite(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(s = state) &amp; ABITS) == 0L</code> 为 true 代表读锁与写锁均未被使用，<code>compareAndSwapLong</code> 表示通过 CAS 更新同步状态值 state。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, next;</span><br><span class="line">    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT)) ?</span><br><span class="line">            next : <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryWriteLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">long</span> next, deadline;</span><br><span class="line">        <span class="keyword">if</span> ((next = tryWriteLock()) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">if</span> ((deadline = System.nanoTime() + nanos) == <span class="number">0L</span>)</span><br><span class="line">            deadline = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">if</span> ((next = acquireWrite(<span class="keyword">true</span>, deadline)) != INTERRUPTED)</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">writeLockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> next;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted() &amp;&amp;</span><br><span class="line">        (next = acquireWrite(<span class="keyword">true</span>, <span class="number">0L</span>)) != INTERRUPTED)</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取悲观读锁"><a href="#获取悲观读锁" class="headerlink" title="获取悲观读锁"></a>获取悲观读锁</h3><p>悲观读锁(非独占锁)，为获得锁一直处于阻塞状态，直到获得锁为止，不响应中断。返回非 0 代表成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s = state, next;  <span class="comment">// bypass acquireRead on common uncontended case</span></span><br><span class="line">    <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT)) ?</span><br><span class="line">            next : acquireRead(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>whead == wtail</code> 代表队列为空 ，<code>s &amp; ABITS) &lt; RFULL</code> 没有写锁且读锁数小于 126 。<code>compareAndSwapLong</code> 表示通过 CAS 更新同步状态值 state。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> s, m, next;</span><br><span class="line">        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) == WBIT)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((next = tryIncReaderOverflow(s)) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryReadLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, m, next, deadline;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) != WBIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT))</span><br><span class="line">                    <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((next = tryIncReaderOverflow(s)) != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">if</span> ((deadline = System.nanoTime() + nanos) == <span class="number">0L</span>)</span><br><span class="line">            deadline = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">if</span> ((next = acquireRead(<span class="keyword">true</span>, deadline)) != INTERRUPTED)</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> next;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted() &amp;&amp;</span><br><span class="line">        (next = acquireRead(<span class="keyword">true</span>, <span class="number">0L</span>)) != INTERRUPTED)</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取乐观读锁"><a href="#获取乐观读锁" class="headerlink" title="获取乐观读锁"></a>获取乐观读锁</h3><p>相对于悲观读锁来说的，在操作数据前并没有通过 CAS 设置锁的状态，仅仅是通过位运算测试。如果当前没有线程持有写锁，则简单的返回一个非 0 的 stamp 版本信息。由于 <code>tryOptimisticRead</code> 并没有使用 CAS 设置锁状态，所以不需要显示的释放该锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryOptimisticRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s;</span><br><span class="line">    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取该 stamp 后在具体操作数据前还需要调用 <code>validate</code> 验证下该 stamp 是否已经不可用，也就是看当调用 <code>tryOptimisticRead</code> 返回 stamp 后，到当前时间是否有其它线程持有了写锁。如果是那么 <code>validate</code> 会返回 0，否者就可以使用该 stamp 版本的锁对数据进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean validate(long stamp) &#123;</span><br><span class="line">    U.loadFence();</span><br><span class="line">    return (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用乐观读锁还是很容易犯错误的，必须要严谨。需要遵循相应的调用模板(判断共享变量是否已经被其他线程写过，如果被写过则升级为悲观读锁)，防止出现数据不一致的问题。</strong></p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>锁释放需要锁状态和 stamp 匹配，才能释放对应的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果锁状态和 stamp 匹配，则释放写锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    WNode h;</span><br><span class="line">    <span class="keyword">if</span> (state != stamp || (stamp &amp; WBIT) == <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    state = (stamp += WBIT) == <span class="number">0L</span> ? ORIGIN : stamp;</span><br><span class="line">    <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">        release(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果锁状态和 stamp 匹配，则释放读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, m; WNode h;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((s = state) &amp; SBITS) != (stamp &amp; SBITS) ||</span><br><span class="line">            (stamp &amp; ABITS) == <span class="number">0L</span> || (m = s &amp; ABITS) == <span class="number">0L</span> || m == WBIT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                    release(h);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果锁状态和 stamp 匹配，则释放相关模式的锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = stamp &amp; ABITS, m, s; WNode h;</span><br><span class="line">    <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            state = (s += WBIT) == <span class="number">0L</span> ? ORIGIN : s;</span><br><span class="line">            <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                release(h);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0L</span> || a &gt;= WBIT)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                    release(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放读锁、写锁的 “try” 版本，即“一次性”版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryUnlockWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> s; WNode h;</span><br><span class="line">     <span class="keyword">if</span> (((s = state) &amp; WBIT) != <span class="number">0L</span>) &#123;</span><br><span class="line">         state = (s += WBIT) == <span class="number">0L</span> ? ORIGIN : s;</span><br><span class="line">         <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">             release(h);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryUnlockRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> s, m; WNode h;</span><br><span class="line">     <span class="keyword">while</span> ((m = (s = state) &amp; ABITS) != <span class="number">0L</span> &amp;&amp; m &lt; WBIT) &#123;</span><br><span class="line">         <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">             <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                     release(h);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="锁转换"><a href="#锁转换" class="headerlink" title="锁转换"></a>锁转换</h3><p><code>StampedLock</code> 读写锁之间可以互相转换，可以更细粒度控制并发。包括三种转换：</p><ol><li>转换成写锁</li><li>转换成悲观读锁</li><li>转换成乐观读锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试转换成写锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryConvertToWriteLock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = stamp &amp; ABITS, m, s, next;</span><br><span class="line">    <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">return</span> stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == RUNIT &amp;&amp; a != <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                     next = s - RUNIT + WBIT))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试转换成悲观读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryConvertToReadLock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = stamp &amp; ABITS, m, s, next; WNode h;</span><br><span class="line">    <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT))</span><br><span class="line">                    <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((next = tryIncReaderOverflow(s)) != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            state = next = s + (WBIT + RUNIT);</span><br><span class="line">            <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                release(h);</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a != <span class="number">0L</span> &amp;&amp; a &lt; WBIT)</span><br><span class="line">            <span class="keyword">return</span> stamp;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试转换成乐观读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryConvertToOptimisticRead</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = stamp &amp; ABITS, m, s, next; WNode h;</span><br><span class="line">    U.loadFence();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((s = state) &amp; SBITS) != (stamp &amp; SBITS))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            state = next = (s += WBIT) == <span class="number">0L</span> ? ORIGIN : s;</span><br><span class="line">            <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                release(h);</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0L</span> || a &gt;= WBIT)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s - RUNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                    release(h);</span><br><span class="line">                <span class="keyword">return</span> next &amp; SBITS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((next = tryDecReaderOverflow(s)) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> next &amp; SBITS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>和 <code>ReadWritLock</code>相比，在一个线程情况下，是读速度其4倍左右，写是1倍。</p><img src="/images/StampedLock1.png" width="800px" height="500px" align="center"><p>和 <code>ReadWritLock</code>相比，六个线程情况下，读性能是其几十倍，写性能也是近10倍左右。</p><img src="/images/StampedLock2.png" width="800px" height="500px" align="center"><p>和 <code>ReadWritLock</code>相比，吞吐量提高</p><img src="/images/StampedLock3.png" width="800px" height="500px" align="center"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>StampedLock</code> 提供的读写锁与 <code>ReentrantReadWriteLock</code> 类似，前者不支持重入，不支持条件变量，也就是没 <code>Condition</code>。不过前者通过提供乐观读锁在多线程多读的情况下能提供更好的性能，这是因为获取乐观读锁时候不需要进行 CAS 操作设置锁的状态，而只是简单的测试状态。</p><p><strong><code>writeLock()</code> 或者 <code>readLock()</code> 获得锁之后，线程还没执行完就被 <code>interrupt()</code> 的话，会导致 CPU 飙升。</strong></p><p>另外，<code>StampedLock</code> 使用时要特别小心，避免锁重入的操作，在使用乐观读锁时也需要遵循相应的调用模板，防止出现数据不一致的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;读写锁如果使用不当，
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="StampedLock" scheme="https://muhouer.github.io/tags/StampedLock/"/>
    
  </entry>
  
  <entry>
    <title>AtomicInteger解析</title>
    <link href="https://muhouer.github.io/posts/4f6208ca/"/>
    <id>https://muhouer.github.io/posts/4f6208ca/</id>
    <published>2019-09-15T14:29:00.000Z</published>
    <updated>2019-09-15T14:30:52.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文代码基于 JDK 8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>AtomicInteger</code> 是 <code>Integer</code> 类型的线程安全原子类，可以在应用程序中以原子方式更新 int 值，是 atomic 框架中经常使用的原子类。</p><h2 id="AtomicInteger-使用示例"><a href="#AtomicInteger-使用示例" class="headerlink" title="AtomicInteger 使用示例"></a>AtomicInteger 使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger atomicRace = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    atomicRace.incrementAndGet();</span><br><span class="line">    race++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">      threads[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10000</span>; i1++) &#123;</span><br><span class="line">          increase();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">      threads[i].join();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"atomic race: "</span> + atomicRace);</span><br><span class="line">    System.out.println(<span class="string">"       race: "</span> + race);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atomic race: 200000</span><br><span class="line">       race: 114084</span><br></pre></td></tr></table></figure><p>由于自增操作并不能保证原子性，所以并发情况下 race 的值每次不太一样，而使用 <code>AtomicInteger</code> 可以保证自增操作原子性，使得每次结果都是 200000。</p><h2 id="AtomicInteger-底层实现"><a href="#AtomicInteger-底层实现" class="headerlink" title="AtomicInteger 底层实现"></a>AtomicInteger 底层实现</h2><p><code>AtomicInteger</code> 继承 <code>Number</code>，底层是通过 <code>Unsafe</code> 类做 CAS 操作，来原子的更新状态值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line">    <span class="comment">// 使用 Unsafe.compareAndSwapInt 去更新状态值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AtomicIntegerd 的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 根据 initialValue 创建一个新的 AtomicInteger 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个新的 AtomicInteger</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicInteger-常用方法"><a href="#AtomicInteger-常用方法" class="headerlink" title="AtomicInteger 常用方法"></a>AtomicInteger 常用方法</h2><p><code>AtomicInteger</code> 常用方法包括原子的加、减等，类似 i++、++i、i–、–i 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 newValue 设置为当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将旧状态值设置为 newValue 并返回旧状态值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果expect值和当前值相等且原子的设置当前值为 update，则返回 true，否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值加一，返回之前的状态值，先取后增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值减一，返回之前的状态值，先取后减</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值加 delta，返回之前的状态值，先取后增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值减 delta，返回之前的状态值，先增后取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值减一，返回当前的状态值，先减后取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子的将当前状态值加 delta，返回当前的状态值，先增后取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicInteger-特殊方法"><a href="#AtomicInteger-特殊方法" class="headerlink" title="AtomicInteger 特殊方法"></a>AtomicInteger 特殊方法</h2><h3 id="lazySet-方法"><a href="#lazySet-方法" class="headerlink" title="lazySet 方法"></a>lazySet 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set() 方法的不可见版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// putOrderedInt 设置值并且马上写入主存，该变量必须是 volatile 类型</span></span><br><span class="line">    unsafe.putOrderedInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lazySet()</code>⽅法是 <code>set()</code> ⽅法的不可⻅版本。通过 <code>volatile</code> 修饰的变量，可以保证在多处理器环境下的<strong>可⻅性</strong>，即当⼀个线程修改⼀个共 享变量时，其它线程能⽴即读到这个修改的值。</p><p><code>volatile</code> 的实现加了内存屏障：</p><ol><li>保证写 <code>volatile</code> 变量时会强制把 CPU 写缓存区的数据刷新到内存。</li><li>读 <code>volatile</code> 变量时，使缓存失效，强制从内存中读取最新的值。</li><li>由于内存屏障的存在，volatile变量还能阻⽌重排序。</li></ol><p><code>lazySet</code> 内部调⽤了 Unsafe 类的 <code>putOrderedInt</code> ⽅法，通过该⽅法对共享变量值的改变，不⼀定能被其他线 程⽴即看到。也就是说以普通变量的操作⽅式来写变量。</p><p>什么情况下需要使⽤ <code>lazySet</code> 呢？ 考虑下⾯这样⼀个场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ai.set(1);</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于锁的存在：</p><ul><li><code>lock()</code> ⽅法获取锁时，和 <code>volatile</code> 变量的读操作⼀样，会强制使 CPU 缓存失效，强制从内存读取变量。</li><li><code>unlock()</code> ⽅法释放锁时，和 <code>volatile</code> 变量的写操作⼀样，会强制刷新 CPU 写缓冲区，把缓存数据写到主内存。</li></ul><p>所以，上述 <code>ai.set(1)</code>可以⽤ <code>ai.lazySet(1)</code> ⽅法替换： <strong>由锁来保证共享变量的可⻅性，以设置普通变量的⽅式来修改共享变量，减少不必要的内存屏障，从⽽提⾼ 程序执⾏的效率。</strong></p><h3 id="weakCompareAndSet-方法"><a href="#weakCompareAndSet-方法" class="headerlink" title="weakCompareAndSet 方法"></a>weakCompareAndSet 方法</h3><p><code>weakCompareAndSet</code> 操作仅保留了 <code>volatile</code>自身变量的特性，而去除了 <strong>happens-before</strong> 规则带来的内存语义。也就是说，<code>weakCompareAndSet</code> 无法保证处理操作目标的 <code>volatile</code> 变量外的其他变量的执行顺序( 编译器和处理器为了优化程序性能而对指令序列进行重新排序 )，同时也无法保证这些变量的可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JDK 8 及之前的版本，<code>weakCompareAndSet</code> 方法并没有被真正意义上的实现，目前该方法所呈现出来的效果与 <code>compareAndSet</code> 方法是一样的。</p><p>在 JDK 9 中 <code>compareAndSet</code> 和 <code>weakCompareAndSet</code> 方法的实现有些许的不同</p><ol><li>底层调用的 native 方法的实现中，<code>cmpxchgb</code> 指令前都会有“<code>lock</code>”前缀，而在 JDK 8 中，程序会根据当前处理器的类型来决定是否为 <code>cmpxchg</code> 指令添加 <code>lock</code> 前缀，只有在 CPU 是多处理器(multi processors)的时候，会添加一个 <code>lock</code> 前缀)。</li><li>新增 <code>@HotSpotIntrinsicCandidate</code> 注解，该注解是特定于 Java 虚拟机的注解。通过该注解表示的方法可能( 但不保证 )通过 HotSpot VM 自己来写汇编或IR编译器来实现该方法以提供性能。</li></ol><h2 id="AtomicInteger-新增方法"><a href="#AtomicInteger-新增方法" class="headerlink" title="AtomicInteger 新增方法"></a>AtomicInteger 新增方法</h2><p>在 JDK 8 中，<code>AtomicInteger</code> 新增了一些方法，使用 JDK 8 的函数式接口。不过这些函数应该是无副作用的，因为当尝试的更新时，如果由于线程争用更新失败，可能会重新应用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子的将给定函数的结果更新当前值，并返回旧值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        <span class="comment">// 将此运算符 applyAsInt 应用于给定的操作数 prev</span></span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子的将函数的结果更新当前值，并返回新值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子的将函数的结果和 x 的计算结果更新当前值，并返回新值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAccumulate</span><span class="params">(<span class="keyword">int</span> x, IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子地根据给定函数的结果和 x 的计算结果更新当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">accumulateAndGet</span><span class="params">(<span class="keyword">int</span> x, IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        <span class="comment">// 将此运算符 applyAsInt 应用于给定的操作数 prev</span></span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicInteger-溢出问题"><a href="#AtomicInteger-溢出问题" class="headerlink" title="AtomicInteger 溢出问题"></a>AtomicInteger 溢出问题</h2><p>使用了 <code>AtomicInteger</code> 的 <code>incrementAndGet</code> 方法不断的增加，如果 <code>AtomicInteger</code> 增加到了2147483647 (即) 再加一，<code>AtomicInteger</code> 的值会变成负数 -2147483648。如果不对其作出处理，当资源数目不断累积超过最大值变成负数的时候。</p><p>比如可以在 <code>AtomicInteger</code> 变量达到最大值的时候，转为零重新开始计数，并保证 <code>AtomicInteger</code> 在多线程环境下的原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> current;</span><br><span class="line">  <span class="keyword">int</span> next;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    current = <span class="keyword">this</span>.i.get();</span><br><span class="line">    next = current &gt;= Integer.MAX_VALUE ? <span class="number">0</span> : current + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!<span class="keyword">this</span>.i.compareAndSet(current, next));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> current;</span><br><span class="line">  <span class="keyword">int</span> next;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    current = <span class="keyword">this</span>.i.get();</span><br><span class="line">    next = current &lt;= <span class="number">0</span> ? Integer.MAX_VALUE : current - <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!<span class="keyword">this</span>.i.compareAndSet(current, next));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>AtomicInteger</code> <strong>使用非阻塞算法实现并发控制</strong>，在一些高并发程序中非常适合，但并不代表每一种场景都适合，不同场景要使用使用不同的数值类。比如 <code>AtomicBoolean</code>、<code>AtomicLong</code> 等。</p><p><code>AtomicIntegerArray</code> 或 <code>AtomicLongArray</code> 操作类似，不过它们对应的数组，操作的是数组中的某个元素，通过索引对值进行操作。</p><h2 id="其他-Atomic-类"><a href="#其他-Atomic-类" class="headerlink" title="其他 Atomic 类"></a>其他 Atomic 类</h2><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><p>可以原子更新的对象引用。和 <code>AtomicInteger</code> 类似，少了一些数字类型的“加”、”减”操作，支持泛型，具体含义和方法名息息相关，具体实现和 <code>AtomicInteger</code> 也类似。<code>AtomicReferenceArray</code> 则和 <code>AtomicIntegerArray</code> 类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1848883965231344442L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 initialValue 创建一个 AtomicReference 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">(V initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicReference with null initial value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 创建一个空 AtomicReference 对象，value 为 null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(V expect, V update)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndUpdate</span><span class="params">(UnaryOperator&lt;V&gt; updateFunction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">updateAndGet</span><span class="params">(UnaryOperator&lt;V&gt; updateFunction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndAccumulate</span><span class="params">(V x, BinaryOperator&lt;V&gt; accumulatorFunction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">accumulateAndGet</span><span class="params">(V x, BinaryOperator&lt;V&gt; accumulatorFunction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h3><p>基于反射的实用工具，可以对指定类的指定 volatile int 字段进行原子更新。此类用于原子数据结构，该结构中同一节点的几个字段都独立受原子更新控制。此类中 <code>compareAndSet</code>方法的保证弱于其他原子类中该方法的保证。因为此类不能确保所有使用的字段都适合于原子访问目的，所以对于相同更新器上的 <code>compareAndSet</code> 和 <code>set</code> 的其他调用，它仅可以保证原子性和可变语义。</p><p>有如下限制：</p><ol><li>操作的 int 字段必须是基本类型数据，用volatile修饰，不能是包装类型，int、long就可以，但是不可以是Integer和Long；</li><li>必须是实例变量，不可以是类变量；</li><li>必须是可变的变量，不能是final修饰的变量。</li></ol><p>示例如下：</p><p>定义一个 Person 类，有一个 id 字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 id 字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指定 Person 对象和 id 字段</span></span><br><span class="line">  AtomicIntegerFieldUpdater&lt;Person&gt; personAtomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Person.class, <span class="string">"id"</span>);</span><br><span class="line">  Person person = <span class="keyword">new</span> Person(<span class="number">99999</span>);</span><br><span class="line">  personAtomicIntegerFieldUpdater.compareAndSet(person, <span class="number">99999</span>, <span class="number">99999</span>);</span><br><span class="line">  System.out.println(<span class="string">"id="</span> + person.getId());</span><br><span class="line">  Person person1 = <span class="keyword">new</span> Person(<span class="number">99999</span>);</span><br><span class="line">  personAtomicIntegerFieldUpdater.incrementAndGet(person1);</span><br><span class="line">  System.out.println(<span class="string">"id="</span> + person1.getId());</span><br><span class="line">  IntBinaryOperator intBinaryOperator = (left, right) -&gt; left+right;</span><br><span class="line">  personAtomicIntegerFieldUpdater.getAndAccumulate(person1, <span class="number">1</span>, intBinaryOperator);</span><br><span class="line">  System.out.println(<span class="string">"id="</span> + person1.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从示例来看，具体操作和 <code>AtomicInteger</code> 操作起来其实和是一样的。只不过操作之前需要指定对哪个对象的哪个字段进行操作。</p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p>在运用 CAS 做锁释放操作中有一个经典的 ABA问题：</p><blockquote><p>在线程1准备用 CAS 将变量的值由A替换为B之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行 CAS 时发现变量的值仍然为A，所以 CAS 成功。但实际上这时的现场已经和最初不同了，尽管 CAS 成功，但可能存在潜藏的问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 内部 Pair 类，一个[reference, stamp]元组 。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="comment">// 版本戳</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据初始 initialRef 和 initialStamp 创建一个 AtomicStampedReference 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;</span><br><span class="line">        pair = Pair.of(initialRef, initialStamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各种乐观锁的实现中通常都会用版本戳 version 来对记录或对象标记，避免并发操作带来的问题，在 Java 中，<code>AtomicStampedReference&lt;V&gt;</code>也实现了这个作用，它通过包装 [E,Integer] 的元组来对对象标记版本戳 stamp，从而避免 ABA 问题。</p><p><code>AtomicMarkableReference</code> 与 <code>AtomicStampedReference</code> ，不过前者版本戳 <code>final int stamp</code> 变成了 <code>final boolean mark</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;本文代码基于 JDK 8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Ato
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="AtomicInteger" scheme="https://muhouer.github.io/tags/AtomicInteger/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal分析</title>
    <link href="https://muhouer.github.io/posts/90bf09a1/"/>
    <id>https://muhouer.github.io/posts/90bf09a1/</id>
    <published>2019-09-13T19:11:00.000Z</published>
    <updated>2019-09-14T17:21:07.555Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ThreadLocal</code> 的官方API解释为：</p><blockquote><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p></blockquote><ol><li><p><code>ThreadLocal</code> 提供了一种访问某个变量的特殊方式：访问到的变量属于当前线程，即保证每个线程的变量不一样，而同一个线程在任何地方拿到的变量都是一致的，这就是所谓的线程隔离。</p></li><li><p>如果要使用 <code>ThreadLocal</code> ，通常定义为 <code>private static</code> 类型，最好是定义为 <code>private static final</code> 类型。</p></li></ol><p>即 <strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</strong></p><h2 id="ThreadLocal-类结构"><a href="#ThreadLocal-类结构" class="headerlink" title="ThreadLocal 类结构"></a>ThreadLocal 类结构</h2><p><code>ThreadLocal</code> 类结构如下：<br><img src="/images/ThreadLocal.png" width="800px" height="500px" align="center"></p><p><code>ThreadLocalMap</code>、<code>SuppliedThreadLocal</code> 是 <code>ThreadLocal</code> 内部类，且 <code>SuppliedThreadLocal</code> 继承自 <code>ThreadLocal</code>， <code>Entry</code> 是 <code>ThreadLocalMap</code> 内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 下一个哈希值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line">    <span class="comment">// 下一个要给出的哈希值，原子更新，从 0 开始。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">// 连续生成的散列码之间的差异：将隐式顺序线程局部id转换为近似最优分布的乘法散列值，以获得两个大小表的幂。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap-实现"><a href="#ThreadLocalMap-实现" class="headerlink" title="ThreadLocalMap 实现"></a>ThreadLocalMap 实现</h2><p><code>ThreadLocalMap</code> 是一个定制的散列映射，仅适用于维护线程本地值。该类是包私有的，允许在 <code>Thread</code> 类中声明字段。在 <code>ThreadLocal</code> 类之外不做任何操作。为了帮助处理占用内存大和存活时间长的用法，哈希表 <code>Entry</code> 使用弱引用作为键。但是，由于不使用引用队列，因此只有当表开始耗尽空间时，才保证删除过时的条目。</p><p><strong>每个线程可能有多个 <code>ThreadLocal</code>，同一线程的各个<code>ThreadLocal</code> 存放于同一个 <code>ThreadLocalMap</code> 中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** 和当前 ThreadLocal 有关 */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code> 具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 哈希表 Entry</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** 该值和当前 ThreadLocal 对象有关 */</span></span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哈希表初始容量，必须是 2 的指数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// Entry表，需要的时候会调整表大小，表大小一定是 2 的指数。</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="comment">// 表中 Entry 数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Entry表大小调整的阈值，默认是 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">    <span class="comment">// 设置阈值为表长度的 2/3</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取下一个 index，i+1&lt;len 则返回 i + 1，否则返回 0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取上一个 index，i - 1 &gt;= 0 则返回 i-1，否则返回 len-1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** ThreadLocalMap 构造函数 */</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">// 创建大小为 INITIAL_CAPACITY 的 Entry表</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="comment">// 根据 firstKey 的哈希值和初始容量获取元素 index</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置表的元素</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置表大小调整阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 根据 parentMap 构造 ThreadLocalMap */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line">                    Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                    <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 根据 key 获取 Entry */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        Entry e = table[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在其直接哈希槽中找不到密钥时使用的GetEntry方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">            e = tab[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** ThreadLocalMap set 方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> sz = ++size;</span><br><span class="line">        <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 从 ThreadLocalMap 中移除 key */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                e.clear();</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用指定 key 的项替换 set 操作期间遇到的过时项</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        Entry e;</span><br><span class="line">        <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = prevIndex(i, len))</span><br><span class="line">            <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line"></span><br><span class="line">                tab[i] = tab[staleSlot];</span><br><span class="line">                tab[staleSlot] = e;</span><br><span class="line">                <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">                <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">        <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过重新清除位于过时槽和下一个空槽之间的任何可能发生冲突的条目来删除过时的条目</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">        Entry e;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    tab[h] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 试探性地扫描一些单元格以查找过时的条目。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">            Entry e = tab[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                n = len;</span><br><span class="line">                removed = <span class="keyword">true</span>;</span><br><span class="line">                i = expungeStaleEntry(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 重新哈希 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        expungeStaleEntries();</span><br><span class="line">        <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">            resize();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 调整 Entry 表大小，大小变为原来的 2 倍 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">        Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">            Entry e = oldTab[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, newLen);</span><br><span class="line">                    newTab[h] = e;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setThreshold(newLen);</span><br><span class="line">        size = count;</span><br><span class="line">        table = newTab;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 删除表中所有过时的项 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = tab[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">                expungeStaleEntry(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SuppliedThreadLocal-实现"><a href="#SuppliedThreadLocal-实现" class="headerlink" title="SuppliedThreadLocal 实现"></a>SuppliedThreadLocal 实现</h2><p><code>SuppliedThreadLocal</code> 是 JDK8 新增的内部类，只是扩展了 <code>ThreadLocal</code> 的初始化值的方法而已，允许使用 JDK8 新增的 Lambda 表达式赋值。需要注意的是，函数式接口 <code>Supplier</code> 不允许为 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppliedThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Supplier容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class="line">    <span class="comment">// SuppliedThreadLocal 构造方法</span></span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">        <span class="comment">// supplier == null 会抛出空指针异常</span></span><br><span class="line">        <span class="keyword">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用get()方法，此时会调用对象的构造方法，即获得到真正对象</span></span><br><span class="line">        <span class="comment">// 每次get都会调用构造方法，即获取的对象不同</span></span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal-的基本方法"><a href="#ThreadLocal-的基本方法" class="headerlink" title="ThreadLocal 的基本方法"></a>ThreadLocal 的基本方法</h2><p><code>ThreadLocal</code> 的基本方法包括取值、设置初始值、赋值、移除等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 根据当前线程获取本地线程 Map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123; <span class="comment">// 本地线程Map不为空</span></span><br><span class="line">        <span class="comment">// 获取当前对象对应的本地线程 Map 的 Entry 对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// Entry 对象不为空</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置初始值后返回初始值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置初始值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 继承 ThreadLocal 后重写，参考 SuppliedThreadLocal</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 本地线程 Map 不存在则创建</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建本地线程 Map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前对象对应的本地线程 Map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 覆盖</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 本地线程 Map 不存在则创建</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建线程局部变量。变量的初始值是通过调用&#123;@code supplier&#125;上的&#123;@code get&#125;方法来确定的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>变量有局部的还有全局的，局部变量没什么好说的，一涉及到全局，那自然就会出现多线程的安全问题，要保证多线程安全访问，不出现脏读脏写，那就要涉及到线程同步了。而 <code>ThreadLocal</code> 相当于提供了介于局部变量与全局变量中间的这样一种线程内部的全局变量。</p><p>当我们只想在本身的线程内使用的变量，可以用 <code>ThreadLocal</code> 来实现，并且这些变量是和线程的生命周期密切相关的，线程结束，变量也就销毁了。 <code>ThreadLocal</code> 不是为了解决线程间的共享变量问题的，如果是多线程都需要访问的数据，那需要用全局变量加同步机制。</p><ol><li>线程中处理一个非常复杂的业务，可能方法有很多，那么，使用 <code>ThreadLocal</code> 可以代替一些参数的显式传递；</li><li>在一些多线程的情况下，如果用线程同步的方式，当并发比较高的时候会影响性能，可以改为 <code>ThreadLocal</code> 的方式，例如高性能序列化框架 Kyro 就要用 <code>ThreadLocal</code> 来保证高性能和线程安全；</li><li>线程内上下文管理器、数据库连接等可以用到 <code>ThreadLocal</code> ;</li><li>用来存储用户 Session。Session 的特性很适合 <code>ThreadLocal</code> ，因为 Session 之前当前会话周期内有效，会话结束便销毁。</li></ol><h2 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h2><p><code>ThreadLocal</code> 的不正确使用会导致内存泄漏。实际上 <code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。JVM 利用调用 remove、get、set 方法的时候，会清除线程 <code>ThreadLocalMap</code> 里所有 key 为 null 的 value，回收弱引用。</p><p>所以如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 <code>ThreadLocalMap</code> 中使用这个 <code>ThreadLocal</code> 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p><p>当使用静态 <code>ThreadLocal</code> 的时候，延长 <code>ThreadLocal</code> 的生命周期，那也可能导致内存泄漏。因为，静态变量在类未加载的时候，它就已经加载，当线程结束的时候，静态变量不一定会回收。</p><p><code>ThreadLocal</code> 出现内存泄漏条件：</p><ol><li><code>ThreadLocal</code> 引用被设置为 null，且后面没有 set、get、remove 操作。</li><li>线程一直运行，不停止。（线程池）</li><li>触发了垃圾回收。（Minor GC或Full GC）</li></ol><p>如何避免内存泄漏：</p><ol><li><code>ThreadLocal</code> 声明为 <code>private final</code>。 <code>private</code> 与 <code>final</code> 尽可能不让他人修改变更引用，最好不要声明为静态的。</li><li><code>ThreadLocal</code> 使用后务必调用 <code>remove</code> 方法。最简单有效的方法是使用后将其移除。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ThreadLocalMap</code> 并不是为了解决线程安全问题，而是提供了一种将实例绑定到当前线程的机制，类似于隔离的效果。每个线程维护一个 <code>ThreadLocalMap</code> 的映射表，映射表的 key 是 <code>ThreadLocal</code> 实例本身，value 是要存储的副本变量。<code>ThreadLocal</code> 实例本身并不存储值，它只是提供一个在当前线程中找到副本值的 key。</p><p><code>ThreadLocal</code> 设计的初衷是为了解决多线程编程中的资源共享问题。对比 <code>synchronized</code>，<code>synchronized</code> 采取的是“以时间换空间”的策略，本质上是对关键资源上锁，让大家排队操作。而 <code>ThreadLocal</code> 采取的是“以空间换时间”的思路，为每个使用该变量的线程提供独立的变量副本，在本线程内部，它相当于一个“全局变量”，可以保证本线程任何时间操纵的都是同一个对象。</p><p><code>ThreadLocal</code> 类最重要的一个概念是，其原理是通过一个 <code>ThreadLocal</code> 的静态内部类 <code>ThreadLocalMap</code> 实现，但是实际中，<code>ThreadLocal</code> 不保存 <code>ThreadLocalMap</code>，而是有每个 Thread 内部维护 <code>ThreadLocal.ThreadLocalMap threadLocals</code> 一份数据结构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Thre
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
      <category term="ThreadLocal" scheme="https://muhouer.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantReadWriteLock解析</title>
    <link href="https://muhouer.github.io/posts/cb5cf479/"/>
    <id>https://muhouer.github.io/posts/cb5cf479/</id>
    <published>2019-09-13T04:15:00.000Z</published>
    <updated>2019-09-13T16:52:49.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ReentrantReadWriteLock</code> 是 <code>Lock</code> 的另一种实现方式， <code>ReentrantLock</code> 是一个排他锁，同一时间只允许一个线程访问，而 <code>ReentrantReadWriteLock</code> 允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。</p><p>读写锁内部维护了两个锁，一个用于读操作，一个用于写操作。所有 <code>ReadWriteLock</code> 实现都必须保证 <code>writeLock</code> 操作的内存同步效果也要保持与相关 <code>readLock</code> 的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</p><p><code>ReentrantReadWriteLock</code> 支持以下功能：</p><ul><li>支持公平和非公平的获取锁的方式；</li><li>支持可重入。读线程在获取了读锁后还可以获取读锁，写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</li><li>允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；</li><li>读取锁和写入锁都支持锁获取期间的中断；</li><li>支持 Condition 。<strong>仅写入锁提供了一个 Conditon 实现，读取锁不支持 Conditon</strong> 。<code>readLock().newCondition()</code> 会抛出 <code>UnsupportedOperationException</code>。</li></ul><h2 id="ReentrantReadWriteLock-类结构"><a href="#ReentrantReadWriteLock-类结构" class="headerlink" title="ReentrantReadWriteLock 类结构"></a>ReentrantReadWriteLock 类结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6992448646407690164L</span>;</span><br><span class="line">    <span class="comment">/** 内部类提供读取锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/** 内部类提供写入锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">/** 执行所有同步机制 */</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁默认是非公平模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 支持指导锁公平模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写入锁</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">    <span class="comment">// 获取读取锁</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/ReentrantReadWriteLock.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code> 、<code>FairSync</code>、<code>NonfairSync</code>、<code>ReadLock</code>、<code>WriteLock</code> 是 <code>ReentrantReadWriteLock</code> 的内部类，<code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> ，而 <code>FairSync</code>、<code>NonfairSync</code> 继承 <code>Sync</code>，分别对应公平锁和非公平锁。<code>ThreadLocalHoldCounter</code> 、<code>HoldCounter</code>是 <code>Sync</code>的内部类。</p><h2 id="Sync-锁"><a href="#Sync-锁" class="headerlink" title="Sync 锁"></a>Sync 锁</h2><p><code>Sync</code> 也是一个继承于AQS的抽象类。<code>Sync</code> 也包括公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code>。sync 对象是 <code>FairSync</code> 和 <code>NonfairSync</code> 中的一个，默认是 <code>NonfairSync</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;</span><br><span class="line">    <span class="comment">/** Lock 状态逻辑上分为两个无符号 short 类型：</span></span><br><span class="line"><span class="comment">     * 1. 低位表示独占（writer）锁写入计数</span></span><br><span class="line"><span class="comment">     * 2. 高位表示共享（reader）锁读取次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回共享（reader）锁被持有次数  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    <span class="comment">/** 返回独占（writer）锁被持有次数  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">    <span class="comment">// 持有计数器：每个线程持有锁的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 为了避免垃圾滞留(garbage retention)，使用 id 而不是引用</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 本地线程持有锁的计数器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程持有的可重入读锁数。每当线程的读取保持计数降至0时删除。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">    <span class="comment">// 成功获取读锁的最后一个线程的保持计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">    <span class="comment">// 第一个获取读锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">    Sync() &#123;</span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        setState(getState()); <span class="comment">// 确保读取锁持有次数可见</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前线程尝试获取读锁，且在其他情况下有资格获取该锁，但由于超过其他等待线程的策略而应该阻塞，则返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程尝试获取写锁，且在其他情况下有资格获取该锁，但由于超过其他等待线程的策略而应该阻塞，则返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 释放写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (free)</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">// 获取当前状态</span></span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 获取写的状态</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 读状态不为0，读锁已获取</span></span><br><span class="line">            <span class="comment">// 写状态为 0 或 当前线程不是独占线程</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 增加写状态，写锁获取成功</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读锁未获取</span></span><br><span class="line">        <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">            !compareAndSetState(c, c + acquires))</span><br><span class="line">            <span class="comment">// 当前线程应该阻塞或通过 CAS 更新 state 为 c + acquires 失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 设置当前线程为独占线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 当前线程是第一个成功获取读锁的线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 线程读锁数量为1，那么第一个成功获取读锁的线程置为null</span></span><br><span class="line">                firstReader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 线程读锁数量减一</span></span><br><span class="line">                firstReaderHoldCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从缓存中获取当前线程的读锁数量</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                rh = readHolds.get();</span><br><span class="line">            <span class="keyword">int</span> count = rh.count; <span class="comment">// 当前线程的读锁数量</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 从本地线程移除读锁线程</span></span><br><span class="line">                readHolds.remove();</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 无读锁可以释放</span></span><br><span class="line">                    <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 线程读锁数量减一</span></span><br><span class="line">            --rh.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> nextc = c - SHARED_UNIT; <span class="comment">// state读锁状态减一</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// 如果state为0，表示无锁状态，返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">// 获取当前状态态</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="comment">// 写状态不为 0 且当前线程是独占线程</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c); <span class="comment">// 获取读状态</span></span><br><span class="line">        <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">            r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">            compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">// 读锁线程不阻塞、读取锁的共享计数未超过限制且通过 CAS 获取锁失败</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 读状态为 0</span></span><br><span class="line">                firstReader = current; <span class="comment">//当前线程是第一个成功获取读锁的线程</span></span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程是第一个成功获取读锁的线程</span></span><br><span class="line">                firstReaderHoldCount++; <span class="comment">// 持有读锁数量加一</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从缓存中获取当前线程的读锁数量</span></span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    <span class="comment">// 缓存读锁为 null 或当前线程的 id 不等于缓存线程 id</span></span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 将读锁线程加到本地线程</span></span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++; <span class="comment">// 持有读锁数量加一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读锁线程阻塞等待</span></span><br><span class="line">        <span class="comment">// 读取锁的共享计数超过限制</span></span><br><span class="line">        <span class="comment">// 通过 CAS 获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果读锁线程阻塞等待、读取锁的共享计数超过限制、通过 CAS 获取锁失败，则通过该方法获取读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState(); <span class="comment">// 获取当前状态</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123; <span class="comment">// 写锁已经被获取</span></span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="comment">// 当前线程不是独占线程</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123; <span class="comment">// 读锁线程阻塞等待</span></span><br><span class="line">                <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前线程不是 firstReader</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123; <span class="comment">// 获取缓存读锁数量</span></span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                            <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                readHolds.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果读锁数量超过 MAX_COUNT，则抛出异常。</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// 通过 CAS 获取锁成功</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123; <span class="comment">// 当前读锁数量为 0</span></span><br><span class="line">                    firstReader = current; <span class="comment">// 当前线程设置为 firstReader</span></span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>; <span class="comment">// firstReader 计数初始化</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程是 firstReader</span></span><br><span class="line">                    firstReaderHoldCount++; <span class="comment">// firstReader 计数加一</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 获取缓存读锁数量</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++; <span class="comment">// 读锁数量加一</span></span><br><span class="line">                    cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并返回 Condition 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getReadLockCount() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 当前线程是首次成功获取读锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) </span><br><span class="line">            <span class="keyword">return</span> firstReaderHoldCount;</span><br><span class="line">        <span class="comment">// 获取缓存读锁数量</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh != <span class="keyword">null</span> &amp;&amp; rh.tid == getThreadId(current))</span><br><span class="line">            <span class="keyword">return</span> rh.count;</span><br><span class="line">        <span class="keyword">int</span> count = readHolds.get().count;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) readHolds.remove();</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反序列化方法，将当前 state 重置为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁和非公平锁实现"><a href="#公平锁和非公平锁实现" class="headerlink" title="公平锁和非公平锁实现"></a>公平锁和非公平锁实现</h2><p>和互斥锁 <code>ReentrantLock</code> 一样，读写锁也分为公平锁和非公平锁。公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 总是不阻塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只要该非公平读锁对应的线程不为 null，则返回 true。</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">       (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">       !s.isShared()         &amp;&amp;</span><br><span class="line">       s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。</span></span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。</span></span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">  <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">  <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readerShouldBlock</code> 的本质就是在检测这次获取读锁资源的操作时，<strong>AQS</strong> 的等待队列中是否已经有写锁了。</p><ul><li>如果已经有写锁，那么要判断写锁是不是本线程，是本线程可以做锁降级。不是本线程就执行<code>fullTryAcquireShared</code>；</li><li>如果没有写锁，就可以继续执行，做 <code>r&lt;MAX_COUNT</code> 判断。</li></ul><p>对公平锁而言，<code>!readerShouldBlock()</code> 就是 <code>!hasQueuedPredecessors()</code>， <code>h == t || ((s = h.next)!=null &amp;&amp; s.thread == Thread.currentThread())</code></p><ol><li><code>h==t</code> 说明Node的等待队列为空</li><li><code>(s = h.next)!=null &amp;&amp; s.thread == Thread.currentThread()</code> 说明等待队列中有值且是本线程申请锁资源。</li></ol><p>满足以上2点的任何一个，可以申请读锁，继续执行下面的 <code>r&lt;MAX_COUNT</code> 判断。</p><h2 id="ReadLock-与-WriteLock"><a href="#ReadLock-与-WriteLock" class="headerlink" title="ReadLock 与 WriteLock"></a>ReadLock 与 WriteLock</h2><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><p>读锁是一个可重入的共享锁，获取读锁的思想(即 <code>lock()</code>的步骤)，是先通过 <code>tryAcquireShared()</code> 尝试获取共享锁。尝试成功的话，则直接返回；尝试失败的话，则通过 <code>doAcquireShared()</code> 不断的循环并尝试获取锁，若有需要，则阻塞等待。<code>doAcquireShared()</code> 在循环中每次尝试获取锁时，都是通过 <code>tryAcquireShared()</code> 来进行尝试的。</p><p>释放读锁的思想(即 <code>unlock()</code>的步骤)，是先通过 <code>tryReleaseShared()</code> 尝试释放共享锁。尝试成功的话，则通过<code>doReleaseShared()</code> 唤醒“其他等待获取共享锁的线程”，并返回true；否则的话，返回 flase。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="comment">// 读锁构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁，不感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 获取共享锁方法 acquireShared</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取读锁，感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 获取共享锁方法 acquireSharedInterruptibly</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState(); <span class="comment">//当前状态</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="comment">// 写锁已经被持有且当前线程不是独占线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c); <span class="comment">// 获取读锁数量</span></span><br><span class="line">            <span class="keyword">if</span> (r == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 通过 CAS 获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 写锁未被获取</span></span><br><span class="line">                    firstReader = current; <span class="comment">// 设置当前线程为 firstReader</span></span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>; <span class="comment">// firstReader 计数初始化</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程是 firstReader</span></span><br><span class="line">                    firstReaderHoldCount++; <span class="comment">// firstReader 计数加一</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从缓存获取读锁数量</span></span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取读锁，感知中断且有超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并返回 Condition，读锁不支持该操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>写锁是一个可重入的排它锁。如果当前线程获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="comment">// 写锁构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁，感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁，不感知中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryWriteLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">//获取当前状态</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 获取写状态</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="comment">// 写状态为0 或 当前线程不是独占线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (w == MAX_COUNT)</span><br><span class="line">                <span class="comment">// 写状态超过 MAX_COUNT</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 CAS 获取锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetState(c, c + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 设置当前线程为独占线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁，感知中断且有超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 的获取排它锁方法 tryAcquireNanos</span></span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放排它锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参考 AQS 的释放排它锁方法 release</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并返回 Condition 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前线程是否是独占线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getWriteHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="利用重入来执行升级缓存后的锁降级"><a href="#利用重入来执行升级缓存后的锁降级" class="headerlink" title="利用重入来执行升级缓存后的锁降级"></a>利用重入来执行升级缓存后的锁降级</h3><p>锁降级指的是写锁降级成为读锁。锁降级是指把持住当前拥有的写锁的同时，再获取到读锁，随后释放写锁的过程。锁降级的意义在于：<strong>在一边读一边写的情况下感知数据变化并提高性能</strong>。</p><blockquote><ol><li><p>首先写锁是独占的，读锁是共享的，然后读写锁是线程间互斥的，锁降级的前提是所有线程都希望对数据变化敏感，但是因为写锁只有一个，所以会发生降级。如果先释放写锁，再获取读锁，可能在获取之前，会有其他线程获取到写锁，阻塞读锁的获取，就无法感知数据变化了。所以需要先hold住写锁，保证数据无变化，获取读锁，然后再释放写锁。</p></li><li><p>如果长时间用写锁独占，对于某些高响应的应用是不允许的。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;    <span class="comment">//缓存是否有效</span></span><br><span class="line">    ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();    <span class="comment">//获取读锁</span></span><br><span class="line">        <span class="comment">//如果缓存无效，更新cache;否则直接使用data</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">//获取写锁前须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();    </span><br><span class="line">            <span class="comment">// Recheck state because another thread might have acquired</span></span><br><span class="line">            <span class="comment">// write lock and changed state before we did.</span></span><br><span class="line">            <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                data = ...</span><br><span class="line">                cacheValid = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">            <span class="comment">// 锁降级，在释放写锁前获取读锁</span></span><br><span class="line">            rwl.readLock().lock();</span><br><span class="line">            rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        use(data);</span><br><span class="line">        rwl.readLock().unlock();    <span class="comment">//释放读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-ReentrantReadWriteLock-来提高-Collection-的并发性"><a href="#使用-ReentrantReadWriteLock-来提高-Collection-的并发性" class="headerlink" title="使用 ReentrantReadWriteLock 来提高 Collection 的并发性"></a>使用 ReentrantReadWriteLock 来提高 Collection 的并发性</h3><p><strong>通常在 collection 数据很多，读线程访问多于写线程并且附带操作的开销高于同步开销时尝试这么做。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock(); <span class="comment">//读锁</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock(); <span class="comment">//写锁</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> m.get(key);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      r.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> m.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      r.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> m.put(key, value);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      m.clear();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相对于排他锁，读写锁提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时 <code>ReentrantReadWriteLock</code> 能够提供比排他锁更好的并发性和吞吐量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Reen
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ReentrantReadWriteLock" scheme="https://muhouer.github.io/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore解析</title>
    <link href="https://muhouer.github.io/posts/e73eaf42/"/>
    <id>https://muhouer.github.io/posts/e73eaf42/</id>
    <published>2019-09-13T04:15:00.000Z</published>
    <updated>2019-09-13T19:14:55.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Semaphore</code> 是JDK1.5的 <code>java.util.concurrent</code> 并发包中提供的一个并发工具类。所谓 <code>Semaphore</code> 即 信号量 的意思。这个叫法并不能很好地表示它的作用，更形象的说法应该是 许可证管理器 。</p><p><code>Semaphore</code> 是一个计数信号量。</p><ul><li>从概念上将，<code>Semaphore</code> 包含一组许可证。</li><li>如果有需要的话，每个 <code>acquire()</code> 方法都会阻塞，直到获取一个可用的许可证。</li><li>每个 <code>release()</code> 方法都会释放持有许可证的线程，并且归还 <code>Semaphore</code> 一个可用的许可证。</li><li>实际上并没有真实的许可证对象供线程使用，<code>Semaphore</code> 只是对可用的数量进行管理维护。</li></ul><h2 id="Semaphore类结构"><a href="#Semaphore类结构" class="headerlink" title="Semaphore类结构"></a>Semaphore类结构</h2><p><code>Semaphore</code> 类结构如下：</p><img src="/images/Semaphore.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code>、<code>FairSync</code>、<code>NonfairSync</code> 是 <code>Semaphore</code> 的内部类。<code>FairSync</code>、<code>NonfairSync</code> 均继承自 <code>Sync</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NonFair version</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 无论当前线程是不是在 CLH 队列的头部，它都会直接获取信号量。</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fair version</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前线程不在 CLH 队列的头部，则排队等候。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="comment">// 判断当前线程是不是在 CLH 队列的头部</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非公平模式共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享式释放同步状态</span></span><br><span class="line">    <span class="comment">// “非公平信号量许可的释放(release)”与“公平信号量许可的释放(release)”是一样的。 </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减少许可数</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取并返回立即可用的所有许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore-构造方法"><a href="#Semaphore-构造方法" class="headerlink" title="Semaphore 构造方法"></a>Semaphore 构造方法</h2><p>构造方法分为两种，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建具有给定的许可数和非公平模式的 Semaphore</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建具有给定的许可数和指定是否公平模式的 Semaphore</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore-获取、释放许可的方法"><a href="#Semaphore-获取、释放许可的方法" class="headerlink" title="Semaphore 获取、释放许可的方法"></a>Semaphore 获取、释放许可的方法</h2><p>获取、释放许可的方法分为两大类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 阻塞方法：</span></span><br><span class="line"><span class="comment"> * 1. 无许可能够获得，则会一直等待，直到获得许可。</span></span><br><span class="line"><span class="comment"> * 2. 在释放许可之前，必须先获获得许可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 获取一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 获取permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>; <span class="comment">// 释放一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span></span>; <span class="comment">// 释放permits个许可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 非阻塞方法：</span></span><br><span class="line"><span class="comment"> * 立即获取执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"><span class="comment">//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span></span>; </span><br><span class="line"><span class="comment">//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><h2 id="Semaphore的其他方法"><a href="#Semaphore的其他方法" class="headerlink" title="Semaphore的其他方法"></a>Semaphore的其他方法</h2><p>其他方法包括获取当前可用许可数、获取队列正在等待许可的线程数目、是否是公平模式等，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回此信号量中当前可用的许可数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回正在等待获取的线程的估计数目。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取并返回立即可用的所有许可。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 查询是否有线程正在等待获取。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 如果此信号量的公平设置为 true，则返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回标识此信号量的字符串，以及信号量的状态。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 collection，包含可能等待获取的线程。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 根据指定的缩减量减小可用许可的数目。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reduction)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Semaphore的使用"><a href="#Semaphore的使用" class="headerlink" title="Semaphore的使用"></a>Semaphore的使用</h2><p><code>Semaphore</code> 经常用于限制获取某种资源的线程数量。</p><p>以请求总数为 6，并发执行的线程数为 2 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求总数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 并发执行的线程数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 随机数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">      executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire(<span class="number">1</span>);</span><br><span class="line">          System.out.println(<span class="string">"处理请求 "</span> + count + <span class="string">" 前，当前许可证数量："</span> + semaphore.availablePermits());</span><br><span class="line">          resolve(count);</span><br><span class="line">          System.out.println(<span class="string">"处理请求 "</span> + count + <span class="string">" 中，正在等待许可证的请求数量："</span> + semaphore.getQueueLength());</span><br><span class="line">          semaphore.release(<span class="number">1</span>);</span><br><span class="line">          System.out.println(<span class="string">"处理请求 "</span> + count + <span class="string">" 后，当前许可证数量："</span> + semaphore.availablePermits());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolve</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"请求 "</span> + i + <span class="string">" 开始处理"</span>);</span><br><span class="line">    <span class="keyword">int</span> r = random.nextInt(i + <span class="number">3</span>) + <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"请求 "</span> + i + <span class="string">"处理"</span> + r + <span class="string">"秒"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span> * r);</span><br><span class="line">    System.out.println(<span class="string">"请求 "</span> + i + <span class="string">" 结束处理"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">处理请求 0 前，当前许可证数量：0</span><br><span class="line">处理请求 1 前，当前许可证数量：0</span><br><span class="line">请求 0 开始处理</span><br><span class="line">请求 1 开始处理</span><br><span class="line">请求 0处理4秒</span><br><span class="line">请求 1处理2秒</span><br><span class="line">请求 1 结束处理</span><br><span class="line">处理请求 1 中，正在等待许可证的请求数量：4</span><br><span class="line">处理请求 1 后，当前许可证数量：1</span><br><span class="line">处理请求 2 前，当前许可证数量：0</span><br><span class="line">请求 2 开始处理</span><br><span class="line">请求 2处理5秒</span><br><span class="line">请求 0 结束处理</span><br><span class="line">处理请求 0 中，正在等待许可证的请求数量：3</span><br><span class="line">处理请求 0 后，当前许可证数量：1</span><br><span class="line">处理请求 3 前，当前许可证数量：0</span><br><span class="line">请求 3 开始处理</span><br><span class="line">请求 3处理6秒</span><br><span class="line">请求 2 结束处理</span><br><span class="line">处理请求 2 中，正在等待许可证的请求数量：2</span><br><span class="line">处理请求 2 后，当前许可证数量：1</span><br><span class="line">处理请求 4 前，当前许可证数量：0</span><br><span class="line">请求 4 开始处理</span><br><span class="line">请求 4处理2秒</span><br><span class="line">请求 4 结束处理</span><br><span class="line">处理请求 4 中，正在等待许可证的请求数量：1</span><br><span class="line">处理请求 4 后，当前许可证数量：1</span><br><span class="line">处理请求 5 前，当前许可证数量：0</span><br><span class="line">请求 5 开始处理</span><br><span class="line">请求 5处理7秒</span><br><span class="line">请求 3 结束处理</span><br><span class="line">处理请求 3 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 3 后，当前许可证数量：1</span><br><span class="line">请求 5 结束处理</span><br><span class="line">处理请求 5 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 5 后，当前许可证数量：2</span><br></pre></td></tr></table></figure><p>当释放许可参数变成 2，即从 <code>semaphore.release(1)</code> 变成 <code>semaphore.release(2)</code>。执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">处理请求 0 前，当前许可证数量：0</span><br><span class="line">请求 0 开始处理</span><br><span class="line">请求 0处理4秒</span><br><span class="line">处理请求 1 前，当前许可证数量：0</span><br><span class="line">请求 1 开始处理</span><br><span class="line">请求 1处理3秒</span><br><span class="line">请求 1 结束处理</span><br><span class="line">处理请求 1 中，正在等待许可证的请求数量：4</span><br><span class="line">处理请求 1 后，当前许可证数量：2</span><br><span class="line">处理请求 2 前，当前许可证数量：1</span><br><span class="line">请求 2 开始处理</span><br><span class="line">处理请求 3 前，当前许可证数量：0</span><br><span class="line">请求 3 开始处理</span><br><span class="line">请求 3处理4秒</span><br><span class="line">请求 2处理5秒</span><br><span class="line">请求 0 结束处理</span><br><span class="line">处理请求 0 中，正在等待许可证的请求数量：2</span><br><span class="line">处理请求 0 后，当前许可证数量：2</span><br><span class="line">处理请求 4 前，当前许可证数量：1</span><br><span class="line">请求 4 开始处理</span><br><span class="line">处理请求 5 前，当前许可证数量：0</span><br><span class="line">请求 5 开始处理</span><br><span class="line">请求 5处理8秒</span><br><span class="line">请求 4处理2秒</span><br><span class="line">请求 4 结束处理</span><br><span class="line">处理请求 4 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 4 后，当前许可证数量：2</span><br><span class="line">请求 3 结束处理</span><br><span class="line">处理请求 3 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 3 后，当前许可证数量：4</span><br><span class="line">请求 2 结束处理</span><br><span class="line">处理请求 2 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 2 后，当前许可证数量：6</span><br><span class="line">请求 5 结束处理</span><br><span class="line">处理请求 5 中，正在等待许可证的请求数量：0</span><br><span class="line">处理请求 5 后，当前许可证数量：8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Semaphore&lt;/code&gt; 是JDK1.5的 &lt;code&gt;java.util.concurrent&lt;/code&gt; 并发包中
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Semaphore" scheme="https://muhouer.github.io/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock解析</title>
    <link href="https://muhouer.github.io/posts/b376c662/"/>
    <id>https://muhouer.github.io/posts/b376c662/</id>
    <published>2019-09-13T04:14:00.000Z</published>
    <updated>2019-09-13T04:27:16.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Reentrant 可重入的;重入;可再入的。即再次进入的意思，entrant: 新职员;新生;新会员;新成员。</p></blockquote><p>JDK 中独占锁的实现除了使用关键字 <code>synchronized</code> 外,还可以使用 <code>ReentrantLock</code>。虽然在性能上<code>ReentrantLock</code> 和 <code>synchronized</code> 没有什么区别，但 <code>ReentrantLock</code> 相比 <code>synchronized</code> 而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。即 <code>ReentrantLock</code> 粒度更小。</p><ul><li><code>ReentrantLock</code> 是独占锁且可重入的。</li><li><code>ReentrantLock</code> 可以实现公平锁。</li><li><code>ReentrantLock</code> 可以响应中断。</li><li><code>ReentrantLock</code> 提供了获取锁超时等待。</li><li><code>ReentrantLock</code> 结合 <code>Condition</code> 接口可以实现线程间的等待通知机制。</li></ul><h2 id="ReentrantLock-类结构"><a href="#ReentrantLock-类结构" class="headerlink" title="ReentrantLock 类结构"></a>ReentrantLock 类结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平可重入锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定可重入锁公平模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/ReentrantLock.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code> 、<code>FairSync</code>、<code>NonfairSync</code>是 <code>ReentrantLock</code> 的内部类，<code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> ，而 <code>FairSync</code>、<code>NonfairSync</code> 继承 <code>Sync</code>，分别对应公平锁和非公平锁。</p><h3 id="Sync-内部类"><a href="#Sync-内部类" class="headerlink" title="Sync 内部类"></a>Sync 内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line">    <span class="comment">// 执行锁操作，由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行非公平 tryLock()</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 利用 CAS 来更新 state 的状态</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 设置当前线程拥有独占访问权限</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取拥有独占访问权限的线程和当前线程比较</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="comment">// 溢出</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 设置新状态</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="comment">// 拥有独占访问权限的线程不是当前线程，抛出 IllegalMonitorStateException</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 清空拥有独占访问权限的线程</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置新状态</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程是否拥有独占访问权限</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 Condition 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取拥有独占访问权限的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否锁住</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解序列化，将状态重置为 0，即锁释放状态</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NonfairSync、FairSync-内部类"><a href="#NonfairSync、FairSync-内部类" class="headerlink" title="NonfairSync、FairSync 内部类"></a>NonfairSync、FairSync 内部类</h3><blockquote><p>线程会重复获取锁。如果申请获取锁的线程足够多，那么可能会造成某些线程长时间得不到锁。这就是非公平锁的“饥饿”问题。</p></blockquote><p>公平锁是指当锁可用时，在锁上等待时间最长的线程将获得锁的使用权，而非公平锁则随机分配这种使用权。和<code>synchronized</code> 一样，默认的 <code>ReentrantLock</code> 实现是非公平锁，因为相比公平锁，非公平锁性能更好。当然公平锁能防止饥饿，某些情况下也很有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">    <span class="comment">// 锁实现</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用 CAS 来更新 state 的状态为1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 设置当前线程拥有独占访问权限，随机分配</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// AQS 的 acquire()</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参考上文 Sync 的 nonfairTryAcquire 实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"><span class="comment">// 锁实现</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 的 acquire()</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，和 AQS 的 nonfairTryAcquire 相比，多了判断队列有没有前置节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 队列没有前置节点，且成功利用 CAS 来更新 state 的状态为 acquires </span></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 设置当前线程拥有独占访问权限</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReentrantLock-提供的方法"><a href="#ReentrantLock-提供的方法" class="headerlink" title="ReentrantLock 提供的方法"></a>ReentrantLock 提供的方法</h2><h3 id="ReentrantLock-锁方法"><a href="#ReentrantLock-锁方法" class="headerlink" title="ReentrantLock 锁方法"></a>ReentrantLock 锁方法</h3><p><code>ReentrantLock</code> 和 <code>synchronized</code> 都是独占锁。不同的是 <code>ReentrantLock</code> 需要手动加锁和解锁，且解锁的操作尽量要放在 finally 代码块中，保证线程正确释放锁。<code>ReentrantLock</code> 操作较为复杂，但是因为可以手动控制加锁和解锁过程，在复杂的并发场景中能派上用场。<code>synchronized</code> 加锁解锁的过程是隐式的，用户不用手动操作，优点是操作简单，但显得不够灵活。一般并发场景使用 <code>synchronized</code> 就足够。</p><p><code>ReentrantLock</code> 和 <code>synchronized</code> 都是可重入的。<code>synchronized</code> 因为可重入，所以可以放在被递归执行的方法上，且不用担心线程最后能否正确释放锁。而 <code>ReentrantLock</code> 在重入时要却<strong>确保重复获取锁的次数必须和重复释放锁的次数一样</strong>，否则可能导致其他线程无法获得该锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁，分别调用公平锁和非公平锁的加锁方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断敏感的加锁，参考 AQS 的 acquireInterruptibly 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平模式加锁，参考 Sync 的 nonfairTryAcquire 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁直至超时，参考 AQS 的 tryAcquireNanos 方法</span></span><br><span class="line"><span class="comment">// 使用该方法配合失败重试机制可以用来解决死锁问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Condition-相关方法"><a href="#Condition-相关方法" class="headerlink" title="Condition 相关方法"></a>Condition 相关方法</h3><p><code>Condition</code> 由 <code>ReentrantLock</code> 对象创建，并且可以同时创建多个。<code>Condition</code> 接口在使用前必须先调用<code>ReentrantLock</code> 的 <code>lock()</code> 方法获得锁。之后调用 <code>Condition</code> 接口的 <code>await()</code> 将释放锁，并且在该<code>Condition</code> 上等待，直到有其他线程调用 <code>Condition</code> 的 <code>signal()</code> 方法唤醒线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Condition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询在给定条件下，是否有线程在等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!(condition <span class="keyword">instanceof</span> AbstractQueuedSynchronizer.ConditionObject))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not owner"</span>);</span><br><span class="line">    <span class="keyword">return</span> sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询在给定条件下，等待线程队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!(condition <span class="keyword">instanceof</span> AbstractQueuedSynchronizer.ConditionObject))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not owner"</span>);</span><br><span class="line">    <span class="keyword">return</span> sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询在给定条件下，所有等待线程</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">(Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!(condition <span class="keyword">instanceof</span> AbstractQueuedSynchronizer.ConditionObject))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not owner"</span>);</span><br><span class="line">    <span class="keyword">return</span> sync.getWaitingThreads((AbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了锁方法和 Condition 相关方法外，还有一些判断是否是公平锁、是否加锁、获取阻塞队列长度、当前队列是否独占等方法，比较简单参考源码即可。</p><h2 id="ReentrantLock-使用示例"><a href="#ReentrantLock-使用示例" class="headerlink" title="ReentrantLock 使用示例"></a>ReentrantLock 使用示例</h2><h3 id="基于官方示例"><a href="#基于官方示例" class="headerlink" title="基于官方示例"></a>基于官方示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公平锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadDemo</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"获得锁的线程："</span> + id);</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是公平锁，线程几乎是轮流的获取到了锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：0</span><br><span class="line">获得锁的线程：0</span><br></pre></td></tr></table></figure><p>如果是非公平锁，线程会重复获取锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：4</span><br><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：1</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：2</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：3</span><br><span class="line">获得锁的线程：0</span><br><span class="line">获得锁的线程：0</span><br></pre></td></tr></table></figure><h3 id="结合-Condition-实现等待通知机制"><a href="#结合-Condition-实现等待通知机制" class="headerlink" title="结合 Condition 实现等待通知机制"></a>结合 Condition 实现等待通知机制</h3><p>使用 <code>synchronized</code> 结合 Object 上的 <code>wait()</code> 和 <code>notify()</code> 方法可以实现线程间的等待通知机制。<code>ReentrantLock</code> 结合 <code>Condition</code> 接口同样可以实现这个功能，而且相比前者使用起来更清晰也更简单。</p><p>使用<code>Condition</code> 实现简单的阻塞队列，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionBlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 阻塞队列最大容量</span></span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// 可重入锁</span></span><br><span class="line">  ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 队列底层实现</span></span><br><span class="line">  LinkedList&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 队列满时的等待条件</span></span><br><span class="line">  Condition notFull = lock.newCondition();</span><br><span class="line">  <span class="comment">// 队列空时的等待条件</span></span><br><span class="line">  Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConditionBlockingQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 队列已满,在 notFull 条件上等待</span></span><br><span class="line">      <span class="keyword">while</span> (list.size() == size) &#123;</span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;</span><br><span class="line">      list.add(e); <span class="comment">// 加入链表末尾</span></span><br><span class="line">      notEmpty.signal(); <span class="comment">// 通知在 notEmpty 条件上等待的线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 队列为空,在 notEmpty 条件上等待</span></span><br><span class="line">      <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      e = list.removeFirst(); <span class="comment">// 移除链表首元素</span></span><br><span class="line">      notFull.signal(); <span class="comment">// 通知在 notFull 条件上等待的线程</span></span><br><span class="line">      <span class="keyword">return</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ReentrantLock</code> 是可重入的独占锁。比 <code>synchronized</code> 功能更加丰富，控制粒度更小，支持公平锁实现，支持中断响应以及超时等待…… <code>ReentrantLock</code> 还可以配合一个或多个 <code>Condition</code> 条件方便的实现等待通知机制。不过需要手动加锁和解锁，且解锁的操作尽量要放在 finally 代码块中，保证线程正确释放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ReentrantLock" scheme="https://muhouer.github.io/tags/ReentrantLock/"/>
    
  </entry>
  
  <entry>
    <title>AQS同步器解析</title>
    <link href="https://muhouer.github.io/posts/cdbd94c4/"/>
    <id>https://muhouer.github.io/posts/cdbd94c4/</id>
    <published>2019-09-13T04:09:00.000Z</published>
    <updated>2019-09-13T04:18:13.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>AQS</strong> (<code>AbstractQueuedSynchronizer</code>) 提供了基于 FIFO 队列机制的模板，可以用来实现阻塞锁以及相关的同步锁 (semaphores, events等)，是构建 Java 同步组件的基础。自定义子类通过继承 <strong>AQS</strong> 类，实现它的抽象方法来管理同步状态。<strong>AQS</strong> 提供了大量的模板方法来实现同步，主要是分为三类：</p><ol><li>独占式获取、释放同步状态。</li><li>共享式获取、释放同步状态</li><li>查询同步队列中的等待线程情况。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>继承关系及 public 方法如下图所示</p><img src="/images/AbstractQueuedSynchronizer.png" width="800px" height="600px" align="center"><h2 id="需要自定义同步组件实现的方法"><a href="#需要自定义同步组件实现的方法" class="headerlink" title="需要自定义同步组件实现的方法"></a>需要自定义同步组件实现的方法</h2><p>基于 <strong>AQS</strong> 实现的自定义同步组件主要有五种</p><ul><li>倒计时器：<code>CountDownLatch.Sync</code>——<a href="/posts/49d01824/" title="CountDownLatch解析">CountDownLatch解析</a></li><li>信号量：<code>Semaphore.Sync</code>——<a href="/posts/e73eaf42/" title="Semaphore解析">Semaphore解析</a></li><li>重入锁：<code>ReentrantLock.Sync</code>——<a href="/posts/b376c662/" title="ReentrantLock解析">ReentrantLock解析</a></li><li>读写锁：<code>ReentrantReadWriteLock.Sync</code> ——<a href="/posts/cb5cf479/" title="ReentrantReadWriteLock解析">ReentrantReadWriteLock解析</a></li><li>线程池执行器：<code>ThreadPoolExecutor.Worker</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占式获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 独占式释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享式获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享式释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前（调用）线程以独占方式持有同步，则返回&#123;@code true&#125;</span></span><br><span class="line"><span class="comment">// 每次调用非等待的方法时都会调用此方法。（等待方法改为调用&#123;@link release&#125;。）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h2><p>独占式，同一时刻仅有一个线程持有同步状态。</p><blockquote><p>在 AQS 中维护着一个 FIFO 的同步队列，当线程获取同步状态失败后，则会加入到这个 CLH 同步队列的对尾并一直保持着自旋。在 CLH 同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出 CLH 同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p></blockquote><h3 id="独占式获取同步状态"><a href="#独占式获取同步状态" class="headerlink" title="独占式获取同步状态"></a>独占式获取同步状态</h3><p><code>acquire(int arg)</code> 方法是 <strong>AQS</strong> 提供的模板方法，该方法为独占式获取同步状态，忽略中断，即线程获取同步状态失败加入到 CLH 同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryAcquire(int arg)</code> 去尝试获取锁，获取成功则设置锁状态并返回 <code>true</code>，否则返回 <code>false</code>。该方法需要自定义同步组件实现，该方法必须要保证线程安全的获取同步状态。</li><li>如果 <code>tryAcquire(int arg)</code> 返回 <code>false</code> 即获取同步状态失败，则调用 <code>addWaiter(Node mode)</code> 将当前线程加入到 CLH 同步队列尾部。</li><li><code>acquireQueued(final Node node, int arg)</code> : 当前线程会根据公平性原则来进行阻塞等待，直到获取锁为止，并且返回当前线程在等待过程中有没有中断过。</li><li><code>selfInterrupt()</code> 会产生一个中断。</li></ul><p><code>acquireQueued(final Node node, int arg)</code> 是一个自旋的过程，也就是说当前线程(Node) 进入同步队列后，当前线程会一直尝试获取同步状态，当前驱节点是头节点并且获取锁成功才会退出。其中只有其前驱节点为头结点才能够尝试获取同步状态，原因有二：1.保持 FIFO 同步队列原则。2.头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 中断标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">               <span class="comment">// 前驱节点是头节点并且获取锁成功</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取失败，线程等待 &amp;&amp; 检查中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 置中断标志位true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">【tryAcquire 获取锁--失败--&gt;【addWaiter 生成 Node 节点并将当前线程加入 CLH 同步队列】</span><br><span class="line">          |                              |&lt;-------------------------------</span><br><span class="line">          |                             ***                              |</span><br><span class="line">          |                              *                               |</span><br><span class="line">          |      【acquireQueued 判断前驱节点是否是头节点】--否--     线程被中断或前驱节点被释放</span><br><span class="line">          |                  |                 |             |</span><br><span class="line">          |                  是      【acquireQueued 线程进入线程等待】</span><br><span class="line">          |                    |                    *</span><br><span class="line">          |                   ***                  ***</span><br><span class="line">          |                              *                    |</span><br><span class="line">          |                  【acquireQueued 获取锁成功】---失败--</span><br><span class="line">          |                            |</span><br><span class="line">          |                           成功 </span><br><span class="line">          |                            |</span><br><span class="line">          |                           ***</span><br><span class="line">          |                            *</span><br><span class="line">         ***                  【设置当前节点为头节点】</span><br><span class="line">          *                               |</span><br><span class="line">          结束&lt;----------------------------</span><br></pre></td></tr></table></figure><h3 id="独占式中断获取同步状态"><a href="#独占式中断获取同步状态" class="headerlink" title="独占式中断获取同步状态"></a>独占式中断获取同步状态</h3><p><strong>AQS</strong> 提供了 <code>acquire(int arg)</code> 以独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于 CLH 同步队列中等待着获取同步状态。为了响应中断，<strong>AQS</strong> 提供了 <code>acquireInterruptibly(int arg)</code> ，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常<code>InterruptedException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 校验该线程是否已经中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">// 抛出InterruptedException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg)) <span class="comment">// 获取同步状态</span></span><br><span class="line">        <span class="comment">// 获取失败，执行doAcquireInterruptibly(arg)</span></span><br><span class="line">        <span class="comment">// 如果获取失败，线程等待 &amp;&amp; 检查有中断则抛出InterruptedException，和 acquireQueued 置中断标志位true不一样</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h3><p><strong>AQS</strong> 除了提供上面两个方法外，还提供了 <code>tryAcquireNanos(int arg,long nanos)</code>。该方法除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回 false，否则返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 获取到直接返回，否则执行 doAcquireNanos(arg, nanosTimeout)</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时获取同步状态最终是在 <code>doAcquireNanos(int arg, long nanosTimeout)</code>中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 生成 Node节点并当前线程加入 CLH 同步队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 前驱节点是头节点获取同步状态成功</span></span><br><span class="line">                setHead(node); <span class="comment">// 设置当前节点为头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 剩余时间计算</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 超时</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">// 获取失败，线程等待并且剩余时间大于 1000 纳秒</span></span><br><span class="line">                <span class="comment">// 等待 nanosTimeout 纳秒，线程会直接从LockSupport.parkNanos中返回</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 超时非常短nanosTimeout&lt;=spinForTimeoutThreshold，AQS会进行无条件的快速自旋。</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独占式释放同步状态"><a href="#独占式释放同步状态" class="headerlink" title="独占式释放同步状态"></a>独占式释放同步状态</h3><p>当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。<strong>AQS</strong> 提供了 <code>release(int arg)</code> 来释放同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用自定义同步器自定义的 tryRelease(int arg) 方法来释放同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h2><p>共享式与独占式的最主要区别在于独占式同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。</p><h3 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="共享式同步状态获取"></a>共享式同步状态获取</h3><p><strong>AQS</strong> 提供 <code>acquireShared(int arg)</code> 共享式获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试获取同步状态，需要自定义同步组件实现</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 自旋方式获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doAcquireShared(int arg)</code> 自旋方式获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建共享式节点并将当前线程加入 CLH 同步队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 前驱节点为头节点</span></span><br><span class="line">                <span class="comment">// 尝试获取同步</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 获取成功</span></span><br><span class="line">                  <span class="comment">// 设置当前节点为头节点并检查后续进程是否可以在共享模式下等待</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取失败线程等待并检查中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireShared(int arg)</code> 不响应中断，与独占式类似，<strong>AQS</strong> 也提供了响应中断、超时的方法，分别是：<code>acquireSharedInterruptibly(int arg)</code>、<code>tryAcquireSharedNanos(int arg,long nanos)</code>，与独占式类似。</p><h3 id="共享式释放同步状态"><a href="#共享式释放同步状态" class="headerlink" title="共享式释放同步状态"></a>共享式释放同步状态</h3><p>获取同步状态后，需要调用 <code>releaseShared(int arg)</code> 释放同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放同步状态，需要自定义同步组件实现</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 自旋释放同步状态</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doReleaseShared()</code> 自旋释放同步状态。因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过 CAS (Conmpare And Swap) 和循环来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;AQ
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="AQS" scheme="https://muhouer.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch解析</title>
    <link href="https://muhouer.github.io/posts/49d01824/"/>
    <id>https://muhouer.github.io/posts/49d01824/</id>
    <published>2019-09-13T04:05:00.000Z</published>
    <updated>2019-09-13T04:08:59.144Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文代码基于<strong>Java8</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>CountDownLatch</code> ，英文翻译为倒计时锁存器，是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。也是基于 <strong>AQS</strong>，它是 <strong>AQS</strong> 的共享功能的一个实现。</p><p>它主要用来保证完成某个任务的先决条件满足，是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</p><ul><li>确保某个计算在其需要的所有资源都被初始化之后才继续执行;</li><li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动;</li><li>等待直到某个操作所有参与者都准备就绪再继续执行。</li></ul><p><code>CountDownLatch</code> 有一个正数计数器，<code>countDown()</code> 方法对计数器做减操作，<code>await()</code> 方法等待计数器达到0。所有 await 的线程都会阻塞直到计数器为0或者等待线程中断或者超时。</p><h2 id="CountDownLatch-类结构"><a href="#CountDownLatch-类结构" class="headerlink" title="CountDownLatch 类结构"></a>CountDownLatch 类结构</h2><img src="/images/CountDownLatch.png" width="800px" height="500px" align="center"><p>其中<code>Sync</code> 是 <code>CountDownLatch</code> 的内部类，<code>Sync</code> 继承自 <code>AbstractQueuedSynchronizer</code> 。使用 <strong>AQS</strong> state 表示 count 计数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"><span class="comment">// 设置初始计数</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取当前计数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 AQS 的 tryAcquireShared 方法，-1 表示 count&gt;0，可以获取。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="comment">// // count-1，如果 count 变为0，则唤醒所有。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前状态，为0表示未锁，不用释放。</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 利用 CAS 来更新 state 的状态，这里可能有并发，所以这也是用死循环更新的原因</span></span><br><span class="line">            <span class="comment">// c为期望值，nextc为更新值。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch-构造方法"><a href="#CountDownLatch-构造方法" class="headerlink" title="CountDownLatch 构造方法"></a>CountDownLatch 构造方法</h2><p>使用给定的 count 构造 <code>CountDownLatch</code>，count 表示线程通过 await 前必须要执行的次数，count 不能小于0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当<code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><h2 id="CountDownLatch-线程等待方法"><a href="#CountDownLatch-线程等待方法" class="headerlink" title="CountDownLatch 线程等待方法"></a>CountDownLatch 线程等待方法</h2><p><code>await()</code> 是通过轮询 state 的状态来判断所有的任务是否都完成。</p><h3 id="无限等待"><a href="#无限等待" class="headerlink" title="无限等待"></a>无限等待</h3><p>让当前线程等待直到 count 减数为0，除非线程被中断。如果 count 为0，线程将立即返回，不再阻塞等待。<br>如果当前计数大于零，则出于线程调度目的，当前线程将禁用，并处于休眠状态，直到发生以下两种情况之一：</p><ol><li><code>countDown()</code> 方法调用使得 count 减数为0；</li><li>当前线程被中断 (如果被中断将会抛出 InterruptedException 异常)。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 AQS 的 acquireSharedInterruptibly() 方法</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h3><p>使当前线程处理等待状态直到 count 减为0或者等待超时。如果当前count是0，则线程立即返回true。<br>如果当前计数大于零，则出于线程调度目的，当前线程将禁用，并处于休眠状态，直到发生以下三种情况之一：</p><ol><li><code>countDown()</code> 方法调用使得 count 减数为0；</li><li>当前线程被中断 (如果被中断将会抛出 InterruptedException 异常)；</li><li>等待超时。</li></ol><p><strong>如果等待超时但是 <code>count&gt;0</code>，则返回 false。如果超时时间小于或等于零，方法将不会等待。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 AQS 的 tryAcquireSharedNanos() 方法</span></span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch-其他方法"><a href="#CountDownLatch-其他方法" class="headerlink" title="CountDownLatch 其他方法"></a>CountDownLatch 其他方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒计时，将会将count-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 AQS 的 releaseShared() 方法</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 的 releaseShared() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参考 Sync 重写的 tryReleaseShared(int releases) 方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒主线程，因为如果 state 不等于0的话，主线程一直是阻塞的。</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前计数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.getCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回标识锁及其状态的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"[Count = "</span> + sync.getCount() + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AQS-的-doReleaseShared-方法"><a href="#AQS-的-doReleaseShared-方法" class="headerlink" title="AQS 的 doReleaseShared() 方法"></a>AQS 的 doReleaseShared() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123; <span class="comment">// 至少有两个节点</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 后继节点需要唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line">        doSomethingElse();            <span class="comment">// don't let run yet</span></span><br><span class="line">        <span class="comment">// 所有worker线程继续执行</span></span><br><span class="line">        startSignal.countDown();      <span class="comment">// let all threads proceed</span></span><br><span class="line">        doSomethingElse();</span><br><span class="line">        <span class="comment">// 允许driver等待直到所有的worker都完成</span></span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">  Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">    <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      startSignal.await(); <span class="comment">// 开始信号阻止任何worker直到driver准备好</span></span><br><span class="line">      doWork();</span><br><span class="line">      doneSignal.countDown(); <span class="comment">// 完成信号，计数减一</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="火箭发射示例"><a href="#火箭发射示例" class="headerlink" title="火箭发射示例"></a>火箭发射示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatchDemo demo = <span class="keyword">new</span> CountDownLatchDemo();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟检查任务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) * <span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"check complete"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//计数减一</span></span><br><span class="line">            <span class="comment">//放在finally避免任务执行过程出现异常，导致countDown()不能被执行</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            exec.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待检查</span></span><br><span class="line">        latch.await();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发射火箭</span></span><br><span class="line">        System.out.println(<span class="string">"Fire!"</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>CountDownLatch</code> 主要用来保证完成某个任务的先决条件满足，是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;本文代码基于&lt;strong&gt;Java8&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Coun
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="Java并发编程" scheme="https://muhouer.github.io/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="CountDownLatch" scheme="https://muhouer.github.io/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>人类愚蠢辞典</title>
    <link href="https://muhouer.github.io/posts/c6491e95/"/>
    <id>https://muhouer.github.io/posts/c6491e95/</id>
    <published>2019-09-08T15:28:00.000Z</published>
    <updated>2019-09-09T15:50:16.015Z</updated>
    
    <content type="html"><![CDATA[<ol><li>习惯的力量与其愚蠢度成正比。我们在个人与社会生活中，总会用同样的方式思考以及做同样的事。</li><li>对于银行来说，25% 就已经是高利贷的标准了。而一些酒吧、饭店来说，它们宣称出于对”卫生问题“的重视不提供直饮水，转而以高达10倍价格向它们愚蠢的顾客推销瓶装水。</li><li>人类的不忠行为远比我们愚蠢地自认为的要多。实际上，男性会偏向于夸大性伴侣的数量，而女性则会倾向于隐藏。不忠行为是对反自然的一夫一妻制进行的自然修正过程。</li><li>往生世界，相信死后我们会有跟活着时一样的烦恼。</li><li>”保护地球“是很愚蠢的：充其量是我们自己有点儿危险罢了。早在25亿年前，光合作用就已经对地球环境的构成造成了更甚于今日的剧烈变化，即所谓的”大氧化事件“。然而，我们地球通过一项调整成功挽救了自己：消灭厌氧生物，并养育需氧生物，也就是人类本身。</li><li>通常，人们愚蠢地认为爱动物就是喜欢小猫小狗，不忍观看斗牛或海豹被屠杀的画面。极少人意识到，真正的问题存在于动物被用于饮食和实验造成的权益侵害。</li><li>愚蠢的种族主义者虽然目标常常变化，但本质永远是不变的。</li><li>斯特金定律：90%的东西都是无意义的废物。</li><li>愚蠢的人有两种截然相反的行事方式，却总能殊途同归，制造麻烦。要么让那些明智的人生活难以为继，无法施展抱负；要么为害群之马铺平道路，帮助他们达成危害大业。</li><li>同样的习惯，于自身都很正常，到了别人那里就怎么看怎么别扭。</li><li>我们愚蠢无知的程度，恰如我们自以为的智慧狡黠一般。</li><li>在任意一群人里，蠢人的比例是固定的，即使是在诺贝尔奖获得者中。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;&lt;li&gt;习惯的力量与其愚蠢度成正比。我们在个人与社会生活中，总会用同样的方式思考以及做同样的事。&lt;/li&gt;&lt;li&gt;对于银行来说，25% 就已经是高利贷的标准了。而一些酒吧、饭店来说，它们宣称出于对”卫生问题“的重视不提供直饮水，转而以高达10倍价格向它们愚蠢的顾客推销瓶装
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://muhouer.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="愚蠢" scheme="https://muhouer.github.io/tags/%E6%84%9A%E8%A0%A2/"/>
    
  </entry>
  
  <entry>
    <title>JavaBean</title>
    <link href="https://muhouer.github.io/posts/207a79f8/"/>
    <id>https://muhouer.github.io/posts/207a79f8/</id>
    <published>2019-09-08T01:15:24.000Z</published>
    <updated>2019-09-08T01:17:59.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaBean-定义"><a href="#JavaBean-定义" class="headerlink" title="JavaBean 定义"></a>JavaBean 定义</h2><p>在 Java 中，有很多<code>class</code>的定义都符合这样的规范：</p><ul><li>若干<code>private</code>实例字段；</li><li>通过<code>public</code>方法来读写实例字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果读写方法符合以下这种命名规范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">getXyz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXyz</span><span class="params">(Type value)</span></span></span><br></pre></td></tr></table></figure><p>那么这种<code>class</code>被称为<code>JavaBean</code></p><p>JavaBean 是一种 Java 语言写成的可重用组件。为写成 JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性。众所周知，属性名称符合这种模式，其他 Java 类可以通过自身机制发现和操作这些 JavaBean 的属性。</p><p>JavaBean 更多的是一种规范，即包含一组 set 和 get 方法的 Java 对象。JavaBean 主要用来传递数据，即把一组数据组合成一个 JavaBean 便于传输。</p><h2 id="枚举-JavaBean-属性"><a href="#枚举-JavaBean-属性" class="headerlink" title="枚举 JavaBean 属性"></a>枚举 JavaBean 属性</h2><p><strong>内省(Introspector) 是 Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。</strong></p><p>调用 <code>Introspector.getBeanInfo()</code> 方法，得到的 BeanInfo 对象封装了把这个类当做 JavaBean 看的结果信息，即属性的信息。调用 <code>BeanInfo</code> 的 <code>getPropertyDescriptors()</code>，可以获得属性的描述，可以采用遍历 BeanInfo 的方法，来查找、设置类的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntrospectorTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    BeanInfo info = Introspector.getBeanInfo(Person.class);</span><br><span class="line">    <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pd.getName().equals(<span class="string">"name"</span>))&#123;</span><br><span class="line">        Method methodSetName = pd.getWriteMethod();</span><br><span class="line">        methodSetName.invoke(person, <span class="string">"Freya"</span>);</span><br><span class="line">        Method methodGetName = pd.getReadMethod();</span><br><span class="line">        System.out.println(methodGetName.invoke(person, <span class="keyword">null</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内省操作非常的繁琐，所以 Apache 开发了一套简单、易用的API来操作 Bean 的属性——<a href="http://commons.apache.org/beanutils/" target="_blank" rel="noopener">BeanUtils工具包</a>。</p><blockquote><p>注意：应用的时候还需要一个 <a href="http://commons.apache.org/logging/" target="_blank" rel="noopener">logging包</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/commons-beanutils/commons-beanutils --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用 BeanUtils 示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Person person = <span class="keyword">new</span> Person();</span><br><span class="line">  BeanUtils.setProperty(person, <span class="string">"name"</span>, <span class="string">"Freya"</span>);</span><br><span class="line">  BeanUtils.setProperty(person, <span class="string">"age"</span>, <span class="number">17</span>);</span><br><span class="line">  BeanUtils.setProperty(person, <span class="string">"id"</span>, <span class="number">1011</span>);</span><br><span class="line">  System.out.println(BeanUtils.getProperty(person, <span class="string">"name"</span>));</span><br><span class="line">  System.out.println(<span class="string">"get name type:"</span> + BeanUtils.getProperty(person, <span class="string">"name"</span>).getClass().getName());</span><br><span class="line">  System.out.println(BeanUtils.getProperty(person, <span class="string">"age"</span>));</span><br><span class="line">  System.out.println(<span class="string">"get age type:"</span> + BeanUtils.getProperty(person, <span class="string">"age"</span>).getClass().getName()); <span class="comment">// get age type:java.lang.String</span></span><br><span class="line">  System.out.println(<span class="string">"get age type:"</span> + PropertyUtils.getProperty(person, <span class="string">"age"</span>).getClass().getName()); <span class="comment">// get age type:java.lang.Integer</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设置属性的值，例如，BeanUtils.setProperty(person, “age”, 8)，参数是字符串或基本类型自动包装。设置属性的值是字符串，获得的值也是字符串，不是基本类型。</p><p>PropertyUtils 类和 BeanUtils 不同在于，运行 getProperty、setProperty 操作时，没有类型转换，使用属性的原有类型或者包装类。</p></blockquote><h2 id="VO、DTO、POJO、DTO、BO的区别"><a href="#VO、DTO、POJO、DTO、BO的区别" class="headerlink" title="VO、DTO、POJO、DTO、BO的区别"></a>VO、DTO、POJO、DTO、BO的区别</h2><h3 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h3><p>value object值对象，主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象。然后用一个 VO 对象在控制层与视图层进行传输交换。</p><h3 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h3><p>Data Transfer Object 数据传输对象，经过处理后的PO，可能增加或者减少PO的属性。主要用于远程调用等需要大量传输对象的地方。比如我们一张表有100个字段，那么对应的 PO 就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</p><h3 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h3><p>Plain Ordinary Java Object，是一个简单的普通的Java对象。简单 Java 对象是一种概念或者接口，身份及作用随环境变化而变化。POJO 有一些private的参数作为对象的属性。然后针对每个参数定义了get和set方法作为访问的接口。它不包含业务逻辑或持久逻辑等，但不是JavaBean、EntityBean等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。POJO对象有时也被称为Data对象，大量应用于表现现实中的对象。<br>一个POJO持久化以后就是PO。直接用它传递、传递过程中就是DTO。直接用来对应表示层就是VO。</p><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>PO持久化到数据库是要进行相关的数据库操作的(CRUQ)，这些对数据库操作的方法会统一放到一个 Java 对象中，这就是DAO。</p><h3 id="BO"><a href="#BO" class="headerlink" title="BO"></a>BO</h3><p>POJO在业务层的体现，对于业务操作来说，更多的是从业务上来包装对象，如一个User的BO，可能包括name, age, sex, privilege, group等，这些属性在数据库中可能会在多张表中，因为每一张表对应一个PO，而我们的BO需要这些PO组合起来(或说重新拼装)才能成为业务上的一个完整对象。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>POJO仅包含最简单的字段属性，没有多余的东西，它本质上就是一个普通的 JavaBean。但是在POJO的基础上，能够扩展出不同的对象。</p><ol><li>为 POJO 增加了持久化的方法（Insert、Update、Delete……）之后，POJO 就变成了 PO。</li><li>为 POJO 增加了数据绑定功能之后，POJO 就变成了 View Object，即UI Model。</li><li>为 POJO 增加业务逻辑的方法（比如单据审核、转帐……）之后，POJO就变成了Domain Model。</li><li>POJO 还可以当作 DTO 使用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaBean-定义&quot;&gt;&lt;a href=&quot;#JavaBean-定义&quot; class=&quot;headerlink&quot; title=&quot;JavaBean 定义&quot;&gt;&lt;/a&gt;JavaBean 定义&lt;/h2&gt;&lt;p&gt;在 Java 中，有很多&lt;code&gt;class&lt;/code&gt;的定义都
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java常用工具类</title>
    <link href="https://muhouer.github.io/posts/8b50b566/"/>
    <id>https://muhouer.github.io/posts/8b50b566/</id>
    <published>2019-09-08T01:08:00.000Z</published>
    <updated>2019-09-08T01:08:31.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK-自带"><a href="#JDK-自带" class="headerlink" title="JDK 自带"></a>JDK 自带</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p><p>求绝对值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(-<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">Math.abs(-<span class="number">2.2</span>); <span class="comment">// 2.2</span></span><br></pre></td></tr></table></figure><p>取最大或最小值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max(100, 101); // 101</span><br><span class="line">Math.min(1.2, 3.1); // 1.2</span><br></pre></td></tr></table></figure><p>计算x^y次方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure><p>计算√x：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.4142135623730951</span></span><br></pre></td></tr></table></figure><p>计算指数与对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.38905609893065</span></span><br><span class="line">Math.log(<span class="number">2</span>); <span class="comment">// 以 e 为底的对数 0.6931471805599453</span></span><br><span class="line">Math.log10(<span class="number">2</span>); <span class="comment">// 以 10 为底的对数 0.3010299956639812</span></span><br></pre></td></tr></table></figure><p>三角函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br></pre></td></tr></table></figure><p>Math还提供了几个数学常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">// 2.7182818...</span></span><br></pre></td></tr></table></figure><p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure><p>Java 标准库还提供了一个 <code>StrictMath</code>，它提供了和 <code>Math</code> 几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，<code>StrictMath</code> 保证所有平台计算结果都是完全相同的，而 <code>Math</code> 会尽量针对平台优化计算速度，所以，绝大多数情况下，使用 <code>Math</code> 就足够了。</p><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p><p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">r.nextInt(); <span class="comment">// 245439114,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 9,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// -485876652878521410,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.6454043,生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.44460046556701727,生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure><p>创建 <code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。如果我们在创建 <code>Random</code> 实例时指定一个种子，就会得到完全确定的随机数序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random(<span class="number">12345</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   System.out.println(r.nextInt(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    51</span></span><br><span class="line"><span class="comment">//    80</span></span><br><span class="line"><span class="comment">//    41</span></span><br><span class="line"><span class="comment">//    28</span></span><br><span class="line"><span class="comment">//    55</span></span><br><span class="line"><span class="comment">//    84</span></span><br><span class="line"><span class="comment">//    75</span></span><br><span class="line"><span class="comment">//    2</span></span><br><span class="line"><span class="comment">//    1</span></span><br><span class="line"><span class="comment">//    89</span></span><br></pre></td></tr></table></figure><p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code> 无法指定种子，它使用RNG（random number generator）算法。JDK的 <code>SecureRandom</code> 实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SecureRandom sr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      sr = SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">      sr = <span class="keyword">new</span> SecureRandom(); <span class="comment">// 获取普通的安全随机数生成器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">    sr.nextBytes(buffer); <span class="comment">// 用安全随机数填充buffer</span></span><br><span class="line">    System.out.println(Arrays.toString(buffer));</span><br><span class="line">    System.out.println(sr.nextInt());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code> 的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p><p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用 <code>SecureRandom</code> 来产生安全的随机数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK-自带&quot;&gt;&lt;a href=&quot;#JDK-自带&quot; class=&quot;headerlink&quot; title=&quot;JDK 自带&quot;&gt;&lt;/a&gt;JDK 自带&lt;/h2&gt;&lt;h3 id=&quot;Math&quot;&gt;&lt;a href=&quot;#Math&quot; class=&quot;headerlink&quot; title=&quot;M
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="常用工具类" scheme="https://muhouer.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java中大数表示</title>
    <link href="https://muhouer.github.io/posts/d9f6149f/"/>
    <id>https://muhouer.github.io/posts/d9f6149f/</id>
    <published>2019-09-08T00:39:30.000Z</published>
    <updated>2019-09-08T00:40:19.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>在 Java 中，由 CPU 原生提供的整型最大范围是 64 位 <code>long</code> 型整数。使用 <code>long</code> 型整数可以直接通过 CPU 指令进行计算，速度非常快。如果我们使用的整数范围超过了 <code>long</code> 型就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code> 就是用来表示任意大小的整数。<code>BigInteger</code> 内部用一个 <code>int[]</code> 数组来模拟一个非常大的整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure><p>使用 BigInteger` 做运算的时候，只能使用实例方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i1 = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);</span><br><span class="line">BigInteger i2 = <span class="keyword">new</span> BigInteger(<span class="string">"12345678901234567890"</span>);</span><br><span class="line">BigInteger sum = i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure><p>和 <code>long</code> 型整数运算比，<code>BigInteger</code> 不会有范围限制，但缺点是速度比较慢。也可以把 <code>BigInteger</code> 转换成 <code>long</code> 型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i = <span class="keyword">new</span> BigInteger(<span class="string">"123456789000"</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure><p>使用 <code>longValueExact()</code> 方法时，如果超出了 <code>long</code> 型的范围，会抛出 <code>ArithmeticException</code>。</p><p><code>BigInteger</code> 和 <code>Integer</code>、<code>Long</code> 一样，也是不可变类，并且也继承自 <code>Number</code> 类。因为 <code>Number</code> 定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>因此，通过上述方法，可以把 <code>BigInteger</code> 转换成基本类型。<strong>如果 <code>BigInteger</code> 表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</strong></p><p>如果 <code>BigInteger</code> 的值甚至超过了<code>float</code>的最大范围（3.4x1038），那么返回的float是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BigInteger n = <span class="keyword">new</span> BigInteger(<span class="string">"999999"</span>).pow(<span class="number">99</span>);</span><br><span class="line">    <span class="keyword">float</span> f = n.floatValue();</span><br><span class="line">    System.out.println(f); <span class="comment">// Infinity</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>和 <code>BigInteger</code> 类似，<code>BigDecimal</code> 可以表示一个任意大小且精度完全准确的浮点数，常用于财务计算。如果查看 <code>BigDecimal</code> 的源码，可以发现，实际上一个 <code>BigDecimal</code> 是通过一个 <code>BigInteger</code> 和一个 <code>scale</code> 来表示的，即 <code>BigInteger</code> 表示一个完整的整数，而 <code>scale</code> 表示小数位数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimal</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code> 也是从 <code>Number</code> 继承的，也是不可变对象。</p><p>通过 <code>BigDecimal</code> 的 <code>stripTrailingZeros()</code> 方法，可以将一个 <code>BigDecimal</code> 格式化为一个相等的，但去掉了末尾0的 <code>BigDecimal</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.4500"</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">"1234500"</span>);</span><br><span class="line">BigDecimal d4 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><p>如果一个 <code>BigDecimal</code> 的 <code>scale()</code> 返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个 <code>BigDecimal</code> 设置它的 <code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456789"</span>);</span><br><span class="line">        BigDecimal d2 = d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">        BigDecimal d3 = d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456"</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">"23.456789"</span>);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br></pre></td></tr></table></figure><p>在比较两个 <code>BigDecimal</code> 的值是否相等时，要特别注意，使用 <code>equals()</code> 方法不但要求两个 <code>BigDecimal</code> 的值相等，还要求它们的 <code>scale()</code> 相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456"</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.45600"</span>);</span><br><span class="line">System.out.println(d1.equals(d2)); <span class="comment">// false,因为scale不同</span></span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="comment">// true,因为d2去除尾部0后scale变为2</span></span><br><span class="line">System.out.println(d1.compareTo(d2)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>必须使用 <code>compareTo()</code> 方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BigInteger&quot;&gt;&lt;a href=&quot;#BigInteger&quot; class=&quot;headerlink&quot; title=&quot;BigInteger&quot;&gt;&lt;/a&gt;BigInteger&lt;/h2&gt;&lt;p&gt;在 Java 中，由 CPU 原生提供的整型最大范围是 64 位 &lt;code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="https://muhouer.github.io/posts/4522df16/"/>
    <id>https://muhouer.github.io/posts/4522df16/</id>
    <published>2019-09-07T07:25:00.000Z</published>
    <updated>2019-09-08T01:13:41.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><blockquote><p>序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。恰当的序列化协议不仅可以提高系统的通用性、强健性、安全性、优化系统性能，而且会让系统更加易于调试、便于扩展。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li><strong>序列化：将数据结构或对象转换成二进制串的过程，在 Java 中对应把对象转换为字节序列的过程。</strong></li><li><strong>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程，在 Java 中对应把字节序列恢复为对象的过程。</strong></li></ol><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li><p>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。</p></li><li><p>在网络上传送对象的字节序列。</p></li></ol><h2 id="JDK-类库中的序列化API"><a href="#JDK-类库中的序列化API" class="headerlink" title="JDK 类库中的序列化API"></a>JDK 类库中的序列化API</h2><blockquote><ol><li><p>在序列化过程中，如果被序列化的类中定义了 writeObject() 和 readObject() 方法，虚拟机会试图调用对象类里的 writeObject() 和 readObject() 方法，进行用户自定义的序列化和反序列化。如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject() 方法以及 ObjectInputStream 的 defaultReadObject() 方法。</p></li><li><p>用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。</p></li></ol></blockquote><p><code>ObjectOutputStream</code> 代表对象输出流，它的 <code>writeObject(Object obj)</code> 方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p><code>ObjectInputStream</code> 代表对象输入流，它的 <code>readObject()</code> 方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</p><p>只有实现了 <code>Serializable</code> 和 <code>Externalizable</code> 接口的类的对象才能被序列化。<code>Externalizable</code> 接口继承自 <code>Serializable</code> 接口，实现 <code>Externalizable</code> 接口的类完全由自身来控制序列化的行为，而仅实现 <code>Serializable</code> 接口的类可以采用默认的序列化方式 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><strong>对象序列化步骤</strong></p><ol><li>创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；</li><li>通过对象输出流的writeObject()方法写对象。</li></ol><p><strong>对象反序列化步骤</strong></p><ol><li>创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；</li><li>通过对象输入流的readObject()方法读取对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Initializes The Object</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"Freya"</span>);</span><br><span class="line">        user.setAge(<span class="number">17</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Write Obj to File</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>));</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(oos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Read Obj from File</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">            User newUser = (User) ois.readObject();</span><br><span class="line">            System.out.println(newUser);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(ois);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileUtils.forceDelete(file);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化版本号"><a href="#序列化版本号" class="headerlink" title="序列化版本号"></a>序列化版本号</h3><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量 <code>serialVersionUID</code>。<code>serialVersionUID</code> 的取值是 Java 运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的 <code>serialVersionUID</code> 的取值有可能也会发生变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID</span><br></pre></td></tr></table></figure><p>如果没有指定类的 <code>serialVersionUID</code>，Java 编译器会自动给这个 class 进行一个摘要算法，类似于指纹算法，只要这个文件多一个空格，得到的 <code>serialVersionUID</code> 就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个字段后，由于没有显指定 <code>serialVersionUID</code>，编译器又为我们生成了一个 <code>serialVersionUID</code>，当然和前面保存在文件中的那个不会一样了，于是就会出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了 <code>serialVersionUID</code>，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原。</p><p>类的 <code>serialVersionUID</code> 的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。<strong>为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值</strong>。</p><p>显式地定义serialVersionUID有两种用途：</p><ol><li><p>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的 <code>serialVersionUID</code>；</p></li><li><p>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的 <code>serialVersionUID</code>。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p><code>Serializable</code> 只是一个接口，本身没有任何实现。如果一个类想被序列化，需要实现Serializable接口。否则将抛出<code>NotSerializableException</code>异常。因为在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum、String和Serializable类型其中的任何一种。(当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。)</p></li><li><p>对象的反序列化并没有调用对象的任何构造方法。序列化时，只对对象的状态进行保存，而不管对象的方法。</p></li><li><p>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化。</p></li><li><p>并非所有的对象都可以序列化，比如：</p><ul><li>安全方面的原因，比如一个对象拥有 private，public 等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</li><li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</li></ul></li><li><p>serialVersionUID 是用于记录文件版本信息的，最好能够自定义。否则，系统会自动生成 serialVersionUID，文件或者对象的任何改变，都会改变 serialVersionUID，导致反序列化的失败，如果自定义就没有这个问题</p></li><li><p>声明为 <code>static</code> 和 <code>transient</code> 类型的成员数据不能被序列化。因为 <code>static</code> 代表类的状态，<code>transient</code> 代表对象的临时数据。</p></li><li><p><code>Serializable</code> 的系统实现是采用 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 实现的，调用 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 时，需要对应的类实现 <code>Serializable</code> 接口。</p></li><li><p>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p></li><li><p>Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。反序列化时，恢复引用关系。该存储规则极大的节省了存储空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>));</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//试图将对象两次写入文件</span></span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.flush();</span><br><span class="line">System.out.println(<span class="keyword">new</span> File(<span class="string">"tempFile"</span>).length());</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line">System.out.println(<span class="keyword">new</span> File(<span class="string">"tempFile"</span>).length());</span><br><span class="line"></span><br><span class="line">ObjectInputStream oin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"tempFile"</span>));</span><br><span class="line"><span class="comment">//从文件依次读出两个文件</span></span><br><span class="line">User t1 = (User) oin.readObject();</span><br><span class="line">User t2 = (User) oin.readObject();</span><br><span class="line">oin.close();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//判断两个引用是否指向同一个对象</span></span><br><span class="line">System.out.println(t1 == t2);</span><br></pre></td></tr></table></figure></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="序列化与单例模式"><a href="#序列化与单例模式" class="headerlink" title="序列化与单例模式"></a>序列化与单例模式</h3><h4 id="序列化对单例的破坏"><a href="#序列化对单例的破坏" class="headerlink" title="序列化对单例的破坏"></a>序列化对单例的破坏</h4><p>使用反射可以破坏单例模式，除了反射以外，使用序列化与反序列化也同样会破坏单例。</p><p>单例示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试序列化对单例模式的破坏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonSerializableTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Write Obj to file</span></span><br><span class="line">    <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>))) &#123;</span><br><span class="line">      oos.writeObject(Singleton.getSingleton());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Read Obj from file</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">    Singleton newInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file))) &#123;</span><br><span class="line">      newInstance = (Singleton) ois.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == newInstance) &#123;</span><br><span class="line">        System.out.println(<span class="string">"newInstance is null"</span>); <span class="comment">// 不打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是同一个对象</span></span><br><span class="line">    System.out.println(Singleton.getSingleton() == newInstance); <span class="comment">// false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过对 Singleton 的序列化与反序列化得到的对象是一个新的对象，这就破坏了 Singleton 的单例性。这是因为序列化会通过反射调用无参数的构造方法创建一个新的对象。</strong></p><h4 id="防止序列化破坏单例模式"><a href="#防止序列化破坏单例模式" class="headerlink" title="防止序列化破坏单例模式"></a>防止序列化破坏单例模式</h4><p>在 Singleton 类中定义 <code>readResolve</code> 就可以解决该问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Singleton 类中定义 <code>readResolve</code> 可以防止序列化破坏单例模式，实现如下：</p><ol><li><code>ObjectOutputStream</code> 的 <code>writeObject()</code> 调用 <code>writeObject0()</code>，<code>writeObject0()</code> 里会调用 <code>writeOrdinaryObject()</code>。</li><li>在 <code>writeOrdinaryObject()</code> 中会通过 <code>hasReadResolveMethod</code> 进行判断，如果实现了Serializable 或者 Externalizable 接口的类中包含 <code>readResolve</code> 则返回 true。从而调用 <code>invokeReadResolve</code>，通过反射的方式调用要被反序列化的类的 <code>readResolve()</code> 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="keyword">null</span> </span><br><span class="line">    &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">    <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">        rep = cloneArray(rep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">        handles.setObject(passHandle, obj = rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化与对象的深拷贝"><a href="#序列化与对象的深拷贝" class="headerlink" title="序列化与对象的深拷贝"></a>序列化与对象的深拷贝</h3><p>实现对象的深拷贝有以下几种方法：</p><ol><li>实现 Clonable 接口，重写 clone() 方法，这种方法没有通用性，优点在于实现简单，并且可以实现定制化。</li><li>基于反射，BeanUtil、Spring 核心包提供的一个工具类，基本原理就是获取 class 实例化，再通过反射实现对象的深拷贝。</li><li>基于Serialize、Deserialize 实现，这种办法比较多，本质上和反射类似，反射相当于 JVM 提供，而 Serialize 是基于上层协议。具体实现可以参考 RMI、thrift、protobuf 序列化方式。</li><li>基于 Unsafe 内存，这种方法极不推荐使用，直接复制对象内存空间，容易造成内存泄露。</li></ol><p>在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">    T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//写入字节流</span></span><br><span class="line">      ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">      ObjectOutputStream obs = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">      obs.writeObject(obj);</span><br><span class="line">      obs.close();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//分配内存，写入原始对象，生成新对象</span></span><br><span class="line">      ByteArrayInputStream ios = <span class="keyword">new</span> ByteArrayInputStream(out.toByteArray());</span><br><span class="line">      ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(ios);</span><br><span class="line">      <span class="comment">//返回生成的新对象</span></span><br><span class="line">      cloneObj = (T) ois.readObject();</span><br><span class="line">      ois.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也可以使用 Apache 推出的 SerializationUtils 序列化工具类</p><h4 id="SerializationUtils-功能"><a href="#SerializationUtils-功能" class="headerlink" title="SerializationUtils 功能"></a>SerializationUtils 功能</h4><ul><li>使用序列化进行深度克隆</li><li>序列化对象</li><li>反序列化对象</li></ul><h4 id="SerializationUtils-优缺点"><a href="#SerializationUtils-优缺点" class="headerlink" title="SerializationUtils  优缺点"></a>SerializationUtils 优缺点</h4><ul><li>深度拷贝实现比较简单，不用实现Cloneable接口。</li><li>深度拷贝<strong>效率不如实现Cloneable接口高</strong>。</li><li>序列化和反序列化，是基于jdk自带的序列化，速度慢，占空间。效率不如Protostuff、Hessian、Kryo等专业序列化工具高。</li></ul><p>更深入的序列化知识可以参考: <a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html" target="_blank" rel="noopener">序列化和反序列化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序列化和反序列化&quot;&gt;&lt;a href=&quot;#序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化和反序列化&quot;&gt;&lt;/a&gt;序列化和反序列化&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="序列化" scheme="https://muhouer.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>演化杂记</title>
    <link href="https://muhouer.github.io/posts/4b4e75fa/"/>
    <id>https://muhouer.github.io/posts/4b4e75fa/</id>
    <published>2019-09-03T16:50:36.000Z</published>
    <updated>2019-09-03T16:56:25.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为什么现在的孩子越来越高、越来越胖？<br>为什么青少年糖尿病越来越多、发病年龄越来越小？<br>为什么越来越多的现代人患上了哮喘、过敏性鼻炎以及五花八门的食物过敏？<br>种种“现代疾病”背后是否有个共同的“罪魁祸首”？</p><p>美国著名科学家马丁布莱泽认为，在过去的几十年里，由于滥用抗生素及剖宫产，我们在不经意间已经伤害了与人类协同演化了数十万年之久的“微生物朋友”，特别是在我们的孩子们身上。这扰乱了人体内微生物的稳态，打破了人体与微生物之间的平衡，进而危害了我们孩子的代谢、免疫和认知能力。</p><footer><strong>微生物</strong></footer></blockquote><hr><blockquote><p>所谓碳基，其实是碳氮合体，碳四氮五氧六氢一，勾结出的一类扭曲生命，柔弱而多愁善感，利用电子结合化学能繁衍生息，能量利用总量低而熵效率高，因此能一直默默不查的偷生于宇宙中而繁衍数十亿年。碳基生命需要用氧氢化合物为催化剂，所以在宇宙背景温度到373k以下时才有萌芽可能，之前没有碳基生命存在。</p><p>地球上的碳基生命经过数亿年进化，于西元1900年发现光电效应，并进一步开发出硅基光电板，由此接触到硅基生命能量模式。硅基生命为镓锗合体，以硅氧为催化剂，利用光电效应直接产生能量繁衍生息。硅基以光传导能量进行代谢，低端硅基生命身体透明，有智能的高级硅基生命布满光纤，以硅氧熔沸点预测，在宇宙背景温度到2500k以下时才有萌芽可能，之前没有硅基生命存在。</p><p>碳基生命西元1945年第一次核爆敲开了铁基生命的大门。铁基以核能为驱动，生命温度在铁沸点以上，以气态和离子态存在，可以说在第一个铁元素诞生的时候就有了铁基生命，铁基生命能量利用巨大，一个低端铁基生命每秒耗费的能量相当于一个广岛原子弹。铁基生命是宇宙中最耀眼的生命，信息以量子纠缠传递，可以轻易实现虫洞在星系间穿梭，是最适合宇宙级生存的生命。</p><p>以能量产生和消耗方式来看，硅基生命不过是在食用铁基生命代谢出的废物－光来生存，而碳基生命则是更低等的生命，食用硅基生命的代谢产物－低端化学能来生存，这些低端化学能产生的光和热能不足以满足硅基生命的生存下限。</p><footer><strong>碳基、硅基、铁基</strong></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;为什么现在的孩子越来越高、越来越胖？&lt;br&gt;为什么青少年糖尿病越来越多、发病年龄越来越小？&lt;br&gt;为什么越来越多的现代人患上了哮喘、过敏性鼻炎以及五花八门的食物过敏？&lt;br&gt;种种“现代疾病”背后是否有个共同的“罪魁祸首”？&lt;/p&gt;&lt;p&gt;美国著名科学家
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="https://muhouer.github.io/posts/2b9621c6/"/>
    <id>https://muhouer.github.io/posts/2b9621c6/</id>
    <published>2019-09-03T16:39:00.000Z</published>
    <updated>2019-09-03T16:41:56.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul><li><p><strong>进程(Process)</strong>：计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p></li><li><p><strong>线程(Thread)</strong>：进程的组成部分，它代表了一条顺序的执行流。线程依托于进程存在，在进程之下，可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据。</p></li><li><p><strong>并行(parallel)</strong>：指在同一时刻，有多条指令在多个处理器上同时执行。</p></li></ul><p><img src="/images/201909040011.png" alt="parallel"></p><ul><li><strong>并发(concurrency)</strong>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li></ul><p><img src="/images/201909040012.png" alt="concurrency"></p><blockquote><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><p>不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源。</p></blockquote><hr><p><strong>@UsesJava8</strong></p><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><p>使用线程池有三个好处</p><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><p>但是只有对线程池原理有深入的了解才能最大程度发挥线程池的作用。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过 <code>ThreadPoolExecutor</code> 来创建一个线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="comment">// 核心线程数</span></span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize, <span class="comment">// 最大线程数</span></span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime, <span class="comment">// 线程存活时间</span></span><br><span class="line">                   TimeUnit unit, <span class="comment">// 线程存活时间的单位</span></span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 阻塞队列</span></span><br><span class="line">                   ThreadFactory threadFactory, <span class="comment">// 创建线程的工厂</span></span><br><span class="line">                   RejectedExecutionHandler handler)  <span class="comment">// 拒绝策略</span></span><br></pre></td></tr></table></figure><p>参数解释如下：</p><ul><li><p><strong>corePoolSize</strong>: 当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于<strong>核心线程数</strong>时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有核心线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>maximumPoolSize</strong>: 线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</p></li><li><p><strong>keepAliveTime</strong>: 线程池的工作线程空闲后，存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p></li><li><p><strong>unit</strong>： 可选的单位有 <code>DAYS</code>，<code>HOURS</code>，<code>MINUTES</code>，<code>MILLISECONDS</code>，<code>MICROSECONDS</code>，<code>NANOSECONDS</code>。参考<code>TimeUnit</code></p></li><li><p><strong>workQueue</strong>: 用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ul><li><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法 <code>Executors.newFixedThreadPool()</code> 使用了这个队列</li><li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 <code>LinkedBlockingQueue</code>，静态工厂方法 <code>Executors.newCachedThreadPool</code> 使用了这个队列。</li><li><code>PriorityBlockingQueue</code>：一个具有优先级得无限阻塞队列。</li></ul></li><li><p><strong>threadFactory</strong>: 可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug 和定位问题时非常又帮助。</p></li><li><p><strong>handler</strong>: 当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。</p><ul><li><p><code>CallerRunsPolicy</code>: 调用者运行策略。当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。一般在不允许失败的、对性能要求不高、并发量较小的场景下使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>AbortPolicy</code>: 中止策略。当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>DiscardPolicy</code>: 丢弃策略。不触发任何动作地丢弃这个任务。如果你提交的任务无关紧要，你就可以使用它 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>DiscardOldestPolicy</code>: 弃老策略。如果线程池未关闭，就弹出队列头部的元素，然后尝试执行。发布消息，和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><h4 id="通过-execute-向线程池提交任务"><a href="#通过-execute-向线程池提交任务" class="headerlink" title="通过 execute 向线程池提交任务"></a>通过 <code>execute</code> 向线程池提交任务</h4><p>execute 方法没有返回值，无法判断任务知否被线程池执行成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get(); <span class="comment">// 获取到当前有效的线程数和线程池的状态</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 线程数小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 在addWorker中创建工作线程执行任务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 线程池是否处于运行状态，且是否任务插入任务队列成功</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 线程池是否处于运行状态，如果不是则使刚刚的任务出队</span></span><br><span class="line">            reject(command); <span class="comment">// 执行拒绝策略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 继续创建线程</span></span><br><span class="line">    &#125; <span class="comment">// 插入队列不成功，且当前线程数数量小于最大线程池数量，此时则创建新线程执行任务，创建失败抛出异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command); <span class="comment">// 创建线程失败执行拒绝策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过-submit向线程池提交任务"><a href="#通过-submit向线程池提交任务" class="headerlink" title="通过 submit向线程池提交任务"></a>通过 <code>submit</code>向线程池提交任务</h4><p>submit 方法返回一个 future ，可以通过这个 future 来判断任务是否执行成功，通过 future 的 get() 方法来获取返回值，get() 方法会阻塞住直到任务完成，而使用 get(long timeout, TimeUnit unit) 方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p>我们可以通过调用线程池的 shutdown() 或 shutdownNow() 方法来关闭线程池，但是它们的实现原理不同，shutdown 的原理是只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。shutdownNow 的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt() 方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow 会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</p><p>只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 isTerminaed() 方法会返回 true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。</p><h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p><strong>通过线程池提供的参数进行监控</strong>。线程池里有一些属性在监控线程池的时候可以使用</p><ul><li><strong>taskCount</strong>: 线程池需要执行的任务数量。</li><li><strong>completedTaskCount</strong>: 线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li><li><strong>largestPoolSize</strong>: 线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li><li><strong>getPoolSize</strong>: 线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。</li><li><strong>getActiveCount</strong>：获取活动的线程数。</li></ul><p><strong>通过扩展线程池进行监控</strong>。通过继承线程池并重写线程池的 beforeExecute，afterExecute 和 terminated 方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的配置策略"><a href="#线程池的配置策略" class="headerlink" title="线程池的配置策略"></a>线程池的配置策略</h2><h3 id="根据任务性质设置"><a href="#根据任务性质设置" class="headerlink" title="根据任务性质设置"></a>根据任务性质设置</h3><p>通常这种设置方式是比较粗略的方式。要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p><ol><li><p><strong>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</strong></p><p>CPU 密集型任务配置尽可能小的线程，如配置CPU数+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*CPU数。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 方法获得当前设备的CPU个数。</p></li><li><p><strong>任务的优先级：高，中和低。</strong></p></li><li><p><strong>任务的执行时间：长，中和短。</strong></p><p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p></li><li><p><strong>任务的依赖性：是否依赖其他系统资源，如数据库连接。</strong></p><p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p></li></ol><p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。如果使用无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。</p><h3 id="利特尔法则"><a href="#利特尔法则" class="headerlink" title="利特尔法则"></a>利特尔法则</h3><blockquote><p>利特尔法则（Little’s law）是说，一个系统请求数等于请求的到达率与平均每个单独请求花费的时间之乘积。</p></blockquote><p>我们可以使用利特尔法则（Little’s law）来判定线程池大小。我们只需计算请求到达率和请求处理的平均时间。然后，将上述值放到利特尔法则（Little’s law）就可以算出系统平均请求数。若请求数小于我们线程池的大小，就相应地减小线程池的大小。与之相反，如果请求数大于线程池大小，事情就有点复杂了。</p><p>当遇到有更多请求待处理的情况时，我们首先需要评估系统是否有足够的能力支持更大的线程池。准确评估的前提是，我们必须评估哪些资源会限制应用程序的扩展能力。最简单的情况是，我们有足够的空间增加线程池的大小。若没有的话，你不得不考虑其它选项，如软件调优、增加硬件，或者调优并增加硬件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a&gt;一些概念&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;进程(Process)&lt;/strong&gt;：计算机中的程序关于某数据集合上的一次运行活动，是系
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
    
      <category term="线程池" scheme="https://muhouer.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>拾句-甜</title>
    <link href="https://muhouer.github.io/posts/ead251ab/"/>
    <id>https://muhouer.github.io/posts/ead251ab/</id>
    <published>2019-09-02T16:53:44.000Z</published>
    <updated>2019-09-02T17:02:33.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="星星睡不着，在数人类。"><a href="#星星睡不着，在数人类。" class="headerlink" title="星星睡不着，在数人类。"></a>星星睡不着，在数人类。</h3><ol><li><strong>有一些小猫假扮成人类来跟我们相爱。</strong></li><li><strong>我也就一般甜啦，也就半糖烤奶加泷珠。</strong></li><li><strong>我们一块儿发会呆吧。</strong></li><li><strong>我永远屈服于温柔，而你是温柔本身。</strong></li><li><strong>放下你的刀，来做本王的妻子吧。</strong></li><li><strong>每天都会有让人长胖的好事情发生。</strong></li><li><strong>你的春日好运正在派件，请保持心情舒畅。</strong></li><li><strong>可爱之人必遇可爱之事。</strong></li><li><strong>希望下次喜欢和合适可以撞个满怀。</strong></li></ol><hr><h3 id="你是我见一个爱一个里面最爱的一个。"><a href="#你是我见一个爱一个里面最爱的一个。" class="headerlink" title="你是我见一个爱一个里面最爱的一个。"></a>你是我见一个爱一个里面最爱的一个。</h3><ol><li><strong>我要去宇宙了，回来摘星星给你。</strong></li><li><strong>好好生活，活到夏天。</strong></li><li><strong>这个人很懒，什么都没有留下。</strong></li><li><strong>既然来到这个世界的话，那就稍微喜欢一下它吧。</strong></li><li><strong>研究了一晚上宇宙，宇宙没理我。</strong></li><li><strong>这家伙很懒，却还想留下点儿什么。</strong></li><li><strong>一觉醒来，觉得甚是爱你。</strong></li><li><strong>你再不来，我就要下雪了。</strong></li><li><strong>所有的告别中，我最喜欢明天见。</strong></li></ol><hr><h3 id="我马上要恋爱了，和谁不知道，先替他高兴一下。"><a href="#我马上要恋爱了，和谁不知道，先替他高兴一下。" class="headerlink" title="我马上要恋爱了，和谁不知道，先替他高兴一下。"></a>我马上要恋爱了，和谁不知道，先替他高兴一下。</h3><ol><li><strong>薏仁做事薏仁汤，小丁做事小叮当。</strong></li><li><strong>既然来了就磕个头再走吧。</strong></li><li><strong>成熟的大人会不动声色的穿上秋裤。</strong></li><li><strong>请你一定要对号入座，我说的所有星光月亮、清泉小溪、蘸着糖的奶油和蜂蜜——这世间所有的美好事物，都只是为了形容你。</strong></li><li><strong>你不是什么小人物，在我这里你是所有的天气和心情。</strong></li><li><strong>我想对你做春天对樱桃树做的事。</strong></li><li><strong>国家二级退堂鼓演奏家</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;星星睡不着，在数人类。&quot;&gt;&lt;a href=&quot;#星星睡不着，在数人类。&quot; class=&quot;headerlink&quot; title=&quot;星星睡不着，在数人类。&quot;&gt;&lt;/a&gt;星星睡不着，在数人类。&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;有一些小猫假扮成人类来跟我们相爱。&lt;/st
      
    
    </summary>
    
    
  </entry>
  
</feed>

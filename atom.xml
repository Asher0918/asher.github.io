<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Muhouer</title>
  
  <subtitle>就是做个记录，先来5分钟的！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muhouer.github.io/"/>
  <updated>2019-08-28T17:27:28.564Z</updated>
  <id>https://muhouer.github.io/</id>
  
  <author>
    <name>Muhouer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java语法糖</title>
    <link href="https://muhouer.github.io/posts/a0d19409/"/>
    <id>https://muhouer.github.io/posts/a0d19409/</id>
    <published>2019-08-28T17:22:00.000Z</published>
    <updated>2019-08-28T17:27:28.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>语法糖(Syntactic Sugar)，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法。这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p><blockquote><p>语法盐(Syntactic Salt)是指在计算机语言设计中，不容易产生不良代码的特性。可以为容易犯的语法错误加上的额外语法限制，比如类型检查。</p><p>语法糖精也叫语法糖浆，指的是未能让编程更加方便的附加语法，一说是设计失败的语法糖。这个语法又麻烦又没用。</p><p>语法海洛因，是指过于喜欢操作符重载，使得程序表面上紧凑。操作符重载就是把已经定义的、有一定功能的操作符进行重新定义，来完成更为细致具体的运算等功能。操作符重载可以将概括性的抽象操作符具体化，便于外部调用而无需知晓内部具体运算过程。</p></blockquote><p>我们所熟知的编程语言中几乎都有语法糖。很多人说 Java 是一个 “低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在 “Project Coin” 项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着 “高糖” 的方向发展。</p><h2 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h2><p>语法糖的存在主要是方便开发人员使用。但其实，Java 虚拟机并不支持这些语法糖，这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</p><p><code>com.sun.tools.javac.main.JavaCompiler</code> 的源码中，compile() 有一个步骤就是调用 desugar() ，这个方法就是负责解语法糖的。</p><p>Java 中最常用的语法糖主要有 switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、foreach、try-with-resource、Lambda表达式等</p><h3 id="switch-支持-String-与枚举"><a href="#switch-支持-String-与枚举" class="headerlink" title="switch 支持 String 与枚举"></a>switch 支持 String 与枚举</h3><p>进行<code>switch</code>的实际是哈希值，然后通过使用<code>equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 switch 或者使用纯整数常量，但这也不是很差。</p><p>参考 <a href="/posts/4a48cd1d/" title="String分析">String分析</a></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>不同的编译器对于泛型的处理方式是不同的。通常情况下，一个编译器处理泛型有两种方式：<strong>Code specialization</strong>和 <strong>Code sharing</strong>。C++ 和 C#是使用 Code specialization 的处理机制，而 Java 使用的是 Code sharing 的处理机制。</p><p>Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。</p><p>也就是说，对于 Java 虚拟机来说，他根本不认识 <code>Map&lt;String, String&gt; map</code>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</p><p>参考 <a href="/posts/4127871b/" title="Java泛型解析">Java泛型解析</a></p><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱。</p><p>反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</p><p>原始类型 byte、short、char、int、long、float、double 和 boolean 对应的封装类为 Byte、Short、Character、Integer、Long、Float、Double、Boolean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;        </span><br><span class="line">Integer n = i; <span class="comment">//  装箱：Integer n = Integer.valueOf(i); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">Integer i = <span class="number">10</span>; <span class="comment">// Integer i = Integer.valueOf(10); </span></span><br><span class="line"><span class="keyword">int</span> n = i; <span class="comment">//  拆箱：int n = i.intValue(); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法变长参数"><a href="#方法变长参数" class="headerlink" title="方法变长参数"></a>方法变长参数</h3><p>可变参数 (<code>variable arguments</code>) 是在 Java 1.5 中引入的一个特性，它允许一个方法把任意数量的值作为参数。</p><p>可变参数在被使用的时候：</p><ol><li>首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数。</li><li>然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>Java SE5 提供了一种新的类型-Java 的枚举类型，关键字<code>enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p><p>当我们使用<code>enmu</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code>final</code>类型的类继承<code>Enum</code>类，所以枚举类型不能被继承。</p><p>参考 <a href="/posts/4502a76f/" title="枚举类型">枚举类型</a></p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。</p><p>Outer.java 里面定义了一个内部类 Inner，一旦编译成功，就会生成两个完全不同的 .class 文件了，分别是 Outer.class 和 Outer$Inner.class。所以<strong>内部类的名字完全可以和它的外部类名字相同</strong>。</p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>C、C++ 等许多语言提供了预处理的功能，并通过预处理来实现条件编译。Java 并没有提供类似的预处理功能，但是 Java 也可以实现条件编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"block 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断言语句"><a href="#断言语句" class="headerlink" title="断言语句"></a>断言语句</h3><p>断言在编译过后被转化成了语句所处类中的一个 static final boolean 字段，并在类初始化阶段借助静态语句块完成其初始化。在程序执行过程中，直接根据该字段判断断言是否开启，来决定是否执行断言检查。</p><h3 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a>数值字面量</h3><h4 id="支持的数字字面量表示"><a href="#支持的数字字面量表示" class="headerlink" title="支持的数字字面量表示"></a>支持的数字字面量表示</h4><p>十进制：默认的。</p><p>八进制：整数之前加数字 0 来表示。</p><p>十六进制：整数之前加“0x”或“0X”来表示。</p><p>二进制：整数之前加“0b”或“0B”来表示。</p><h4 id="在数值字面量中使用下划线"><a href="#在数值字面量中使用下划线" class="headerlink" title="在数值字面量中使用下划线"></a>在数值字面量中使用下划线</h4><p>在 Java 7 中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1_500_000 </span><br><span class="line">5_6.3_4 </span><br><span class="line">89_3___1</span><br></pre></td></tr></table></figure><blockquote><p><strong>下划线只能出现在数字中间，前后必须是数字。</strong>所以<code>_100</code>、<code>0b_101</code>是不合法的，无法通过编译。<br>这样限制的动机就是可以降低实现的复杂度。有了这个限制，Java 编译器只需在扫描源代码的时候将所发现的数字中间的下划线直接删除就可以了。如果不添加这个限制，编译器需要进行语法分析才能做出判断。比如：<code>_100</code>,可能是一个整数字面量 100，也可能是一个变量名称。这就要求编译器的实现做出更复杂的改动。</p></blockquote><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ul><li>对有实现 Iterable 接口的对象采用 foreach 语法糖的话，编译器会将这个 for 关键字转化为对目标的迭代器使用。如果要想使自己自定义的类可以采用foreach语法糖就必须实现Iterable接口。</li><li>对于数组而言，其实就是转换为普通的遍历。</li><li>对于实现 RandomAccess 接口的集合比如 ArrayList，应当使用最普通的 for 循环而不是 foreach 循环来遍历。</li></ul><p>实现 RandomAccess 接口的类实例，假如是随机访问的，使用普通 for 循环效率将高于使用 foreach 循环；反过来，如果是顺序访问的，则使用 Iterator 会效率更高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterable(); </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">      iterator.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。编译之后会判断对象是否为 null，如果不是 null，则调用 close 函数进行资源回收。</p><p>所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。不同的是 java.io.Closable 要求实现者保证 close 函数可以被重复调用。而 java.lang.AutoCloseable 的close 函数则不要求是幂等的。</p><p>try-with-resources 声明在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>TODO 待补充</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>javap 是 JDK 自带的反汇编器，可以查看 java 编译器为我们生成的字节码。通过它，我们可以对照源代码和字节码，从而了解很多编译器内部的工作。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>  <code>javap [option] class</code><br>javap 命令用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。</p><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><p>-help 输出 javap 的帮助信息。<br>-l 输出行及局部变量表。<br>-b 确保与 JDK 1.1 javap 的向后兼容性。<br>-public 只显示 public 类及成员。<br>-protected 只显示 protected 和 public 类及成员。<br>-package 只显示包、protected 和 public 类及成员。这是缺省设置。<br>-private 显示所有类和成员。<br>-J[flag] 直接将 flag 传给运行时系统。<br>-s 输出内部类型签名。<br>-c 输出类中各方法的未解析的代码，即构成 Java 字节码的指令。<br>-verbose 输出堆栈大小、各方法的 locals 及 args 数,以及class文件的编译版本<br>-classpath[路径] 指定 javap 用来查找类的路径。如果设置了该选项，则它将覆盖缺省值或 CLASSPATH 环境变量。目录用冒号分隔。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语法糖&quot;&gt;&lt;a href=&quot;#语法糖&quot; class=&quot;headerlink&quot; title=&quot;语法糖&quot;&gt;&lt;/a&gt;语法糖&lt;/h2&gt;&lt;p&gt;语法糖(Syntactic Sugar)，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="语法糖" scheme="https://muhouer.github.io/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
  </entry>
  
  <entry>
    <title>编码方式杂记</title>
    <link href="https://muhouer.github.io/posts/d6bee64/"/>
    <id>https://muhouer.github.io/posts/d6bee64/</id>
    <published>2019-08-28T16:11:08.000Z</published>
    <updated>2019-08-28T16:14:00.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ASCII-Unicode-UTF-8"><a href="#ASCII-Unicode-UTF-8" class="headerlink" title="ASCII - Unicode - UTF-8"></a>ASCII - Unicode - UTF-8</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p><p>ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p><p>汉字使用的符号多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号，所以，中国制定了GB2312编码，用来把中文编进去。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode应运而生，Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。具体的符号对应表，可以查询<a href="http://www.unicode.org/" target="_blank" rel="noopener">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字对应表</a>。</p><p>不过，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。这就导致 Unicode 有多种存储方式，即有许多种不同的二进制格式，可以用来表示 Unicode。如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是<code>0</code>，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>互联网的普及，强烈要求出现一种统一的编码方式。<strong>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式</strong>。浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器。很多网页的源码上会有类似 <code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的 UTF-8 编码。</p><p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>UTF-8 的编码规则很简单，只有二条：</p><ol><li><p>对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p></li><li><p>对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围      |        UTF-8编码方式</span><br><span class="line">(十六进制)           |              （二进制）</span><br><span class="line">--------------------+------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p>例如：<br><img src="/images/201908281058.png" width="800px" height="500px" align="center"></p><h2 id="UTF-8、UTF-16、UTF-32区别"><a href="#UTF-8、UTF-16、UTF-32区别" class="headerlink" title="UTF-8、UTF-16、UTF-32区别"></a>UTF-8、UTF-16、UTF-32区别</h2><p>UTF 意思是 Unicode 转换格式(Unicode Transform Format)， UTF-8、UTF-16、UTF-32 是为了在内存中存储字符而对 Unicode 字符编号进行编码。它们都是 Unicode 的实现方式，其中 <strong>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式</strong>。<strong>UTF-16(字符用 2 个字节或 4 个字节表示)</strong> 和 <strong>UTF-32(字符用 4 个字节表示)</strong>，不过在互联网上基本不用。</p><p>UTF-16 使用 2 或 4 个字节进行存储。对于 Unicode 编号范围在 0~FFFF 之间的字符，统一用两个字节存储，无需字符转换，直接存储 Unicode 编号。对于 Unicode 字符编号在 10000-10FFFF 之间的字符，UTF16 用 4 个字节存储。</p><p>UTF-32 用固定长度的字节存储字符编码，不管 Unicode 字符编号需要几个字节，全部都用 4 个字节存储，直接存储 Unicode 编号。无需经过字符编号向字符编码的转换步骤，提高效率，用空间换时间。</p><h2 id="GB2312、GBK、GB18030、GB13000之间的区别"><a href="#GB2312、GBK、GB18030、GB13000之间的区别" class="headerlink" title="GB2312、GBK、GB18030、GB13000之间的区别"></a>GB2312、GBK、GB18030、GB13000之间的区别</h2><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p><strong>GB2312 或 GB2312-80 是中国国家标准简体中文字符集</strong>，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持 GB2312。<br>，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。</p><ul><li>GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。</li><li>对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。</li></ul><p><strong>GB2312对任意一个图形字符都采用两个字节表示</strong>，并对所收汉字进行了“分区”处理，每区含有94个汉字／符号，分别对应第一字节和第二字节。这种表示方式也称为区位码。</p><ul><li>01-09区为特殊符号。</li><li>16-55区为一级汉字，按拼音排序。</li><li>56-87区为二级汉字，按部首／笔画排序。</li></ul><p>10-15区及88-94区则未有编码。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p><strong>GBK</strong>即，为汉语拼音 Kuo Zhan（扩展）中“扩”字的声母。英文全称Chinese Internal Code Specification。</p><ul><li>GB2312中的全部汉字、非汉字符号。</li><li>BIG5中的全部汉字。</li><li>与ISO 10646相应的国家标准GB13000中的其它CJK汉字，以上合计20902个汉字。</li><li>其它汉字、部首、符号，共计984个。</li></ul><p>GBK向下与GB2312 完全兼容，向上支持ISO 10646国际标准，在前者向后者过渡过程中起到的承上启下的作用。</p><p><strong>GBK 采用双字节表示</strong>，总体编码范围为8140-FEFE之间，首字节在81-FE之间，尾字节在40-FE之间，剔除XX7F一条线。GBK编码区分三部分：</p><ul><li><p>汉字区</p><ul><li>GBK/2：OXBOA1-F7FE，收录GB2312汉字6763个，按原序排列。</li><li>GBK/3：OX8140-AOFE，收录CJK汉字6080个。</li><li>GBK/4：OXAA40-FEAO，收录CJK汉字和增补的汉字8160个。</li></ul></li><li><p>图形符号区</p><ul><li>GBK/1：OXA1A1-A9FE，除GB2312的符号外，还增补了其它符号。</li><li>GBK/5：OXA840-A9AO，扩除非汉字区。</li></ul></li><li><p>用户自定义区</p><ul><li>GBK区域中的空白区，用户可以自己定义字符。</li></ul></li></ul><p>GBK 最初是由微软对 GB2312 的扩展，也就是CP936字码表 (Code Page 936)的扩展（原来的CP936和GB 2312-80一模一样），最初出现于Windows 95简体中文版中，由于Windows产品的流行和在大陆广泛被使用，中华人民共和国国家有关部门将其作为技术规范。<strong>注意 GBK 并非国家正式标准，只是国家技术监督局标准化司、电子工业部科技与质量监督司发布的“技术规范指导性文件”。</strong>虽然 GBK 收录了所有 Unicode 1.1 及 GB 13000.1-93 之中的汉字，但是编码方式与 Unicode 1.1 及 GB 13000.1-93 不同。仅仅是 GB2312 到 GB13000.1-93 之间的过渡方案。GBK 收录了 21886 个符号，它分为汉字区和图形符号区。汉字区包括 21003 个字符。</p><p>GBK 作为对 GB2312 的扩展，在现在的 Windows 系统中仍然使用代码页 CP936 表示，但是同样的 936 的代码页跟一开始的 936 的代码页只支持 GB2312 编码不同，现在的 936 代码页支持 GBK 的编码，GBK 同时也向下兼容 GB2312 编码。</p><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p><strong>GB18030</strong>，全称是中华人民共和国现时最新的内码字集，是GB18030-2000《信息技术信息交换用汉字编码字符集基本集的扩充》的修订版。</p><p><strong>GB18030</strong> 与 <strong>GB2312-1980</strong> 完全兼容，与 GBK 基本兼容，支持 GB13000 及 Unicode 的全部统一汉字，共收录汉字 70244 个。</p><ul><li>与 UTF-8 相同，采用多字节编码，每个字可以由1个、2个或4个字节组成。</li><li>编码空间庞大，最多可定义161万个字符。</li><li>支持中国国内少数民族的文字，不需要动用造字区。</li><li>汉字收录范围包含繁体汉字以及日韩汉字</li></ul><p><strong>GB18030 编码是一二四字节变长编码。</strong></p><ul><li>单字节，其值从0到0x7F，与 ASCII 编码兼容。</li><li>双字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x40到0xFE（不包括0x7F），与 GBK标准基本兼容。</li><li>四字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节从0x81到0xFE，第四个字节从0x30到0x39。</li></ul><p>2000 年的 GB18030 取代了 GBK1.0 的正式国家标准。该标准收录了 27484 个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的 PC 平台必须支持 GB18030，对嵌入式产品暂不作要求。所以手机、MP3 一般只支持 GB2312。</p><p>GB18030 在 Windows 中的代码页是 CP54936。</p><h3 id="GB13000"><a href="#GB13000" class="headerlink" title="GB13000"></a>GB13000</h3><p>GB13000 等同于国际标准的《通用多八位编码字符集 (UCS)》 ISO10646.1，就是等同于 Unicode 的标准，代码页等等的都使用 UTF 的一套标准。</p><p>从 ASCII、GB2312、GBK 到 GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为 0。按照程序员的称呼，GB2312、GBK 到 GB18030 都属于双字节字符集 (DBCS)。</p><h2 id="URL编解码"><a href="#URL编解码" class="headerlink" title="URL编解码"></a>URL编解码</h2><p>一般来说，网页URL只能使用英文、数字、还有一些特定的字符。根据网络标准<a href="http://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">RFC 1738</a>做了硬性规定：</p><blockquote><p>只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!*’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。</p></blockquote><p>如果 URL中包括中文等字符，就必须经过编码后使用，否则传给服务器的 request URL 就会包含乱码，服务器无法正确识别。因为RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定，所以导致“URL编码”领域非常混乱。想要了解浏览器多种情况下的编码处理，可以参考阮一峰大神的<a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">关于URL编码</a>。</p><ol><li><strong>网址路径的编码，用的是utf-8编码。</strong></li><li><strong>查询字符串的编码，用的是操作系统的默认编码。</strong></li><li><strong>GET和POST方法的编码，用的是网页的编码。</strong></li><li><strong>在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码。</strong></li></ol><p>不同的操作系统、不同的浏览器、不同的网页字符集，将导致完全不同的编码结果，为了保证客户端只用一种编码方法向服务器发出请求，可以使用 Javascript 先对 URL 编码，然后再向服务器提交，不要给浏览器插手的机会。</p><p>编码方法有三种：<code>escape(url)</code>、<code>encodeURL(url)</code>、<code>encodeURLComponent(url)</code></p><p>解码方法也有三种: <code>unescape(url)</code>、<code>decodeURL(url)</code>、<code>decodeURLComponent(url)</code></p><table><thead><tr><th>方法</th><th>规则</th><th>特点</th></tr></thead><tbody><tr><td>escape、unescape</td><td>除了ASCII字母、数字、标点符号”@ * _ + - . /“以外，对其他所有字符进行编码</td><td>它的作用是返回一个字符的 Unicode 编码值。现在已经不提倡使用这种方法了，它不能直接运用与 URL 编码。</td></tr><tr><td>encodeURI（编码）decodeURI（解码）</td><td>除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码</td><td>encodeURI() 是 Javascript 中真正用来对 URL 编码的函数，它着眼于对整个URL 进行编码</td></tr><tr><td>encodeURIComponent（编码）decodeURIComponent解码）</td><td>在encodeURI()中不被编码的符号”; / ? : @ &amp; = + $ , #”，在encodeURIComponent()中统统会被编码</td><td>与 encodeURI() 的区别是，它用于对 URL 的组成部分进行个别编码，而不用于对整个URL进行编码。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> url = <span class="string">"https://www.zhihu.com/question/342936488/answer/804030108"</span>;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; <span class="built_in">escape</span>(url)</span><br><span class="line"><span class="string">"https%3A//www.zhihu.com/question/342936488/answer/804030108"</span></span><br><span class="line">&gt; <span class="built_in">encodeURI</span>(url)</span><br><span class="line"><span class="string">"https://www.zhihu.com/question/342936488/answer/804030108"</span></span><br><span class="line">&gt; <span class="built_in">encodeURIComponent</span>(url)</span><br><span class="line"><span class="string">"https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F342936488%2Fanswer%2F804030108"</span></span><br></pre></td></tr></table></figure><h2 id="Big-Endian-和-Little-Endian"><a href="#Big-Endian-和-Little-Endian" class="headerlink" title="Big Endian 和 Little Endian"></a>Big Endian 和 Little Endian</h2><ul><li><strong>Little-endian：将低序字节存储在起始地址（低位编址）</strong></li><li><strong>Big-endian：将高序字节存储在起始地址（高位编址）</strong></li></ul><p>例如，如果我们将 0x1234abcd 写入到以 0x0000 开始的内存中，则结果为：</p><table><thead><tr><th>address</th><th>big-endian</th><th>little-endian</th></tr></thead><tbody><tr><td>0x0000</td><td>0x12</td><td>0xcd</td></tr><tr><td>0x0001</td><td>0x34</td><td>0xab</td></tr><tr><td>0x0002</td><td>0xab</td><td>0x34</td></tr><tr><td>0x0003</td><td>0xcd</td><td>0x12</td></tr></tbody></table><p>对于字节序列的存储格式，目前有两大阵营，那就是 Motorola 的 PowerPC 系列 CPU 和 Intel 的 x86 系列 CPU。PowerPC 系列采用 big endian 方式存储数据，而 x86 系列则采用 little endian 方式存储数据。</p><p>所有网络协议也都是采用 big endian 的方式来传输数据的。所以有时我们也会把 big endian 方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。</p><p>目前应该 little endian 是主流，因为在数据类型转换的时候（尤其是指针转换）不用考虑地址问题。</p><p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p><p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用 big endian 方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用 little endian 方式。</p><h2 id="如何解决乱码问题"><a href="#如何解决乱码问题" class="headerlink" title="如何解决乱码问题"></a>如何解决乱码问题</h2><p>乱码本质上都是由于<strong>字符串原本的编码格式与读取时解析用的编码格式不一致导致的</strong>。</p><h3 id="网页乱码问题"><a href="#网页乱码问题" class="headerlink" title="网页乱码问题"></a>网页乱码问题</h3><ul><li>服务器返回的响应头 Content-Type 指明字符编码。</li><li>网页内使用 meta http-equiv 标签指定字符编码。</li><li>网页文件本身存储时使用的字符编码和网页声明的字符编码一致。</li></ul><h3 id="Java代码乱码问题"><a href="#Java代码乱码问题" class="headerlink" title="Java代码乱码问题"></a>Java代码乱码问题</h3><ul><li><p>使用 getBytes() 方法指定编码。</p></li><li><p>使用字节流时指定编码。</p></li><li><p>使用 new String() 时指定编码。</p></li><li><p>使用 HttpClient post请求时指定编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求实体</span></span><br><span class="line">HttpEntity reqEntity = <span class="keyword">new</span> ByteArrayEntity(reqStr.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">httpPost.setEntity(reqEntity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求实体</span></span><br><span class="line">StringEntity reqEntity = <span class="keyword">new</span> StringEntity(reqStr, Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">httpPost.setEntity(reqEntity);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ASCII-Unicode-UTF-8&quot;&gt;&lt;a href=&quot;#ASCII-Unicode-UTF-8&quot; class=&quot;headerlink&quot; title=&quot;ASCII - Unicode - UTF-8&quot;&gt;&lt;/a&gt;ASCII - Unicode - UTF-8&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java中的基本类型</title>
    <link href="https://muhouer.github.io/posts/3f6a1294/"/>
    <id>https://muhouer.github.io/posts/3f6a1294/</id>
    <published>2019-08-27T16:06:49.000Z</published>
    <updated>2019-08-27T16:11:35.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>Java 中有 8 种基本数据类型，分为三大类。</p><ol><li><p>字符型：<code>char</code></p></li><li><p>布尔型：<code>boolean</code></p></li><li><p>数值型：</p><ol><li>整型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>浮点型：<code>float</code>、<code>double</code></li></ol></li></ol><p>String 不是基本数据类型，是引用类型。</p><h2 id="整型中byte、short、int、long的取值范围"><a href="#整型中byte、short、int、long的取值范围" class="headerlink" title="整型中byte、short、int、long的取值范围"></a>整型中byte、short、int、long的取值范围</h2><p>Java 中的整型主要包含 byte、short、int 和 long 这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。</p><ul><li>byte：byte 用 1 个字节来存储，范围为 -128(-2^7) 到 127(2^7-1)，在变量初始化的时候，byte类型的默认值为 0。</li><li>short：short 用 2 个字节存储，范围为 -32768 (-2^15) 到 32767 (2^15-1)，在变量初始化的时候，short类型的默认值为0，一般情况下，因为 Java 本身转型的原因，可以直接写为 0。</li><li>int：int 用 4 个字节存储，范围为 -2147483648 (-2^31) 到 2147483647 (2^31-1)，在变量初始化的时候，int类型的默认值为 0。</li><li>long：long 用 8 个字节存储，范围为 -9223372036854775808 (-2^63) 到 9223372036854775807 (2^63-1)，在变量初始化的时候，long 类型的默认值为 0L 或 0l，也可直接写为 0。</li></ul><p>整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。</p><p>溢出的时候并不会抛异常，也没有任何提示。所以，在程序中，使用同类型的数据进行运算的时候，一定要注意数据溢出的问题。</p><h2 id="什么是浮点型"><a href="#什么是浮点型" class="headerlink" title="什么是浮点型"></a>什么是浮点型</h2><p>在计算机科学中，浮点是一种对于实数的近似值数值表现法，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（floating-point number）。</p><p>计算机使用浮点数运算的主因，在于电脑使用二进位制的运算。例如：4÷2=2，4的二进制表示为100、2的二进制表示为010，在二进制中，相当于退一位数(100 -&gt; 010)。</p><p>1 的二进制是 01，1.0/2=0.5，那么，0.5 的二进制表示应该为(0.1)，以此类推，0.25的二进制表示为0.01，所以，并不是说所有的十进制小数都能准确的用二进制表示出来，如 0.1，因此只能使用近似值的方式表达。</p><p>也就是说，十进制的小数在计算机中是由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到的，这种表示方法类似于基数为 10 的科学计数法。</p><p>一个浮点数a由两个数m和e来表示：a = m × be。在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd…ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1）。如果m的第一位是非0整数，m称作正规化的。有一些描述使用一个单独的符号位（s 代表+或者-）来表示正负，这样m必须是正的。e是指数。</p><p>位(bit)是衡量浮点数所需存储空间的单位，通常为32位或64位，分别被叫作单精度和双精度。</p><p>单精度浮点数在计算机存储器中占用 4 个字节(32 bits)，利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。</p><p>比起单精度浮点数，双精度浮点数(double)使用 8 个字节(64 bits) 来存储一个浮点数。</p><p><strong>注意</strong>：由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。</p><p><strong>建议使用BigDecimal或者Long（单位为分）来表示金额。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;p&gt;Java 中有 8 种基本数据类型，分为三大类。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;字符型：&lt;code&gt;char&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么Java中byte类型的取值范围为-128~127?</title>
    <link href="https://muhouer.github.io/posts/ca021682/"/>
    <id>https://muhouer.github.io/posts/ca021682/</id>
    <published>2019-08-27T15:45:14.000Z</published>
    <updated>2019-08-27T15:52:45.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：探路的淮–Ontheway<br>原文链接：<a href="https://blog.csdn.net/qq_23418393/article/details/57421688" target="_blank" rel="noopener">https://blog.csdn.net/qq_23418393/article/details/57421688</a></p></blockquote><p>在学习 Java 基础语法的时候，初学者的我们可能都会有这么一个疑问为什么 byte 类型的取值范围为什么是 -128 ~ 127 而不是 -127 ~ 127。<code>01111111</code> 表示最大的数值：127，因为第一位是符号位，所以 <code>11111111</code> 应该是最小的数值：-127，不是这样才对？</p><p>在解释这个问题之前我们需要了解几个概念：机器数、真值、原码、反码、补码</p><h2 id="机器数、真值、原码、反码、补码"><a href="#机器数、真值、原码、反码、补码" class="headerlink" title="机器数、真值、原码、反码、补码"></a>机器数、真值、原码、反码、补码</h2><h3 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h3><p>一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为 0，负数为 1。</p><p>比如：十进制中的数 +3 ，计算机字长为 8 位，转换成二进制就是 <code>00000011</code>。如果是 -3 ，就是 <code>10000011</code> 。那么，这里的 <code>00000011</code> 和 <code>10000011</code> 就是机器数。</p><h3 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h3><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 <code>10000011</code>，其最高位 1代表负，其真正数值是 -3 而不是形式值 131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><p>​ 例：0000 0001 的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><p>​ [+1]原 = 0000 0001<br>​ [-1]原 = 1000 0001<br>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]<br>即[-127 , 127]。原码是人脑最容易理解和计算的表示方式.</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>反码的表示方法是：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p><p>​ [+1] = [00000001]原 = [00000001]反<br>​ [-1] = [10000001]原 = [11111110]反</p><p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算。</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码的表示方法是:</p><ol><li><p>正数的补码就是其本身。</p></li><li><p>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 +1。(即在反码的基础上 +1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补<br>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p></li></ol><p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。</p><h2 id="为什么-byte-类型的取值范围为-128-127？"><a href="#为什么-byte-类型的取值范围为-128-127？" class="headerlink" title="为什么 byte 类型的取值范围为 -128~127？"></a>为什么 byte 类型的取值范围为 -128~127？</h2><h3 id="为何计算机内部不使用原码表示一个数？"><a href="#为何计算机内部不使用原码表示一个数？" class="headerlink" title="为何计算机内部不使用原码表示一个数？"></a>为何计算机内部不使用原码表示一个数？</h3><p>现在我们知道了计算机可以有三种编码方式表示一个数，对于正数因为三种编码方式的结果都相同：</p><p>　　[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>但是对于负数:</p><p>　　[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>可见原码，反码和补码是完全不同的。 既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？</p><p>首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即: <code>1-1 = 1 + (-1) = 0</code> ，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。</p><p>于是人们开始探索 将符号位参与运算，并且只保留加法的方法。首先来看原码：</p><p>　　计算十进制的表达式: 1-1=0</p><p>　　1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p><p>如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。</p><h3 id="反码的诞生"><a href="#反码的诞生" class="headerlink" title="反码的诞生"></a>反码的诞生</h3><p>为了解决原码做减法的问题，出现了反码：</p><p>　　计算十进制的表达式: 1-1=0</p><p>　　1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p><p>发现用反码计算减法，结果的真值部分是正确的。而唯一的问题其实就出现在”0”这个特殊的数值上。虽然人们理解上 +0 和 -0 是一样的，但是 0 带符号是没有任何意义的。而且会有 [0000 0000]原 和 [1000 0000]原 两个编码表示 0。</p><h3 id="补码的诞生"><a href="#补码的诞生" class="headerlink" title="补码的诞生"></a>补码的诞生</h3><p>补码的出现，解决了 0 的符号以及两个编码的问题：</p><p>　　1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 =[0000 0001]反 + [1111 1110]反= [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p><p>这样0用 [0000 0000] 表示，而以前出现问题的 -0 则不存在了。而且可以用 [1000 0000] 表示-128：</p><p>　　(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p><p>-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补 就是 -128。但是注意因为实际上是使用以前的 -0 的补码来表示 -128, 所以 -128 并没有原码和反码表示。(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)，使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，<strong>使用原码或反码表示的范围为 -127<del>+127， 而使用补码表示的范围为 -128</del>127。</strong></p><p>因为机器使用补码，所以对于编程中常用到的 32 位 int 类型, 可以表示范围是：-2^31~2^31-1 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?</p><p>可以参考：<a href="https://www.cnblogs.com/zhengfengyun/p/5090601.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengfengyun/p/5090601.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者：探路的淮–Ontheway&lt;br&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/qq_23418393/article/details/57421688&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java泛型解析</title>
    <link href="https://muhouer.github.io/posts/4127871b/"/>
    <id>https://muhouer.github.io/posts/4127871b/</id>
    <published>2019-08-26T16:27:00.000Z</published>
    <updated>2019-08-26T16:28:49.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型是什么"><a href="#泛型是什么" class="headerlink" title="泛型是什么"></a>泛型是什么</h2><blockquote><p>泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。</p></blockquote><p>泛型的英文是 generics，generic 的意思是通用,而翻译成中文，泛应该意为广泛，型是类型。所以泛型就是能广泛适用的类型。<strong>但泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。</strong></p><p>Object 是所有类的根类，任何类的对象都可以设置给该 Object 引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T value;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的定义和使用"><a href="#泛型的定义和使用" class="headerlink" title="泛型的定义和使用"></a>泛型的定义和使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>如果一个类被 <code>&lt;T&gt;</code>的形式定义，那么它就被称为是泛型类。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号 &lt;&gt;中的 T 被称作是类型参数，用于指代任何类型。其中T只是一种习惯写法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T field1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，泛型类不至接受一个类型参数，它还可以这样接受多个类型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiType</span>&lt;<span class="title">E</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">E value1;</span><br><span class="line">T value2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getValue1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getValue2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如：</p><ol><li><p>E ——代表 Element (在集合中使用，因为集合中存放的是元素)，或者 Exception 异常的意思</p></li><li><p>T ——代表 Type（一般的任何 Java 类）</p></li><li><p>K——代表 Key（键）</p></li><li><p>V ——代表 Value（值），通常与 K 一起配合使用</p></li><li><p>N——代表 Number（数值类型）</p></li><li><p>？——表示不确定的java类型（无限制通配符类型）</p></li><li><p>S、U、V——代表 2nd、3rd、4th Subtype</p></li></ol><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法与泛型类稍有不同的地方是，类型参数也就是尖括号那一部分是写在返回值前面的。<code>&lt;T&gt;</code>中的 T 被称为类型参数，而方法中的 T 被称为参数化类型，它不是运行时真正的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">testMethodWithReturn</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型方法始终以自己定义的类型参数为准</strong>。即泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的。例如：泛型类的实际类型参数是 String，而传递给泛型方法的类型参数是 Integer，两者不想干。</p><p>但是，为了避免混淆，如果在一个泛型类中存在泛型方法，那么两者的类型参数最好不要同名。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口和泛型类类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限定通配符和非限定通配符"><a href="#限定通配符和非限定通配符" class="headerlink" title="限定通配符和非限定通配符"></a>限定通配符和非限定通配符</h2><p><strong>通配符的出现是为了指定泛型中的类型范围</strong>。</p><p>通配符有 3 种形式。</p><ol><li><code>&lt;?&gt;</code>被称作非限定通配符。</li><li><code>&lt;? extends T&gt;</code>被称作有上界通配符。</li><li><code>&lt;? super T&gt;</code>被称作有下界通配符。</li></ol><p>非限定通配符经常与容器类配合使用，它其中的 ? 其实代表的是未知类型，所以涉及到 ? 时的操作，一定与具体类型无关，类型是未知的。所以，你只能调用使用非限定通配符类中与类型无关的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWildCards</span><span class="params">(Collection&lt;?&gt; collection)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 只能调用 Collection 中与类型无关的方法。</span></span><br><span class="line">  <span class="comment">// 当你调用 add() 方法时，编译会失败。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限定通配符包括两种：</p><ol><li><code>&lt;？extends T&gt;</code> 表示类型的上界，即类型必须为T类型或者T子类。</li><li><code>&lt;？super T&gt;</code> 表示类型的下界，即类型必须为T类型或者T的父类。</li></ol><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>泛型是 Java 1.5 版本才引进的概念，在这之前是没有泛型的概念的，但显然，泛型代码能够很好地和之前版本的代码很好地兼容。</p><p>这是因为，泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</p><p>通俗地讲，泛型类和普通类在 java 虚拟机内是没有什么特别的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">System.out.println(strList.getClass() == intList.getClass()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 <code>&lt;T&gt;</code>则会被转译成普通的 Object 类型，如果指定了上限如 <code>&lt;T extends String&gt;</code>则类型参数就被替换成类型上限。</p><blockquote><p>原始类型 List 和带参数类型之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查。你可以把任何带参数的类型传递给原始类型 List，但却不能把 List 传递给接受 List 的方法，因为会产生编译错误。</p></blockquote><p>类型擦除，它会抹掉很多继承相关的特性，这是它带来的局限性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">integers.add(<span class="number">9</span>);</span><br><span class="line">integers.add(<span class="string">"freya"</span>); <span class="comment">// 由于泛型的限制，编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过基于对类型擦除的了解，利用反射，我们可以绕过这个限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">    integers.add(<span class="number">9</span>);</span><br><span class="line">    <span class="comment">// integers.add("freya");</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Method method = integers.getClass().getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        method.invoke(integers, <span class="string">"freya"</span>);</span><br><span class="line">        method.invoke(integers, <span class="number">10.11f</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(integers); <span class="comment">// [9, freya, 10.11]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>泛型类或者泛型方法中，不接受 8 种基本数据类型，需要使用它们对应的包装类。</li><li>Java 不能创建具体类型的泛型数组。这是因为所有的类型信息都被擦除，程序也无法分辨一个数组中的元素类型具体是哪种类型。</li><li>非限定通配符涉及的操作都基本上与类型无关，因此 JVM 不需要针对它对类型作判断，只提供了数组中的元素因为通配符原因，它只能读，不能写。</li><li>如果可以使用泛型的地方，尽量使用泛型。因为它抽离了数据类型与代码逻辑，本意是提高程序代码的简洁性和可读性，并提供可能的编译时类型转换安全检测功能。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;泛型是什么&quot;&gt;&lt;a href=&quot;#泛型是什么&quot; class=&quot;headerlink&quot; title=&quot;泛型是什么&quot;&gt;&lt;/a&gt;泛型是什么&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="泛型" scheme="https://muhouer.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>拾句-念念不忘</title>
    <link href="https://muhouer.github.io/posts/e5f2c01c/"/>
    <id>https://muhouer.github.io/posts/e5f2c01c/</id>
    <published>2019-08-26T14:52:53.000Z</published>
    <updated>2019-08-27T16:17:06.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="人生除了死亡，其他都是擦伤。"><a href="#人生除了死亡，其他都是擦伤。" class="headerlink" title="人生除了死亡，其他都是擦伤。"></a>人生除了死亡，其他都是擦伤。</h3><blockquote><p><strong>你是在拜佛，还是在拜自己的欲望？</strong><br>正义的反面不是邪恶，正义的反面是别的正义。<br><strong>不知道发⽣了什么，是这个世界；不知道在做什么，是⾃⼰。</strong><br>我的任性是理所当然，别人的任性是不可原谅。<br>如果一切祈祷都为了满足私欲，那所有的美好希望都是一种对别人的诅咒。<br><strong>让花谢的是⻛⾬/让花开的也是⻛⾬/但没了⻛⾬/花不会开也不会落</strong><br>并不是所有⼈都能轻盈地度过这⼀⽣，有些⼈，光是活着就已经竭尽全⼒。<br>我们终其⼀⽣都想成为那个喜欢的⼈，殊不知，⼈⼈都有光彩和阴影，只是有些⼈已经学会了欣赏⾃⼰，并且接纳了阴影。<br>没有⼀朵花，从⼀开始就是花。<br><strong>世界再⼤，不过是⼈与⼈之间的距离。</strong><br>所谓孩⼦，⼤多是在⽗⺟看不⻅的地⽅成⻓起来的。<br>当⼥⼉捡起落叶/我看到⽣命与季节/交汇的点——⼥⼉与秋天》理正道<br>如果房⼦没有窗户，⻔会望着谁。——《⻛适应着这个季节》晚⼭<br>我的身体在寂静中安置⾃⼰，时刻准备着成为灵魂的故乡——《回乡偶书》⾼寒<br><strong>纸质信回信要等⼀个⽉， 电⼦邮件回信等⼀周， LINE回复⼀⼩时。 不⽤等待的⼈⽣真忙碌啊。</strong><br>你认为“谢谢”的反义词是什么？<br>众⽣喧哗归⼀处，万物静默为⼀听。<br>形形⾊⾊的⼈⽣，五味杂陈的故事，百转千回，令⼈回味。<br>不必太纠结于当下，也不必太忧虑未来，当你经历过一些事情的时候，眼前的风景已经和从前不一样了。<br>不解释就弄不懂的事，就意味着怎样解释也弄不懂。——《1Q84》<br><strong>总有一天，你会离开这个世界。所以这辈子要活得更加精彩。</strong></p></blockquote><h3 id="我能承受任何痛苦，只要这种痛苦有意义。"><a href="#我能承受任何痛苦，只要这种痛苦有意义。" class="headerlink" title="我能承受任何痛苦，只要这种痛苦有意义。"></a>我能承受任何痛苦，只要这种痛苦有意义。</h3><blockquote><p><strong>遇到真正喜欢的人，你才发现之前定的标准都是空话。</strong><br><strong>天裂了，去缝起。</strong><br><strong>欲望本身没有对错善恶，只有当与规则碰撞，人对欲望的态度才显示出丑陋或者善良的一面。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;人生除了死亡，其他都是擦伤。&quot;&gt;&lt;a href=&quot;#人生除了死亡，其他都是擦伤。&quot; class=&quot;headerlink&quot; title=&quot;人生除了死亡，其他都是擦伤。&quot;&gt;&lt;/a&gt;人生除了死亡，其他都是擦伤。&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;你是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于减肥</title>
    <link href="https://muhouer.github.io/posts/c8dcfc3f/"/>
    <id>https://muhouer.github.io/posts/c8dcfc3f/</id>
    <published>2019-08-25T10:32:00.000Z</published>
    <updated>2019-08-25T11:10:11.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者: 三木水<br>原文: <a href="https://mp.weixin.qq.com/s/Bgc2DbHBq_tRuMbTukaj9w" target="_blank" rel="noopener">求求珍珠奶茶放过我吧</a></p></blockquote><h2 id="减肥和毅力，没有半毛钱关系。"><a href="#减肥和毅力，没有半毛钱关系。" class="headerlink" title="减肥和毅力，没有半毛钱关系。"></a>减肥和毅力，没有半毛钱关系。</h2><p>很多人在减肥中，遇到的最大的障碍就是：管不住自己的嘴。总是忍不住要多吃，而且，一吃就停不下来。</p><p>就像我的一位女性来访者，30+，极度自律。但是，在减肥这件事上，她却遭遇了滑铁卢。她最大的困扰就是：吃。</p><p>像我一样，吃之前很理性，吃的时候管不住，事后很懊恼，伴随极度的焦虑和自责。有的时候，她还会把这份焦虑转移到伴侣身上，对伴侣发脾气。</p><p>当然，这只不过是对自己无力的这部分的一种向外投射。她说，她用极大的毅力来控制自己不要多吃。为了不吃晚饭，晚餐时，她是不上桌的：家人吃晚饭，她就在旁边找个地方啃个苹果。</p><p>即便这样，“吃”和“不吃”就好像在打游击战一样，在每一个毅力稍稍缺席的地方，“吃”的欲望就会铺天盖地地袭来。吃完之后，又陷入了懊恼、自责和极度的焦虑当中。</p><p>你也许就要问了，不靠毅力控制，那靠什么？</p><p>在提出这个问题的时候，你想的还是控制。</p><p>在回答这个问题之前，我们不妨换个角度，我们为什么对“吃”如此痴迷？那是因为，“吃”给我们带来了很大的快感。</p><p>我的很多痴迷于“吃”的朋友，曾这么跟我说：在吃的时候，让他们感觉到了无比的满足，就好像在天堂，如果不让他们“吃吃吃”一段时间，他们觉得，人生的意义都没有了。</p><p>“人生的意义”“生活的乐趣”“活着的快感”都没有了，这是多么严重的问题。在这样的情况下，你可曾看到，控制“吃”的背后，我们在尝试控制什么。控制“吃”，就是在和自己的人性做对，而和人性做对，这几乎是一场必输的游戏。</p><p>这就是为什么我们这么努力控制，却毫无进展的原因。</p><p>因为，“吃”，这是一件我们控制不了的事情。</p><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><ol><li><strong>想要减肥，不要节食，先满足吃欲。</strong>(少食多餐)</li><li><strong>别着急，慢慢吃。</strong>每一个食物，都是巨大的恩赐，值得好好品味，不可辜负。</li><li>每天或者每周安排一顿饭，放肆的吃。<strong>总有一个时空，我可以“为所欲为”。</strong></li></ol><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>这让我想起了《<a href="https://book.douban.com/subject/27052052/" target="_blank" rel="noopener">人体的故事：进化、健康与疾病</a>》里面的一个观点：</p><blockquote><p>如果他们开始节食或增加运动量，这就意味着他们摄入的热量少于消耗的，那么就会不可避免地变得又饿又累，而这又会激活他们体内的原始冲动：增加食量、减少运动。饥饿和嗜睡是古代的适应机制。</p></blockquote><blockquote><p>失配性疾病，即由于我们旧石器时代的身体不能或不足以适应某些现代行为和条件而导致的疾病。(没有说肥胖是疾病，这是书中解释一些现代社会才会遇到的疾病时提出的名词。)</p></blockquote><p>纵观整个人类历史，人类就好像突然从石器时代进入现代。因为我们人类在石器时代停留的时间为99%，现代才1%不到。人类的进化是缓慢的，已经跟不上现代社会的变化。</p><p>生活越来越好，这点无可否认，可是身体上的那些机能还没有转变过来。所以说，减肥这件事本身就是与人性在作对(还得和社会的审美做抗争)，基本没有胜利的可能。换回的是无尽的纠结、自责、懊恼……</p><p>这有点像电脑在国内刚起步那几年，家长们怕你沉迷，防这个，防那个。可是现在呢，电脑根本不是什么稀奇物，那些 00 后赶上了好时代，刚出生就接触电脑、智能机、平板…… 而石器时代食物匮乏，能吃到东西就很不错了，所以为了活下去，那种对甜食、脂肪的渴望很强烈，或者说有一种瘾。现代社会能吃饱也是近几十年的事情(感谢袁老)，食物极大丰富对体内的原始冲动来说，就像一夜暴富，开始肆意挥霍。</p><p>所以我们需要先满足体内的原始冲动，让它慢慢减弱那种食物匮乏的不安全感，然后驯服它，不过这一切都需要时间和耐心，不能一蹴而就，蛮干换回的只能是纠结、自责、懊恼……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者: 三木水&lt;br&gt;原文: &lt;a href=&quot;https://mp.weixin.qq.com/s/Bgc2DbHBq_tRuMbTukaj9w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;求求珍珠奶茶放过我吧&lt;/a&gt;&lt;/p&gt;&lt;
      
    
    </summary>
    
      <category term="减肥" scheme="https://muhouer.github.io/categories/%E5%87%8F%E8%82%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>Java异常解析</title>
    <link href="https://muhouer.github.io/posts/d868df11/"/>
    <id>https://muhouer.github.io/posts/d868df11/</id>
    <published>2019-08-23T15:32:54.000Z</published>
    <updated>2019-08-23T15:39:51.253Z</updated>
    
    <content type="html"><![CDATA[<p>Java 将所有的错误封装为一个对象，其根本父类为 <code>Throwable</code>， <code>Throwable</code>有两个子类：<code>Error</code> 和 <code>Exception</code>。</p><img src="/images/201908231133.png" width="800px" height="500px" align="center"><p>Trowable 类中常用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回异常发生时的详细信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">getMessage</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">// 返回异常发生时的简要描述</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">toString</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">// 返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">getLocalizedMessage</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">// 在控制台上打印Throwable对象封装的异常信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><blockquote><p>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions.</p></blockquote><p><code>Error</code> 是 <code>Throwable</code> 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。虽然 <strong>ThreadDeath</strong> 错误是一个“正规”的条件，但它也是 Error 的子类，因为大多数应用程序都不应该试图捕获它。在执行该方法期间，无需在其 throws 子句中声明可能抛出但是未能捕获的 Error 的任何子类，因为这些错误可能是再也不会发生的异常条件。</p><blockquote><p>调用 stop() 方法时会抛出 java.lang.ThreadDeath 错误，但在通常的情况下，此错误不需要显式地捕捉。不过方法 stop() 已经被作废，因为如果强制让线程停止则有可能使一些清理性的工作得不到完成。另外一个情况就是对锁定的对象进行了“解锁”，导致数据得不到同步的处理，出现数据不一致的问题。</p></blockquote><p>经典 <code>Error</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutOfMemoryError</span><br><span class="line">StackOverflowError</span><br></pre></td></tr></table></figure><h3 id="VirtulMachineError"><a href="#VirtulMachineError" class="headerlink" title="VirtulMachineError"></a>VirtulMachineError</h3><p>有四种不同类型的 <code>VirtulMachineError</code>：</p><ul><li>OutOfMemoryError</li><li>StackOverflowError</li><li>InternalError</li><li>UnknownError</li></ul><h4 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h4><p>OutOfMemoryError 有八种不同类型：</p><ol><li>java.lang.OutOfMemoryError：Java 堆空间</li><li>java.lang.OutOfMemoryError：GC 开销超过限制</li><li>java.lang.OutOfMemoryError：请求的数组大小超过虚拟机限制</li><li>java.lang.OutOfMemoryError：PermGen 空间</li><li>java.lang.OutOfMemoryError：Metaspace</li><li>java.lang.OutOfMemoryError：无法新建本机线程</li><li>java.lang.OutOfMemoryError：杀死进程或子进程</li><li>java.lang.OutOfMemoryError：发生 stack_trace_with_native_method</li></ol><p>触发每种错误的原因各有不同。类似地，根据 OutOfMemoryError 不同的问题类型，对应的解决方案也不一样。</p><h4 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h4><p>线程的堆栈存储了执行的方法、基本数据类型值、局部变量、对象指针和返回值信息，所有这些都会消耗内存。当栈深度超过虚拟机分配给线程的栈大小时，那么就会抛出 java.lang.StackOverflowError。通常由于执行程序中有一个错误，在线程重复递归调用同一个函数时会发生这个问题。</p><h4 id="InternalError"><a href="#InternalError" class="headerlink" title="InternalError"></a>InternalError</h4><p>JVM 抛出 java.lang.InternalError 有三个原因，虚拟机软件出现错误、系统软件底层出现错误或者硬件出现故障。</p><p>一般极少会遇到 InternalError 这样的错误。要了解哪些特定情况可能导致 InternalError，请在 Oracle 的 <a href="https://bugs.java.com/bugdatabase/" target="_blank" rel="noopener">Java Bug 数据库</a> 中搜索 InternalError。</p><h4 id="UnknownError"><a href="#UnknownError" class="headerlink" title="UnknownError"></a>UnknownError</h4><p>当发生异常或错误，但 Java 虚拟机无法报告确切的异常或错误时，就会抛出 java.lang.UnknownError。UnknownError 很少出现。事实上，在 Oracle <a href="https://bugs.java.com/bugdatabase/" target="_blank" rel="noopener">Java Bug 数据库</a> 中搜索 UnknownError 时，只找到了2个 Bug。</p><blockquote><h4 id="Bug-ID-JDK-4023606-AppletViewer-generates-java-lang-UnknownError-when-loading-inner-class"><a href="#Bug-ID-JDK-4023606-AppletViewer-generates-java-lang-UnknownError-when-loading-inner-class" class="headerlink" title="Bug ID: JDK-4023606 AppletViewer generates java.lang.UnknownError when loading inner class."></a><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4023606" target="_blank" rel="noopener">Bug ID: JDK-4023606 AppletViewer generates java.lang.UnknownError when loading inner class.</a></h4><h4 id="Bug-ID-JDK-4054295-UnknownError-while-loading-class-with-super-class-equal-to-zero"><a href="#Bug-ID-JDK-4054295-UnknownError-while-loading-class-with-super-class-equal-to-zero" class="headerlink" title="Bug ID: JDK-4054295 UnknownError while loading class with super_class equal to zero"></a><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4054295" target="_blank" rel="noopener">Bug ID: JDK-4054295 UnknownError while loading class with super_class equal to zero</a></h4></blockquote><h3 id="AWTError"><a href="#AWTError" class="headerlink" title="AWTError"></a>AWTError</h3><p><strong>AWT(Abstract Window Toolkit)</strong>，中文译为抽象窗口工具包，是 Java 提供的用来建立和设置 Java 的图形用户界面的基本工具。<code>AWTError</code>一般也很少用到。事实上，在 Oracle <a href="https://bugs.java.com/bugdatabase/" target="_blank" rel="noopener">Java Bug 数据库</a> 中搜索 AWTError 时，只找到了8个 Bug。</p><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p><code>Exception</code> 类及其子类是 <code>Throwable</code> 的一种形式，它指出了合理的应用程序想要捕获的条件。<code>Exception</code> 分为未检查异常(<code>RuntimeException</code>)和已检查异常(非<code>RuntimeException</code>)。 未检查异常是因为程序员没有进行必需要的检查，因为疏忽和错误而引起的错误。几个经典的 <code>RunTimeException</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException</span><br><span class="line">ArithmaticException</span><br><span class="line">ArrayIndexoutofBoundsException</span><br></pre></td></tr></table></figure><blockquote><ol><li>可查异常(编译器要求必须处置的异常)：正确的程序在运行中，很容易出现的、情理可容的异常状况。除了 Exception 中的 RuntimeException 及其子类以外，其他的 Exception 类及其子类(例如：IOException和ClassNotFoundException)都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</li><li>不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。RuntimeException表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。</li></ol></blockquote><h3 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h3><p>运行时异常都是 RuntimeException 类及其子类异常，如 NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是 Java 编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用 try-catch 语句捕获它，也没有用 throws 子句声明抛出它，也会编译通过。</p><h3 id="非RuntimeException"><a href="#非RuntimeException" class="headerlink" title="非RuntimeException"></a>非RuntimeException</h3><p>非运行时异常(也称受检查的异常)是 RuntimeException 以外的异常，类型上都属于 Exception 类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException、SQLException 等以及用户自定义的 Exception 异常，一般情况下不自定义检查异常。</p><h3 id="异常处理的机制"><a href="#异常处理的机制" class="headerlink" title="异常处理的机制"></a>异常处理的机制</h3><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p><p>任何 Java 代码都可以抛出异常，如：自己编写的代码、来自 Java 开发环境包中代码，或者 Java 运行时系统。无论是谁，都可以通过 Java 的 throw 语句抛出异常。从方法中抛出的任何异常都必须使用throws子句。</p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p><p>捕捉异常通过try-catch语句或者try-catch-finally语句实现。</p><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throws</span> <span class="comment">//直接往上一层抛出异常；</span></span><br><span class="line"><span class="keyword">try</span>&#123;&#125;<span class="keyword">catch</span> <span class="comment">// 捕获异常</span></span><br><span class="line"><span class="keyword">finally</span> <span class="comment">// 扫尾工作</span></span><br></pre></td></tr></table></figure><h3 id="throw-和-throws-两个关键字有什么不同"><a href="#throw-和-throws-两个关键字有什么不同" class="headerlink" title="throw 和 throws 两个关键字有什么不同"></a>throw 和 throws 两个关键字有什么不同</h3><ul><li>throw 是用来抛出任意异常的，你可以抛出任意 Throwable，包括自定义的异常类对象；</li><li>throws 总是出现在一个函数头中，用来标明该成员函数可能抛出的各种异常。如果方法抛出了异常，那么调用这个方法的时候就需要处理这个异常。</li></ul><h3 id="try-catch-finally-return执行顺序"><a href="#try-catch-finally-return执行顺序" class="headerlink" title="try-catch-finally-return执行顺序"></a>try-catch-finally-return执行顺序</h3><ul><li>不管是否有异常产生，finally 块中代码都会执行；</li><li>当 try 和 catch 中有 return 语句时，finally 块仍然会执行；</li><li>finally 是在 return 后面的表达式运算后执行的，所以函数返回值是在 finally 执行前确定的。无论 finally 中的代码怎么样，返回的值都不会改变，仍然是之前 return 语句中保存的值；</li><li>finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按正常顺序执行。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 程序执行 try 块中 return 之前(包括 return 语句中的表达式运算)代码； </span></span><br><span class="line"><span class="comment"> * 2. 再执行 finally 块，最后执行 try 中 return; </span></span><br><span class="line"><span class="comment"> * 3. finally 块后面的 return 语句不再执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="keyword">return</span>; </span><br><span class="line">&#125; <span class="keyword">catch</span> ()&#123;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.程序先执行 try，如果遇到异常执行 catch 块， </span></span><br><span class="line"><span class="comment"> * 有异常则执行 catch 中 return 之前(包括 return 语句中的表达式运算)代码，再执行 finally 语句中全部代码，最后执行 catch 块中 return，finally 块后面的 return 语句不再执行。 </span></span><br><span class="line"><span class="comment"> * 无异常执行完 try 再 finally 再执行最后的 return 语句。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序执行 try 块中 return 之前(包括 return 语句中的表达式运算)代码； </span></span><br><span class="line"><span class="comment"> * 再执行 finally 块，因为 finally 块中有 return 所以提前退出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="keyword">return</span>; </span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序执行catch块中return之前（包括return语句中的表达式运算）代码； </span></span><br><span class="line"><span class="comment"> * 再执行finally块，因为finally块中有return所以提前退出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>在设计模式中有一个叫做责任链模式，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：异常链。</p><p>我们有两种方式处理异常，一是 throws 抛出交给上级处理，二是 try…catch 做具体处理。try…catch 的 catch 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 throws 继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。</p><p>​ <strong>通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。</strong></p><p>同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。在异常链的使用中，throw 抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在 Throwable 及其子类中的构造器中都可以接受一个 <code>Throwable cause</code> 参数，该参数保存了原有的异常信息，通过 getCause() 就可以获取该原始异常信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> XxxException</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do something:可能抛出异常信息的代码块</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> XxxException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="精确原则"><a href="#精确原则" class="headerlink" title="精确原则"></a>精确原则</h3><ol><li><strong>尽可能的减小 try 块</strong>——try 块不要包含太多的信息，仅包所需。</li><li><strong>catch 语句应当尽量指定具体的异常类型，不要一个Exception试图处理所有可能出现的异常</strong></li></ol><h3 id="不要做渣男，负点责"><a href="#不要做渣男，负点责" class="headerlink" title="不要做渣男，负点责"></a>不要做渣男，负点责</h3><ol><li><strong>既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃。</strong></li><li><strong>在异常处理模块中提供适量的错误原因信息，使其后续易于理解和阅读。</strong></li><li><strong>保证所有资源都被正确释放。</strong> ——充分运用finally关键词。或者使用 Java 提供的语法糖 try() catch</li></ol><h3 id="两不要"><a href="#两不要" class="headerlink" title="两不要"></a>两不要</h3><ol><li><strong>不要在 finally 块中处理返回值。</strong></li><li><strong>不要在构造函数中抛出异常。</strong></li></ol><h2 id="异常使用指南"><a href="#异常使用指南" class="headerlink" title="异常使用指南"></a>异常使用指南</h2><p>应该在下列情况下使用异常(From 《Think in java》)。</p><ol><li>在恰当的级别处理问题(在知道该如何处理异常的情况下才捕获异常)。</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事情尽量做完。然后把相同(不同)的异常重新抛到更高层。</li><li>终止程序。</li><li>进行简化。</li><li>让类库和程序更加安全。(这既是在为调试做短期投资，也是在为程序的健壮做长期投资)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 将所有的错误封装为一个对象，其根本父类为 &lt;code&gt;Throwable&lt;/code&gt;， &lt;code&gt;Throwable&lt;/code&gt;有两个子类：&lt;code&gt;Error&lt;/code&gt; 和 &lt;code&gt;Exception&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java的一些基本概念</title>
    <link href="https://muhouer.github.io/posts/d7d0bf4a/"/>
    <id>https://muhouer.github.io/posts/d7d0bf4a/</id>
    <published>2019-08-21T16:39:00.000Z</published>
    <updated>2019-08-21T17:02:40.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h2><h3 id="什么是面向过程？"><a href="#什么是面向过程？" class="headerlink" title="什么是面向过程？"></a>什么是面向过程？</h3><p>自顶而下的编程模式。占用资源相对低，速度相对快。</p><p>把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。</p><p>最典型的用法就是实现一个简单的算法，比如实现冒泡排序。</p><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p>将事务高度抽象化的编程模式。占用资源相对高，速度相对慢。</p><p>将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p><p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。</p><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h3><p>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><h3 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h3><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p><h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态(Polymorphism)"></a>多态(Polymorphism)</h3><p>所谓多态就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><p>最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p><h2 id="重载-amp-重写"><a href="#重载-amp-重写" class="headerlink" title="重载 &amp; 重写"></a>重载 &amp; 重写</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>重载是一个编译期概念，重写是一个运行期间概念。</li><li>重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。</li><li>重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法</li><li>因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）</li></ol><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数，是一种特殊的方法。 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。</p><p>构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。构造器的函数名称必须和它所属的类的名称相同。 它承担着初始化对象数据成员的任务。</p><p>如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数一般会把成员变量的值初始化为默认值，如int -&gt; 0，Integer -&gt; null。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java中共有三种变量，分别是类变量、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author Hollis</span><br><span class="line"> */</span><br><span class="line">public class Variables &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 类变量</span><br><span class="line">     */</span><br><span class="line">    private static int a;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 成员变量</span><br><span class="line">     */</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 局部变量</span><br><span class="line">     * @param c</span><br><span class="line">     */</span><br><span class="line">    public void test(int c)&#123;</span><br><span class="line">        int d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义的三个变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="public"><a href="#public" class="headerlink" title="public"></a><code>public</code></h3><p>表明该成员变量或者方法是对所有类或者对象都是可见的，所有类或者对象都可以直接访问。</p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a><code>protected</code></h3><p>表明成员变量或者方法对类自身以及同在一个包中的其他类可见，其他包下的类不可访问，除非是他的子类。</p><h3 id="default"><a href="#default" class="headerlink" title="default"></a><code>default</code></h3><p>表明该成员变量或者方法只有自己和其位于同一个包的内可见，其他包内的类不能访问，即便是它的子类。</p><h3 id="private"><a href="#private" class="headerlink" title="private"></a><code>private</code></h3><p>表明该成员变量或者方法是私有的，只有当前类对其具有访问权限，除此之外其他类或者对象都没有访问权限，子类也没有访问权限。</p><h2 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h2><p>5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”</p><h3 id="单一职责原则（Single-Resposibility-Principle）"><a href="#单一职责原则（Single-Resposibility-Principle）" class="headerlink" title="单一职责原则（Single-Resposibility Principle）"></a>单一职责原则（Single-Resposibility Principle）</h3><p>其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。</p><h3 id="开放封闭原则（Open-Closed-principle）"><a href="#开放封闭原则（Open-Closed-principle）" class="headerlink" title="开放封闭原则（Open-Closed principle）"></a>开放封闭原则（Open-Closed principle）</h3><p>其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。开放封闭原则主要体现在两个方面：</p><ol><li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li><li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。</li></ol><p>实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。</p><h3 id="里式替换原则（Liskov-Substitution-Principle）"><a href="#里式替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里式替换原则（Liskov-Substitution Principle）"></a>里式替换原则（Liskov-Substitution Principle）</h3><p>其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 里式替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了里式替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 里式替换原则是关于继承机制的设计原则，违反了里式替换原则就必然导致违反开放封闭原则。 里式替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。</p><h3 id="依赖倒置原则（Dependecy-Inversion-Principle）"><a href="#依赖倒置原则（Dependecy-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependecy-Inversion Principle）"></a>依赖倒置原则（Dependecy-Inversion Principle）</h3><p>其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。</p><h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface-Segregation Principle）"></a>接口隔离原则（Interface-Segregation Principle）</h3><p>其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象与面向过程&quot;&gt;&lt;a href=&quot;#面向对象与面向过程&quot; class=&quot;headerlink&quot; title=&quot;面向对象与面向过程&quot;&gt;&lt;/a&gt;面向对象与面向过程&lt;/h2&gt;&lt;h3 id=&quot;什么是面向过程？&quot;&gt;&lt;a href=&quot;#什么是面向过程？&quot; class=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="学习笔记" scheme="https://muhouer.github.io/categories/Java/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基本概念" scheme="https://muhouer.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>理财杂记</title>
    <link href="https://muhouer.github.io/posts/847d5b8e/"/>
    <id>https://muhouer.github.io/posts/847d5b8e/</id>
    <published>2019-08-21T16:27:00.000Z</published>
    <updated>2019-08-27T16:16:12.534Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一直很乐观，一直很谨慎。这才是长期生存之道。</strong></p><h2 id="一盆冷水"><a href="#一盆冷水" class="headerlink" title="一盆冷水"></a>一盆冷水</h2><h3 id="年轻人收入少，最好的投资是投资自己。"><a href="#年轻人收入少，最好的投资是投资自己。" class="headerlink" title="年轻人收入少，最好的投资是投资自己。"></a>年轻人收入少，最好的投资是投资自己。</h3><p>什么叫投资自己？什么叫让自己变得值钱？投资是一件带有明确目的性的东西，如果做事情没有目的性，那么不如不做。</p><p>如果做了没有达到目的，那就说明在浪费时间和金钱。变得值钱这件事情，更要有目的性，要有明确的KPI。</p><p>回过头来再看，各种让你学习烘焙旅游化妆穿衣的东西，能算是投资自己吗？<br>即使是所谓的考证，健身，读书，也得考虑一个回报率和执行力的问题。大多数人对于长期坚持考证这种事情，是坚持不下来的，人和人就是不一样的。办了健身房年卡，一年能去几次？去闲鱼看看那些便宜出的年卡就知道了。</p><p><strong>在没有足够数量的有效信息前，各种所谓的投资都是抓瞎。</strong></p><h3 id="依靠理财实现财务自由"><a href="#依靠理财实现财务自由" class="headerlink" title="依靠理财实现财务自由"></a>依靠理财实现财务自由</h3><p>如果说投资自己是欺负年轻人的话，那么依靠理财财务自由则是针对职场人士的春秋大梦。那些靠吃利息的人，绝大多数也都是通过其他行业完成了自己的资本积累，例如1000万。</p><p>理财这件事情说穿了就是把你已有的资金做一个增量，这显然是受限于你的本金的，人家1000万本金一年赚3%都有30万，你5万块钱一年15%也就7千5.</p><p><strong>很多人的问题不在于3%或者15%，而是在于1000万还是5万。</strong></p><p>而且投资其实一个技能，这个技能需要大量的时间积累和实战的，就和你做医生，程序员，工程师，老师一样，不是一蹴而就的，你一个普普通通在自己行业冒头都费劲的人，突然就靠理财财务自由了，这东西有点魔幻。</p><p>一开始就要把目的定下来，让自己舒服一点，但不求大富大贵。大富大贵的东西不要学理财，建议去学刑法。</p><h3 id="投资一定要跟着高手进行操作"><a href="#投资一定要跟着高手进行操作" class="headerlink" title="投资一定要跟着高手进行操作"></a>投资一定要跟着高手进行操作</h3><p>认真想想，你和高手的风险承受能力，信息获取能力，资金量级，心态，时间成本都是完全不一样的，你去学高手的操作模式是得有多么想不通。</p><p>人家高手加杠杆的同时还有另一批资金做风险对冲，你自己傻乎乎地跟着人家加杠杆进场一波就把自己玩儿炸掉。人家高手投资某个标的的时候往往有数据支撑或者内幕消息，你傻乎乎跟着投进去最后就是给高手接盘的。</p><p>高手的操作模式和普通人的操作根本不是一种东西，二者从目的性上就有本质的区别。</p><ol><li>开F1和骑自行车都是交通技术，但能一样么？</li><li>十以内加减法和微积分都是数学，你让小学生学微积分试试？</li></ol><p>不同的人，要有不同的投资模式，强行并线很容易出事故的。而且吧，专业人士操作的时效性要求很高，哪里有空和你比比？</p><p>我自己玩高频交易的时候，根本没空和人家废话，各种公式等着我配平，各种市场风险要在指标变化的第一时间做对冲，时刻要盯着自己的平仓线和保证金，哪里有心思还教人怎么玩儿？</p><p>有的人就是想赚点小钱，学什么杠杆，找死么。有的人心理承受能力就是差，那就去买银行理财，搞什么P2P。有的人天生就是只想投自己懂的公司，那就买股票，死也是个明白鬼。</p><p>普通人应该是有普通人的玩法。非得跟着高手操作的结果，很有可能是人家车都开到下一站了，你还在天上飘着呢。</p><h3 id="大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。"><a href="#大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。" class="headerlink" title="大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。"></a>大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。</h3><p>这话本身没错，但是要看对谁说。</p><p>对于已经挺有钱的人而言是对的，因为他们的时间本身就挺值钱，没有必要在细节上浪费。但是对于绝大多数时间不能直接变成钱的普通人而言，这句话是最毒的鸡汤。</p><p>对于普通人而言，买房买车买包买表这种大钱，大家都会本能性的谨慎，去收集信息，去权衡利弊，其实用不着和人讲谨慎，大家都知道要谨慎。反而是打车，是大量奶茶零食，是大量9块9包邮，是各种拼单凑单，才是普通人资金流血的最大问题所在。</p><p>电子支付的快速发展更加剧了这一问题，过去有一堆堆的现金摆在面前还会让人警醒一点，而现在年轻人手机一刷，感知上就弱了很多。甚至负债类消费已经流行到不需要感知的程度，二维码背后就是信用卡和透支产品，很多人都是一到要还卡的时候才傻了眼，平时根本没什么感觉。</p><p>而投资理财这件事情，我上面第二点说了，最重要的是先要有本金，哪怕是不多的本金，然后才是收益率。</p><p>如果不控制住这种弱感知的消费，管理不好自己的资金流，那么永远也没有本金可言，所谓的投资理财在一开始就完犊子了。</p><p><strong>资金流管理，是我觉得每个人都应该学的第一步。</strong></p><h2 id="我觉得还会涨"><a href="#我觉得还会涨" class="headerlink" title="我觉得还会涨"></a>我觉得还会涨</h2><img src="/images/201908240012.png" width="800px" height="300px" align="center"><p>出现负利率贷款，金毛大总统接连搞事，不确定因素太多了…… 如果回到一年前，我一定重仓黄金，然后把这件事忘记，一年半之后再卖掉。这个时候我也买了点，看看能不能赶上末班车，喝点汤。希望别打脸~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一直很乐观，一直很谨慎。这才是长期生存之道。&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;一盆冷水&quot;&gt;&lt;a href=&quot;#一盆冷水&quot; class=&quot;headerlink&quot; title=&quot;一盆冷水&quot;&gt;&lt;/a&gt;一盆冷水&lt;/h2&gt;&lt;h3 id=&quot;年轻人收入少，最好的投
      
    
    </summary>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>CodeReview最佳实践</title>
    <link href="https://muhouer.github.io/posts/eb547231/"/>
    <id>https://muhouer.github.io/posts/eb547231/</id>
    <published>2019-08-21T16:15:06.000Z</published>
    <updated>2019-08-21T16:25:18.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：宝玉<br>原文：<a href="https://www.cnblogs.com/dotey/p/11216430.html" target="_blank" rel="noopener">https://www.cnblogs.com/dotey/p/11216430.html</a></p></blockquote><p>我一直认为Code Review（代码审查）是软件开发中的最佳实践之一，可以有效提高整体代码质量，及时发现代码中可能存在的问题。包括像Google、微软这些公司，Code Review都是基本要求，代码合并之前必须要有人审查通过才行。</p><p>然而对于我观察到的大部分软件开发团队来说，认真做Code Review的很少，有的流于形式，有的可能根本就没有Code Review的环节，代码质量只依赖于事后的测试。也有些团队想做好代码审查，但不知道怎么做比较好。</p><p>网上关于如何做Code Review的文章已经有很多了，这里我结合自己的一些经验，也总结整理了一下Code Review的最佳实践，希望能对大家做好Code Review有所帮助。</p><h2 id="Code-Review有什么好处？"><a href="#Code-Review有什么好处？" class="headerlink" title="Code Review有什么好处？"></a>Code Review有什么好处？</h2><p>很多团队或个人不做Code Review，根源还是不觉得这是一件有意义的事情，不觉得有什么好处。这个问题要从几个角度来看。</p><h3 id="团队知识共享的角度"><a href="#团队知识共享的角度" class="headerlink" title="团队知识共享的角度"></a>团队知识共享的角度</h3><p>一个开发团队中，水平有高有低，每个人侧重的领域也有不同。怎么让高水平的帮助新人成长？怎么让大家都对自己侧重领域之外的知识保持了解？怎么能有人离职后其他人能快速接手？这些都是团队管理者关心的问题。</p><p>而代码审查，就是一个很好的知识共享的方式。通过代码审查，高手可以直接指出新手代码中的问题，新手可以马上从高手的反馈中学习到好的实践，得到更快的成长；通过代码审查，前端也可以去学习后端的代码，做功能模块A的可以去了解功能模块B的。</p><p>可能有些高手觉得给新手代码审查浪费时间，自己也没收获。其实不然，新人成长了，就可以更多的帮高手分担繁重的任务；代码审查中花时间，就少一些帮新人填坑擦屁股的时间；良好的沟通能力、发现问题的能力、帮助其他人成长，都是技术转管理或技术上更上一层楼必不可少的能力，而通过代码审查可以有效的去练习这些方面的能力。</p><h3 id="代码质量的角度"><a href="#代码质量的角度" class="headerlink" title="代码质量的角度"></a>代码质量的角度</h3><p>现实中的项目总是人手缺进度紧，所以被压缩的往往就是自动化测试和代码审查，结果影响代码质量，欠下技术债务，最后还是要加倍偿还。</p><p>也有人寄希望于开发后的人工测试，然而对于代码质量来说，很多问题通过测试是测试不出来的，只能通过代码审查。比如说代码的可读性可维护性，比如代码的结构，比如一些特定条件才触发的死循环、逻辑算法错误，还有一些安全上的漏洞也更容易通过代码审查发现和预防。</p><p>也有人觉得自己水平高就不需要代码审查了。对于高手来说，让别人审查自己的代码，可以让其他人学习到好的实践；在让其他人审查的同时，在给别人说明自己代码的时候，也等于自己对自己的代码进行了一次审查。这其实就跟我们上学时做数学题一样，真正能拿高分的往往是那些做完后还会认真检查的。</p><h3 id="团队规范的角度"><a href="#团队规范的角度" class="headerlink" title="团队规范的角度"></a>团队规范的角度</h3><p>每个团队都有自己的代码规范，有自己的基于架构设计的开发规范，然而时间一长，就会发现代码中出现很多不遵守代码规范的情况，有很多绕过架构设计的代码。比如难以理解和不规范的命名，比如三层架构里面UI层绕过业务逻辑层直接调用数据访问层代码。</p><p>如果这些违反规范的代码被纠正的晚了，后面再要修改就成本很高了，而且团队的规范也会慢慢的形同虚设。</p><p>通过代码审查，就可以及时的去发现和纠正这些问题，保证团队规范的执行。</p><p>关于代码审查的好处，还有很多，也不一一列举。还是希望能认识到Code Review和写自动化测试一样，都是属于磨刀不误砍柴工的工作，在上面投入一点点时间，未来会收获代码质量，会节约整体的开发时间。</p><h2 id="该怎么做？"><a href="#该怎么做？" class="headerlink" title="该怎么做？"></a>该怎么做？</h2><p>现在很多人都已经有意识到Code Review的重要性了，只是苦于不知道如何去实践，不知道怎么样算是好的Code Review实践。</p><h3 id="把Code-Review作为开发流程的必选项而不是可选项"><a href="#把Code-Review作为开发流程的必选项而不是可选项" class="headerlink" title="把Code Review作为开发流程的必选项而不是可选项"></a>把Code Review作为开发流程的必选项而不是可选项</h3><p>在很早以前，我就尝试过将代码审查作为代码流程的一部分，但只是一个可选项，没有Code Review也可以把代码合并到master。这样的结果就是想起来才会去做Code Review，去检查的时候已经有了太多的代码变更，审查起来非常困难，另外就算审查出问题，也很难得以修改。</p><p>我们现在对代码的审查则是作为开发流程的一个必选项，每次开发新功能或者修复Bug，开一个新的分支，分支要合并到master有两个必要条件：</p><ol><li>所有的自动化测试通过</li><li>有至少一个人Code Review通过，如果是新手的PR，还必须有资深程序员Code Review通过。</li></ol><p>这样把Code Review作为开发流程的一个必选项后，就很好的保证了代码在合并之前有过Code Review。而且这样合并前要求代码审查的流程，好处也很明显：</p><ol><li>由于每一次合并前都要做代码审查，这样一般一次审查的代码量也不会太大，对于审查者来说压力也不会太大。</li><li>如果在Code Review时发现问题，被审查者希望代码能尽快合并，也会积极的对审查出来的问题进行修改，不至于对审查结果太过抵触。</li></ol><p>如果你觉得Code Review难以推行，不妨先尝试着把Code Review变成你开发流程的一个必选项。</p><h3 id="把Code-Review变成一种开发文化而不仅仅是一种制度"><a href="#把Code-Review变成一种开发文化而不仅仅是一种制度" class="headerlink" title="把Code Review变成一种开发文化而不仅仅是一种制度"></a>把Code Review变成一种开发文化而不仅仅是一种制度</h3><p>把Code Review 作为开发流程的必选项后，不代表Code Review这件事就可以执行的很好，因为Code Review 的执行，很大部分程度上依赖于审查者的认真审查，以及被审查者的积极配合，两者缺一不可！</p><p>如果仅仅只是当作一个流程制度，那么就可能会流于形式。最终结果就是看起来有Code Review，但没有人认真审查，随便看下就通过了，或者发现问题也不愿意修改。</p><p>真要把Code Review这件事做好，必须让Code Review变成团队的一种文化，开发人员从心底接受这件事，并认真执行这件事。</p><p>要形成这样的文化，不那么容易，也没有想象的那么难，比如这些方面可以参考：</p><ol><li>首先，得让开发人员认识到Code Review这件事为自己、为团队带来的好处。</li><li>然后，得要有几个人做好表率作用，榜样的力量很重要。</li><li>还有，对于管理者来说，你激励什么，往往就会得到什么。</li><li>最后，像写自动化测试一样，把Code Review要作为开发任务的一部分，给审查者和被审查者都留出专门的时间去做这件事，不能光想着马儿跑得快又舍不得给马儿吃草。</li></ol><p>如何形成这样的文化，有心的话，还有很多方法可以尝试。只有真正让大家都认同和践行，才可能去做好Code Review这件事。</p><h2 id="一些Code-Review的经验技巧"><a href="#一些Code-Review的经验技巧" class="headerlink" title="一些Code Review的经验技巧"></a>一些Code Review的经验技巧</h2><p>在做好Code Review这件事上，还有一些经验技巧可以参考。</p><h3 id="选什么工具辅助做CODE-REVIEW？"><a href="#选什么工具辅助做CODE-REVIEW？" class="headerlink" title="选什么工具辅助做CODE REVIEW？"></a>选什么工具辅助做CODE REVIEW？</h3><p>现在很多源代码管理工具都自带Code Review工具，典型的像Github、Gitlab、微软的Azure DevOps，尤其是像Gitlab，还可以自己在本地搭建环境，根据自己的需要灵活配置。</p><h3 id="配合什么样的开发流程比较好？"><a href="#配合什么样的开发流程比较好？" class="headerlink" title="配合什么样的开发流程比较好？"></a>配合什么样的开发流程比较好？</h3><p>像Github Flow[1]这样基于分支开发的流程是特别适合搭配Code Review的。其实不管什么样的开发流程，关键点在于代码合并到master（主干）之前，要先做Code Review。</p><h3 id="真遇到紧急情况，来不及代码审查怎么办？"><a href="#真遇到紧急情况，来不及代码审查怎么办？" class="headerlink" title="真遇到紧急情况，来不及代码审查怎么办？"></a>真遇到紧急情况，来不及代码审查怎么办？</h3><p>虽然原则上，必须要Code Review才能合并，但有时候确实会存在一些紧急情况，比如说线上故障补丁，而又没有其他人在线，那么这种情况下，最好是在任务管理系统中，创建一个Ticket，用来后续跟踪，确保后续补上Code Review，并对Code Review结果有后续的代码更新。</p><h3 id="先设计再编码"><a href="#先设计再编码" class="headerlink" title="先设计再编码"></a>先设计再编码</h3><p>有些新人发现自己的代码提交PR（Pull Request）后，会收到一堆的Code Review意见，必须要做大量的改动。这多半是因为在开始做之前，没有做好设计，做出来后才发现问题很多。</p><p>建议在做一个新功能之前，写一个简单的设计文档，表达清楚自己的设计思路，找资深的先帮你做一下设计的审查，发现设计上的问题。设计上没问题了，再着手开发，那么到Review的时候，相对问题就会少很多。</p><h3 id="代码在提交CODE-REVIEW之前，作者要自己先REVIEW和测试一遍"><a href="#代码在提交CODE-REVIEW之前，作者要自己先REVIEW和测试一遍" class="headerlink" title="代码在提交CODE REVIEW之前，作者要自己先REVIEW和测试一遍"></a>代码在提交CODE REVIEW之前，作者要自己先REVIEW和测试一遍</h3><p>我在做代码审查的时候，有时候会发现一些非常明显的问题，有些甚至自己都没有测试过，就等着别人Code Review和测试帮助发现问题。这种依赖心理无论是对自己还是对团队都是很不负责任的。</p><p>一个好的开发人员，代码在提交Code Review之前，肯定是要自己先Review一遍，把该写的自动化测试代码写上，自己把基本的测试用例跑一遍的。</p><p>我对于团队提交的PR，有个要求就是要在PR的描述中增加截图或者录屏，就是为了通过截图或者录屏，确保提交PR的人自己是先测试过的。这也是一个有效的辅助手段。</p><h3 id="PR要小"><a href="#PR要小" class="headerlink" title="PR要小"></a>PR要小</h3><p>在做Code Review的时候，如果有大量的文件修改，那么Review起来是很困难的，但如果PR比较小，相对就比较容易Review，也容易发现代码中可能存在的问题。</p><p>所以在提交PR时，PR要小，如果是比较大的改动，那么最好分批提交，以减轻审查者的压力。</p><h3 id="对评论进行分级"><a href="#对评论进行分级" class="headerlink" title="对评论进行分级"></a>对评论进行分级</h3><p>在做Code Review时，需要针对审查出有问题的代码行添加评论，如果只是评论，有时候对于被审查者比较难甄别评论所代表的含义，是不是必须要修改。</p><p>建议可以对Review的评论进行分级，不同级别的结果可以打上不同的Tag，比如说：</p><ol><li>[blocker]: 在评论前面加上一个blocker标记，表示这个代码行的问题必须要修改</li><li>[optional]：在评论前面加上一个[optional]标记，表示这个代码行的问题可改可不改</li><li>[question]：在评论前面加上一个[question]标记，表示对这个代码行不理解，有问题需要问，被审查者需要针对问题进行回复澄清<br>类似这样的分级可以帮助被审查者直观了解Review结果，提高Review效率。</li></ol><p>评论要友好，避免负面词汇；有说不清楚的问题当面沟通</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Code Review是一种非常好的开发实践，如果你还没开始，不妨逐步实践起来；如果已经做了效果不好，不妨对照一下，看有没有把Code Review作为开发流程的必选项而不是可选项？有没有把Code Review变成一种开发文化而不仅仅是一种制度？</p><p>虽然评论是主要的Code Review沟通方式，但也不要过于依赖，有时候面对面的沟通效率更高，也容易消除误解。</p><p>另外文明用语，不要用一些负面的词汇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作者：宝玉&lt;br&gt;原文：&lt;a href=&quot;https://www.cnblogs.com/dotey/p/11216430.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/do
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>杂记-数学概念</title>
    <link href="https://muhouer.github.io/posts/a12aac50/"/>
    <id>https://muhouer.github.io/posts/a12aac50/</id>
    <published>2019-08-21T15:37:00.000Z</published>
    <updated>2019-08-22T15:29:12.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欧拉常数与圆周率"><a href="#欧拉常数与圆周率" class="headerlink" title="欧拉常数与圆周率"></a>欧拉常数与圆周率</h2><p><code>e</code> 是一个不可思议且特别的定数。在这层意义上，欧拉常数 <code>e</code> 与圆周率 <code>π</code> 是两个至关重要的数学定数，就算说成是神赐予人类的数字也不为过。吹爆炸！！！</p><h2 id="m-n-x-y-mx-my-nx-ny"><a href="#m-n-x-y-mx-my-nx-ny" class="headerlink" title="(m+n)(x+y) = mx + my + nx + ny"></a>(m+n)(x+y) = mx + my + nx + ny</h2><img src="/images/201908211139.png" width="800px" height="400px" align="center"><h2 id="除法的两个意义"><a href="#除法的两个意义" class="headerlink" title="除法的两个意义"></a>除法的两个意义</h2><p>a÷n=p</p><h3 id="等分除"><a href="#等分除" class="headerlink" title="等分除"></a>等分除</h3><p>将a分成n等份，则每份有p个。不同单位的比例为等分除。</p><h3 id="包含除"><a href="#包含除" class="headerlink" title="包含除"></a>包含除</h3><p>将a按照每份有n个等分，则可以分成p份（a有p份的n个）。相同单位的比例为包含除。</p><h2 id="图表的特点"><a href="#图表的特点" class="headerlink" title="图表的特点"></a>图表的特点</h2><ol><li>柱状图：表示大小</li><li>折线图：表示变化</li><li>饼图：表示比例</li><li>带状图：比较比例</li></ol><h2 id="频数分布表"><a href="#频数分布表" class="headerlink" title="频数分布表"></a>频数分布表</h2><p>频数分布表就是将每组中的频数、相对频数、累计相对频数等做成一张表。</p><ol><li>组：将数据以相同间隔分开的区间。</li><li>组中值：各组上下限中间的数值。</li><li>频数：各组中包含数值的数量。</li><li>相对频数：各组数据频数在总频数中的占比。</li><li>累计相对频数：逐级相对频数相加的和。</li></ol><h2 id="分组取组段值"><a href="#分组取组段值" class="headerlink" title="分组取组段值"></a>分组取组段值</h2><p>分组取组段值时，可以参照下面的JIS（日本工业标准的简称）标准：</p><blockquote><p>将包含最大值与最小值在内的数据，分成5～20组时，用最大值与最小值之差（R）除以1、2、5（或者是10、20、50;0.1、0.2、0.5）等各备选范围，选择结果在5～20范围内的数。如果有两个不同的结果，那么，最大值与最小值之差大于100则取小，反之则取大。</p></blockquote><h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><p>将数据由大到小排列时，位于最中间的数值。</p><p>中位数的求法</p><ol><li>将数据按大小排列。</li><li>“当数据个数为奇数时”:中位数=正中间的数值。</li><li>“当数据个数为偶数时”:中位数=正中间两个数值的平均值。</li></ol><h2 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h2><p>一组数据中出现次数最多的数值。即频数最高的数据的值。</p><h2 id="偏差"><a href="#偏差" class="headerlink" title="偏差"></a>偏差</h2><p>偏差 = 50 + (指定的值-平均值)/标准差 * 10</p><h2 id="四分位数"><a href="#四分位数" class="headerlink" title="四分位数"></a>四分位数</h2><p>四分位数是指，将数据从小到大排列并分成4等份后，处于3个分割点上的数。这3个四分位数按照从小到大的顺序分别被称为第一四分位数、第二四分位数和第三四分位数。</p><p>第二四分位数和数据的中位数是一致的。</p><p>四分位数的求法</p><ol><li>找出数据的最大值与最小值。</li><li>找出数据的中位数→第二四分位数。</li><li>求出中位数前半部分数据的中位数→第一四分位数。</li><li>求出中位数后半部分数据的中位数→第三四分位数。</li></ol><h2 id="倍数的辨别方法"><a href="#倍数的辨别方法" class="headerlink" title="倍数的辨别方法"></a>倍数的辨别方法</h2><p>2的倍数：尾数为偶数。</p><p>3的倍数：各位数相加的和为3的倍数。</p><p>4的倍数：末尾两位数为4的倍数或整百数。</p><p>5的倍数：尾数为0或5。</p><p>6的倍数：尾数为偶数，且各位数的和为3的倍数。</p><p>7的倍数：将个位数字去掉之后的数 - 个位数字的两倍 = 7的倍数。</p><h3 id="证明判断3的倍数方法"><a href="#证明判断3的倍数方法" class="headerlink" title="证明判断3的倍数方法"></a>证明判断3的倍数方法</h3><p>首先，拿一个3位数举个栗子，a，b，c 是一个小于10的正整数，则 <code>100a + 10b + c</code>可以表示一个三位数，从而可以得到 <code>100a + 10b + c = 99a + 9b + (a + b + c)</code>，从而只需要<strong>各位数相加的和为3的倍数</strong>即可。更多位数同理可证。</p><h3 id="证明判断7的倍数方法"><a href="#证明判断7的倍数方法" class="headerlink" title="证明判断7的倍数方法"></a>证明判断7的倍数方法</h3><p>如果把一个数记作 10x + y，则<code>10x + y = 7(x + y) + 3x - 6y = 7(x + y) + 3(x - 2y)</code>，即<strong>将个位数字去掉之后的数 - 个位数字的两倍=7的倍数</strong>。</p><h2 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h2><p>一般来说，成功概率为p的实验，独立重复n次后的成功次数为X的概率分布，被称为关于发生概率为p、次数为n的二项分布。</p><h2 id="和事件与积事件"><a href="#和事件与积事件" class="headerlink" title="和事件与积事件"></a>和事件与积事件</h2><p>一般来说，如果一个试验中有A与B两个事件，“A与B至少有一个事件发生”的事件被称为A与B的和事件，写作A∪B；而“A与B同时发生”的事件被称为积事件，写作A∩B。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;欧拉常数与圆周率&quot;&gt;&lt;a href=&quot;#欧拉常数与圆周率&quot; class=&quot;headerlink&quot; title=&quot;欧拉常数与圆周率&quot;&gt;&lt;/a&gt;欧拉常数与圆周率&lt;/h2&gt;&lt;p&gt;&lt;code&gt;e&lt;/code&gt; 是一个不可思议且特别的定数。在这层意义上，欧拉常数 &lt;code
      
    
    </summary>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="数学概念" scheme="https://muhouer.github.io/tags/%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>枚举类型</title>
    <link href="https://muhouer.github.io/posts/4502a76f/"/>
    <id>https://muhouer.github.io/posts/4502a76f/</id>
    <published>2019-08-20T16:44:00.000Z</published>
    <updated>2019-08-20T16:52:25.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>枚举类型（<code>enum type</code>）是指由一组固定的常量组成合法的类型。<code>Java</code> 中由关键字 <code>enum</code> 来定义一个枚举类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">    SPRING, SUMMER, AUTUMN, WINER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句定义：</p><ol><li>使用关键字 <code>enum</code></li><li>类型名称，比如这里的<code>Season</code></li><li>枚举中的属性必须放在最前面，一般使用大写字母表示</li><li>枚举可以单独定义在一个文件中，也可以嵌在其它<code>Java</code>类中</li><li>枚举可以实现一个或多个接口（Interface）</li><li>可以和 java 类一样定义方法 ，枚举中的构造方法必须是私有的。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 <code>javap</code> 进行反编译可以看到 <code>public final class Season extends Enum</code>，也就是说当我们使用 <code>enum</code> 来定义一个枚举类型的时候，编译器会自动帮我们创建一个 <code>final</code> 类型且继承自 <code>Enum</code> 的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Season</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Season</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season SPRING;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season SUMMER;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season AUTUMN;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.muhouer.algorithm.Season WINER;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.muhouer.algorithm.Season[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.muhouer.algorithm.<span class="function">Season <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些特殊方法"><a href="#一些特殊方法" class="headerlink" title="一些特殊方法"></a>一些特殊方法</h2><ol><li><p>Java 枚举值比较用 <code>==</code> 和 <code>equals()</code> 方法效果是一样的。因为枚举 Enum 类的 <code>equals()</code> 方法的实现就是使用 <code>==</code> ；</p></li><li><p>Enum 的 <code>compareTo()</code>方法实际上比较的是 Enum 的 ordinal 顺序大小；</p></li><li><p>Enum 在 <code>switch</code> 中比较的是 Enum 的 ordinal 值；</p></li><li><p>Enum 的 <code>name()</code>方法和 <code>toString()</code> 方法效果一样，返回的都是 Enum 的 name 值。</p></li></ol><h2 id="序列化及线程安全"><a href="#序列化及线程安全" class="headerlink" title="序列化及线程安全"></a>序列化及线程安全</h2><p>为了保证枚举类型像 Java 规范中规定的那样，每一个枚举类型极其定义的枚举变量在 JVM 中都是唯一的，在枚举类型的序列化和反序列化上，Java 做了特殊的规定:</p><blockquote><p>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.</p></blockquote><p>大概意思就是说，在序列化的时候 Java 仅仅是将枚举对象的 name 属性输出到结果中，反序列化的时候则是通过java.lang.Enum 的 <code>valueOf()</code> 方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了 <code>writeObject</code>、<code>readObject</code>、<code>readObjectNoData</code>、<code>writeReplace</code> 和 <code>readResolve</code> 等方法。 我们看一下这个<code>valueOf()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String name)</span> </span>&#123;</span><br><span class="line">    T result = enumType.enumConstantDirectory().get(name); <span class="comment">// 获取枚举类型的枚举常量字典</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 找到即返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) <span class="comment">// 否则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Map&lt;String, T&gt; enumConstantDirectory = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a map from simple name to enum constant.  This package-private</span></span><br><span class="line"><span class="comment"> * method is used internally by Enum to implement</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)&#125;</span></span><br><span class="line"><span class="comment"> * efficiently.  Note that the map is returned by this method is</span></span><br><span class="line"><span class="comment"> * created lazily on first use.  Typically it won't ever get created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Map&lt;String, T&gt; <span class="title">enumConstantDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enumConstantDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        T[] universe = getEnumConstantsShared();  <span class="comment">// 反射的方式调用枚举类型的 values() 静态方法</span></span><br><span class="line">        <span class="keyword">if</span> (universe == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                getName() + <span class="string">" is not an enum type"</span>);</span><br><span class="line">        Map&lt;String, T&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span> * universe.length);</span><br><span class="line">        <span class="keyword">for</span> (T constant : universe)</span><br><span class="line">            m.put(((Enum&lt;?&gt;)constant).name(), constant); <span class="comment">// 填充 enumConstantDirectory</span></span><br><span class="line">        enumConstantDirectory = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enumConstantDirectory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从👆可以看出，JVM 对枚举类型序列化有保证。</p><p>枚举类型是一个 final 类型的继承自 Enum 的类，所以枚举类型不能被继承，而且这个类中的属性和方法都是static 类型的。当一个 Java 类第一次被真正使用到的时候静态资源初始化、Java 类的加载和初始化过程都是线程安全的。所以，<strong>创建一个enum类型是线程安全的</strong>。</p><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>在StakcOverflow中，有一个关于<a href="https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java" target="_blank" rel="noopener">在 Java 中哪种写单例的方式最好</a>的讨论。</p><p>Joshua Bloch大神在《Effective Java》中明确表达过的观点：</p><blockquote><p>使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</p></blockquote><p>使用枚举实现单例的好处：</p><ol><li><p>枚举单例写法简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程安全：枚举实现的单例是天生线程安全的。</p></li><li><p>反序列化不会破坏单例。</p><blockquote><p>普通的 Java 类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。所以，即使单例中构造函数是私有的，也会被反射给破坏掉。由于反序列化后的对象是重新 new 出来的，所以这就破坏了单例。</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;枚举类型（&lt;code&gt;enum type&lt;/code&gt;）是指由一组固定的常量组成合法的类型。&lt;code&gt;Java&lt;/code&gt; 中由关键字 
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="枚举类型" scheme="https://muhouer.github.io/tags/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>杂记-天秀</title>
    <link href="https://muhouer.github.io/posts/ff247979/"/>
    <id>https://muhouer.github.io/posts/ff247979/</id>
    <published>2019-08-20T15:06:47.000Z</published>
    <updated>2019-08-20T16:44:49.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。"><a href="#在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。" class="headerlink" title="在一个8×8的国际象棋棋盘上, 显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。"></a>在一个8×8的国际象棋棋盘上, 显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。</h2><h3 id="问：如果将对角线上的两个方格挖掉-那剩下来的62个格子还能用31张骨牌覆盖住吗？"><a href="#问：如果将对角线上的两个方格挖掉-那剩下来的62个格子还能用31张骨牌覆盖住吗？" class="headerlink" title="问：如果将对角线上的两个方格挖掉, 那剩下来的62个格子还能用31张骨牌覆盖住吗？"></a>问：如果将对角线上的两个方格挖掉, 那剩下来的62个格子还能用31张骨牌覆盖住吗？</h3><img src="/images/201908201107.png" width="500px" height="500px" align="center"><p>答：每一张骨牌在棋盘上必是覆盖住两个相邻方格, 一白一黑。挖掉两个角之后只有 32 黑 30 白, 于是就不存在这样一种能用31个骨牌覆盖的方法。</p><h3 id="问：任意切掉一个一白一黑的格子就一定可以吗？"><a href="#问：任意切掉一个一白一黑的格子就一定可以吗？" class="headerlink" title="问：任意切掉一个一白一黑的格子就一定可以吗？"></a>问：任意切掉一个一白一黑的格子就一定可以吗？</h3><img src="/images/201908201108.png" width="500px" height="500px" align="center"><p>答：可以。粗黑线条将整个棋盘转变为一条首尾相连、黑白格相间的封闭路线。从这棋盘上切掉任何两个颜色不同的方格, 会让这个封闭线路变成两段线路, 当然如果切掉的方格是相连的, 那就是一条线路。显然, 在任何线路中, 两种颜色的格子数量都是偶数，故分别都可以被若干张骨牌覆盖。从而整个棋盘一定可以被31张骨牌完全覆盖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。&quot;&gt;&lt;a href=&quot;#在一个8×8的国际象棋棋盘上-显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。&quot; class=&quot;headerlink&quot; title=&quot;在一个8
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>杂记-科学与方法</title>
    <link href="https://muhouer.github.io/posts/b549d39b/"/>
    <id>https://muhouer.github.io/posts/b549d39b/</id>
    <published>2019-08-20T14:40:00.000Z</published>
    <updated>2019-08-20T14:44:59.797Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>假如在那里居住着智者，这些智者毫无好奇心，避免一切过度行为，那么他们不会死于疾病，而确实将死于无聊。</p></li><li><p>法则一经确立，我们首先就要寻找这个法则具有最大失效机遇的情况。我们应该达到的目的主要不在于弄清相似和差异，而是要认出隐藏在表观偏离下的类似性。</p></li><li><p>科学家研究自然，并非因为它有用处；他研究它，是因为他喜欢它，他之所以喜欢它，是因为它是美的。如果自然不美，它就不值得了解；如果自然不值得了解，生命也就不值得活着。</p></li><li><p>假如没有能够在事实中选择、分辨在哪些事实背后隐藏某种东西，以及识别什么正在隐藏着的精神，假如没有在未加工的事实下察觉事实精髓的精神，事实也许是毫无成果的。</p></li><li><p>事实的重要性用它产生的效益来衡量，也就是说，用它容许我们节省的思维数量来衡量。思维经济是我们应该对准的目标，因此提供仿效的模型还是不够的。需要使我们之后的人能够省却这些模型，不去重复已做出的论据，而用几句话概括它。</p></li><li><p>我们应该经常力图去做的，可以说是定性地解决问题；也就是说，力图去了解表示未知函数的曲线的一般形状。依然要寻找问题的定量的解。</p></li><li><p>往往发生这种情况：不完美的解把我们引向比较完美的解。有时，级数收敛过慢，以致计算无法实际进行。我们仅仅得以证明问题的可能性。</p></li><li><p>偶然性仅仅是我们无知的度量。按照定义，偶然发生的现象就是我们不知道其规律的现象。</p></li><li><p>对称性的最小欠缺将使它稍微倾斜到一侧或另一侧，而且如果它倾斜了，不管倾斜得多么小，它必将完全倾向那一侧。</p></li><li><p>我不可能预见我推动的指针将停在何处，这就是我的心紧张地跳动，期望一切都交好运的缘由。原因上的差别是难以觉察的，而结果上的差别对我来说却是至关重要的，由于它就是我的整个赌注。</p></li><li><p>我们忽路了这样一些情况,这些情况乍看起来似乎完全是在我们预见之外发生的，人们从来也没有梦想到把任何影响归咎于它，不过与我们的预期相反，它最终却起着重要的作用。</p></li><li><p>我们不知道偶然误差由什么引起的，而且正因为我们不知道，我们才意识到它们服从高斯定律。</p></li><li><p>不是严格的证明微不足道。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;&lt;li&gt;&lt;p&gt;假如在那里居住着智者，这些智者毫无好奇心，避免一切过度行为，那么他们不会死于疾病，而确实将死于无聊。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;法则一经确立，我们首先就要寻找这个法则具有最大失效机遇的情况。我们应该达到的目的主要不在于弄清相似和差异，而是要认出隐藏在表观
      
    
    </summary>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="科学与方法" scheme="https://muhouer.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>证明杂记</title>
    <link href="https://muhouer.github.io/posts/c1a19f3f/"/>
    <id>https://muhouer.github.io/posts/c1a19f3f/</id>
    <published>2019-08-18T06:22:00.000Z</published>
    <updated>2019-08-21T16:06:47.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何证明-0-99999……-1"><a href="#如何证明-0-99999……-1" class="headerlink" title="如何证明 0.99999…… = 1"></a>如何证明 <code>0.99999…… = 1</code></h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><code>1/3 = 0.33333……</code> ==&gt; <code>1 = 0.99999……</code></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><code>10 * 0.99999…… = 9.9999……</code><br>两边各减去一个 <code>0.99999……</code> ==&gt; <code>9 * 0.99999…… = 9</code> ==&gt; <code>0.99999…… = 1</code></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p><code>0.99999…… = 0.9 + 0.09 + 0.009 + ……</code><br>采用等比数列求和，然后求极限。</p><p>从而可以得到 <strong>0.99999…… + n = n + 1</strong>，例如： <strong>9.99999…… = 10</strong></p><h2 id="有趣的-PI-和-E"><a href="#有趣的-PI-和-E" class="headerlink" title="有趣的 PI 和 E"></a>有趣的 <code>PI</code> 和 <code>E</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.pow(Math.PI, 4) + Math.pow(Math.PI, 5)</span><br><span class="line">403.4287758192838</span><br><span class="line">&gt; Math.pow(Math.E, 6)</span><br><span class="line">403.428793492735</span><br></pre></td></tr></table></figure><p><code>PI^4 + PI^5 约等于 E^6</code> 可以精确到小数点后四位。<br>紧跟这个精度之后的是 <code>PI^146 + PI^152 约等于 E^174</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.pow(Math.PI, 146) + Math.pow(Math.PI, 152)</span><br><span class="line">3.6917488742520865e+75</span><br><span class="line">&gt; Math.pow(Math.E, 174)</span><br><span class="line">3.6918143295804325e+75</span><br></pre></td></tr></table></figure><p>神奇！神奇！神奇！<br>有趣！有趣！有趣！</p><h2 id="时间复利"><a href="#时间复利" class="headerlink" title="时间复利"></a>时间复利</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.pow((1+1/365), 365)</span><br><span class="line">2.714567482021973</span><br><span class="line">&gt; Math.pow((1+1/365), 365*10)</span><br><span class="line">21727.333146076744</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何证明-0-99999……-1&quot;&gt;&lt;a href=&quot;#如何证明-0-99999……-1&quot; class=&quot;headerlink&quot; title=&quot;如何证明 0.99999…… = 1&quot;&gt;&lt;/a&gt;如何证明 &lt;code&gt;0.99999…… = 1&lt;/code&gt;&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数学" scheme="https://muhouer.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="杂记" scheme="https://muhouer.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>HashSet分析</title>
    <link href="https://muhouer.github.io/posts/88817346/"/>
    <id>https://muhouer.github.io/posts/88817346/</id>
    <published>2019-08-18T05:58:00.000Z</published>
    <updated>2019-08-20T16:46:43.638Z</updated>
    
    <content type="html"><![CDATA[<p><code>HashSet</code> 是一个不允许存储重复元素的集合，它的实现比较简单，只要理解了 <code>HashMap</code>，<code>HashSet</code> 基本就没什么问题。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>主要就两个变量:</p><ul><li><code>map</code> ：用于存放最终数据的。</li><li><code>PRESENT</code> ：是所有写入 map 的 <code>value</code> 值。</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数也很简单，利用 <code>HashMap</code> 初始化了 map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new set containing the elements in the specified</span></span><br><span class="line"><span class="comment"> * collection.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor</span></span><br><span class="line"><span class="comment"> * (0.75) and an initial capacity sufficient to contain the elements in</span></span><br><span class="line"><span class="comment"> * the specified collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash table</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的就是这个 <code>add()</code> 方法。 可以看出它是将存放的对象当做了 <code>HashMap</code> 的健，<code>value</code> 都是相同的 <code>PRESENT</code> 。由于 <code>HashMap</code> 的 <code>key</code> 是不能重复的，所以每当有重复的值写入到 <code>HashSet</code> 时，<code>value</code> 会被覆盖，但 <code>key</code> 不会受到影响，这样就保证了 <code>HashSet</code> 中只能存放不重复的元素。</p><h2 id="TreeSet-与-HashSet-的区别"><a href="#TreeSet-与-HashSet-的区别" class="headerlink" title="TreeSet 与 HashSet 的区别"></a>TreeSet 与 HashSet 的区别</h2><p>1、<code>TreeSet</code> 是二差树实现的，<code>Treeset</code>c中的数据是自动排好序的，不允许放入 null 值 2、<code>HashSet</code> 是哈希表实现的，<code>HashSet</code> 中的数据是无序的，可以放入 null，但只能放入一个 null，两者中的值都不能重复，就如数据库中唯一约束。</p><p>在 <code>HashSet</code> 中，基本的操作都是由 <code>HashMap</code> 底层实现的，因为 <code>HashSet</code> 底层是用 <code>HashMap</code> 存储数据的。当向<code>HashSet</code> 中添加元素的时候，首先计算元素的hashcode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。</p><p><code>TreeSet</code> 的底层是 <code>TreeMap</code> 的 keySet()，而 <code>TreeMap</code> 是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。</p><p><code>TreeMap</code> 是按key排序的，元素在插入 <code>TreeSet</code> 时 compareTo() 方法要被调用，所以 <code>TreeSet</code> 中的元素要实现Comparable 接口。<code>TreeSet</code> 作为一种Set，它不允许出现重复元素。<code>TreeSet</code> 是用 compareTo() 来判断重复元素的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>HashSet</code> 的原理比较简单，几乎全部借助于 <code>HashMap</code> 来实现的。即 <code>HashSet</code> 和 <code>HashMap</code> 是命运共同体，一荣俱荣，一损俱损。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;HashSet&lt;/code&gt; 是一个不允许存储重复元素的集合，它的实现比较简单，只要理解了 &lt;code&gt;HashMap&lt;/code&gt;，&lt;code&gt;HashSet&lt;/code&gt; 基本就没什么问题。&lt;/p&gt;&lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; 
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HashSet" scheme="https://muhouer.github.io/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList分析</title>
    <link href="https://muhouer.github.io/posts/5c1acfc0/"/>
    <id>https://muhouer.github.io/posts/5c1acfc0/</id>
    <published>2019-08-18T05:55:00.000Z</published>
    <updated>2019-08-20T16:46:27.303Z</updated>
    
    <content type="html"><![CDATA[<p><code>LinkedList</code> 底层是基于双向链表 <code>Deque</code> 实现的，也是实现了 <code>List</code> 接口，所以也拥有 List 的一些特点，出场率不高，了解一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>即类似如下形式：</p><p><code>first.prev == null &amp;&amp; first.next == a</code> &lt;——&gt; <code>a.prev = first&amp;&amp; a.next == last</code> &lt;——&gt; <code>last.prev == a &amp;&amp; last.next == null</code></p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>每次插入都是移动指针，和 <code>ArrayList</code> 的拷贝数组相比效率提升不少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>利用了双向链表的特性，使用空间来换取时间。如果索引值小于链表大小的一半，即 <code>index</code> 离链表头比较近，就从节点头部遍历，否则将从尾结点开始遍历。这就导致效率降低，特别是当 <code>index</code> 越接近 <code>size</code> 的中间值时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>LinkedList 插入，删除都是移动指针效率很高。</li><li>查找需要进行遍历查询，效率较低。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; 底层是基于双向链表 &lt;code&gt;Deque&lt;/code&gt; 实现的，也是实现了 &lt;code&gt;List&lt;/code&gt; 接口，所以也拥有 List 的一些特点，出场率不高，了解一下。&lt;/p&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="LinkedList" scheme="https://muhouer.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>HashMap分析</title>
    <link href="https://muhouer.github.io/posts/9c86c04c/"/>
    <id>https://muhouer.github.io/posts/9c86c04c/</id>
    <published>2019-08-18T01:34:00.000Z</published>
    <updated>2019-08-18T06:07:55.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Map 这样的 <code>Key Value</code> 在软件开发中是非常经典的结构，常用于在内存中存放数据。Java 中最常用的 Map 有两种，首先是 HashMap ，其次是 ConcurrentHashMap 。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>从整个 HashMap 的声明可以看出它内部是基于<strong>数组</strong> + <strong>链表</strong>实现的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p><h3 id="基于-1-7"><a href="#基于-1-7" class="headerlink" title="基于 1.7"></a>基于 1.7</h3><p>HashMap 在 jdk1.7 中的数据结构图：<br><img src="/images/5cd1d2be77958.png" width="900px" height="600px" align="center"><br>首先来看 jdk1.7 中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//初始化桶大小，因为底层是数组，所以这是数组默认的大小。默认大小16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">//桶最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; <span class="comment">//真正存放数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;      <span class="comment">//存放key-value元素的个数</span></span><br><span class="line"><span class="keyword">int</span> threshold;           <span class="comment">//桶容量大小，可在初始化时显式指定，扩容判定threshold = capacity * loadFactor，默认为0.75 * 16 = 12</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;  <span class="comment">//负载因子，可在初始化时显式指定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个属性是在抽象类AbstractMap中定义的</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt;        keySet = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Map 在使用过程中不断的往里面存放数据，当数量达到了 threshold 就需要将当前容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。因此通常建议能<strong>提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗</strong>。</p></blockquote><p>根据代码可以看到其实真正存放数据的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p>这个数组，那么它又是如何定义的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry 是 HashMap 中的一个内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;     <span class="comment">// key，写入时的键</span></span><br><span class="line">    V value;         <span class="comment">// value，值</span></span><br><span class="line">    Entry&lt;K,V&gt; next; <span class="comment">// 用于实现链表结构，当有hash冲突，存储的下一个元素</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">// 当前 key 的 hashcode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> key;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">      V oldValue = value;</span><br><span class="line">      value = newValue;</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上即为 HashMap 的基本结构，接下来来看写入和获取方法：</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123; // 判断当前数组是否需要初始化。</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key == null) // 如果 key 为空，则 put 一个空值进去</span><br><span class="line">        return putForNullKey(value); // </span><br><span class="line">    int hash = hash(key); // 计算根据 key 计算出 hash 值------</span><br><span class="line">    int i = indexFor(hash, table.length); // 根据计算出的 hash 值定位出所在桶</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 如果桶是一个链表则，需要遍历判断</span><br><span class="line">        Object k;</span><br><span class="line">        // hash 值、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 桶是空的，说明当前位置没有数据存入</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i); // 新增一个 Entry 对象写入当前位置</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    // 初始容量是一个偶数，当 length-1 的时候，这个数的有效二进制位都是1。</span><br><span class="line">    // 只要保证了 h 的分散性就行。&amp;用来取mod运算，效率比%高。</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; // 判断是否需要扩容</span><br><span class="line">        resize(2 * table.length); // 两倍扩充</span><br><span class="line">        hash = (null != key) ? hash(key) : 0; // 当前的 key 重新 hash</span><br><span class="line">        bucketIndex = indexFor(hash, table.length); // 重新定位</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key); <span class="comment">// 根据 key 计算出 hash 值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; </span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123; <span class="comment">// 定位到具体的桶中</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">            <span class="keyword">return</span> e; <span class="comment">//  key 及 hash 值相等时候就返回对应的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回 null </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表死循环"><a href="#链表死循环" class="headerlink" title="链表死循环"></a>链表死循环</h4><p><a href="https://blog.csdn.net/xyh930929/article/details/84777301" target="_blank" rel="noopener">HashMap由并发引起的链表死循环</a></p><h3 id="基于-1-8"><a href="#基于-1-8" class="headerlink" title="基于 1.8"></a>基于 1.8</h3><p>HashMap 在 jdk1.7 的实现中有个明显缺点：</p><blockquote><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。</p></blockquote><p>因此 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 <code>O(logn)</code>。</p><p>话不多说，上🐎：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>和 1.7 大体上都差不多，还是有几个重要的区别：</p><ul><li><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</li><li><code>Entry</code> 修改为 <code>Node</code>。</li></ul><p>Node 的核心组成其实也是和 1.7 中的 Entry 一样，存放的都是 <code>key value hashcode next</code> 等数据。</p><h4 id="put-方法-1"><a href="#put-方法-1" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length; <span class="comment">// 当前桶为空，进行初始化（resize 中会判断是否进行初始化）</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 根据当前 key 的 hash 值定位到具体的桶中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 为空表明没有 Hash 冲突就直接在当前位置创建一个新桶</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 不为空，有 Hash 冲突</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p; <span class="comment">// 比较当前桶中的 key、key 的 hash 值与写入的 key 是否相等，相等就赋值给 e</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前桶为红黑树，那就要按照红黑树的方式写入数据</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果在遍历过程中找到 key 相同时直接退出遍历</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 存在相同的 key ，需要将值覆盖</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 判断是否需要进行扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="comment">// 将 key hash 之后取得所定位的桶</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断桶的第一个位置的 key 是否为查询的 key，是就直接返回 value。</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 红黑树</span></span><br><span class="line">                    <span class="comment">// 按照树的查找方式返回值</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">// 链表</span></span><br><span class="line">                    <span class="comment">// 按照链表的方式遍历匹配返回值</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 桶为空则直接返回 null </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>HashMap 在并发时可能出现的问题主要有三个方面：</p><ul><li><p>如果多个线程同时使用 put 方法添加元素，而且假设正好存在两个 put 的 key 发生了碰撞（根据 hash 值计算的 bucket 一样），那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程 put 的数据被覆盖。</p></li><li><p>如果多个线程同时检测到元素个数超过 threshold，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。</p></li></ul><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String key = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>强烈建议</code>使用第一种 EntrySet 进行遍历。第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。</p><blockquote><p>无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题）。</p></blockquote><p>因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 <code>java.util.concurrent</code> 包下，专门用于解决并发问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Map 这样的 &lt;code&gt;Key Value&lt;/code&gt; 在软件开发中是非常经典的结构，常用于在内存中存放数据。Java 中最常用的 M
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HashMap" scheme="https://muhouer.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>String分析</title>
    <link href="https://muhouer.github.io/posts/4a48cd1d/"/>
    <id>https://muhouer.github.io/posts/4a48cd1d/</id>
    <published>2019-08-18T01:31:00.000Z</published>
    <updated>2019-08-26T16:50:45.018Z</updated>
    
    <content type="html"><![CDATA[<p><code>String</code> 这个类是我们在写 Java 代码中用得最多的一个类，没有之一，今天我们就讲讲它。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>String</code> 并不是基本数据类型，而是一个对象，并且是不可变的对象。</p><p>查看源码就会发现 <code>String</code> 类为<code>final</code> 型的(当然也不可被继承)，而且通过查看 JDK 文档会发现几乎每一个修改 <code>String</code> 对象的操作，实际上都是创建了一个全新的 <code>String</code> 对象。</p><p><code>String</code> 类实现了 <code>Serializable</code>，<code>Comparable</code>，<code>CharSequence</code>接口，被 <code>final</code> 修饰。内部维护了一个字符数组。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">== <span class="comment">// 判断内容与地址是否相同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> <span class="comment">// 判断两个字符串内容是否相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> <span class="comment">// 忽略大小写，判断两个字符串内容是否相同，底层调用了regionMatches方法</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span> <span class="comment">// 判断字符序列和字符串内容是否相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span> <span class="comment">// 判断StringBuffer和字符串内容是否相同，实际上调用的是contentEquals方法</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> <span class="comment">// 按照字典大小比较两个字符串的大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span> <span class="comment">// 忽略大小写，按照字典大小比较两个字符串的大小，使用忽略大小写比较器</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断两个字符串部分内容是否相同，ignoreCase:是否忽略大小写，toffset:子字符串的偏移量，ooffset:参数字符串中子字符串的偏移量，len:比较的子字符串的长度</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 返回索引上的字符，索引从0开始</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> <span class="comment">// 从字符串开始检索字符(Unicode 码) ch，并返回第一次出现的位置，未出现返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch，<span class="keyword">int</span> fromIndex)</span> <span class="comment">// 从字符串的第fromIndex个字符开始检索字符(Unicode 码) ch，未出现返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> <span class="comment">// 从字符串检索字符(Unicode 码) ch最后一次出现的位置。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> <span class="comment">//从字符串的第fromIndex个字符检索字符(Unicode 码) ch最后一次出现的位置。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> <span class="comment">// 判断此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> <span class="comment">// 判断此字符串是否以指定前缀开始。</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> <span class="comment">// 判断此字符串是否以指定后缀结尾。</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串截取与替换"><a href="#字符串截取与替换" class="headerlink" title="字符串截取与替换"></a>字符串截取与替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> <span class="comment">// 返回一个新的字符串，是从beginIndex开始到length-1的串。</span></span></span><br><span class="line"><span class="function">String <span class="title">subString</span><span class="params">(<span class="keyword">int</span> beginIndex，<span class="keyword">int</span> endIndex)</span>------返回一个新的字符串，是从beginIndex开始到endIndex-1的串。</span></span><br><span class="line"><span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> <span class="comment">// 返回从beginIndex开始到endIndex-1的字符序列</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> <span class="comment">// 将字符串中的oldChar字符替换为newChar</span></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> <span class="comment">// 将字符串中的target字符序列替换为replacement序列</span></span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> <span class="comment">// 使用replacement替换第一个通过regex匹配到子串。</span></span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> <span class="comment">// 使用replacement替换所有通过regex匹配到子串。</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串其他常用方法"><a href="#字符串其他常用方法" class="headerlink" title="字符串其他常用方法"></a>字符串其他常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="comment">// 获取字符串长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="comment">// 判断字符串是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span> <span class="comment">// 判断字符串是否包含字符序列 s</span></span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span> <span class="comment">// 字符串拼接</span></span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span> <span class="comment">// 字符串去掉首尾空白</span></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">(Locale locale)</span> <span class="comment">// 字符串转大写</span></span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span> <span class="comment">// 字符串转小写</span></span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex)</span> <span class="comment">// 字符串分割</span></span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span> <span class="comment">// 字符串分割，多了结果阈值参数</span></span></span><br></pre></td></tr></table></figure><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>第一种方式是在常量池中直接拿对象，第二种是在堆内存空间创建一个新的对象。只要使用new方法，就需要创建新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Freya"</span>); <span class="comment">// 这句话创建了两个对象。</span></span><br></pre></td></tr></table></figure><p>首先，字符串“Freya”放入常量池，然后 new 了一个字符串“Freya”放入 Java 堆。字符串常量”Freya”在编译期就已经确定放入常量池，而 Java 堆上的”Freya”是在运行期初始化阶段才确定。然后 Java 栈中的 str 指向了 Java 堆中的 “Freya”。</p><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>字符串常量池是 JVM 实例全局共享的，全局只有一个。字符串常量池及到一个设计模式，叫“享元模式”，顾名思义 就是<strong>共享元素模式</strong>。也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素。</p><ul><li>直接使用双引号声明的 String 对象直接存储在字符串常量池。</li><li>不是双引号声明的，可以使用 <code>String.intern()</code> 方法，这是一个Native方法。如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"Freya"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String b = <span class="string">"Freya"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String c = <span class="keyword">new</span> String(<span class="string">"Freya"</span>);</span><br><span class="line">    String d = a.intern();</span><br><span class="line">    String e = <span class="string">"Freya"</span> + <span class="string">" 17"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    String f = <span class="string">" 17"</span>;</span><br><span class="line">    String g = a + f; <span class="comment">//在堆上创建的新的对象</span></span><br><span class="line">    String h = <span class="string">"Freya 17"</span>; <span class="comment">//常量池中的对象</span></span><br><span class="line">    System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line">    System.out.println(a == c); <span class="comment">//false</span></span><br><span class="line">    System.out.println(a == d); <span class="comment">//true</span></span><br><span class="line">    System.out.println(e == g); <span class="comment">//false</span></span><br><span class="line">    System.out.println(e == h); <span class="comment">//true</span></span><br><span class="line">    System.out.println(g == h); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变，可以使用StringBuilder或者StringBuffer。</p></blockquote><h2 id="String-对象的不可变性"><a href="#String-对象的不可变性" class="headerlink" title="String 对象的不可变性"></a>String 对象的不可变性</h2><p>打开 <code>String</code> 类源码，可以看到一句话:</p><blockquote><p>Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared.</p></blockquote><p>意思是 <code>String</code> 是个常量，创建之后就是不可变的。不可变的意思是不能改变对象内的成员变量，包括基本数据类型变量的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><h3 id="String-对象不可变性是如何实现的？"><a href="#String-对象不可变性是如何实现的？" class="headerlink" title="String 对象不可变性是如何实现的？"></a>String 对象不可变性是如何实现的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length); <span class="comment">// deep copy操作</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">     <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">        <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];</span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出：</p><ul><li>String 类被 final 修饰，不可继承。</li><li>String内部所有成员都设置为私有变量。</li><li>不存在value的setter方法。</li><li>将value和offset设置为final。</li><li>当传入可变数组value[]时，进行copy而不是直接将value[]复制给内部变量。</li><li>获取value时不是直接返回对象引用，而是返回对象的copy。</li></ul><h3 id="String-对象不可变性的优缺点"><a href="#String-对象不可变性的优缺点" class="headerlink" title="String 对象不可变性的优缺点"></a>String 对象不可变性的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p><strong>字符串常量池的需要</strong><br>字符串常量池可以将一些字符常量放在常量池中重复使用，避免每次都重新创建相同的对象、节省存储空间。但如果字符串是可变的，此时相同内容的String还指向常量池的同一个内存空间，当某个变量改变了该内存的值时，其他遍历的值也会发生改变。所以不符合常量池设计的初衷。</p></li><li><p><strong>线程安全考虑</strong><br>同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p></li><li><p><strong>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载</strong></p><p>譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</p></li><li><p><strong>支持hash映射和缓存</strong><br>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果有对String对象值改变的需求，那么会创建大量的String对象。</p><h2 id="String对象是否真的不可变"><a href="#String对象是否真的不可变" class="headerlink" title="String对象是否真的不可变"></a>String对象是否真的不可变</h2><p>虽然 String 对象将 value 设置为 final，并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>;</span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s); <span class="comment">//Hello World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">//Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="其他相关内容"><a href="#其他相关内容" class="headerlink" title="其他相关内容"></a>其他相关内容</h2><h3 id="substring-方法"><a href="#substring-方法" class="headerlink" title="substring 方法"></a>substring 方法</h3><p>在 JDK 1.6中，当调用 substring 方法的时候，会创建一个新的 String 对象，但是这个 String 的值仍然指向堆中的同一个字符数组。这两个对象中只有 count 和offset 的值是不同的。如果你有一个很长很长的字符串，但是当你使用 substring 进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 1.6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x.substring(x, y) + <span class="string">""</span></span><br></pre></td></tr></table></figure><p>以上问题在jdk 7+中得到解决。在jdk 7+ 中，substring方法会在堆内存中创建一个新的数组。其使用<code>new String</code>创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。</p><h3 id="String-valueOf和Integer-toString的区别"><a href="#String-valueOf和Integer-toString的区别" class="headerlink" title="String.valueOf和Integer.toString的区别"></a>String.valueOf和Integer.toString的区别</h3><p>我们有三种方式将一个int类型的变量变成呢过String类型，那么他们有什么区别？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">String i1 = <span class="string">""</span> + i; <span class="comment">//其实是String i1 = (new StringBuilder()).append(i).toString();，首先创建一个StringBuilder对象，然后再调用append方法，再调用toString方法。</span></span><br><span class="line">String i2 = String.valueOf(i); <span class="comment">//调用 Integer.toString(i)</span></span><br><span class="line">String i3 = Integer.toString(i);</span><br></pre></td></tr></table></figure><h3 id="replaceFirst、replaceAll、replace-的区别"><a href="#replaceFirst、replaceAll、replace-的区别" class="headerlink" title="replaceFirst、replaceAll、replace 的区别"></a>replaceFirst、replaceAll、replace 的区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line">    a.replace(<span class="string">"e"</span>,<span class="string">"f"</span>);</span><br><span class="line">    System.out.println(a); <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line">    a = a.replace(<span class="string">"e"</span>,<span class="string">"f"</span>);</span><br><span class="line">    System.out.println(a); <span class="comment">// Hfllo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>replace(CharSequence target, CharSequence replacement)</strong> ，用 replacement 替换所有的 target ，两个参数都是字符串。</li><li><strong>replaceAll(String regex, String replacement)</strong> ，用 replacement 替换所有的 regex 匹配项，regex 很明显是个正则表达式，replacement 是字符串。</li><li><strong>replaceFirst(String regex, String replacement)</strong> ，基本和 replaceAll 相同，区别是只替换第一个匹配项。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>replace 替换的只能是字符或字符串形式。</p></li><li><p>replaceAll() 和 replaceFirst() 是基于正则表达式的替换。</p></li><li><p>replaceAll() 和 replace() 是替换所有的，而 replaceFirst() 仅替换第一次出现的。</p></li><li><p>如果 replaceAll() 和 replaceFirst() 所用的参数据不是基于正则表达式的，则与 replace() 替换字符串的效果是一样的。</p></li><li><p>执行了替换操作后，源字符串的内容是没有发生改变的。</p></li></ul><h3 id="switch-对字符串的支持"><a href="#switch-对字符串的支持" class="headerlink" title="switch 对字符串的支持"></a>switch 对字符串的支持</h3><p><strong>switch 中只能使用整型，其他数据类型都是转换成整型之后在使用switch的。</strong>比如<code>byte</code>、<code>short</code>、<code>char</code>(ASCII码是整型)以及<code>int</code>。</p><p>字符串进行<code>switch</code>的实际是哈希值，然后通过使用 equals 方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 switch 或者使用纯整数常量，但这也不是很差。因为Java编译器只增加了一个<code>equals</code>方法，如果你比较的是字符串字面量的话会非常快。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"world"</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">            System.out.println(<span class="string">"world"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对代码进行反编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoString</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">switchDemoString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">"world"</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">switch</span>((s = str).hashCode())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"hello"</span>))</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"world"</span>))</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;String&lt;/code&gt; 这个类是我们在写 Java 代码中用得最多的一个类，没有之一，今天我们就讲讲它。&lt;/p&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;co
      
    
    </summary>
    
      <category term="Java" scheme="https://muhouer.github.io/categories/Java/"/>
    
      <category term="源码学习" scheme="https://muhouer.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="String" scheme="https://muhouer.github.io/tags/String/"/>
    
  </entry>
  
</feed>

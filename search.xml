<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[堆内存和栈内存]]></title>
    <url>%2Fposts%2Fe896e76f%2F</url>
    <content type="text"><![CDATA[在Java中，您会看到大量关于堆内存和栈内存的引用，Java把内存分成两种，一种叫做栈内存，一种叫做堆内存。Java 堆内存(Heap Memory)Java运行时会在堆内存中将内存分配给对象和子类。每当我们创建任何对象时，它总是在堆空间中创建的。垃圾收集在堆内存上运行，以释放没有任何引用的对象使用的内存。堆空间中创建的任何对象都具有全局访问权限，可以从应用程序的任何位置引用。Java 栈内存(Stack Memory)Java栈内存用于执行线程。它们包含短期存活的方法的特定值，以及堆中方法对其他对象的引用。栈内存总是按后进先出顺序引用。每当调用一个方法时，都会在栈内存中创建一个新块，以便该方法保存本地基元值以及该方法对其他对象的引用。一旦方法结束，该块就不再使用，就可用于下一个方法。与堆内存相比，栈内存非常小。Java 程序中的堆内存和栈内存12345678910111213public class Memory &#123; public static void main(String[] args) &#123; // Line 1 int i = 1; // Line 2 Object obj = new Object(); // Line 3 Memory mem = new Memory(); // Line 4 mem.foo(obj); // Line 5 &#125; // Line 9 private void foo(Object param) &#123; // Line 6 String str = param.toString(); //// Line 7 System.out.println(str); &#125; // Line 8&#125;下图展示了上述程序的堆栈内存的引用程序执行的过程如下：一旦程序开始运行，它将会加载所有运行时类到堆内存，第1行发现了main方法，Java Runtime 创建了栈内存给main方法线程使用。第2行，我们创建了int型本地变量，它被创建并存储在栈内存的main方法里。第3行，我们创建一个对象，它创建在堆内存，栈内存保存它的引用。Memory 对象类似。第5行，我们调用foo方法，在栈内存头部创建一个内存块给foo方法使用，既然Java通过值传递，第6行，对象的新引用将在foo方法的栈内存块内创建。第7行，创建了字符串，它将会进入堆中的字符串常量池，foo方法的栈空间内将创建一个它的引用。foo方法在第8行终止。栈中分配的内存块将会被释放。在第9行，main方法终止，分配给main方法的栈内存将会被销毁。同时，程序也在这一行结束，因此 Java Runtime将会释放所有内存，然后结束程序的执行。堆内存和栈内存的区别应用程序的所有地方都会使用堆内存，而只有线程的执行会使用栈内存。当一个对象创建时，它存放在堆内存中，引用放在栈内存中。栈内存只包含本地原始变量和引用变量。存放在堆内存的对象是全局的，而栈内存中的不能被其他线程获取。栈中的内存管理是以后进先出的方式完成的，而堆内存中的内存管理更复杂，因为它是全局使用的。堆内存分为新生代、老年代等，更多信息可以参考Java 垃圾回收。栈内存是短暂存在的，而堆内存从应用程序执行的开始到结束都是存在的。我们可以使用-Xms和-Xmx来定义堆内存启动时的大小和内存最大值。可以使用-Xss去定义栈内存大小。当栈内存被填满的时候，将会抛出 java.lang.StackOverFlowError，然而，当堆内存被填满的时候，它会抛出 java.lang.OutOfMemoryError: Java Heap Space 错误。和堆内存大小相比，栈内存大小非常小。由于内存分配（LIFO）的简单性，与堆内存相比，栈内存非常快。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>堆栈内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型与内存管理]]></title>
    <url>%2Fposts%2F1f8d140b%2F</url>
    <content type="text"><![CDATA[如果您想弄清楚Java垃圾回收的的工作原理，那么理解JVM内存模型以及Java内存管理非常重要。 今天我们将探讨一下Java中的内存管理、JVM内存的组成以及如何监控和进行垃圾回收调优。Java（JVM）内存模型正如上图所示，JVM内存划分为多个不同部分。 从广义上讲，JVM堆内存内存在物理上分为两部分——新生代(Young Generation)和老年代(Old Generation)。Java 内存管理——年轻代年轻代是创建新对象的地方。 当年轻代被填满时，将会进行垃圾回收，称为Minor GC。 Young Generation分为三个部分——Eden内存空间和两个Survivor内存空间。关于新生代(Young Generation)的要点：大多数新创建的对象都位于Eden内存空间中。当Eden空间填满对象时，执行Minor GC并将所有幸存者对象移动到其中一个Survivor内存空间。Minor GC还会检查幸存者对象并将其移动到其他Survivor内存空间。 所以，在同一时间内，总有一个Survivor内存空间是空的。在多次GC循环后幸存的对象将被移动到老年代(Old Generation)。 通常，新生代(Young Generation)对象达到设定的年龄阈值后才有资格晋升到老年代(Old Generation)。Java 内存管理——老年代老年代(Old Generation)包含在多次Minor GC循环之后长期存在并存活下来的对象。通常，当老年代(Old Generation)被填满后，也会执行垃圾回收，称为Major GC，通常花费时间较长。停顿(Stop the World Event)所有垃圾回收都是“Stop the World”事件，因为所有应用程序线程都会停止，直到操作完成。由于新生代(Young Generation)主要保存短暂存活的对象，因此Minor GC非常快，应用程序不会受此影响。然而，Major GC需要花费很长时间，因为它会检查所有活动对象。 Major GC应该最小化，因为它会使您的应用程序在垃圾回收期间没有响应。 因此，如果您有响应式应用程序而且进行了大量Major GC，您会注意到超时错误。垃圾收集器进行垃圾回收时持续的时间取决于采用的垃圾回收策略。为了避免高响应应用程序中的超时，很有必要去监控、调整垃圾收集器。Java 内存模型——永久代永久代(Permanent Generation或Perm Gen)包含JVM描述应用程序中类和方法所需的应用程序元数据。 请注意，Perm Gen不是Java堆内存的一部分。Perm Gen在运行时，由JVM根据应用程序使用的类填充。 Perm Gen还包含Java SE库中的类和方法。 Perm Gen中的对象在完全垃圾回收(full garbage collection)中将会被回收。Java 内存模型——方法区方法区(Method Area)属于Perm Gen一部分，用于存储类结构(运行时常量和静态变量)以及方法和构造函数的代码。Java 内存模型——内存池内存池(Memory Pool)由JVM内存管理器创建，支持创建不可变对象( immutable object)池。比如 String池。 内存池可以属于Java堆内存或Perm Gen，具体取决于JVM内存管理器实现。Java 内存模型——运行时常量池运行时常量池(Runtime constant pool)是类中常量池的每类运行时表示形式。它包含类运行时常量和静态方法。 运行时常量池是方法区的一部分。Java 内存模型——栈内存Java栈内存(Stack Memory)用于执行线程。 它们包含方法特定的值，这些值是短暂存活的，并且引用了堆内存中被方法引用的其他对象。 堆内存和栈内存Java 内存管理——Java 堆内存开关Java提供了许多内存开关，我们可以用来设置内存大小和它们的比率。一些常用的内存开关是：VM SWITCHVM SWITCH DESCRIPTION-Xms在 JVM 启动时设置初始堆内存大小。-Xmx设置堆内存空间大小的最大值。-Xmn设置新生代内存空间大小，剩下的空间大小就是老年代的内存空间大小。-XX:PermGen设置永久代初始内存空间大小-XX:MaxPermGen设置永久代内存空间大小的最大值。-XX:SurvivorRatio设置Eden内存空间和Survivor内存空间的比例，例如，如果新生代的空间大小是10M，而-XX:SurvivorRatio=2，那么Eden内存空间大小为5M，两个Survivor内存空间大小将分别为2.5M。-XX:SurvivorRatio 默认值为8。-XX:NewRatio设置老年代和新生代空间大小的比例。 默认值为 2.大多数情况下，上面的选项足够使用了，但是如果您想使用其他选项，可以参考JVM 选项。Java 内存管理——垃圾回收Java垃圾收集是从内存中标识、删除未使用对象以及释放空间的过程。 Java编程语言的特色之一是自动垃圾回收，与其他编程语言(如C)不同，它们的内存需要手动分配和释放。垃圾收集器(Garbage Collector)是在后台运行的程序(守护线程)，它检查内存中的所有对象，并找出程序所有未被引用的对象。 然后删除所有未被引用的对象，并释放空间以分配给其他对象。垃圾回收的一个简单实现可以分为三步：标记——这是垃圾回收的第一步，将识别出哪些对象正在使用，哪些对象没有在使用。普通删除——垃圾收集器将删除未被使用的对象，然后回收内存空间分配给其他对象使用。压缩删除——为了获得更好的性能，在删除未被使用的对象后，可以将所有幸存的对象移动到一起。 这会提高给新对象分配内存时的性能。标记-删除方法的缺点它效率不高，因为大多数新创建的对象都将被闲置在多个垃圾收集周期中使用的对象很有可能在未来的垃圾收集周期中继续使用。这是因为堆内存分为新生代(Young Generation)和老年代(Old Generation)，Java垃圾回收是分代的。 上文中已经解释过如何根据Minor GC和Major GC扫描对象并将其从一个空间移动到另一个空间。Java 内存管理——垃圾回收的类型在应用程序中我们可以使用5种垃圾回收类型，我只需要调整JVM开关即可为我们的应用程序选择垃圾回收策略。Serial GC (-XX:+UseSerialGC): Serial GC使用简单的标记 - 清除 - 整理(mark-sweep-compact)方法用于新生代和老年代的垃圾回收，即Minor GC和Major GC。Serial GC在客户端机中非常有用，例如我们的应用程序比较独立，而且CPU比较小。 它适用于内存占用少的小型应用程序。Parallel GC (-XX:+UseParallelGC): Parallel GC与Serial GC相同，不同的是Parallel GC使用N(N是系统中的CPU核心数)个线程进行新生代的垃圾回收。 我们可以使用-XX：ParallelGCThreads = nJVM 选项来控制线程数。并行垃圾收集器也称为吞吐量收集器，因为它使用多个 CPU 来提升 GC 性能。 Parallel GC使用单个线程进行老年代的垃圾回收。Parallel Old GC (-XX:+UseParallelOldGC): 和Parallel GC相同，不同的是它采用多线程进行老年代和新生代的垃圾回收。Concurrent Mark Sweep (CMS) Collector (-XX:+UseConcMarkSweepGC): CMS收集器也称为并发低暂停收集器。 在老年代进行垃圾回收时，CMS收集器尝试通过与应用程序线程同时执行大多数垃圾收集工作来最小化由于垃圾收集而导致的暂停。新生代的CMS收集器与并行收集器使用相同的算法。 此垃圾收集器适用于我们无法忍受暂停时间过长的响应式应用程序。 我们可以使用-XX:ParallelCMSThreads=nJVM选项调整CMS收集器中的线程数 。G1 Garbage Collector (-XX:+UseG1GC): Garbage First 或G1垃圾收集器从 Java 7 开始支持，它的目标是取代CMS收集器。 G1收集器是并行，并发和增量压缩的低暂停垃圾收集器。G1收集器不像其他收集器那样工作，并且没有新生代和老年代的概念。 它将堆空间划分为多个大小相等的堆区域。 当进行垃圾回收时，它首先收集具有较少实时数据的区域，因此称为“Garbage First”。 您可以在Oracle Garbage-First Collector 文档中找到有关它的更多详细信息。Java 内存管理——Java 垃圾回收监控我们可以使用Java命令行以及UI工具来监视应用程序的垃圾收集活动。jstat我们可以使用jstat命令行工具来监控JVM 内存和垃圾收集活动。 它适配标准JDK，因此您无需执行任何其他操作即可使用它。在使用jstat命令之前，你需要知道 Java 应用的进程id。你可以使用ps -ef | grep java命令来获取进程id。假如我的进程id是9582，那么我就可以使用jstat -gc 9582 1000来查看垃圾回收的信息。命令中最后一个参数是每个输出之间的时间间隔，因此它将每1秒打印一次内存和垃圾收集数据。123456789$ jstat -gc 9582 1000 S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT1024.0 1024.0 0.0 0.0 8192.0 7933.3 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8026.5 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8030.0 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8122.2 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8171.2 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 48.7 0.0 8192.0 106.7 42108.0 23401.3 20480.0 19990.9 158 0.275 40 1.381 1.6561024.0 1024.0 48.7 0.0 8192.0 145.8 42108.0 23401.3 20480.0 19990.9 158 0.275 40 1.381 1.656每一列的含义如下：S0C and S1C: Survivor0 和 Survivor1当前的内存大小，以 KB 计。S0U and S1U: Survivor0 和 Survivor1当前已使用的内存大小，以 KB 计。注意其中一个 survivor 一直是空的。EC and EU: Eden 区当前的内存大小和 Eden 区当前已使用的内存大小，以 KB 计。注意 EU 的大小会一直增大直到接近EC的大小，此时会执行Minor GC，然后EU 的大小就降低了。OC and OU: 老年代当前的大小和已使用的大小，以 KB 计。PC and PU: 永久代当前的大小和已使用的大小，以 KB 计。YGC and YGCT: YGC 代表在新生代 GC 发生的次数；YGCT 代表新生代执行GC的累计时间。注意，这两个值都在同一行中增加，因为 Minor GC 会使得 EU 值下降。FGC and FGCT: FGC 代表 Full GC 发生的次数；FGCT Full GC 发生的累计时间。 注意，与新生代 GC 相比， Full GC 花费时间太长。GCT: GC 操作的总累计时间。注意，它是 YGCT 和 FGCT 列值的总和。jstat的优点是它也可以在没有 GUI 的远程服务器上执行。请注意，根据-xmn10mjvm选项的限制，S0C、S1C和EC的总和为10M。可视化的 Java VisualVM如果您想在GUI中看到内存和GC操作，那么可以使用jvisualvm工具。Java VisualVM也是JDK的一部分，不需要单独下载。只需在终端中运行jvisualvm命令即可启动Java VisualVM应用程序。启动后，您需要从tools -&gt; plugins 选项安装VisualGC插件，如下图所示。安装完VisualGC之后，只需打开左侧列中的应用程序，然后转到VisualGC部分。您将得到一个JVM内存和垃圾收集细节的映像，如下图所示。垃圾回收调优Java垃圾回收调优应该是提高应用程序吞吐量的最后选项，只有当GC时间较长导致应用程序超时时，才看到性能下降。假如你在日志中看到java.lang.OutOfMemoryError: PermGen space错误，你可以通过-XX:PermGen和-XX:MaxPermGen来监控和提供永久代内存。你也可以使用-XX:+CMSClassUnloadingEnabled，然后观察在CMS 垃圾收集器的性能。假如你看到很多 Full GC 操作，你可以提高老年代内存大小。总的来说，垃圾回收调优需要花费大量的精力和时间，而且没有硬性和快速的规则。您需要尝试不同的选项并进行比较，从中找出最适合您的选项。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis进阶教程]]></title>
    <url>%2Fposts%2Fc275b75f%2F</url>
    <content type="text"><![CDATA[Redis 数据备份与恢复数据备份Redis save 命令用于创建当前数据库的备份。该命令将在 redis 安装目录中创建dump.rdb文件。创建 redis 备份文件也可以使用命令 bgsave，该命令在后台执行。语法save实例12127.0.0.1:6379&gt; save OK恢复数据如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用config命令，如下所示：123127.0.0.1:6379&gt; config get dir1) &quot;dir&quot;2) &quot;/usr/local/redis-5.0.5/src&quot;Redis 安全我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。语法auth password实例12345678910111213127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;&quot;127.0.0.1:6379&gt; config set requirepass &quot;redis&quot;OK127.0.0.1:6379&gt; config get requirepass(error) NOAUTH Authentication required.127.0.0.1:6379&gt; auth redisOK127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;redis&quot;127.0.0.1:6379&gt;Redis 性能测试Redis 性能测试是通过同时执行多个命令实现的。语法redis-benchmark [option] [option value]注意：该命令是在 redis 的目录下执行的，而不是 redis客户端的内部指令。实例同时执行 10000 个请求来检测性能:12345678910111213141516171819$ ./redis-benchmark -n 10000 -qPING_INLINE: 104166.66 requests per secondPING_BULK: 106382.98 requests per secondSET: 105263.16 requests per secondGET: 105263.16 requests per secondINCR: 103092.78 requests per secondLPUSH: 106382.98 requests per secondRPUSH: 105263.16 requests per secondLPOP: 108695.65 requests per secondRPOP: 102040.82 requests per secondSADD: 106382.98 requests per secondHSET: 107526.88 requests per secondSPOP: 97087.38 requests per secondLPUSH (needed to benchmark LRANGE): 101010.10 requests per secondLRANGE_100 (first 100 elements): 106382.98 requests per secondLRANGE_300 (first 300 elements): 109890.11 requests per secondLRANGE_500 (first 450 elements): 107526.88 requests per secondLRANGE_600 (first 600 elements): 99009.90 requests per secondMSET (10 keys): 101010.10 requests per second序号选项描述默认值1-h指定服务器主机名127.0.0.12-p指定服务器端口63793-s指定服务器 socket4-c指定并发连接数505-n指定请求数100006-d以字节的形式指定 SET/GET 值的数据大小27-k1=keep alive 0=reconnect18-rSET/GET/INCR 使用随机 key, SADD 使用随机值9-P通过管道传输&lt;numreq&gt;请求110-q强制退出 redis。仅显示 query/sec 值11–csv以 CSV 格式输出12-l生成循环，永久执行测试13-t仅运行以逗号分隔的测试命令列表。14-IIdle 模式。仅打开 N 个 idle 连接并等待。123$ ./redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -qSET: 104166.66 requests per secondLPUSH: 105263.16 requests per second以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。Redis 客户端连接Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送Socket编程中，TCP_NODELAY选项是用来控制是否开启Nagle算法，该算法是为了提高较慢的广域网传输效率，减小小分组的报文个数，完整描述：该算法要求一个TCP连接上最多只能有一个未被确认的小分组，在该小分组的确认到来之前，不能发送其他小分组。最大连接数在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。1234127.0.0.1:6379&gt; config get maxclients1) "maxclients"2) "10000"127.0.0.1:6379&gt;1$ ./redis-server --maxclients 100000 # 在服务启动时设置最大连接数为 100000客户端命令序号命令描述可用版本时间复杂度1client list以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据。返回的信息含义参见&gt;=2.4.0O(N)， N 为连接到服务器的客户端数量。2client setname1. 为当前连接分配一个名字。这个名字会显示在client list命令的结果中， 用于识别当前正在与服务器进行连接的客户端。获取通过client setname 命令设置的服务名称。2. 名字使用 Redis 的字符串类型来保存， 最大可以占用 512 MB 。3. 另外， 为了避免和client list命令的输出格式发生冲突， 名字里不允许使用空格。4. 要移除一个连接的名字， 可以将连接的名字设为空字符串 &quot;&quot; 。5. 新创建的连接默认是没有名字的。在 Redis 应用程序发生连接泄漏时，为连接设置名字是一种很好的 debug 手段。&gt;=2.6.9O(1)3client getname返回client getname命令为连接设置的名字。因为新创建的连接默认是没有名字的， 对于没有名字的连接， client getname返回空白回复。&gt;=2.6.9O(1)4client pause挂起客户端连接，指定挂起的时间以毫秒计&gt;=2.9.5O(1)5client kill当指定的客户端存在，且被成功关闭时，返回 OK 。关闭地址为 ip:port 的客户端。ip:port 应该和client-list)命令输出的其中一行匹配。因为 Redis 使用单线程设计，所以当 Redis 正在执行命令的时候，不会有客户端被断开连接。&gt;=2.4.0O(N) ， N 为已连接的客户端数量。6client id返回当前连接的id&gt;=5.0.0O(1)实例123456789127.0.0.1:6379&gt; client getname(nil)127.0.0.1:6379&gt; client setname freya-connectionOK127.0.0.1:6379&gt; client getname"freya-connection"127.0.0.1:6379&gt; client listid=7 addr=127.0.0.1:56661 fd=8 name= age=265815 idle=261969 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribeid=1012 addr=127.0.0.1:51537 fd=9 name=freya-connection age=647 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client12345678910127.0.0.1:6379&gt; client setname # 只用空格是不行的！(error) ERR Unknown subcommand or wrong number of arguments for 'setname'. Try CLIENT HELP127.0.0.1:6379&gt; client setname "" # 必须双引号显示包围OK127.0.0.1:6379&gt; client getname(nil)127.0.0.1:6379&gt; client listid=7 addr=127.0.0.1:56661 fd=8 name= age=265951 idle=262105 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribeid=1012 addr=127.0.0.1:51537 fd=9 name= age=783 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client127.0.0.1:6379&gt;Redis client list 命令返回值命令返回多行字符串，这些字符串按以下形式被格式化：每个已连接客户端对应一行（以 LF 分割）每行字符串由一系列 属性=值 形式的域组成，每个域之间以空格分开以下是域的含义：域含义addr客户端的地址和端口fd套接字所使用的文件描述符age以秒计算的已连接时长idle以秒计算的空闲时长flags客户端flag(见下表)db该客户端正在使用的数据库IDsub已订阅频道的数量psub已订阅模式的数量multi在事务中被执行的命令数量qbuf查询缓存的长度(0 表示没有查询在等待)qbuf-free查询缓存的剩余空间(0 表示没有剩余空间)obl输出缓存的长度oll输出列表的长度(当输出缓存没有剩余空间时，回复被入队到这个队列里)omem输出缓存的内存占用量events文件描述符事件(见下文)cmd最近一次执行的命令客户端 flag 可以由以下部分组成：域含义O客户端是 monitor 模式下的附属节点 (slave)S客户端是一般模式下 (normal) 的附属节点M客户端是主节点 (master)x小写x，客户端正在执行事务b客户端正在等待阻塞事件i客户端正在等待 VM I/O 操作 (已废弃)d一个受监控 (watched) 的键已被修改， exec命令将失败c在将回复完整写出来之后，关闭连接u客户端未被阻塞 (unblocked)A尽可能快地关闭连接N未设置任何 flag文件描述符事件文件描述符事件含义r客户端套接字（在事件 loop 中）是可读的（readable）w客户端套接字（在事件 loop 中）是可写的（writeable）注意为了 debug 的需要，经常会对域进行添加和删除，一个安全的 Redis 客户端应该可以对 CLIENT LIST 的输出进行相应的处理（parse），比如忽略不存在的域，跳过未知域，诸如此类。实例123127.0.0.1:6379&gt; client listid=7 addr=127.0.0.1:56661 fd=8 name= age=150289 idle=146443 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribeid=10 addr=127.0.0.1:64043 fd=9 name= age=525 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=clientRedis 管道技术Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。实例123456789$ (echo -en &quot;auth pwd\r\n PING\r\n SET freya redis\r\nGET freya\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n&quot;; sleep 10) | nc localhost 6379+OK+PONG+OK$5redis:1:2:3以上命令采用auth pwd授权，采用PING命令查看redis服务是否可用， 之后我们设置了 freya 的值为 redis，然后我们获取 freya 的值并使得 visitor 自增 3 次。管道技术的优势管道技术最显著的优势是提高了 redis 服务的性能。Redis 分区分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。分区的优势通过利用多台计算机内存的和值，允许我们构造更大的数据库。通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。分区的不足涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。涉及多个key的redis事务不能使用。当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。分区类型Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。范围分区最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各种对象的映射表，通常对Redis来说并非是好的方法。哈希分区另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。Java 使用 Redis安装开始在 Java 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 Java redis 驱动，且你的机器上能正常使用 Java。连接到 redis 服务123456789101112import redis.clients.jedis.Jedis;public class RedisTest &#123; public static void main(String[] args) &#123; // 连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;)； //验证密码 jedis.auth(&quot;redis&quot;); // 查看服务是否运行 System.out.println(&quot;服务正在运行: &quot; + jedis.ping()); &#125;&#125;]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>进阶教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis命令5]]></title>
    <url>%2Fposts%2Fe33ec7a3%2F</url>
    <content type="text"><![CDATA[Redis 服务器命令Redis 服务器命令主要是用于管理 redis 服务。实例如何获取 redis 服务器的统计信息：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141127.0.0.1:6379&gt; info# Serverredis_version:5.0.5redis_git_sha1:00000000redis_git_dirty:0redis_build_id:6d3bf9e511543b78redis_mode:standaloneos:Darwin 18.6.0 x86_64arch_bits:64multiplexing_api:kqueueatomicvar_api:atomic-builtingcc_version:4.2.1process_id:65254run_id:3d46ae00173412623b99d81100173246db224357tcp_port:6379uptime_in_seconds:497757uptime_in_days:5hz:10configured_hz:10lru_clock:4627403executable:/Users/asher/Desktop/redis-5.0.5/src/./redis-serverconfig_file:# Clientsconnected_clients:2client_recent_max_input_buffer:2client_recent_max_output_buffer:0blocked_clients:0# Memoryused_memory:1070656used_memory_human:1.02Mused_memory_rss:1712128used_memory_rss_human:1.63Mused_memory_peak:1070656used_memory_peak_human:1.02Mused_memory_peak_perc:100.03%used_memory_overhead:1054744used_memory_startup:987824used_memory_dataset:15912used_memory_dataset_perc:19.21%allocator_allocated:1024592allocator_active:1674240allocator_resident:1674240total_system_memory:8589934592total_system_memory_human:8.00Gused_memory_lua:37888used_memory_lua_human:37.00Kused_memory_scripts:0used_memory_scripts_human:0Bnumber_of_cached_scripts:0maxmemory:0maxmemory_human:0Bmaxmemory_policy:noevictionallocator_frag_ratio:1.63allocator_frag_bytes:649648allocator_rss_ratio:1.00allocator_rss_bytes:0rss_overhead_ratio:1.02rss_overhead_bytes:37888mem_fragmentation_ratio:1.67mem_fragmentation_bytes:687536mem_not_counted_for_evict:0mem_replication_backlog:0mem_clients_slaves:0mem_clients_normal:66616mem_aof_buffer:0mem_allocator:libcactive_defrag_running:0lazyfree_pending_objects:0# Persistenceloading:0rdb_changes_since_last_save:0rdb_bgsave_in_progress:0rdb_last_save_time:1564893311rdb_last_bgsave_status:okrdb_last_bgsave_time_sec:0rdb_current_bgsave_time_sec:-1rdb_last_cow_size:0aof_enabled:0aof_rewrite_in_progress:0aof_rewrite_scheduled:0aof_last_rewrite_time_sec:-1aof_current_rewrite_time_sec:-1aof_last_bgrewrite_status:okaof_last_write_status:okaof_last_cow_size:0# Statstotal_connections_received:8total_commands_processed:214instantaneous_ops_per_sec:0total_net_input_bytes:9198total_net_output_bytes:101508instantaneous_input_kbps:0.00instantaneous_output_kbps:0.00rejected_connections:0sync_full:0sync_partial_ok:0sync_partial_err:0expired_keys:0expired_stale_perc:0.00expired_time_cap_reached_count:0evicted_keys:0keyspace_hits:66keyspace_misses:7pubsub_channels:1pubsub_patterns:0latest_fork_usec:966migrate_cached_sockets:0slave_expires_tracked_keys:0active_defrag_hits:0active_defrag_misses:0active_defrag_key_hits:0active_defrag_key_misses:0# Replicationrole:masterconnected_slaves:0master_replid:b65a8be1272fab6dfd7b73b0c51e75d06e370c79master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0# CPUused_cpu_sys:36.666434used_cpu_user:23.420130used_cpu_sys_children:0.044782used_cpu_user_children:0.009325# Clustercluster_enabled:0# Keyspacedb0:keys=6,expires=0,avg_ttl=0127.0.0.1:6379&gt;Redis time 命令用于返回当前服务器时间。可用版本 &gt;= 2.6.0语法time返回值一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒数。实例123127.0.0.1:6379&gt; time 1) &quot;1564908791&quot;2) &quot;483839&quot;Redis lastsave 命令返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。可用版本 &gt;= 1.0.0语法lastsave返回值一个 UNIX 时间戳。实例12127.0.0.1:6379&gt; lastsave (integer) 1564893311]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇闻异事]]></title>
    <url>%2Fposts%2Fa0f75295%2F</url>
    <content type="text"><![CDATA[为什么饮料瓶上要写「此瓶仅用于灌装本产品，请勿重复使用」？这些都是有人用血泪证明出来的。举个栗子，知道现在为什么沐浴露上面标注:请勿吞食吗？因为以前在美国，有一个人，专门钻法律空子的那种，有一天忽然想到，这个沐浴露上面没有标注不能吞食，发财的机会来了，然后就喝了，送到医院洗了胃，告了卖沐浴露的公司，他们公司赔了几个亿。。。。所以以后的沐浴露标的都有请勿吞食。不过刚才我看了海飞丝没有备注，请勿模仿，因为在我国，食品安全只赔十倍。也就几百块。不要模仿。知乎仙授为什么饮料瓶上要写「此瓶仅用于灌装本产品，请勿重复使用」？为什么录取通知书要用EMS？国内快递只有邮政EMS可以全国范围内无差别覆盖的投送，用顺风的话，你家住在江浙沪好办，你家住在祖国某个边疆偏远山区，顺风就傻眼了。并且邮政可以去一些别的快递送不到的地方（部队等）。知乎夏东为什么录取通知书要用EMS？排位为什么要选不一样的英雄相同的英雄，相同的技能，如果一旦出现经济等级差，那逆转几乎是不可能的。不仅如此，即便是相同水平的玩家，在使用相同英雄博弈的时候也会因为种种原因失误，一旦被单杀，这种耻辱是很难让己方队友接受的，会有种“你看人家的李白”这种冷嘲热讽，被单杀的队友也会很沮丧，甚至怄气，进而产生消极游戏心理。这可能造成初级玩家对游戏的热忱程度大打折扣。佚名排位为什么要选不一样的英雄]]></content>
      <categories>
        <category>记录</category>
        <category>角度</category>
      </categories>
      <tags>
        <tag>另类观点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis命令4]]></title>
    <url>%2Fposts%2F9439f735%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Redis 发布订阅、事务、脚本、连接四个方面的命令。Redis 发布订阅Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。一个频道也可以被多个客户端订阅。实例创建了订阅频道名为 redisChat12345127.0.0.1:6379&gt; subscribe redisChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;redisChat&quot;3) (integer) 1重新开启个 redis 客户端，然后在同一个频道 redisChat 发布消息，订阅者就能接收到消息。12127.0.0.1:6379&gt; publish redisChat &quot;Redis is a great caching technique&quot;(integer) 112345678127.0.0.1:6379&gt; subscribe redisChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;redisChat&quot;3) (integer) 11) &quot;message&quot;2) &quot;redisChat&quot;3) &quot;Redis is a great caching technique&quot;Redis psubscribe命令订阅一个或多个符合给定模式的频道。可用版本 &gt;= 2.0.0每个模式以 * 作为匹配符，比如 redis* 匹配所有以 redis 开头的频道( redis.news 、 redis.blog等等)。punsubscribe 命令用于退订所有给定模式的频道。与 psubscribe 类似。语法psubscribe pattern [pattern ...]返回值接收到的信息。Redis subscribe命令用于订阅给定的一个或多个频道的信息。可用版本 &gt;= 2.0.0unsubscribe 命令用于退订所有给定模式的频道。与 subscribe 类似。语法subscribe channel [channel ...]返回值接收到的信息Redis publish命令用于将信息发送到指定的频道。可用版本 &gt;= 2.0.0语法publish channel message返回值接收到信息的订阅者数量。Redis pubsub命令pubsub是一个查看订阅与发布系统状态的内省命令，它由数个不同格式的子命令组成。可用版本 &gt;= 2.8.0语法pubsub &lt;subcommand&gt; [argument [argument ...]]channels 子命令列出当前的活跃频道。活跃频道指的是那些至少有一个订阅者的频道，订阅模式的客户端不计算在内。语法pubsub channels [pattern]pattern 参数是可选的，如果不给出 pattern 参数，那么列出订阅与发布系统中的所有活跃频道。如果给出 pattern 参数，那么只列出和给定模式 pattern 相匹配的那些活跃频道。复杂度O(N) ， N 为活跃频道的数量（对于长度较短的频道和模式来说，将进行模式匹配的复杂度视为常数）。返回值一个由活跃频道组成的列表。numsub 子命令返回给定频道的订阅者数量， 订阅模式的客户端不计算在内。语法pubsub numsub [channel-1 ... channel-N]复杂度O(N)， N 为给定频道的数量。返回值一个多条批量回复(Multi-bulk reply)，回复中包含给定的频道，以及频道的订阅者数量。 格式为：频道 channel-1，channel-1 的订阅者数量，频道 channel-2，channel-2 的订阅者数量，诸如此类。 回复中频道的排列顺序和执行命令时给定频道的排列顺序一致。不给定任何频道而直接调用这个命令也是可以的，在这种情况下，命令只返回一个空列表。numpat 子命令返回订阅模式的数量。这个命令返回的不是订阅模式的客户端的数量，而是客户端订阅的所有模式的数量总和。当有多个客户端订阅相同的模式时，相同的订阅也被计算在内语法pubsub numpat复杂度O(1) 。返回值一个整数回复（Integer reply）。Redis 事务Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：批量操作在发送exec命令前被放入队列缓存。收到exec命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。一个事务从开始到执行会经历三个阶段：开始事务-&gt;命令入队。-&gt;执行事务。Redis multi与exec命令用于标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由exec命令原子性(atomic)地执行。可用版本 &gt;= 1.2.0语法multi返回值总是返回 OK 。实例12345678910111213141516127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr user_idQUEUED127.0.0.1:6379&gt; incr user_idQUEUED127.0.0.1:6379&gt; incr user_idQUEUED127.0.0.1:6379&gt; pingQUEUED127.0.0.1:6379&gt; exec1) (integer) 12) (integer) 23) (integer) 34) PONG127.0.0.1:6379&gt;Redis discard命令用于取消事务，放弃执行事务块内的所有命令。可用版本 &gt;= 2.0.0语法discard返回值总是返回 OK 。实例12345678910111213127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr user_idQUEUED127.0.0.1:6379&gt; incr user_idQUEUED127.0.0.1:6379&gt; pingQUEUED127.0.0.1:6379&gt; discardOK127.0.0.1:6379&gt; exec(error) ERR EXEC without MULTI127.0.0.1:6379&gt;Redis watch命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。可用版本 &gt;= 2.2.0语法watch key [key ...]返回值总是返回 OK 。Redis unwatch 命令用于取消watch命令对所有 key 的监视。可用版本 &gt;= 2.2.0语法redis Unwatch 命令基本语法如下：redis 127.0.0.1:6379&gt; UNWATCH返回值总是返回 OK 。Redis 脚本Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。语法EVAL script numkeys key [key ...] arg [arg ...]实例123456127.0.0.1:6379&gt; EVAL &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second1) &quot;key1&quot;2) &quot;key2&quot;3) &quot;first&quot;4) &quot;second&quot;127.0.0.1:6379&gt;Redis eval 命令使用 Lua 解释器执行脚本。可用版本 &gt;= 2.6.0语法EVAL script numkeys key [key ...] arg [arg ...]参数说明：script： 参数是一段 Lua 5.1 脚本程序。脚本不必(也不应该)定义为一个 Lua 函数。numkeys： 用于指定键名参数的个数。key [key …]： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。arg [arg …]： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。Redis evalsha 命令根据给定的 sha1 校验码，执行缓存在服务器中的脚本。可用版本 &gt;= 2.6.0将脚本缓存到服务器的操作可以通过SCRIPT LOAD命令进行。这个命令的其他地方，比如参数的传入方式，都和 EVAL 命令一样。语法EVALSHA sha1 numkeys key [key ...] arg [arg ...]参数说明：sha1 ： 通过SCRIPT LOAD生成的 sha1 校验码。numkeys： 用于指定键名参数的个数。key [key …]： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。arg [arg …]： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。实例12345127.0.0.1:6379&gt; SCRIPT LOAD &quot;return &apos;hello freya&apos;&quot;&quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;127.0.0.1:6379&gt; evalsha &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot; 0&quot;hello freya&quot;127.0.0.1:6379&gt;Redis script exists 命令用于校验指定的脚本是否已经被保存在缓存当中。可用版本 &gt;= 2.6.0语法SCRIPT EXISTS sha1 [sha1 ...]返回值一个列表，包含 0 和 1 ，前者表示脚本不存在于缓存，后者表示脚本已经在缓存里面了。列表中的元素和给定的 SHA1 校验和保持对应关系，比如列表的第三个元素的值就表示第三个 SHA1 校验和所指定的脚本在缓存中的状态。实例123456789127.0.0.1:6379&gt; SCRIPT LOAD &quot;return &apos;hello freya&apos;&quot;&quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;127.0.0.1:6379&gt; script exists &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;1) (integer) 1127.0.0.1:6379&gt; script flushOK127.0.0.1:6379&gt; script exists &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;1) (integer) 0127.0.0.1:6379&gt;Redis script kill 命令用于杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。可用版本 &gt;= 2.6.0这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限循环的脚本。script kill执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从EVAL命令的阻塞当中退出，并收到一个错误作为返回值。语法script kill返回值总是返回 OKRedis 连接Redis 连接命令主要是用于连接 redis 服务。实例1234127.0.0.1:6379&gt; auth &quot;password&quot;OK127.0.0.1:6379&gt; pingPONGRedis auth 命令用于检测给定的密码和配置文件中的密码是否相符。可用版本 &gt;= 1.0.0语法auth pwd返回值密码匹配时返回 OK ，否则返回一个错误。Redis echo 命令用于打印给定的字符串。可用版本 &gt;= 1.0.0语法echo message返回值返回字符串本身。Redis Quit 命令用于关闭与当前客户端与redis服务的连接。可用版本 &gt;= 1.0.0一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。返回值总是返回 OK 。实例12127.0.0.1:6379&gt; quit$Redis select 命令用于切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。可用版本 &gt;= 1.0.0语法select index返回值总是返回 OK 。]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis命令3]]></title>
    <url>%2Fposts%2Fa5d6296%2F</url>
    <content type="text"><![CDATA[Redis 集合(Set)命令Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)。实例12345678910127.0.0.1:6379&gt; sadd set redis(integer) 1127.0.0.1:6379&gt; sadd set mysql(integer) 1127.0.0.1:6379&gt; sadd redis(error) ERR wrong number of arguments for &apos;sadd&apos; command127.0.0.1:6379&gt; smembers set1) &quot;mysql&quot;2) &quot;redis&quot;127.0.0.1:6379&gt;Redis Sadd 命令将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。可用版本 &gt;= 1.0.0当集合 key 不是集合类型时，返回一个错误。在Redis2.4版本以前， SADD 只接受单个成员值。语法sadd key value1... valuen返回值被添加到集合中的新元素的数量，不包括被忽略的元素。srandmember key [count] 命令如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。该操作和spop相似，但spop将随机元素从集合中移除并返回，而 srandmember则仅仅返回随机元素，而不对集合进行任何改动。可用版本 &gt;= 1.0.0从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。时间复杂度:只提供 key 参数时为 O(1)。如果提供了 count 参数，那么为 O(N)，N 为返回数组的元素个数。返回值只提供 key 参数时，返回一个元素；如果集合为空，返回 nil 。如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。其他命令命令含义可用版本时间复杂度scard key返回集合 key 的基数(集合中元素的数量)。当 key 不存在时，返回 0 。&gt;=1.0.0O(1)sdiff key [key...]返回一个集合的全部成员，该集合是所有给定集合之间的差集。不存在的 key 被视为空集。差集的结果来自前面的 FIRST_KEY ,而不是后面的 OTHER_KEY1，也不是整个 FIRST_KEY OTHER_KEY1..OTHER_KEYN 的差集。&gt;=1.0.0O(N)， N 是所有给定集合的成员数量之和。sdiffstore destination key [key...]这个命令的作用和sdiff类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。&gt;=1.0.0O(N)， N 是所有给定集合的成员数量之和。sinter key [key ...]返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。&gt;=1.0.0O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。sinterstore destination key [key ...]这个命令的作用和sinter类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。&gt;=1.0.0O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。sismember key member判断 member 元素是否集合 key 的成员。如果 member 元素是集合的成员，返回 1 。如果 member 元素不是集合的成员，或 key 不存在，返回 0 。&gt;= 1.0.0O(1)smembers key返回集合 key 中的所有成员。不存在的 key 被视为空集合。&gt;= 1.0.0O(N)，N 为集合的基数smove source destination member将 member 元素从 source 集合移动到 destination 集合。原子性操作。如果 source 集合不存在或不包含指定的 member 元素，则 smove命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。&gt;= 1.0.0O(1)spop key移除并返回集合中的一个随机元素。当 key 不存在或 key 是空集时，返回 nil 。如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 srandmember命令。&gt;= 1.0.0O(1)srem key member [member...]移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。当 key 不是集合类型，返回一个错误。在 Redis 2.4 版本以前，srem只接受单个 member 值。&gt;= 1.0.0O(n)，n为给定member元素的数量sunion key [key ...]返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集。&gt;= 1.0.0O(N)， N 是所有给定集合的成员数量之和。sunionstore dest key [key ...]这个命令的作用和sinter类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。&gt;=1.0.0O(N * M)， N 是所有给定集合的成员数量之和。sscan key cursor [MATCH pattern] [COUNT count]和 scan 、hscan、zscan一样，看不太明白。回头用到再看。Redis 有序集合(sorted set)命令Redis 有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。实例12345678910111213141516127.0.0.1:6379&gt; zadd sset 1 redis(integer) 1127.0.0.1:6379&gt; zadd sset 2 mongodb(integer) 1127.0.0.1:6379&gt; zadd sset 3 mysql(integer) 1127.0.0.1:6379&gt; zadd sset 3 mysql(integer) 0127.0.0.1:6379&gt; zadd sset 4 mysql(integer) 0127.0.0.1:6379&gt; zrange sset 0 10 withscores1) &quot;redis&quot;2) &quot;1&quot;3) &quot;mongodb&quot;4) &quot;2&quot;5) &quot;mysql&quot;zadd 命令将一个或多个 member 元素及其 score 值加入到有序集 key 当中。如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。score 值可以是整数值或双精度浮点数。如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。当 key 存在但不是有序集类型时，返回一个错误。语法zadd key score member [[score member] [score member] ...]可用版本：可用版本&gt;= 1.2.0 。在 Redis 2.4 版本以前， zadd每次只能添加一个元素。时间复杂度:O(M*log(N))，N 是有序集的基数，M 为成功添加的新成员的数量。返回值:被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。zrange 命令返回有序集 key 中，指定区间内的成员。可用版本 &gt;= 1.2.0其中成员的位置按 score 值递增(从小到大)来排序。具有相同 score 值的成员按字典序(lexicographical order )来排列。如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE 命令。语法zrange key start stop [WITHSCORES]说明下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。超出范围的下标并不会引起错误。比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。时间复杂度O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。zrangebyscore 命令返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。可用版本 &gt;= 1.0.5语法zrangebyscore key min max [WITHSCORES] [LIMIT offset count]说明具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。该选项自 Redis 2.0 版本起可用。区间及无限min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。举个例子：1zrangebyscore zset (1 5返回所有符合条件 1 &lt; score &lt;= 5 的成员，而zrangebyscore zset (5 (10则返回所有符合条件 5 &lt; score &lt; 10 的成员。时间复杂度O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。zremrangebyrank 命令移除有序集 key 中，指定排名(rank)区间内的所有成员。返回被移除成员的数量。区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。语法zremrangebyrank key start stop时间复杂度O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。zremrangebyscore 命令移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。返回被移除成员的数量。可用版本 &gt;= 1.2.0自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 zrangebyscore 命令。语法zremrangebyscore key min max时间复杂度O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。zrevrange 命令返回有序集 key 中，指定区间内的成员。可用版本 &gt;= 1.2.0其中成员的位置按 score 值递减(从大到小)来排列。具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。除了成员按 score 值递减的次序排列这一点外， zrevrange命令的其他方面和zrange命令一样。语法zrevrange key start stop [WITHSCORES]时间复杂度O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。zunionstore 命令计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。返回保存到 destination 的结果集的基数。可用版本 &gt;= 2.0.0默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和 。语法zunionstore destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]WEIGHTS 选项使用 WEIGHTS 选项，你可以为 每个给定有序集分别指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。AGGREGATE 选项使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之和作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。时间复杂度O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。zinterstore 命令计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。返回保存到 destination 的结果集的基数。可用版本 &gt;= 2.0.0默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.关于 WEIGHTS 和 AGGREGATE 选项的描述，参见zinterstore命令。时间复杂度O(NK)+O(Mlog(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。其他命令命令含义可用版本时间复杂度zcard key返回有序集 key 的基数。当 key 存在且是有序集类型时，返回有序集的基数。当 key 不存在时，返回 0 。&gt;=1.2.0O(1)zcount key min max返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。&gt;=2.0.0O(log(N)+M)， N 为有序集的基数， M 为值在 min 和 max 之间的元素的数量。zincrby key increment member为有序集 key 的成员 member 的 score 值加上增量 increment 。可以通过传递一个负数值 increment ，让 score 减去相应的值。当 key 不存在，或 member 不是 key 的成员时， zincrby key increment member 等同于 zadd key increment member 。当 key 不是有序集类型时，返回一个错误。score 值可以是整数值或双精度浮点数。&gt;=1.2.0O(log(N))zrank key member返回有序集 key 中成员 member 的排名。如果 member 不是有序集 key 的成员，返回 nil 。其中有序集成员按 score 值递增(从小到大)顺序排列。排名以 0 为底，也就是说， score 值最小的成员排名为 0 。&gt;=2.0.0O(log(N))zrem key member [member ...]移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。f返回被成功移除的成员的数量，不包括被忽略的成员。当 key 存在但不是有序集类型时，返回一个错误。在 Redis 2.4 版本以前，zrem每次只能删除一个元素。&gt;=1.2.0O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。zrevrank key member返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。排名以 0 为底，也就是说， score 值最大的成员排名为 0 。&gt;=2.0.0O(log(N))zscore key member返回有序集 key 中，成员 member 的 score 值，以字符串形式表示。如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。&gt;=1.2.0O(1)zrevrangebyscore key max min [withscores] [limit offset count]返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。除了成员按 score 值递减的次序排列这一点外，zrevrangebyscore 命令的其他方面和 zrangebyscore命令一样。&gt;=2.2.0O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis命令2]]></title>
    <url>%2Fposts%2F7d5a5200%2F</url>
    <content type="text"><![CDATA[Redis 哈希(Hash)相关命令Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。Redis hset命令用于为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，旧值将被覆盖。可用版本&gt;= 2.0.0语法hset key field1 value1 [field2 value2 ]返回值如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 。Redis hsetnx命令用于为哈希表中不存在的的字段赋值。如果哈希表不存在，一个新的哈希表被创建并进行hset操作。如果字段已经存在于哈希表中，操作无效。如果 key 不存在，一个新哈希表被创建并执行hsetnx命令。可用版本 &gt;= 2.0.0语法hsetnx key field value返回值设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0 。Redis hget命令用于返回哈希表中指定字段的值。可用版本&gt;= 2.0.0语法hget key field返回值返回给定字段的值。如果给定的字段或 key 不存在时，返回 nil 。Redis hgetall命令用于返回哈希表中，所有的字段和值。在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍。可用版本 &gt;= 2.0.0语法hgetall key返回值以列表形式返回哈希表的字段及字段值。若 key 不存在，返回空列表。Redis hmget命令用于返回哈希表中，一个或多个给定字段的值。如果指定的字段不存在于哈希表，那么返回一个 nil 值。可用版本 &gt;= 2.0.0语法hmget key field1...fieldn返回值一个包含多个给定字段关联值的表，表值的排列顺序和指定字段的请求顺序一样。如果对应的 field 不存在则返回 nil。Redis hlen命令用于获取哈希表中字段的数量。可用版本 &gt;= 2.0.0语法hlen key返回值哈希表中字段的数量。当 key 不存在时，返回 0 。Redis hkeys命令用于获取哈希表中的所有域（field）。可用版本 &gt;= 2.0.0语法hkeys key返回值包含哈希表中所有域（field）列表。 当 key 不存在时，返回一个空列表。Redis hvals命令返回哈希表所有域(field)的值。可用版本 &gt;= 2.0.0语法hvals key返回值一个包含哈希表中所有域(field)值的列表。 当 key 不存在时，返回一个空表。Redis hexists命令用于查看哈希表的指定字段是否存在。语法hexists key field返回值如果哈希表含有给定字段，返回 1 。 如果哈希表不含有给定字段，或 key 不存在，返回 0 。Redis hdel命令用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略。可用版本 &gt;= 2.0.0语法hdel key field.. fieldn返回值被成功删除字段的数量，不包括被忽略的字段。Redis hincrby命令用于为哈希表中的字段值加上指定增量值 increment。增量也可以为负数，相当于对指定字段进行减法操作。可用版本 &gt;= 2.0.0如果哈希表的 key 不存在，一个新的哈希表被创建并执行hincrby命令。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。对一个储存字符串值的字段执行hincrby命令将造成一个错误。本操作的值被限制在 64 位(bit)有符号数字表示之内。语法hincrby key field increment返回值执行 HINCRBY 命令之后，哈希表中字段的值。实例123456789101112131415127.0.0.1:6379&gt; hset freya age 17(integer) 1127.0.0.1:6379&gt; hincrby freya age 1(integer) 18127.0.0.1:6379&gt; hincrby freya age -1(integer) 17127.0.0.1:6379&gt; exists asher(integer) 0127.0.0.1:6379&gt; hexists asher age(integer) 0127.0.0.1:6379&gt; hincrby asher age 19(integer) 19127.0.0.1:6379&gt; hgetall asher1) &quot;age&quot;2) &quot;19&quot;Redis hincrbyfloat命令用于为哈希表中的字段值加上指定浮点数增量值 increment。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。可用版本 &gt;= 2.6.0语法hincrbyfloat key field increment返回值执行 Hincrbyfloat 命令之后，哈希表中字段的值。Redis hscan命令hscan key cursor [MATCH pattern] [COUNT count]迭代哈希表中的键值对。与scan类似，看不太懂，回头再战。Redis 列表(List)相关命令Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。Redis lpush命令将一个或多个值插入到列表头部。如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误。可用版本&gt;= 1.0.0 。在Redis 2.4版本以前的lpush命令，都只接受单个 value 值。 rpush 与之类似，只不过在列表尾部添加。语法lpush key value1.. valuen返回值执行lpush命令后，列表的长度。Redis lpushx命令将一个值插入到已存在的列表头部，列表不存在时操作无效。可用版本 &gt;= 2.2.0 。rpushx与之类似，只不过在列表尾部添加。语法lpushx key value1.. valuen返回值lpush命令执行之后，列表的长度。Redis lindex命令用于通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。可用版本 &gt;= 1.0.0语法lindex key index返回值列表中下标为指定索引值的元素。如果指定索引值不在列表的区间范围内，返回 nil。Redis llen命令用于返回列表的长度。如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 。 如果 key 不是列表类型，返回一个错误。可用版本 &gt;= 1.0.0语法llen key返回值列表的长度。Redis linsert命令用于在列表的元素前或者后插入元素。当指定元素不存在于列表中时，不执行任何操作。可用版本 &gt;= 1.0.0当列表不存在时，被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。语法linsert key BEFORE|AFTER pivot value将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。返回值如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到指定元素 ，返回 -1 。 如果 key 不存在或为空列表，返回 0 。Redis lpop命令用于移除并返回列表的第一个元素。可用版本 &gt;= 1.0.0语法lpop key返回值列表的第一个元素。当列表 key 不存在时，返回 nil 。Redis rpop命令用于移除列表的最后一个元素，返回值为移除的元素。可用版本 &gt;= 1.0.0语法rpop key返回值被移除的元素。当列表不存在时，返回 nil 。Redis lrange命令返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。可用版本 &gt;= 1.0.0语法lrange key start end返回值一个列表，包含指定区间内的元素。Redis lrem命令根据参数 count 的值，移除列表中与参数 value 相等的元素。可用版本 &gt;= 1.0.0count 的值可以是以下几种：count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。count = 0 : 移除表中所有与 value 相等的值。语法lrem key count value返回值被移除元素的数量。列表不存在时返回 0 。Redis lset命令通过索引来设置元素的值。当索引参数超出范围，或对一个空列表进行lset时，返回一个错误。可用版本 &gt;= 1.0.0语法lset key index value返回值操作成功返回 ok ，否则返回错误信息。Redis ltrim命令对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。可用版本 &gt;= 1.0.0下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。语法ltrim key start end返回值命令执行成功时，返回 ok 。Redis blpop命令移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。可用版本 &gt;= 2.0.0 。brpop与之类似，只不过在列表尾部移除。当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。语法blpop list[list...] timeout返回值如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。可用版本 &gt;= 1.0.0Redis rpoplpush命令用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。在一个原子时间内，执行以下两个动作：将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。语法rpoplpush source_key dest_key返回值被弹出的元素。Redis brpoplpush命令brpoplpush是rpoplpush的阻塞版本，当给定列表 source 不为空时，brpoplpush的表现和rpoplpush一样。可用版本 &gt;= 2.2.0当列表 source 为空时，brpoplpush命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行lpush或rpush命令为止。超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。返回值：假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。]]></content>
  </entry>
  <entry>
    <title><![CDATA[拾句-现实]]></title>
    <url>%2Fposts%2Fa9bf165e%2F</url>
    <content type="text"><![CDATA[001我们现在的现代生活里，在忙碌之后，真正夜半三更的时候，更多的体会还是孤独，所以这个时候就特别渴望有一个相伴，所以爱情在这个地方，跟我们这个部分就有高度的契合。所以孤独本身有时候会让人滑向爱情，好像爱情可以填补这个孤独，但是这是一个特别大的误区，因为两个人真正在一起，它有时候释放出来的孤独，比你原来一个人承担的孤独还要大，因为它伴随着一个特别大的失望，生存生命是要靠自己去承担的，而不是躲到那种所谓的爱情里面去，就像柏拉图讲，人要在洞穴阶段，在一片黑暗里面，获得反思，获得认识，获得沉淀。所以我们人生有时候不要回避，一孤独就觉得为什么我孤独了，就忙着逃避，有的人觉得为什么我还不谈恋爱，我的女朋友、男朋友怎么还不出现，然后我一个人还单着，很多人在恋爱里面，爱人变成对自己的一个弥补，根本的爱的来源是创伤，我们要意识到为什么一个人特别需要，在现代生活里面，需要独立地去成长一段时间，因为在这个过程里面要把自己内心的创伤，要给它认识到，要给它愈合。生命要打开新的叶子，生长出新的枝叶来，来获得一个比较完整的生命，然后去爱人。因为我们今天的社会里面，特别容易有创伤，尤其是我们今天的的独生子女一代，他没有任何经验，也没有任何以前我们传统社会里面的兄弟姐妹，我们的要求太多了，渴望得到的东西也太多了，所以在这种情况下，我们的爱情里面就承担了太多的东西，所以一旦结婚的话，互相的需求度太大了，造成沉重的压力，然后每一个都没有什么输出的能力，互相都是枯竭的，所以就是巨大的失望，所以这些，潜在的需要，我们要有一种自我清理，其实你要珍惜你的这一段孤独，你一旦在这个孤独里面获得了自己的这种独立的生存，获得了自己的内容，获得了自己生命的坚实，这个时候你才真正地变成了一个在这个世界能承担爱情的人，你一生里面如何获得几年的孤独时间，这还真是挺值得去好好地努力的东西，实际上从另外一个意义上说，你的成长就在孤独里面，所以我觉得这个是一个我们原来很容易被扭曲的东西，在天黑以后，往热闹地方躲，可心里头，有定时的闹钟，提醒你有多寂寞。一席|万象|孤独yixi.tv/wanxiang/2/10在我们国家在出轨这件事上，对小三和对出轨丈夫的接受程度简直天差地别。对小三的态度是绝对的零容忍，但对出轨的男人来说会相对宽容。人生最好的三个词——久别重逢、失而复得、虚惊一场。但却没有「和好如初」。只因和好容易，如初太难。打太极——踢皮球曾经那些如胶似漆的，终有一天会因激情燃尽厌弃对方后而渐行渐远。人，总以缘分来作为了却情义的假词。人活着注定是要孤独的，以前不懂的，现在也应该懂了。你觉得电流只走耗电少的那一条。事实上并不是。电流其实走了所有的路。因为电路中电流的产生是要靠电场的。电场会迅速找到阻抗最小的路。期间是一个局部场强不断重新分布的过程，只不过电场很快，你感受不到它的分布。简单地说，电流是由电场建立的，电场的建立依据波动方程，你所看到的现象只是电路达到平衡后的稳态，而稳态建立前的瞬间，电流是向四面八方传播的。其实很多女生都很好，只是少数女生被那些有毒公众号洗脑了。「好人若不团结，必被坏人一一消灭」，这条基本原则不仅适用于以个人为单位，也适用于以国家为单位。——饭否所谓政治，就是老年人谈话、年轻人流血。002你和我玩就不许和我讨厌的人玩，你是我爸妈就是这么多年只想着对我这个小孩付出，你是我朋友不能对我有一丝抱怨和吐槽，你是我的恋人该永远忠贞不能有一丝一毫别的念头。后来发现，绝不是这样的…因为人实在是一种太复杂的生物了太多时候，一些行为并不代表对方不爱你或者不在乎你。如果非要纠结，就会发现世界本就是不纯粹的迈入成年人阶段的过程中，你的三观是无限摧毁建立的。到最后你发现，很多你认定错或者对的事情，到最后只是你以为了而已…你会发现每个人都不是你想象那般好，也不是你想象那般差。你会发现，前一刻的自己的想法如此幼稚，看法过于绝对慢慢宽容一切之后发现，其实是解放了自己。——博主:为什么不去问问神奇的阿UU呢知乎无闻www.zhihu.com/question/328988589/answer/742934290只有观念才能战胜观念，学者的使命是纠正错误观念。——哈耶克战争年代，由于存在战争这种强力的淘汰工具，能够迅速证明一个军官的能力和判断，从而保证这个体系掌握在有能力的人手里。而和平时期，这样一个体系没有了这种最终验证的机制，很容易在内部文化上形成上级对下级的粗暴干涉，层层相压，带有强烈的威权色彩。一旦主官的意志形成绝对，那么天然就是官僚威权体系的温床，甚至比普通的官僚体系还要差。人们总以为在某个特定时刻，一切错误将被纠正，所有伤痕将会痊愈，但这样的时刻并不存在。虽然老话常说，己所不欲，勿施于人。但这就是大道理罢了，很多人都是把自己受的气，又原封不动地撒到比自己更弱小的人身上去。这世界上，越是弱小越是容易遭遇令人讨厌的事情。于荣光在《给爸爸的信》里差点把李连杰打死，论个头块头功夫真打起来，除了职业散打选手谁都打不过他，中国人不爱看体格压制的电影，就喜欢以小博大。给个淘宝链接，加个微信，百度一下，已经成了很正常的语义，品牌代表品类，这才是基础设施最恐怖的地方。——半佛仙人人类文明史就像一场永不退场的牌局，只是出牌的人变了又变。人类是一个进化飞快的民族，很多问题只要被发现，就离解决不远了。——半佛仙人对一部作品解读最差的可能就是作者本人了。——苏格拉底咸吃萝卜淡操心往往不是太闲，是太坏。003A10攻击机的第一视角。电视剧主角在这样的扫射下一路狂奔是不可能的，炮弹比音速还快，正确的拍法是主角什么都没听到呢，没有任何反应，突然人就没了……100多年前，当大型企业首次出现时，它们能够模仿的唯一组织就是军队。——彼得·德鲁克不要说美团卧虎藏龙？因为是有太多的强者向生活低了头。怀孕的时候，老公说我陪你一起胖，生过孩子我再陪你一起减肥！越伪装越可悲，越伪装越没有机会。年轻时一定要把这点当成纪律遵守。并不是说中年人老年人不要遵守这纪律，只是年轻时违反这纪律，中老年在财务与人格上双重破产，一点也不重要了，随他们去吧。——连叔那种最庞大的金融机器一旦开动起来就几乎不可能平稳停下来，不管是基于战争的金融，还是基于土地的金融。——饭否中国有一句话，徒弟找师傅，师傅也找徒弟，找一个好徒弟很难的。之所以大家觉得天气预报“特别不准”，很大程度上是心理原因，天气预报准的时候，大家并不会惊呼。可一旦不准就立马成为谈资，这才留下“特别不准”的偏见。著名的哲学家阿甘他妈曾说过，生活就像一盒巧克力，你永远不知道下一颗的味道。生活也用一次次无情耳光告诉我们：天有不测风云，人有祸福旦夕。004斯蒂格勒定律，又名“名字来由法则”，是美国统计学家史蒂芬·斯蒂格勒提出的定律，指出科学发现或定律的命名最终大多归功于后来更有名望的科学家，而非其原发现者或创始人。礼貌最大的作用，就是营造这种距离感。有余力的话还能继续装，没有余力了就会原形毕露。与人深交的成本是很高的。她对你没有好奇，你说的，她就听，没说的，她也不会追着问；你问的，她就答，没问到的，也不多解释。没有特别想要了解你，或被你了解，就不必走太近。待人友善是教养，独来独往是性格。自媒体时代，大家多以吃瓜围观为主。没做什么伤天害理的事，大家多是看个乐子，消遣一把，真没人把你恨到天上去。公众人物真的需要一点自黑的特质，脸皮厚点，不怕别人评论，不怕别人黑你。很多时候，没有那么绝对的，失去了一些东西，可能会因此得到另外一些东西。低级别创业，最重要的技能就是学会算帐。财务，是主导一切的核心，不会有效的算帐。就无法有效的决定一些事。中国历史和区块链的原理有点像，每个朝代给前朝修史，就像生成一个新的区块。要想篡改也并非绝对不可能，但必须掌握超过50%的算力。——饭否005没有神的光环，你我生而平凡。——《只要平凡》在经济高速增长阶段，随便投资什么都很容易获得超过10%稳定回报，自然看不上双汇这种每年分红5%的公司。但一旦经济降速，其他投资困难，自然只能回头来买可口可乐和双汇了。证金公司降低了转融资利率80P，这件事就相当于针对股市定向降息，鼓励大家借钱炒股。股市降息、楼市按揭加息。伴随而来的资本主义和消费社会又极度压缩了普通人成年后的学习寿命。历史长河中的每一段，普通成年人是没有终身学习习惯的。过去二十年，全中国的房地产就像是个比上交所大很多很多倍的证券交易所，每个城市都是一只股票，在某个城市买了一套房就相当于入股了这只股票。那些房地产开发商就相当于大大小小的投行。]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>现实</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis命令1]]></title>
    <url>%2Fposts%2Fe45303ba%2F</url>
    <content type="text"><![CDATA[Redis命令Redis 命令用于在 redis 服务上执行操作。要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。语法Redis 客户端的基本语法为：1$ redis-cli实例以下实例讲解了如何启动 redis 客户端：启动 redis 客户端，打开终端并输入命令 redis-cli。该命令会连接本地的 redis 服务。连接到本地的 redis 服务并执行 PING 命令，该命令用于检测 redis 服务是否启动。1234$ redis-cli127.0.0.1:6379&gt;127.0.0.1:6379&gt; pingPONG在远程服务上执行命令如果需要在远程 Redis 服务上执行命令，同样我们使用的也是 redis-cli 命令。和上面实例类似，上述命令执行的是默认参数，host 为 127.0.0.1 ，port为 6379， 无需密码1$ redis-cli -h host -p port -a password实例以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。1234$ redis-cli -h 127.0.0.1 -p 6379 -a "mypass"127.0.0.1:6379&gt;127.0.0.1:6379&gt; pingPONG语法1$ redis-cli -h host -p port -a password实例以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。1234$ redis-cli -h 127.0.0.1 -p 6379 -a "mypass"127.0.0.1:6379&gt;127.0.0.1:6379&gt; pingPONGRedis 键(key)相关命令Redis 键命令用于管理 redis 的键。语法Redis 键命令的基本语法如下：1127.0.0.1:6379&gt; COMMAND KEY_NAME实例12345$ # del 是一个命令， name 是一个键。如果键被删除成功，命令执行后输出 (integer) 1，否则将输出 (integer) 0127.0.0.1:6379&gt; set name redisOK127.0.0.1:6379&gt; del name (integer) 1Redis键相关的基本命令命令描述可用版本del key该命令用于在 key 存在时删除 key。返回被删除 key 的数量&gt;= 1.0.0dump key该命令用于序列化给定 key 。如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。&gt;= 2.6.0exists key该命令用于检查给定 key 是否存在。若 key 存在返回 1 ，否则返回 0 。&gt;= 1.0.0expire key seconds1. 该命令用于设置 key 的过期时间，key 过期后将不再可用。单位以秒计。设置成功返回 1 。 当 key 不存在或者不能为 key 设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的过期时间)返回 0 。在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。2. 在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 key 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。&gt;= 1.0.0pexpire key milliseconds该命令和 expire 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间。&gt;= 2.6.0expireat key timestamp该命令用于以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间，单位以秒计。key 过期后将不再可用。设置成功返回 1 。当 key 不存在或者不能为 key 设置过期时间时返回 0 。&gt;= 1.2.0pexpireat key milliseconds-timestamp该命令和expireat命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳。&gt;= 2.6.0keys pattern1. 该命令用于查找所有符合给定模式 pattern 的 key。时间复杂度：O(N)， N 为数据库中 key 的数量。返回符合给定模式的 key 列表。2. keys的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 key ，你最好还是用 Redis 的集合结构(set)来代替。&gt;= 1.0.0move key db1. 该命令用于将当前数据库的 key 移动到给定的数据库 db 当中。时间复杂度：O(1)。移动成功返回 1 ，失败则返回 0 。2. 如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。因此，也可以利用这一特性，将 move当作锁(locking)原语(primitive)。&gt;= 1.0.0persist key该命令用于移除给定 key 的生存时间，将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key )。时间复杂度：O(1)。当生存时间移除成功时，返回 1 .如果 key 不存在或 key 没有设置生存时间，返回 0 。&gt;= 2.2.0ttl key1. 该命令以秒为单位返回 key 的剩余过期时间。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。时间复杂度：O(1)2. 在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。&gt;= 1.0.0pttl key1. 该命令以毫秒为单位返回 key 的剩余过期时间。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。时间复杂度：O(1)2. 在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。&gt;= 2.6.0randomkey该命令从当前数据库中随机返回(不删除)一个 key 。时间复杂度：O(1)。当数据库不为空时，返回一个 key 。当数据库为空时，返回 nil 。&gt;= 1.0.0rename key newkey将 key 改名为 newkey 。时间复杂度：O(1)。改名成功时提示 OK ，当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。当 newkey 已经存在时， raname命令将覆盖旧值。&gt;= 1.0.0renamenx key newkey将 key 改名为 newkey 。时间复杂度：O(1)。当且仅当 newkey 不存在时，将 key 改名为 newkey 。修改成功时，返回 1 。当 newkey 存在时，返回 0 。当 key 不存在时，返回一个错误。&gt;= 1.0.0type key返回 key 所储存的值的类型。时间复杂度：O(1)。none (key不存在)string (字符串)list (列表)set (集合)zset (有序集)hash (哈希表)&gt;= 1.0.0Redis键相关的其他命令sort语法sort key [by pattern] [limit offset count] [get pattern [get pattern ...]] [asc | desc] [alpha] [store destination]返回或保存给定列表、集合、有序集合 key 中经过排序的元素。排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。一般 SORT 用法最简单的 SORT 使用方法是 SORT key 和 SORT key DESC ：sort key 返回键值从小到大排序的结果。sort key desc 返回键值从大到小排序的结果。1234567891011121314151617127.0.0.1:6379&gt; lpush cost 20 18 35 9.3 18(integer) 5# 排序127.0.0.1:6379&gt; sort cost1) &quot;9.3&quot;2) &quot;18&quot;3) &quot;18&quot;4) &quot;20&quot;5) &quot;35&quot;# 逆序排序127.0.0.1:6379&gt; sort cost desc 1) &quot;35&quot;2) &quot;20&quot;3) &quot;18&quot;4) &quot;18&quot;5) &quot;9.3&quot;127.0.0.1:6379&gt;使用外部 key 进行排序可以使用外部 key 的数据作为权重，代替默认的直接对比键值的方式来进行排序。假设现在有用户数据如下：uiduser_name_{uid}user_level_{uid}1admin99992jack103peter251234567891011121314151617181920212223127.0.0.1:6379&gt; lpush uid 1(integer) 1127.0.0.1:6379&gt; set user_name_1 adminOK127.0.0.1:6379&gt; set user_level_1 9999OK127.0.0.1:6379&gt; lpush uid 2(integer) 2127.0.0.1:6379&gt; set user_name_2 jackOK127.0.0.1:6379&gt; set user_level_2 10OK127.0.0.1:6379&gt; lpush uid 3(integer) 3127.0.0.1:6379&gt; set user_name_3 peterOK127.0.0.1:6379&gt; set user_level_3 25OK127.0.0.1:6379&gt; sort uid by user_level_*1) &quot;2&quot;2) &quot;3&quot;3) &quot;1&quot;127.0.0.1:6379&gt;默认情况下， SORT uid 直接按 uid 中的值排序，通过使用 BY 选项，可以让 uid 按其他键的元素来排序。user_level_* 是一个占位符， 它先取出 uid 中的值， 然后再用这个值来查找相应的键。比如在对 uid 列表进行排序时， 程序就会先取出 uid 的值 1 、 2 、 3 ， 然后使用 user_level_1 、 user_level_2 、 user_level_3的值作为排序 uid 的权重。get 选项使用get选项， 可以根据排序的结果来取出相应的键值。12345127.0.0.1:6379&gt; sort uid get user_name_*1) &quot;admin&quot;2) &quot;jack&quot;3) &quot;peter&quot;127.0.0.1:6379&gt;组合使用 by 和 get通过组合使用by和get， 可以让排序结果以更直观的方式显示出来。比如说， 以下代码先按 user_level_{uid} 来排序 uid 列表， 再取出相应的 user_name_{uid} 的值：1234127.0.0.1:6379&gt; sort uid by user_level_* get user_name_*1) &quot;jack&quot; 2) &quot;peter&quot; 3) &quot;mary&quot;获取多个外部键可以同时使用多个get选项， 获取多个外部键的值。get有一个额外的参数规则——可以用 # 获取被排序键的值。1234567891011127.0.0.1:6379&gt; sort uid get # get user_level_* get user_name_*1) &quot;1&quot;2) &quot;9999&quot;3) &quot;admin&quot;4) &quot;2&quot;5) &quot;10&quot;6) &quot;jack&quot;7) &quot;3&quot;8) &quot;25&quot;9) &quot;peter&quot;127.0.0.1:6379&gt;获取外部键，但不进行排序通过将一个不存在的键作为参数传给by选项， 可以让sort跳过排序操作， 直接返回结果：1234127.0.0.1:6379&gt; sort uid by not-exists-key1) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;这种用法在单独使用时，没什么实际用处。不过，通过将这种用法和get选项配合， 就可以在不排序的情况下， 获取多个外部键， 相当于执行一个整合的获取操作（类似于 SQL 数据库的 join 关键字）。1234567891011127.0.0.1:6379&gt; sort uid by not-exists-key get # get user_level_* get user_name_*1) &quot;3&quot;2) &quot;25&quot;3) &quot;peter&quot;4) &quot;2&quot;5) &quot;10&quot;6) &quot;jack&quot;7) &quot;1&quot;8) &quot;9999&quot;9) &quot;admin&quot;127.0.0.1:6379&gt;保存排序结果默认情况下， sort操作只是简单地返回排序结果，并不进行任何保存操作。通过给store选项指定一个 key 参数，可以将排序结果保存到给定的键上。如果被指定的 key 已存在，那么原有的值将被排序结果覆盖。1234567891011121314151617181920212223242526272829127.0.0.1:6379&gt; rpush numbers 1 3 5 7 9(integer) 5127.0.0.1:6379&gt; rpush numbers 2 4 6 8 10(integer) 10127.0.0.1:6379&gt; lrange numbers 0 -1 1) &quot;1&quot; 2) &quot;3&quot; 3) &quot;5&quot; 4) &quot;7&quot; 5) &quot;9&quot; 6) &quot;2&quot; 7) &quot;4&quot; 8) &quot;6&quot; 9) &quot;8&quot;10) &quot;10&quot;127.0.0.1:6379&gt; sort numbers store sorted-numbers(integer) 10127.0.0.1:6379&gt; lrange sorted-numbers 0 -1 1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 4) &quot;4&quot; 5) &quot;5&quot; 6) &quot;6&quot; 7) &quot;7&quot; 8) &quot;8&quot; 9) &quot;9&quot;10) &quot;10&quot;127.0.0.1:6379&gt;可以通过将sort命令的执行结果保存，并用expire为结果设置生存时间，以此来产生一个sort操作的结果缓存。这样就可以避免对sort操作的频繁调用：只有当结果集过期时，才需要再调用一次sort操作。另外，为了正确实现这一用法，你可能需要加锁以避免多个客户端同时进行缓存重建(也就是多个客户端，同一时间进行sort操作，并保存为结果集)，具体参见setnx命令。objectobject subcommand [arguments [arguments]]object命令允许从内部察看给定key的 Redis 对象。它通常用在除错(debugging)或者了解为了节省空间而对 key 使用特殊编码的情况。当将Redis用作缓存程序时，你也可以通过 OBJECT 命令中的信息，决定 key 的驱逐策略(eviction policies)。可用版本：&gt;= 2.2.3 ，时间复杂度：O(1)。object 命令子命令object refcount key 返回给定 key 引用所储存的值的次数。此命令主要用于除错。object encoding key 返回给定 key 锁储存的值所使用的内部表示(representation)。object idletime key 返回给定 key 自储存以来的空转时间(idle， 没有被读取也没有被写入)，以秒为单位。对象编码方式：字符串可以被编码为raw(一般字符串)、embstr或int(用字符串表示64位数字是为了节约空间)。列表可以被编码为ziplist或linkedlist。 ziplist是为节约大小较小的列表空间而作的特殊表示。集合可以被编码为intset或者hashtable。 intset是只储存数字的小集合的特殊表示。哈希表可以编码为zipmap或者hashtable 。 zipmap是小哈希表的特殊表示。有序集合可以被编码为 ziplist 或者 skiplist 格式。 ziplist 用于表示小的有序集合，而 skiplist 则用于表示任何大小的有序集合。示例12345678910111213141516171819202122232425127.0.0.1:6379&gt; set name &quot;redis&quot;OK127.0.0.1:6379&gt; object refcount name (integer) 1 # 只有一个引用127.0.0.1:6379&gt; 127.0.0.1:6379&gt; object idletime name(integer) 104 # 等待一阵，然后查看空转时间127.0.0.1:6379&gt; get name&quot;redis&quot;127.0.0.1:6379&gt; object idletime name(integer) 1 # get之后立即查空转时间127.0.0.1:6379&gt; object encoding name&quot;embstr&quot; # 对象编码方式127.0.0.1:6379&gt; set phone 17608882643OK127.0.0.1:6379&gt; object encoding phone&quot;int&quot;127.0.0.1:6379&gt; set phone 9223372036854775808OK # 大于或等于2的64次方，被编码为字符串127.0.0.1:6379&gt; object encoding phone&quot;embstr&quot;127.0.0.1:6379&gt; set phone 111111111111111111111111111111111111111111111OK # 超过44位之后以 raw 编码127.0.0.1:6379&gt; object encoding phone&quot;raw&quot;具体为什么是44而不是其他数字，原因可参考为什么redis小等于39字节的字符串是embstr编码，大于39是raw编码？ 44和39只是因为版本支持不同，github修改记录可参考commitrestorerestore key ttl serialized-value反序列化给定的序列化值，并将它和给定的key关联。与dump相对应。可用版本：&gt;= 2.6.0参数ttl以毫秒为单位为key设置生存时间；如果ttl为 0 ，那么不设置生存时间。restore在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么restore会拒绝进行反序列化，并返回一个错误。时间复杂度查找给定键的复杂度为 O(1) ，对键进行反序列化的复杂度为 O(N*M) ，其中 N 是构成 key 的 Redis 对象的数量，而 M 则是这些对象的平均大小。有序集合(sorted set)的反序列化复杂度为 O(NMlog(N)) ，因为有序集合每次插入的复杂度为 O(log(N)) 。如果反序列化的对象是比较小的字符串，那么复杂度为 O(1) 。示例1234567891011121314127.0.0.1:6379&gt; set hi "Hello, World!"OK127.0.0.1:6379&gt; dump hi # 序列化"\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR"127.0.0.1:6379&gt; restore hi 0 "\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR" # 反序列化时key已存在(error) BUSYKEY Target key name already exists.127.0.0.1:6379&gt; restore hi-restore 0 "\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR" # 反序列化OK127.0.0.1:6379&gt; restore fake-hi 0 "hello blablabla" # 使用错误的值进行反序列化(error) ERR DUMP payload version or checksum are wrongmigratemigrate host port key destination-db timeout [copy] [replace]将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。可用版本：&gt;= 2.6.0。迁移成功时返回 OK ，否则返回相应的错误。这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。可选项：copy ：不移除源实例上的 key 。replace ：替换目标实例上已存在的 key 。内部实现它在当前实例对给定 key 执行dump命令 ，将它序列化，然后传送到目标实例，目标实例再使用restore对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到restore命令返回 OK ，它就会调用del删除自己数据库上的 key 。timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。migrate命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。当 IOERR 出现时，有以下两种可能：key 可能存在于两个实例key 可能只存在于当前实例唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）。时间复杂度：这个命令在源实例上实际执行 DUMP 命令和 DEL 命令，在目标实例执行 RESTORE 命令，查看以上命令的文档可以看到详细的复杂度说明。key 数据在两个实例之间传输的复杂度为 O(N) 。实例启动两个Redis实例，一个默认 6379 端口，一个 9999 接口1234567891011121314151617181920212223242526$ ./redis-server --port 999980619:C 01 Aug 2019 23:21:22.685 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo80619:C 01 Aug 2019 23:21:22.686 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=80619, just started80619:C 01 Aug 2019 23:21:22.686 # Configuration loaded80619:M 01 Aug 2019 23:21:22.687 * Increased maximum number of open files to 10032 (it was originally set to 256). _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 5.0.5 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 9999 | `-._ `._ / _.-&apos; | PID: 80619 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 80619:M 01 Aug 2019 23:21:22.691 # Server initialized80619:M 01 Aug 2019 23:21:22.692 * DB loaded from disk: 0.001 seconds80619:M 01 Aug 2019 23:21:22.692 * Ready to accept connections用客户端连上 6379 端口的实例，设置一个键，然后将它迁移到 7777 端口的实例上12345678910$ ./redis-cli127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; set hello "Hello from 6379 instance"OK127.0.0.1:6379&gt; migrate 127.0.0.1 9999 hello 0 1000OK127.0.0.1:6379&gt; exists hello (integer) 0$ # 迁移成功后 key 被删除使用另一个客户端，查看 9999 端口上的实例123$ ./redis-cli -p 9999127.0.0.1:9999&gt; get hello&quot;Hello from 6379 instance&quot;scanscan cursor [MATCH pattern] [COUNT count]scan命令是一个基于游标的迭代器（cursor based iterator）： scan命令每次被调用之后，都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数，以此来延续之前的迭代过程。当scan命令的游标参数被设置为 0 时，服务器将开始一次新的迭代，而当服务器向用户返回值为 0 的游标时，表示迭代已结束。MATCH 选项和keys命令一样，增量式迭代命令也可以通过提供一个 glob 风格的模式参数，让命令只返回和给定模式相匹配的元素，这一点可以通过在执行增量式迭代命令时，通过给定 MATCH参数来实现。TODO 不是很明白，回头继续Redis 字符串(String)相关命令Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：语法1127.0.0.1:6379&gt; COMMAND KEY_NAME实例1234127.0.0.1:6379&gt; set name redisOK127.0.0.1:6379&gt; get name&quot;redis&quot;Redis字符串(String)相关的基本命令命令描述时间复杂度可用版本set key value1. 将字符串值 value 关联到 key 。如果 key 已经持有其他值， set就覆写旧值，无视类型。对于某个原本带有生存时间（TTL）的键来说， 当set命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。2. 在 Redis 2.6.12 以前版本， set 命令总是返回 OK 。从 Redis 2.6.12 版本开始，set 在设置操作成功完成时，才返回 OK 。如果设置了 NX 或者 XX ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。3. 从 Redis 2.6.12 版本开始， set命令的行为可以通过一系列参数来修改：EX、PX、NX、XX 。http://doc.redisfans.com/string/set.htmlO(1)&gt;= 1.0.0get key返回 key 所关联的字符串值。如果 key 不存在那么返回特殊值 nil 。假如 key 储存的值不是字符串类型，返回一个错误，因为get只能用于处理字符串值。O(1)&gt;= 1.0.0getrange key start end返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。getrange通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。O(N)， N 为要返回的字符串的长度。复杂度最终由字符串的返回值长度决定，但因为从已有字符串中取出子字符串的操作非常廉价(cheap)，所以对于长度不大的字符串，该操作的复杂度也可看作O(1)。&gt;= 2.4.0getset key value将给定 key 的值设为 value ，并返回 key 的旧值(old value)。当 key 存在但不是字符串类型时，返回一个错误。key 不存在时，返回 nil。O(1)&gt;= 1.0.0incr key1. 将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行incr操作，返回执行命令之后 key 的值。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。2. 本操作的值限制在 64 位(bit)有符号数字表示之内。这是一个针对字符串的操作，因为 Redis 没有专用的整数类型，所以 key 内储存的字符串被解释为十进制 64 位有符号整数来执行 incr 操作。3. 限速器与计数器的应用。4. incrby key increment、incrbyfloat key increment、decr key、decrby key decrement命令与之类似。http://doc.redisfans.com/string/incrbyfloat.htmlO(1)&gt;= 1.0.0getbit key offset对 key 所储存的字符串值，获取指定偏移量上的位(bit)。当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。O(1)&gt;= 2.2.0setbit key offset value对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。当 key 不存在时，自动生成一个新的字符串值。字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。2. offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。对使用大的 offset 的 setbit操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考setrange命令，warning(警告)部分。O(1)&gt;= 2.2.0strlen key返回 key 所储存的字符串值的长度。当 key 不存在时，返回 0 。当 key 储存的不是字符串值时，返回一个错误。O(1)&gt;= 2.2.0mget key [key ...]返回所有(一个或多个)给定 key 的值。如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败。O(N) , N 为给定 key 的数量。&gt;= 1.0.0mset key value [key value ...]1. 同时设置一个或多个 key-value 对。如果某个给定 key 已经存在，那么mset会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用msetnx命令：它只会在所有给定 key 都不存在的情况下进行设置操作。2. mset是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，某些给定 key 被更新而另一些给定 key 没有改变的情况，不可能发生。总是返回 OK (因为 MSET 不可能失败)O(N)， N 为要设置的 key 数量。&gt;= 1.0.1msetnx key value [key value ...]1. 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。即使只有一个给定 key 已存在， msetnx也会拒绝执行所有给定 key 的设置操作。当所有 key 都成功设置，返回 1 。如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。2. msetnx是原子性的，因此它可以用作设置多个不同 key 表示不同字段(field)的唯一性逻辑对象(unique logic object)，所有字段要么全被设置，要么全不被设置。O(N)， N 为要设置的 key 数量。&gt;= 1.0.1append key value1. 如果 key 已经存在并且是一个字符串， append命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， append就简单地将给定 key 设为 value ，就像执行 set key value 一样。2. 返回追加 value 之后， key 中字符串的长度。平摊O(1)&gt;= 2.0.0Redis字符串(String)相关的其他命令bitcountbitcount key [start] [end]计算给定字符串中，被设置为 1 的比特位的数量。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的start或 end参数，可以让计数只在特定的位上进行。start和end参数的设置和getrange命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推。不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。可用版本：&gt;= 2.6.0，时间复杂度：O(N)示例1234567891011127.0.0.1:6379&gt; bitcount bits(integer) 0127.0.0.1:6379&gt; setbit bits 0 1(integer) 0127.0.0.1:6379&gt; bitcount bits(integer) 1127.0.0.1:6379&gt; setbit bits 3 1(integer) 0127.0.0.1:6379&gt; bitcount bits(integer) 2127.0.0.1:6379&gt;使用 bitmap 实现用户上线次数统计Bitmap 对于一些特定类型的计算非常有效。假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 SETBIT 和 BITCOUNT 来实现。比如说，每当用户在某一天上线的时候，我们就使用 SETBIT ，以用户名作为 key ，将那天所代表的网站的上线日作为 offset 参数，并将这个 offset 上的为设置为 1 。举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 SETBIT peter 100 1 ；如果明天 peter 也继续阅览网站，那么执行命令 SETBIT peter 101 1 ，以此类推。当要计算 peter 总共以来的上线次数时，就使用 BITCOUNT 命令：执行 BITCOUNT peter ，得出的结果就是 peter 上线的总天数。更详细的实现可以参考博文(墙外) Fast, easy, realtime metrics using Redis bitmaps 。性能前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， BITCOUNT 的处理速度就像 GET 和 INCR 这种 O(1) 复杂度的操作一样快。如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。使用 BITCOUNT 的 start 和 end 参数，每次只对所需的部分位进行计算，将位的累积工作(accumulating)放到客户端进行，并且对结果进行缓存 (caching)。更详细的实现可以参考博文 REDIS BITMAPS – FAST, EASY, REALTIME METRICSbitopbitop operation destkey key [key ...]对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：bitop add destkey key [key ...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。bitop or destkey key [key ...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。bitop xor destkey key [key ...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。bitop not destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。处理不同长度的字符串当bitop处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。可用版本：&gt;= 2.6.0，时间复杂度：O(N)，返回值：保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。bitop 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。示例1234567891011121314151617127.0.0.1:6379&gt; setbit bits-1 0 1 # 1001(integer) 1127.0.0.1:6379&gt; setbit bits-1 3 1(integer) 0127.0.0.1:6379&gt; setbit bits-2 0 1 # 1011(integer) 0127.0.0.1:6379&gt; setbit bits-2 1 1(integer) 0127.0.0.1:6379&gt; setbit bits-2 3 1(integer) 1127.0.0.1:6379&gt; bitop and and-result bits-1 bits-2 # 1001(integer) 1127.0.0.1:6379&gt; getbit and-result 2(integer) 0127.0.0.1:6379&gt; getbit and-result 3(integer) 1127.0.0.1:6379&gt;setrangesetrange key offset value用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。可用版本：&gt;= 2.2.0。返回被setrange修改之后，字符串的长度。setrange命令会确保字符串足够长以便将 value 设置在指定的偏移量上，不存在的 key 当作空白字符串处理。如果给定 key 原来储存的字符串长度比偏移量小，那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )来填充。注意你能使用的最大偏移量是 2^29-1(536870911) ，因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内。如果你需要使用比这更大的空间，你可以使用多个 key 。时间复杂度：对小(small)的字符串，平摊复杂度O(1)(关于什么字符串是”小”的，请参考 append命令)。否则为O(M)， M 为 value 参数的长度。实例123456789101112131415$ # 对非空字符串进行 setrange127.0.0.1:6379&gt; set hello &quot;hello world&quot;OK127.0.0.1:6379&gt; setrange hello 6 &quot;Redis&quot;(integer) 11127.0.0.1:6379&gt; get hello&quot;hello Redis&quot;$ # 对空字符串/不存在的 key 进行 setrange127.0.0.1:6379&gt; exists empty_string(integer) 0127.0.0.1:6379&gt; setrange empty_string 5 &quot;Redis!&quot;(integer) 11127.0.0.1:6379&gt; get empty_string &quot;\x00\x00\x00\x00\x00Redis!&quot;模式因为有了setrange和getrange命令，你可以将 Redis 字符串用作具有O(1)随机访问时间的线性数组，这在很多真实用例中都是非常快速且高效的储存方式，具体请参考append命令的『模式：时间序列』部分。appendappend key valueappend key value之后，返回 key 中字符串的长度。如果 key 已经存在并且是一个字符串，append命令将 value 追加到 key 原来的值的末尾。如果 key 不存在，append就简单地将给定 key 设为 value ，就像执行 set key value 一样。可用版本：&gt;= 2.0.0。时间复杂度：平摊O(1)。实例1234567127.0.0.1:6379&gt; exists money(integer) 0127.0.0.1:6379&gt; append money &quot;five cent&quot;(integer) 9127.0.0.1:6379&gt; append money &quot;one dollor&quot;(integer) 19127.0.0.1:6379&gt;时间序列(Time series)append可以为一系列定长(fixed-size)数据(sample)提供一种紧凑的表示方式，通常称之为时间序列。每当一个新数据到达的时候，执行命令：append timeseries &quot;fixed-size sample&quot;然后可以通过以下的方式访问时间序列的各项属性：strlen 给出时间序列中数据的数量getrange 可以用于随机访问。只要有相关的时间信息的话，我们就可以在 Redis 2.6 中使用 Lua 脚本和 GETRANGE 命令实现二分查找。setrange 可以用于覆盖或修改已存在的的时间序列。这个模式的唯一缺陷是我们只能增长时间序列，而不能对时间序列进行缩短，因为 Redis 目前还没有对字符串进行修剪(tirm)的命令，但是，不管怎么说，这个模式的储存方式还是可以节省下大量的空间。可以考虑使用 UNIX 时间戳作为时间序列的键名，这样一来，可以避免单个 key 因为保存过大的时间序列而占用大量内存，另一方面，也可以节省下大量命名空间。setset key value [EX seconds] [PX milliseconds] [NX|XX]将字符串值 value 关联到 key 。如果 key 已经持有其他值， SET 就覆写旧值，无视类型。对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。可选参数从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：EX second ：设置键的过期时间为 second 秒。 set key value EX second 效果等同于 setex key second value 。PX millisecond ：设置键的过期时间为 millisecond 毫秒。 set key value PX millisecond 效果等同于 psetex key millisecond value 。NX ：只在键不存在时，才对键进行设置操作。 set key value NX 效果等同于 setnx key value 。XX ：只在键已经存在时，才对键进行设置操作。返回值在 Redis 2.6.12 版本以前， SET 命令总是返回 OK 。从 Redis 2.6.12 版本开始， SET 在设置操作成功完成时，才返回 OK 。如果设置了 NX 或者 XX ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。使用模式命令 set resource-name anystring NX EX max-lock-time 是一种在 Redis 中实现锁的简单方法。客户端执行以上的命令：如果服务器返回 OK ，那么这个客户端获得锁。如果服务器返回 NIL ，那么客户端获取锁失败，可以在稍后再重试。设置的过期时间到达之后，锁将自动释放。可以通过以下修改，让这个锁实现更健壮：不使用固定的字符串作为键的值，而是设置一个不可猜测（non-guessable）的长随机字符串，作为口令串（token）。不使用 DEL 命令来释放锁，而是发送一个 Lua 脚本，这个脚本只在客户端传入的值和键的口令串相匹配时，才对键进行删除。这两个改动可以防止持有过期锁的客户端误删现有锁的情况出现。123456if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1]then return redis.call(&quot;del&quot;, KEYS[1])else return 0end]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis配置与数据类型]]></title>
    <url>%2Fposts%2F2c68463d%2F</url>
    <content type="text"><![CDATA[Redis配置Redis的配置文件位于Redis安装目录下，文件名为 redis.conf(Windows 名为redis.windows.conf)。你可以通过config命令查看或设置配置项。⚠️不推荐对原始的redis.conf文件进行修改，推荐重新建一个配置文件进行修改，然后运行自己创建的配置文件查看配置语法1127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME示例1234567891011121314151617181920212223242526272829303132127.0.0.1:6379&gt; config get dbfilename #获取某个配置项1) "dbfilename"2) "dump.rdb"127.0.0.1:6379&gt; config get * # 获取所有配置项 1) "dbfilename" 2) "dump.rdb" 3) "requirepass" 4) "" 5) "masterauth" 6) "" 7) "cluster-announce-ip" 8) "" 9) "unixsocket" 10) "" 11) "logfile" 12) "" 13) "pidfile" 14) "" 15) "slave-announce-ip" 16) "" 17) "replica-announce-ip" 18) "" 19) "maxmemory" 20) "0"……208) "0"209) "slaveof"210) ""211) "notify-keyspace-events"212) ""213) "bind"214) ""修改配置你可以通过修改redis.conf文件或使用config set命令来修改配置。语法1127.0.0.1:6379&gt; config set CONFIG_SETTING_NAME NEW_CONFIG_VALUE示例12345127.0.0.1:6379&gt; config set loglevel "notice"OK127.0.0.1:6379&gt; config get loglevel1) "loglevel"2) "notice"参数说明redis.conf 配置项说明如下：类型配置项说明基本daemonize no是否以守护进程的方式运行，默认为 no，使用yes启用守护进程基本databases 16设置数据库的数量，默认数据库为0，可以使用SELECT命令在连接上指定数据库id基本stop-writes-on-bgsave-error yes后台存储错误停止写，默认为 yes基本save &lt;seconds&gt; &lt;changes&gt;指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合。Redis默认配置文件中提供了三个条件：save 900 1 、 save 300 10、save 60 10000基本rdbcompression yes指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大。基本rdbchecksum yes存储和加载rdb文件时校验，默认为 yes基本dbfilename dump.rdb指定本地数据库文件名，默认值为dump.rdb基本dir ./指定本地数据库存放目录，默认为当前安装目录主从slaveof &lt;masterip&gt; &lt;masterport&gt;设置当本机为slave服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步主从masterauth &lt;master-password&gt;当master服务设置了密码保护时，slav服务连接master的密码主从slave-serve-stale-data yes当主从断开或正在复制中，从服务器是否应答，默认为 yes主从repl-disable-tcp-nodelay no主端是否合并数据,大块发送给slave主从slave-priority 100如果master不能再正常工作，那么会在多个slave中，选择优先值最小的一个slave提升为master，优先值为0表示不能提升为master。主从slave-read-only yes从服务器只读，默认为 yes主从repl-ping-slave-period 10从ping主的时间间隔，秒为单位主从repl-timeout 60主从超时时间(超时认为断线了)，要比period大安全requirepass foobared设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH命令提供密码，默认关闭安全rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52如果公共环境，可以重命名部分敏感命令，如config限制maxclients 128设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息限制maxmemory &lt;bytes&gt;指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区限制maxmemory-policy volatile-lru内存到极限后的处理1. volatile-lru -&gt; LRU 算法删除过期key2. allkeys-lru -&gt; LRU算法删除key(不区分过不过期)3. volatile-random -&gt; 随机删除过期key4. allkeys-random -&gt; 随机删除key(不区分过不过期)5. volatile-ttl -&gt; 删除快过期的key6. noeviction -&gt; 不删除,返回错误信息日志模式appendonly no指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no日志模式appendfilename appendonly.aof指定更新日志文件名，默认为appendonly.aof日志模式appendfsync everysec指定更新日志条件，共有3个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折衷，默认值）日志模式no-appendfsync-on-rewrite no为yes，则其他线程的数据放内存里,合并写入(速度快，容易丢失的多)日志模式auto-AOF-rewrite-percentage 100aof文件增长比例，指当前aof文件比上次重写的增长比例大小。aof重写即在aof文件在一定大小之后，重新将整个内存写到aof文件当中，以反映最新的状态(相当于bgsave)。这样就避免了，aof文件过大而实际内存数据小的问题(频繁修改数据问题)。日志模式auto-AOF-rewrite-min-size 64mbaof文件重写最小的文件大小，即最开始aof文件必须要达到这个文件时才触发，后面的每次重写就不会根据这个变量了(根据上一次重写完成之后的大小)，此变量仅初始化启动redis有效。如果是redis恢复时，则lastSize等于初始aof文件大小。日志模式aof-load-truncated yes指redis在恢复时，会忽略最后一条可能存在问题的指令。默认值yes。即在aof写入时，可能存在指令写错的问题(突然断电，写了一半)，这种情况下，yes会log并继续，而no会直接恢复失败。日志loglevel verbose指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose日志logfile stdout日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null连接auth 密码密码登陆(如果有密码)连接ping测试服务器是否可用连接echo &quot;some content&quot;测试服务器是否正常交互连接select 0/1/2…选择数据库连接quit退出连接服务端shutdown [save/nosave]关闭服务器，保存数据，修改AOF(如果设置)服务端flushdb清空当前数据库的所有数据服务端flushall清空所有数据库的所有数据(误用了怎么办?)服务端config get 选项(支持*通配)config set 选项 值config rewriteconfig restart获取配置项修改配置项把值写到配置文件更新info命令的信息服务端timedbsizebgrewriteaofbgsavesavelastsave1. 返回时间戳+微秒2. 返回key的数量3.重写aof4. 在后台异步保存当前数据库的数据到磁盘5. 执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘6.返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示服务端monitor打开控制台,观察命令(调试用)服务端client listclient killclient getnameclient setname &quot;名称&quot;1. 列出所有连接2. 杀死某个连接 CLIENT KILL 127.0.0.1:435013. 获取连接的名称 默认nil4. 设置连接名称,便于调试慢查询slowlog get获取慢查询日志慢查询slowlog len获取慢查询日志条数慢查询slowlog reset清空慢查询慢查询slowlog-log-slower-than 10000记录响应时间大于10000微秒的慢查询。慢查询slowlog-max-len 128最多记录128条Redis数据类型Redis支持五种数据类型：string(字符串)，hash(哈希)，list(列表)，set(集合)及zset(sorted set：有序集合)。Stringstring 是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个 key 对应一个 value。string 类型是二进制安全的。意思是Redis的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是Redis最基本的数据类型，string 类型的值最大能存储 512MB。1234127.0.0.1:6379&gt; set name &quot;redis&quot;OK127.0.0.1:6379&gt; get name&quot;redis&quot;HashRedis hash 是一个键值(key=&gt;value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。每个 hash 可以存储 2^32-1 键值对（40多亿）存储、读取、修改用户属性1234567127.0.0.1:6379&gt; del name # 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value127.0.0.1:6379&gt; hmset name field1 &quot;Hello&quot; field2 &quot;World&quot;&quot;OK&quot;127.0.0.1:6379&gt; hget name field1&quot;Hello&quot;127.0.0.1:6379&gt; hget name field2&quot;World&quot;ListRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。列表最多可存储 2^32-1 元素 (4294967295, 每个列表可存储40多亿)。实例1234567891011127.0.0.1:6379&gt; del name127.0.0.1:6379&gt; lpush name redis(integer) 1127.0.0.1:6379&gt; lpush name mongodb(integer) 2127.0.0.1:6379&gt; lpush name mysql(integer) 3127.0.0.1:6379&gt; lrange name 0 101) &quot;mysql&quot;2) &quot;mongodb&quot;3) &quot;redis&quot;SetRedis的Set是string类型的无序集合，提供了求交集、并集、差集等操作。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为 2^32-1(4294967295, 每个集合可存储40多亿个成员)。sadd 命令:添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。共同好友、利用唯一性，统计访问网站的所有独立ip、好友推荐时，根据tag求交集，大于某个阈值就可以推荐12345678910111213127.0.0.1:6379&gt; del name127.0.0.1:6379&gt; sadd name redis(integer) 1127.0.0.1:6379&gt; sadd name mongodb(integer) 1127.0.0.1:6379&gt; sadd name mongodb(integer) 0127.0.0.1:6379&gt; sadd name mysql(integer) 1127.0.0.1:6379&gt; smembers name1) &quot;redis&quot;2) &quot;rabitmq&quot;3) &quot;mongodb&quot;zsetRedis zset 和 set 一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数(score)却可以重复。zadd 命令：添加元素到集合，元素在集合中存在则更新对应score排行榜、带权重的消息队列格式：zadd key score member12345678910111213127.0.0.1:6379&gt; del name127.0.0.1:6379&gt; zadd name 0 redis(integer) 1127.0.0.1:6379&gt; zadd name 0 mongodb(integer) 1127.0.0.1:6379&gt; zadd name 0 mysql(integer) 1127.0.0.1:6379&gt; zadd name 0 mysql(integer) 0127.0.0.1:6379&gt; &gt; zrangebyscore name 0 10001) &quot;mongodb&quot;2) &quot;mysql&quot;3) &quot;redis&quot;]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis配置与数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis问题记录]]></title>
    <url>%2Fposts%2F9f25d6e0%2F</url>
    <content type="text"><![CDATA[强制把redis快照关闭了导致不能持久化的问题现象1234567127.0.0.1:6379&gt; ping(error) MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.解决办法通过stop-writes-on-bgsave-error值设置为no即可避免这种问题。有两种修改方法，一种是通过redis命令行修改，另一种是直接修改redis.conf配置文件。redis命令行修改示例：1127.0.0.1:6379&gt; config set stop-writes-on-bgsave-error no使用 redis-cli 过程中出现中文乱码使用redis-cli时后面加上--raw就可以避免中文乱码。1$ redis-cli --raw -h host -p port -a passwordNOAUTH Authentication required.12345678910Exception in thread &quot;main&quot; redis.clients.jedis.exceptions.JedisDataException: NOAUTH Authentication required. at redis.clients.jedis.Protocol.processError(Protocol.java:127) at redis.clients.jedis.Protocol.process(Protocol.java:161) at redis.clients.jedis.Protocol.read(Protocol.java:215) at redis.clients.jedis.Connection.readProtocolWithCheckingBroken(Connection.java:340) at redis.clients.jedis.Connection.getStatusCodeReply(Connection.java:239) at redis.clients.jedis.BinaryJedis.ping(BinaryJedis.java:196) at org.sang.RedisTest.main(RedisTest.java:12)Process finished with exit code 1进行密码验证或者把密码置空。在多线程场景下使用redis时，可能会出现各种类型转换异常：如：B cannot be cast to java.util.List原因在多线程场景下，如果使用jedis连接池获取连接，在各个地方调用，且使用完之后没有释放，则可能在某次使用的时候，拿到的是其他线程的连接，则会出现类型转换异常。解决方案在每次使用完连接后，将其返回连接池。具体操作如下：1234567891011121314/** * return resource to pool * @paran isBroken 是否产生异常 */public void returnResource(Jedis shardedJedis, boolean isBroken) &#123; // starting from Jedis 3.0 this method will not be exposed. Resource cleanup should be done using @see &#123;@link redis.clients.jedis.Jedis#close()&#125; // returnBrokenResource | returnResource 在Jedis 3.0之后已经被废弃，释放shardedJedis调用Jedis的close()方法即可。 if (isBroken) &#123; jedisPool.returnBrokenResource(shardedJedis); &#125; else &#123; jedisPool.returnResource(shardedJedis); &#125;&#125;线上Redis禁止使用Keys正则匹配操作背景redis是单线程的，其所有操作都是原子的，不会因并发产生数据异常使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。案例运维人员进行keys *操作，该操作比较耗时，又因为redis是单线程的，所以redis被锁住。此时QPS比较高，又来了几万个对redis的读写请求，因为redis被锁住，所以全部Hang在那。因为太多线程Hang在那，CPU严重飙升，造成redis所在的服务器宕机。所有的线程在redis那取不到数据，一瞬间全去数据库取数据，数据库就宕机了。其他危险命令但凡发现时间复杂度为O(N)的命令，都要慎重，不要在生产上随便使用。例如hgetall、lrange、smembers、zrange、sinter等命令，它们并非不能使用，但这些命令的时间复杂度都为O(N)，使用这些命令需要明确N的值，否则也会出现缓存宕机。flushdb 命令用于清空当前数据库中的所有 keyflushall 命令用于清空整个 Redis 服务器的数据(删除所有数据库的所有 key )config 客户端连接后可配置服务器如何禁用危险命令在redis.conf中，在SECURITY这一项中，我们新增以下命令：1234rename-command FLUSHALL &quot;&quot;rename-command FLUSHDB &quot;&quot;rename-command CONFIG &quot;&quot;rename-command KEYS &quot;&quot;另外，对于flushall命令，需要设置配置文件中appendonly no，否则服务器是无法启动。请注意，更改[记录到AOF文件或传输到副本的命令]的名称可能会导致问题。改良建议使用scan命令来改良keys和smembers命令redis2.8版本以后有了一个新命令scan，可以用来分批次扫描redis记录，这样肯定会导致整个查询消耗的总时间变大，但不会影响redis服务卡顿，影响服务使用。更多信息可参考redis scan命令]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis简单介绍与安装]]></title>
    <url>%2Fposts%2F985fe3fe%2F</url>
    <content type="text"><![CDATA[Redis 简单介绍REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、高性能的key-value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值(value)可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets) 和有序集合(sorted sets)等类型。Redis 特点key-value缓存产品的三个特点：支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。支持简单的key-value类型的数据。支持数据的备份，即master-slave模式的数据备份。Redis的优势：性能极高——Redis能读的速度是110000次/s，写的速度是81000次/s 。丰富的数据类型——Redis支持list、set、zset、hash等数据结构的操作。原子性——Redis的所有操作都是原子性的：单个操作是原子性的，多个操作也支持事务(通过MULTI和EXEC指令包起来)。丰富的特性——Redis还支持publish/subscribe，通知，key 过期等等特性。Redis 安装Window 下安装下载地址：https://github.com/MSOpenTech/redis/releases。Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。如果下载Redis-x64-3.2.100.msi，双击执行安装即可。如果下载Redis-x64-3.2.100.zip，解压到指定目录即可使用。进入安装目录执行以下命令，如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。1&gt; redis-server.exe redis.windows.confLinux 下安装下载地址：http://redis.io/download，下载最新稳定版本。1234$ wget http://download.redis.io/releases/redis-5.0.5.tar.gz$ tar xzf redis-5.0.5.tar.gz$ cd redis-5.0.5$ makemake完后redis-5.0.5目录下会出现编译后的redis服务程序redis-server，还有用于测试的客户端程序redis-cli，两个程序位于安装目录 src 目录下：下面启动redis服务.123$ cd src$ ./redis-server # 使用默认配置$ ./redis-server ../redis.conf # redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务进行交互。Ubuntu 下安装在 Ubuntu 系统安装 Redis 可以使用以下命令:12$sudo apt-get update$sudo apt-get install redis-server启动 Redis1$ redis-serverMac 下安装方法一官网http://redis.io/ 下载最新的稳定版本,这里是5.0.512345$ sudo mv redis-5.0.5.tar.gz /usr/local/ # 移至 /usr/local/$ sudo tar xzf redis-5.0.5.tar.gz # 解压文件$ cd redis-5.0.5 # 进入解压目录$ sudo make test # 测试编译$ sudo make install # 安装方法二使用 homebrew1234$ brew search redis # 查找可用的redis包$ brew install redis #安装redis，可加@版本号安装指定版本，eg: brew install redis@4.0$ # 只能安装可用的redis包，可能不是官网最新版本，比如此次支持最高的是redis@4.0，redis官网是Stable (5.0)$ brew services start redis # 或者直接启动：redis-server /usr/local/etc/redis.conf安装后的简单操作启动Redis server1234567891011121314151617181920212223242526$ cd redis-5.0.5/src$ ./redis-server ../redis.conf60379:C 28 Jul 2019 09:46:36.625 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo60379:C 28 Jul 2019 09:46:36.625 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=60379, just started60379:C 28 Jul 2019 09:46:36.625 # Configuration loaded60379:M 28 Jul 2019 09:46:36.627 * Increased maximum number of open files to 10032 (it was originally set to 256). _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 5.0.5 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 60379 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 60379:M 28 Jul 2019 09:46:36.631 # Server initialized60379:M 28 Jul 2019 09:46:36.631 * Ready to accept connections测试 Redis 是否启动12345$ ./redis-cli # 不知道IP和端口127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; pingPONG# 已经成功安装了redis。Redis 的简单 set 和 get123456$ ./redis-cli -h 127.0.0.1 -p 6379 #指定ip和端口127.0.0.1:6379&gt; set hello worldOK127.0.0.1:6379&gt; get hello"world"127.0.0.1:6379&gt;退出 Redis 客户端1127.0.0.1:6379&gt; exit退出 Redis 服务1$ ./redis-cli shutdown检测 Redis 服务123456#检测后台进程是否存在$ ps -ef |grep redis#检测6379端口是否在监听$ netstat -tln | grep 6379#因为Redis可以妥善处理SIGTERM信号，所以直接 kill -9 进程id 也是可以关闭redis的kill -9 PID卸载 Redis先关闭 Redis 服务，检测以确定关闭。删除 make 的时候产生的几个 redis 文件1234567$ rm -rf /usr/local/bin/redis*# redis-benchmark# redis-check-aof# redis-check-rdb# redis-cli# redis-sentinel# redis-server删除解压后的文件目录和所有文件123$ cd /usr/local/$ rm -rf redis-5.0.5$ rm -rf redis-5.0.5.tar.gz]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源软件协议对比]]></title>
    <url>%2Fposts%2F6821cef2%2F</url>
    <content type="text"><![CDATA[开源不等于免费，开源也不等于没有约束。License就是版权许可证，里面详尽表述了你获得代码后拥有的权利，可以对别人的作品进行何种操作，何种操作又是被禁止的。世界上的开源许可证(Open Source License)大概有上百种，我们常用的开源软件协议大致有GPL、BSD、MIT、Mozilla、Apache和LGPL。协议介绍Apache LicenseApache License（Apache许可证），是Apache软件基金会发布的一个自由软件许可证。Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件：需要给代码的用户一份Apache Licence。如果修改了代码，需要再被修改的文件中说明。在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。Apache Licence也是对商业应用又好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。使用这个协议的好处是:永久权利：一旦被授权，永久拥有。全球范围的权利：在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。授权免费：无版税， 前期、后期均无任何费用。授权无排他性：任何人都可以获得授权。授权不可撤消：一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码。BSDBSD是”Berkeley Software Distribution”的缩写，意思是”伯克利软件发行版”。BSD开源协议：是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。GPLGPL （GNU General Public License） ：GNU通用公共许可协议。Linux 采用了 GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。LGPLLGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。MITMIT是和BSD一样宽范的许可协议,源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。MPL (Mozilla Public License 1.1)MPL协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。EPL (Eclipse Public License 1.0)EPL允许Recipients任意使用、复制、分发、传播、展示、修改以及改后闭源的二次商业发布。使用EPL协议，需要遵守以下规则：当一个Contributors将源码的整体或部分再次开源发布的时候,必须继续遵循EPL开源协议来发布,而不能改用其他协议发布.除非你得到了原”源码”Owner 的授权；EPL协议下,你可以将源码不做任何修改来商业发布.但如果你要发布修改后的源码,或者当你再发布的是Object Code的时候,你必须声明它的Source Code是可以获取的,而且要告知获取方法；当你需要将EPL下的源码作为一部分跟其他私有的源码混和着成为一个Project发布的时候,你可以将整个Project/Product以私人的协议发布,但要声明哪一部分代码是EPL下的,而且声明那部分代码继续遵循EPL；独立的模块(Separate Module),不需要开源。Creative Commons 知识共享协议Creative Commons (CC) 许可协议并不能说是真正的开源协议，它们大多是被使用于设计类的工程上。 CC 协议种类繁多，每一种都授权特定的权利。 一个 CC 许可协议具有四个基本部分，这几个部分可以单独起作用，也可以组合起来。下面是这几部分的简介：署名：作品上必须附有作品的归属。如此之后，作品可以被修改，分发，复制和其它用途。相同方式共享：作品可以被修改、分发或其它操作，但所有的衍生品都要置于CC许可协议下。非商业用途：作品可以被修改、分发等等，但不能用于商业目的。但语言上对什么是”商业”的说明十分含糊不清 (没有提供精确的定义)，所以你可以在你的工程里对其进行说明。例如，有些人简单的解释”非商业”为不能出售这个作品。而另外一些人认为你甚至不能在有广告的网站上使用它们。 还有些人认为”商业”仅仅指你用它获取利益。禁止衍生作品CC 许可协议的这些条款可以自由组合使用。大多数的比较严格的CC协议会声明 “署名权，非商业用途，禁止衍生”条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且必须声明作品的归属。这个许可协议非常的有用，它可以让你的作品传播出去，但又可以对作品的使用保留部分或完全的控制。最少限制的CC协议类型当属 “署名”协议，这意味着只要人们能维护你的名誉，他们对你的作品怎么使用都行。CC 许可协议更多的是在设计类工程中使用，而不是开发类，但没有人或妨碍你将之使用与后者。只是你必须要清楚各部分条款能覆盖到的和不能覆盖到的权利。如何选择简洁版稍微复杂版链接各种开源协议介绍]]></content>
      <categories>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>开源协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-乐评]]></title>
    <url>%2Fposts%2F70b9f430%2F</url>
    <content type="text"><![CDATA[001后来再想，你哪点值得我义无反顾？——《那女孩对我说》你回头看一眼我好不好，我就要放弃你了。——《不找了》写歌的人假正经，听歌的人最无情，人要是矫情起来，听什么都像在说自己。——《不找了》每天都在找饭卡：“我觉得这首歌对我的ID有莫大的恶意。”——《不找了》多年以后一场大雨惊醒沉睡的我。——《星星点灯》嗯，我不会慌张，爱在我心上❤️——《给未来》希望我们冰释前嫌，再也不相见。——《消愁》没有正儿八经谈过恋爱，特别喜欢听情歌😌——《情歌》孤岛——仙人掌——铁树002我仍然认为向人诉苦不过是徒劳，与其如此，不如默默承受。——《标签》我一直都不敢承认自己是个抑郁患者。——《标签》人们真的会因为嘴硬失去很多东西，就像我一样，失去了那个爱我的她——《标签》你爱的人原本也是凡人，是你的注视让他镀上金身。做一个俗人，贪君子之财，好美景之色，一身正气，行正义之事，了前生之怨，爱此生之爱人。——《Skin》有人说：二十年的太子，一天的皇上，十个月的奴才，一辈子的提款机，这就是男人的一生；可有人又说：二十年的公主，一天的皇后，十个月的宠妃，一辈子的保姆，这就是女人的一生。我觉得，应该是：二十年的追寻，一天的仪式，十个月的呵护，换来一辈子的相濡以沫。——《What Makes You Beautiful》沈腾的角色很丧，还要被随时准备打脸，偷车架，卖唱，卖炒饭，做一切不可谓卑微的事情。可是都没忘了，那一千多个弯道。我们会被逗笑，这人真背，可是想想自己，是否用尽过全力去追求热爱的事？全力到，尊严和生命都可以牺牲，就是想，在别人眼里当傻子一样的想。我们有那么多故事，是否欠一个结局？——《奉献》小学时，想和喜欢的人同桌；初中时，想和喜欢的人同班；高中时，想和喜欢的人同校；工作时，想和喜欢的人同城；年老时，想和喜欢的人同一个世界。起初我们揣着糊涂装明白，后来我们揣着明白装糊涂。并不是我们愿意活得不明不白，只是好多事情一用力就会拆穿，拆穿就会失去。长大以后的世界总是这么脆弱！——《那女孩对我说》003人的一生，要死去三次。第一次，当你的心跳停止，呼吸消逝，你在生物学上被宣告了死亡；第二次，当你下葬，人们穿着黑衣出席你的葬礼，他们宣告，你在这个社会上不复存在，你悄然离去；而第三次死亡，是这个世界上最后一个记得你的人，把你忘记，于是，你就真正地死去。整个宇宙都将不再和你有关。——《the sound of silence》人之所以遭受各种各样的伤害大多源于：眼睛看到不该看的东西；嘴巴说出伤人的话语；耳朵听到他人的秘密。——《耳朵》你说一个人自杀，是想通了还是想不通了。——《遗书》看看老电影，听听老调子，对新的人与事物慵懒懈怠。如果那一日的天比较倦，余晖也打着哈欠，我就和一些旧人，谈笑风生。然后等我变老，红酒也够老，就趁着微醺伴着爵士乐沉沉睡去，直到落日的余晖完全融在突如其来的雨里。——《未妨惆怅是清狂》毛不易创作手记：“这个世界上，还有很多不被认可的梦想，不被祝福的感情，不被眷顾的孩子，他们不曾犯错，却只能颤颤巍巍，单薄地行走在路上。这首歌送给他们，借天地万物，不求终将到达某处，只求路上少些阻碍，让他们同样平凡。”——《借》我所有自负都来自我的自卑，所有的英雄气概都来自于我内心的软弱，所有的振振有词都因为心中满是怀疑。我假装无情，其实是痛恨自己的深情。我以为人生的意义在于四处游荡流亡，其实只是掩饰至今没有找到愿意驻足的地方。——《词不达意》我觉得我就像集市上的鱼，水分蒸发得差不多了。我时常觉得自己就要撑不下去，而你总是适时又吝啬地洒点水给我，我便要再提着一口气蹦哒两下，作出生龙活虎的样子给你看。我在前途未卜的痛苦里周而复始，你是不要我死的，又偏不肯温柔豢养我。——《鱼》但凡死缠烂打的人，大都不是真的深爱你，那只是在跟自己赛跑。真正爱你的人，做不到死缠烂打。因为自尊不允许。我们一直深信，爱就是把最好的一切给予对方，包括尊严。多少浅浅淡淡的转身，是旁人看不懂的情深。即使遗憾，那也就遗憾吧。——《献世》任何感情问题都不要冷处理，无论是和家人还是恋人。你有疑惑的时候就要去询问，你有错误的时候就要去承认，你想他就要告诉他。很多事情忍着忍着就变得模糊了，明明不是误会也变成了误会。别以为那些问题会在忍耐的时间中被化解，它只会在日积月累中爆发，给你一个承受不了的结果。——《玩笑》004我觉得这样的距离很好，就隔着一片海互不打扰，谁能够决定谁 怎样最好，我疏离得很舒服 不想治疗，这种距离对大家都好，就隔着一片海互相远眺，懂的人懂得就好，我是座小小岛 心满意足的小岛，我爱的人爱我就好。 ——《离岛》慢慢大家会明白的，无法跟喜欢的人在一起，其实是人生的常态。忘记一个人可以有两种方式一种是时间，另一种是新欢，而你却选择了时间。——《爱了很久的朋友》某天，你无端想起了一个人，他曾让你对明天有所期许，但是却完全没有出现在你的明天里。——《再见金华站》爱与被爱是世界上最重要的事。——《再见金华站》有时候会喜欢听奇奇怪怪的歌 吃奇奇怪怪的东西 做奇奇怪怪的事 爱奇奇怪怪的人——《桂花巷》没有神的光环，你我生而平凡。——《只要平凡》]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>乐评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记]]></title>
    <url>%2Fposts%2F8eda3648%2F</url>
    <content type="text"><![CDATA[理论篇Redis简单介绍与安装Redis问题记录Redis配置与数据类型Redis命令1Redis命令2Redis命令3Redis命令4Redis命令5Redis进阶教程实战篇]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-开解自己]]></title>
    <url>%2Fposts%2F4be8e193%2F</url>
    <content type="text"><![CDATA[001尝试着，放下已有的知识，让自己像孩子一样，慢慢的重新认识这个世界。即便暂时没有什么突破也不要紧，保持那个节奏，允许自己暂时没有突破。为什么不要作弊，不是因为“作弊会对别的学生不公平”，也不是因为“作弊会败坏学校的风气”，而是作弊最终会把你困在一个自己不擅长也不喜欢的职业，困住你真正的人生追求…——加州大学伯克利分校的教授 BrianHarvey好人的皮囊穿久了，都快忘记了怎么做坏人。不强求是美德，更是好方法。清汤一定要清。看起来清澈见底，入口却滋味丰富，这才是一碗好清汤。科学是在黑暗中探索，人性就是黑暗中的蜡烛，照亮我们走过的道路以及前方的危险。失去人性，我们将迎来一个可怕的世界。——迪姆·库克赌性更坚强：光拼是不够的，那是体力活；赌才是脑力活。——曾毓群但愿日子清静，抬头遇见的都是柔情。上天很有意思，猫喜欢吃鱼，猫却不能下水，鱼喜欢吃蚯蚓，鱼却不能上岸。人生，就是一边拥有，一边失去，一边选择，一边放弃。人生，哪有事事如意，生活，哪有样样顺心。所以，不和别人较真，因为不值得，不和自己较真，因为伤不起，不和往事较真，因为回不去。002地球这么大，世界这么宽阔，如果找不到相似的灵魂也不要太难过，遇到了也不一定能合拍，合拍也不一定能长久，人生也不过如此。人生天地间，忽如远行客。笑看人间沉浮事，闲坐摇扇一壶茶。春有百花秋有月，夏有凉风冬有雪。三生有幸遇见你，纵然悲凉也是情。我与春分皆过客，你携秋水揽星河。我爱你，不光是因为你的样子；还因为和你在一起时，我的样子。欲买桂花同载酒，终不似，少年游。岂能尽如人意，但求无愧我心。003吾貌虽丑，其心温柔。忙着工作懒得吃饭的时候会想，人为什么要会饿呢？享受美食的时候会想，人为什么要会饱呢？还有，人为什么要会胖呢？没有人愿意成为一个孤岛，也没有人愿意成为被人群淹没的一员。要处理好自己害怕被抛弃的感觉。你们搞心理学的，想法的确跟别人不一样。相信快，是相信奇迹；相信慢，是相信明天。快，意味着更多的荷尔蒙；慢，意味着耐得住寂寞，以及持续的投入。「因为看见，所以相信。」 VS 「因为相信，所以看见。」你看见的未来，你相信的那个未来，你主观上的那个未来，和实际上要发生的未来未必是一样的。错了就是错了，挨打要立正。大(多)和小(少)是最基础的不对称。——饭否004重大决策常常是既显然又困难。——饭否爱情和友情一样，都存在很好的人但不合适，于是就没法产生交集，也没法产生共鸣，即使产生了，最终也会消失，因为不对的人，成不了对的事。不要因为寂寞而去谈感情，这样就会因为错的感情更加寂寞。下了决心要做的事要保持不动声色却满心澎湃。读书多了，容颜自然的改变，他们在气质上，在谈吐上，在胸襟上的无涯。——三毛真正骂人的最高境界是面带微笑，云淡风轻。表面看起来很犀利，却掩盖不住内心的色厉内荏，实际上是无能狂怒。生活一地鸡毛，理想得竖起来。贪财惜命，有所为，有所不为。到底有没人在下一盘很大的棋？这是个世界观问题。——饭否005人获得财富、才能、地位，第一步都是储蓄。你的所得比你的花费多，积攒可使用的能量，雪球由小滚大。人生最大的痛苦莫过于，坚持了不该坚持的，放弃了不该放弃的。毕竟几人真得鹿，不知终日梦为鱼。——黄庭坚《杂诗七首》姚明的思维模式，是用自己的冷静把对方的“火”扑灭；而孙杨的思维模式，则是用更大的“火”去冲击对方的“火”，至于这把“火”会波及到谁，孙杨可能并没想过。相比于「技工贸」，柳传志老先生当年主张的「贸工技」路线并没有错。事实上，华为正是沿着这条路线发展起来的，从早期代理程控交换机到自己造程控交换机再逐步深入各方面的研发乃至于自己做芯片和操作系统。也就是说，关键是从贸到工之后没有停，真的搞了技。当没什么事可做的时候，你在做什么？世界上之所以需要鞋匠，是因为有人需要鞋，而不是因为鞋匠需要钱。无限接近死亡，更能领悟生存的真谛。“平等”等于没有执行力，项目上需要有人说了算，并且承担责任。006等我把脸皮磨厚，再给你想要的温柔！仪式感相当于提醒功能，告诉你时间的流逝。时间是人最宝贵的资源，但一天天地过日子，最容易忘掉的又是时间。任何东西，都有时限。七夕的时限是一天，生日的时限也是一天。孩子只能在童年举高高，他变少年，就不接受你这游戏，再说，你也举不动。只要是人做决定，就得把时间这个维度放进去，看看事物的时限，这样才能分出表象与本质。]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>开解自己</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM是如何执行方法调用的?]]></title>
    <url>%2Fposts%2Ff090e573%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>方法调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机是如何加载Java类的？]]></title>
    <url>%2Fposts%2F2ce44cf1%2F</url>
    <content type="text"><![CDATA[从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。Java 语言的类型分为两大类——基本类型(primitive types)和引用类型(reference types)，其中引用类型分为4种：类、接口、数组类和泛型参数。由于泛型参数会在编译过程中被擦除，因此 Java 虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。字节流最常见的形式要属由 Java 编译器生成的 class 文件。除此之外，我们也可以在程序内部直接生成，或者从网格中获取(例如网页中内嵌的小程序 Java applet)字节流。这些不同形式的字节流，都会被加载到 Java虚拟机中，成为类或接口。为了叙述方便，接下来统一使用“类”来称呼。无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。加载加载，是指查找字节流，并且据此创建类的过程。对于非 Java 虚拟机直接生成的类来说，Java 虚拟机需要借助类加载器来完成查找字节流的过程。类加载器的“祖师爷”叫启动类加载器(bootstrap class loader)，它是由 c++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。除了启动类加载器之外，其他的类加载器都是java.lang.ClassLoader的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父 类加载器。在父 类加载器没有找到所请求的情况下，该类加载器才会尝试去加载。在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包的类以及由虚拟机参数-Xbootclasspath指定的类。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器(extension class loader)和应用类加载器(application class loader)，均由 Java 核心类库提供。扩展类加载器的父 类加载器是启动类加载器。它负责加载相对次要的、但又通用的类，比如存放在 JRE 的 lib/ext目录下 jar 包中的类(以及由系统变量 java.ext.dirs指定的类)。应用类加载器的父 类加载器是扩展类加载器。它负责加载应用程序路径下的类。即虚拟机参数 -cp/-classpath、系统变量java.class.path或环境变量 CLASSPATH所指定的路径。默认情况下，应用程序所包含的类便是应用类加载器加载的。Java 9 引入了模块系统，并且略微更改了上述的类加载。扩展类加载器改名为平台类加载器(platform class loader)。Java SE 中除了少数几个关键模块之外，其他模块均由平台类加载器所加载。除了由 Java 核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊的加载方式。例如：我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其进行解密。除了加载功能外，类加载器还提供了命名空间的作用。在 Java 虚拟机中，类的唯一性是由类加载器实现以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们会借助这一特性，来运行同一个类的不同版本。链接链接，是指将创建的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。准备阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则在稍后的初始化阶段进行。除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。在 class 文件被加载到 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址。甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能无歧义地定位到具体目标上。解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或未被加载类的字段或方法，那么解析将触发这个类的加载(未必触发这个类的链接以及初始化)。Java虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。初始化在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。如果直接赋值的静态字段被final所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值(ConstantValue)，其初始化直接由 Java 虚拟机完成。除此之外，直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为&lt;clinit&gt;，即 class init。类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行&lt;clinit&gt;方法的过程。 Java 虚拟机会通过加锁来确保类的&lt;clinit&gt;方法仅被执行一次。只有初始化完成之后，类才正式成为可执行的状态。类的初始化触发情况：当虚拟机启动时，初始化用户指定的主类；当遇到用以创建模板类实例的 new 指令时，初始化 new 指令的目标类；当遇到调用静态方法的指令时，初始化该静态方法所在的类；当遇到访问静态字段的指令时，初始化该静态字段所在的类；子类的初始化会触发父类的初始化；如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；使用反射 API 对某个类进行反射调用时，初始化这个类；当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。其他Java中所有的非私有实例方法，都算是虚方法。调用这些方法的指令，也区分直接调用和虚调用。被final修饰的静态成员变量，如果不是基本类型或字符串，也会放在clinit来做。链接时取得的不是被加载类的地址，而是被加载类所调用的其他方法的地址。在加载阶段就已经生成了 class 结构，已经写入方法区，只是被标记为未链接而暂时不能使用，如果验证失败会报错退出。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java类加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的基本类型]]></title>
    <url>%2Fposts%2F12a97f14%2F</url>
    <content type="text"><![CDATA[在 Smalltalk 中，所有的值都是对象。因此，许多人认为它是一门纯粹的面向对象语言。Java 则不同，它引进了八个基本类型，用来支撑数值计算。Java 这么做主要是出于工程上的考虑，使用基本类型能够在执行效率以及内存使用两方面提升软件性能。Java 虚拟机的 boolean 类型在 Java 语言规范中，boolean类型的值只有两种可能，分别使用符合true和false来表示。在 Java 虚拟机规范中， boolean类型则被映射成int类型，具体来说，true被映射为整数1，false被映射为整数0。这个编码规则约束了 Java 字节码的具体实现。Java 虚拟机规范同时也要求 Java 编译器遵守这个编码规则，并且使用整数相关的字节码来实现逻辑运算。当然，这个约束很容易绕开，除了汇编工具 AsmTools外，还有许多可以修改字节码的 Java 库，比如ASMJava 的基本类型类型值域默认值虚拟机内部符号boolean{false, true}falseZbyte[-128, 127]0Bshort[-32768, 32767]0Schar[0, 65535]‘\u000’Cint[-2^31, 2^31-1]0Ilong[-2^63, 2^63-1]0LJfloat~[-3.4E38, 3.4E38]+0.0FFdouble~[-1.8E308, 1.8E308]+0.0DDbyte、short、int、long、float以及double的值域依次扩大，而且前面的值被后面的值域所包含。因此从前面的基本类型转换至后面的基本类型，无需强制转换。它们的默认值看起来都不一样，但在内存中都是0。这些基本类型中，boolean和char是唯二的无符号类型。声明为byte、char以及short的局部变量，能够存储它们取值范围的数值，但在正常使用 Java 编译器的情况下，生成的字节码会遵守 Java 虚拟机规范对编译器的约束。Java 浮点数Java 的浮点数采用 IEEE 754 浮点数格式。以 float 为例，浮点数类型通常有两个0，+0.0F以及-0.0F。前者在 Java 里是0，后者是符号位为1、其它位均为0的浮点数，在内存中等同于十六进制整数0x8000000。尽管它们的内存数值不同，但是在 Java 中+0.0F==-0.0F 会返回真。浮点数中的正无穷：任意正浮点数除以 +0.0F 得到的值，在内存中等同于0x7F800000;浮点数中的负无穷：任意正浮点数除以 -0.0F 得到的值，在内存中等同于0xFF800000。标准 NaN(Not-a-Number)：通过+0.0F/+0.0F 计算得到，在内存中为0x7FC00000；非标准 NaN(Not-a-Number)：0x7F800001、0x7FFFFFF、0xFF800001、0xFFFFFFFF等NaN 和其它浮点数相比较，除了!=始终返回true外，所有其它比较结果均会返回false。1234567public static void main(String[] args) &#123; System.out.println(Float.floatToIntBits(0.0F)); //0 System.out.println(Float.floatToIntBits(-0.0F)); //-2147483648 System.out.println(Float.floatToIntBits(0.0F/0.0F)); //2143289344 System.out.println(0x7FC00000); //2143289344 System.out.println(Float.intBitsToFloat(0x7F800001)); //NaN&#125;Java 基本类型的大小Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。为了方便解释，这里只讨论供解释器使用的解释栈帧(Interpreted frame)。该栈帧有两个主要组成部分，分别是局部变量区以及字节码的操作数栈。这里的局部变量是广义的，除了普通意义下的局部变量外，它还包含实例方法的”this指针”以及方法所接收的参数。在 Java 虚拟机规范中，局部变量等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储外，其他基本类型以及引用类型的值均占用一个数组单元。即 boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 一样，和引用类型也一样。因此，在32位的HotSpot 中，这些类型将占用4个字节，而在64位的 HotSpot 中，他们将占用8个字节。(int 所包含的数据是4字节，由于 JVM 栈的实现方式，它们实际使用的内存可能占用得更多)当然这种情况仅仅存在于局部变量，并不会出现在存储于堆上的字段或者数组元素。对于 byte、char以及 short 这三种类型的字段或数组单元，它们在堆上占用的空间分别为1字节、2字节以及2字节。(变长数组不好控制，所以选择浪费一些空间，以便访问时直接通过下标来计算地址)当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把0xFFFFFFFF(-1)存储到一个声明为 char 类型的字段里时，由于该字段仅占用1字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”。boolean 和 boolean 数组比较特殊，在 HotSpot 中，boolean 字段占用一字节，而boolean 数组直接使用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式进行掩码操作，即只取最后一位的值存入 boolean 字段或数组中。加载Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成int类型来运算。对于 boolean、char这两类无符号类型来说，加载伴随着零扩展，例如：在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节会用0来填充。对于byte、short这两个类型来说，加载伴随着符号扩展，例如：在加载时，short 值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为0，那么该 int 类型的值的高二字节会用0来填充，否则用1来填充。其他ASM 是字节码工程包，它提供了字节码抽象的工具，允许用 Java 代码来生成或更改字节码。JDK里也会使用 ASM 来生成一些适配器什么的。Unsafe 就是一些不被虚拟机控制的内存操作的合集，需要根据 API 来了解。CAS 可以理解为原子性的写操作，概念来自于底层 CPU 指令。Unsafe 提供了一些 cas 的 Java 接口，在即时编译器中我们会将对这些接口的调用替换成具体的 CPU 指令测试 NaN1234567891011121314public static void main(String[] args) &#123; float nan1 = 0.0f/0.0f; float f = 0.0f; float nan2 = f/f; double d = 0.0; System.out.println(&quot;nan1 raw: &quot; + Integer.toHexString(Float.floatToRawIntBits(nan1))); System.out.println(&quot;nan1: &quot; + Integer.toHexString(Float.floatToIntBits(nan1))); System.out.println(&quot;nan2 raw: &quot; + Integer.toHexString(Float.floatToRawIntBits(nan2))); System.out.println(&quot;nan2: &quot; + Integer.toHexString(Float.floatToIntBits(nan2))); System.out.println(&quot;nan3 raw: &quot; + Long.toHexString(Double.doubleToRawLongBits(0.0/0.0))); System.out.println(&quot;nan3: &quot; + Long.toHexString(Double.doubleToLongBits(0.0/0.0))); System.out.println(&quot;nan4 raw: &quot; + Long.toHexString(Double.doubleToRawLongBits(d/d))); System.out.println(&quot;nan4: &quot; + Long.toHexString(Double.doubleToLongBits(d/d)));&#125;测试结果12345678910nan1 raw: 7fc00000nan1: 7fc00000nan2 raw: ffc00000nan2: 7fc00000nan3 raw: 7ff8000000000000nan3: 7ff8000000000000nan4 raw: fff8000000000000nan4: 7ff8000000000000Process finished with exit code 0如果不使用 raw 方法进行 NaN 的转换，采用 0.0f/0.0f 或 先定义变量f = 0.0f再进行f/f的计算，最终结果是一样的，但是如果使用 raw 方法进行转换，结果会有所不同，如:nan1 raw: 7fc00000和nan2 raw: ffc00000，原因是前者是 Java编译器给出的，后者是 CPU 用 DIVSS 指令计算出来的，跟具体的 CPU 实现有关系。由于都是 NaN，理论上哪个值都是正确的。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java基本类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java代码是怎么运行的？]]></title>
    <url>%2Fposts%2F6e9f02ed%2F</url>
    <content type="text"><![CDATA[写在前面Java代码有很多种不同的运行方式，比如在开发工具中运行、双击jar文件运行、在命令行中运行、在网页中运行等，不过这些执行方式都离不开JRE，即Java运行时环境(Java Runtime Environment)。实际上，JRE仅包含Java程序的必需组件，包括Java虚拟机以及Java核心类库等。我们通常接触的JDK(Java开发工具包)同样包含了JRE，并且还附带了一系列开发、诊断工具。为什么 Java 要在虚拟机里运行？Java作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此直接在硬件上运行这种复杂的程序不太现实。所以，在运行 Java 程序之前需要对其进行一番转换。（C++ 的策略是直接编译成目标架构的机器码，Java的策略是编译成一个虚拟架构的机器码。）这个转换操作是怎么操作的呢？当前主流思路是这样：设计一个面向Java语言特性的虚拟机，并通过编译器将 Java 程序转换成该虚拟机能识别的指令序列，即 Java 字节码(Java字节码指令的操作码被固定为一个字节)。Java虚拟机可以由硬件(Java procesor)实现，但更为常见的是在各个现有平台(如Windows ——x64、Linux_aarch64)上提供软件实现。这样一来，一旦一个程序被转换成 Java 字节码，它就可以在不同平台实现的虚拟机实现里运行，即“一次编译，到处运行。”除此之外，虚拟机还提供了一个托管环境(Managed Runtime)。这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。比如：自动内存管理与垃圾回收、数据越界、动态类型、安全权限等等动态监测。Java 虚拟机具体怎样运行 Java 字节码的？虚拟机角度执行 Java 代码首先需要将它编译成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区(Method Area)中，实际运行时，虚拟机会执行方法区内的代码。Java虚拟机会将内存划分为堆和栈来存储运行时数据。Java 虚拟机将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法(用C++写的 native 方法)的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。在运行过程中，每当调用进入一个 Java 方法，Java虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。硬件角度Java 字节码无法直接执行，需要 Java 虚拟机将字节码翻译成机器码。在HotSpot中，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时翻译(Just-In-Time compilation, JIT)，即将一个方法中包含的所有字节码翻译成机器码后再执行。前者优势是无需等待编译，后者优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合解释执行和即时编译的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。Java 虚拟机的运行效率是怎么样的？HotSpot 采用了多种技术来提升启动性能以及峰值性能。即时编译建立在程序符合二八定律的假设之上，即百分之二十的代码占用了百分之八十的计算资源。对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。理论上讲，即时编译后的 Java 程序的执行效率是可能超过 C++ 程序的。这是因为与静态编译相比，即时编译拥有程序的运行时信息，并且可以根据这个信息作出相应优化。比如：一个虚方法的调用，尽管它有很多个目标方法，但是在实际运行过程中它可能只调用其中的一个。这个信息就可以被即时编译器所利用，来规避虚方法调用的开销，从而达到比静态编译的 C++ 程序更高的性能。为了满足不同用户场景的需要，HotSpot 内置了多个即时编译器：C1、C2 和 Graal。其中 Graal 是Java 10正式引入的实验性即时编译器。这样以来就可以在编译时间和生成代码的执行效率上进行取舍。C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。从 Java 7 开始，HotSpot 的即时编译是放在额外的编译栈程中进行的。HotSpot 会根据 CPU 的数量设置编译线程的数目，并且按 1:2 的比例配置还给 C1 和 C2编译器。在资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。问题Java 语言和 Java 虚拟机看待boolean类型的方式是否不同？Java 虚拟机将 boolean 类型看成 int 型 0 和 1 进行处理。123456789101112// Foo.javapublic class Foo &#123; public static void main(String[] args) &#123; boolean flag = true; if (flag) &#123; System.out.println(&quot;Hello, Java!&quot;); &#125; if (flag == true) &#123; System.out.println(&quot;Hello, JVM!&quot;); &#125; &#125;&#125;12345678910$ # linux环境$ javac Foo.java$ java Foo$ # 两个都打印$ # 反汇编器与汇编器 将flag对应的值iconst_1改成了iconst_2$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &gt; Foo.jasm.1$ awk &apos;NR==1,/iconst_1/&#123;sub(/iconst_1/, &quot;iconst_2&quot;)&#125; 1&apos; Foo.jasm.1 &gt; Foo.jasm $ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm$ java Foo$ # 第二个不打印其他热点代码探测热点代码探测有两种算法——基于采样的热点探测和基于计数器的热点探测。一般采样的是基于计数器的热点探测，这种算法有两个计数器，方法调用计数器和回边计数器，它们在 C1 和 C2 中有不同的阈值。对于性能要求高的 web 应用为什么不直接使用即时编译器在启动时全部编译成机器码呢？对于长时间运行的程序来说，大部分编译就发生在前几个小时。再之后的即时编译主要是一些非热点代码，以及即时编译器中的 bug 造成的反复去优化重新编译。JVM 这么做主要也是看中字节码的可移植性，从而牺牲了启动性能。JVM 也引入了 AOT 编译，在线下将 Java 代码编译成可链接库。为什么理论上比 C++ 快？实际上会插入一些虚拟机相关的代码。现代编译器一般都分为平台无关的前端和平台相关的后端。如果要生成某个平台的代码，编译器会选择相应的后端。因此，无论是 C 编译器还是 JIT 编译器，都是基于目标 CPU 的指令集来做优化的。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>代码运行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入拆解Java虚拟机]]></title>
    <url>%2Fposts%2Fec055895%2F</url>
    <content type="text"><![CDATA[极客时间《深入拆解Java虚拟机》 | 郑雨迪 | Oracle高级研究员好记性不如烂笔头，做下笔记顺便加强一下记忆，之前了解虚拟机笔记零散，准备借此机会梳理一下。为什么我们要学习Java虚拟机？“知其然”也要“知其所以然”，学习Java虚拟机的本质，更多是了解Java程序是如何被执行且优化的。这样一来，你才可以从内部入手，达到高效编程的目的。与此同时，你也可以为学习更深层级、更为核心的Java技术打好基础。了解Java虚拟机有如下好处：优化：Java虚拟机提供了很多配置参数，用于满足不同应用场景下，对程序性能的需求。学习Java虚拟机，你可以针对自己的应用，最优化匹配运行参数。避险：Java虚拟机本身是一种工程产品，在实现过程中自然存在不少局限性。学习Java虚拟机，可以更好地规避它在使用过程中的bug，也可以更快地识别出Java虚拟机中的错误。触类旁通：Java虚拟机拥有当前最前沿、最成熟的垃圾回收算法，以及即时编译器实现。学习Java虚拟机，我们可以了解其背后的设计决策，今后再遇到其他代码托管技术也能触类旁通。百发齐放：Java虚拟机发展到今天，已经脱离Java语言，形成一套相对独立的、高性能的执行方案。除了Java以外，Scala、Clojure、Groovy，以及时下热门的Kotlin，这些语言都可以运行在Java虚拟机上。学习Java虚拟机，便可以了解这些语言的通用机制，甚至于让这些语言共享生态系统。基本原理剖析Java虚拟机的运行机制，逐一介绍Java虚拟机的设计决策以及工程实现。Java代码是怎么运行的？Java的基本类型Java虚拟机是如何加载Java类的？高效实现探索Java编译器，以及内嵌于Java虚拟机中的即时编译器，帮助你更好地理解Java语言特性，继而写出简洁高效的代码。代码优化介绍如何利用工具定位并解决代码中的问题，以及在已有工具不适用的情况下，打造专属轮子。虚拟机黑科技介绍甲骨文实验室近年来的前沿工作之——GraalVM。包括如何在JVM上高效运行其他语言；如何混搭这些编程语言，实现Polyglot；如何将这些语言事前编译(Ahead-Of-Time, AOT)成机器指令，单独运行甚至嵌入数据库中运行。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-丧]]></title>
    <url>%2Fposts%2F60ae6d78%2F</url>
    <content type="text"><![CDATA[可能会太丧，不建议一次性食用，千万不要贪杯哦~别人都祝你快乐，我只愿你，遍历山河，觉得人间值得。——夫禾《禾叔的杂货铺》001我希望她三十岁没嫁，我也不希望她三十岁没嫁。——网易云音乐《三十岁的女人》热评我从未拥有过你一秒钟，心里却失去过你千万次。——网易云音乐《再见二丁目》热评慢慢大家会明白的，互相喜欢的两个人无法在一起，其实是人生的常态。———网易云《三角题》热评不在一起就不在一起吧，反正一辈子也没多长。——网易云音乐《关于郑州的记忆》热评多数人25岁就死了，但直到75岁才埋。——网易云音乐《杀死那个石家庄人》热评电影太仁慈，总能让错过的人重新相遇，生活不一样，有些人说过再见就再也不见了。——出处不详她的手只有我的手四分之三那么大，可我还是没能抓住。——网易云音乐《一生所爱》热评那时候没有手机没有网络，只能通过书信来往，才会有这样依依不舍，现在的人很难感受到那种离别后再无音讯的难舍了。——网易云音乐《离别的车站》热评希望我是一个让你心动的人，而不是权衡取舍分析利弊后，觉得不错的人。——出处不详——《成全》002你总想依赖别人，到最后，你会发现人生的每一个最艰难时刻，都是自己挺过来的。这里是我的心，奇迹般万物生长，后来你来这儿走了一遭，这里荒芜寸草不生死亡，仿佛水消失在水中。自杀，也是一种变相的对自我的执着。希望每个感觉在黑暗里往下沉的人，都能找到再浮起来的力量。善良长不出牙齿，就是软弱。我有抑郁症，所以就去死一死，没什么重要的原因，大家不必在意我的离开。——微博用户走饭你没有如期归来，而这正是离别的意义。——北岛《白日梦》生活真的好累，可我又不能去死吧，那些难捱的事情还得咬咬牙挺过去，不管过程怎么艰难，努力点总比碌碌无为要来的好吧。——出处不详003你没有如期归来，而这正是离别的意义。——北岛《白日梦》小时候真傻，居然盼着长大。—— 丰子恺你长大了，就要做好每个人都会离开的准备 。——出处不详张三丰瞧着郭襄的遗书，眼前似乎又看到了那个明慧潇洒的少女，可是，那是一百年前的事了。——金庸或许我的心包有一层硬壳，能破壳而入的东西是极其有限的。所以我才不能对人一往情深。——村上春树《挪威的森林》热闹是他们的，我什么都没有。——朱自清哪里会有人喜欢孤独，不过是不喜欢失望罢了。——村上春树《挪威的森林》现代人的崩溃，是一种很安静的崩溃，看起来特别正常。会说笑，会打闹，会社会，表面很平静，实际心情已经糟到一定程度了。但不会骂人，不会砸东西，更不会哭。就算有那么一刻，达到所能承受的极限了，也只是不说话，不会真的崩溃，就是不太想活，却也不敢去死。——出处不详我以前以为秘密不能说，现在才知道难过也不能说。——出处不详004后来我终于知道，它并不是我的花，我只是恰好途径了它的盛放。——出处不详世间所有的爱都指向团聚，唯有父母的爱指向别离。——出处不详我今年十八岁，如果身体健康，没有飞来横祸，我还可以活四十年，五十年，六十年，但我可能再也见不到她了，而我又只有这么一辈子。——出处不详生活从来不会招招手说，“小子过来我们讲讲道理”，生活只会一个大嘴巴把你打在地上后说，“傻逼，学着点。”——出处不详希望你能明白，那些离开了你的人，不管当时是出于什么原因离开，也许彷徨过犹豫过挣扎不舍过。但至少，在他决定要走的那个瞬间，他觉得没有你，他会过得更好。——出处不详生活中尽是瑕疵，大多平淡。——沃梓基天堂和地狱都太过分了，人们的行为不值得那么多。前已无通路，后不见归途。敌视现实，虚构远方。东张西望，一无所长。四体不勤，五谷不分。文不能测字，武不能防身——《十万嬉皮》领导看的是结果，不看过程，这个社会也是。——Muhouer005你不愿意种花，你说，我不愿看见它一点点凋落。是的，为了避免结束，你避免了一切开始。——顾城《避免》太年轻了，还没成为想成为的样子，所以也没有时间遇上共度余生的人。从没和你一起坐过飞机，总是一个人坐飞机跑来找你，再一个人坐飞机回去。我一生未做坏事，为何这样？——张国荣那一刻你心里有场海啸，可你静静地，没有让任何人知道。——独木舟葛婉仪我其实刻薄，不擅温言宽慰，惰于交流，说着说着便沉默。往往疏离，孤独执着。我在自己周围筑起高墙，没有哪个人能够入内，也尽量不放自己出去。——村上春树 《海边的卡夫卡》我的不幸，恰恰在于我缺乏拒绝的能力。我害怕一旦拒绝别人，便会在彼此心里留下永远无法愈合的裂痕。——太宰治《人间失格》好想抱一抱每一个因为敏感而变得小心翼翼的人，我懂得他们内心的善良，亦知晓他们的可贵。(优先考虑哪些优先考虑你的人)006有的人就是会天生自我厌恶，我非常清楚自己就是那种表面看的过去，各方面普普通通，有点小特长，坐在人群里不至于太扎眼，实际上非常糟糕的人。很多时候做给别人看，有时候甚至卑劣到做给自己看。每次想要对别人说明这一点的时候，大家总是好心安慰:不是的，你很好呀。不是这样的，我一点也不好，你不明白。你走了真好，不然总担心你要走。对于丑人，细看是种残忍。被人指出丑陋之处的滋味并不好受。坦然地剥开自己并不容易。很难过的是，我所认真重视对待的其实并没有人关心，我所渴望被理解的、努力倾诉希望有人愿意懂得的，其实并没有人真正去倾听。我喜爱很多事物，却唯独讨厌自己。哪有什么不合适，无非就是腻了，倦了，权衡利弊之后懒得爱了，想遇见比你更好的人了。以后的以后，多点自知之明，少点自作多情。我最信任的人，教会我不要信任何人。007有些事情做不完，就留到明天做吧！運氣好的話，明天死了就不用做了。其实不想丧的，但真的不快乐。生活到底对你们做了什么，不敢再尝试，不敢再用力爱，不敢再探索。你以为那是成熟，我认为那叫死了。人生这么短，我要和像我喜欢你一样喜欢我的人一起过。少吃兩口飯我都做不到，怎麼可能說不喜歡就不喜歡呢？不是所有怪物一开始就是怪物，也不是所有怪物看起来都像怪物。有些人会把怪物的一面藏在心里。——弗雷德里克·巴克曼《外婆的道歉信》死亡最强大的力量不在于它能让人死去，而在于让留下来的人不想再活着。——弗雷德里克·巴克曼《外婆的道歉信》我什么都做不了，只能眼睁睁地看着。一切都消失在迷雾之中了。过去给抹掉了，而抹掉本身又被遗忘了，谎言便变成了真话。——乔治·奥威尔《一九八四》008人在无端微笑时，不是百无聊赖，就是痛苦难当。——王小波《革命时期的爱情》人性本凉薄，又何介，谁比谁更多。——三毛心，若没有栖息的地方，到哪里都是流浪。——三毛一见钟情，明明是见色起意。日久生情，不过是权衡利弊。就连白头到老，都只是习惯使然。——安逸《这咬人的爱》在青春的掩护下，颓废是勇气，懒惰是反抗，空虚是性感。——刘渝任凭怎么解释，世人也只能相信自己愿意相信的事情。越是拼命争扎，我们的处境越是狼狈。——村上春树《挪威的森林》哪里会有人喜欢孤独，不过是不喜欢失望。——村上春树《挪威的森林》我们究竟是活了365天，还是活了一天，重复了364遍。那天，我忍住没哭。——Muhouer009以前挺理想主义的，一直都认为金钱不是自由生活的前提，精神自由最重要。当我走出校园真正开始接触社会才发现，赚到的钱越多，生活的可选择性越大，也就越不容易受到周遭环境的影响。希望你们可以尽己所能，想方设法给自己挣到足够的钱，好去旅游，去无所事事，去思索世界的未来或过去，去看书、做梦或是在街头闲逛，让思考的鱼线深深沉入这条溪流中去。——伍尔夫在《一间自己的房间》一切正常的生命都会有意识或无意识地对控制感到愤恨。如果这种控制来自能力低下的一方或据说能力低下的一方，这种愤恨就会更加强烈。人类的智力就像是孔雀的羽毛。只不过是种用来吸引配偶的浮夸表演。最让我崩溃的不是贫穷，而是这种看不见希望的生活。有些事情做不完，就留到明天做吧！運氣好的話，明天死了就不用做了！心酸纵有千万种，沉默不语最难过。半身风雨半身伤，半句别恨半身凉。有情皆虐，无人不冤。慧极必伤，情深不寿。得之我幸，失之我命。010三里清风三里路，步步清风再无你。闻君有两意，故来与君绝。卿本良人，奈何缘浅。你眼里灿若清河，唯独偏偏无我。不喜欢”丧”用在这里，我们只是偶尔不开心从小我就懂得保护自己，我知道，要想不被人拒绝，最好的办法就是先拒绝别人。——王家卫我终于扛不住了，把所有心里话说出来了，却有人说我不懂事。我真的很差劲，真的，我讨厌这样的自己。没有人喜欢孤独。011我觉得自己是个内心非常肮脏的人，并为此感到悲伤。如果快乐太难，那再次祝你平安。人间不值得。曾经的梦想天真无邪，后来满脑子都是为了钱，每年生日闭眼许的愿，能有几个可以灵验，人总会变抱歉，都说生命可以不分贵贱，可有人生来就被叫做少爷，有人只能看着地面，抬头都是些肮脏的嘴脸，励志要走社会的前列，可总是败在势力的面前，肺腑之言，抱歉，我想忘了从前的一切，做一个凡事不问的俗人，从今天起远离人群，做一只狡猾的狐狸，那天我双手合十，看着镜子里狼狈的自己，我用了一半的青春，来思考做人的道理，对不起年少的自己。——尚士达的单曲《生而为人》]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>丧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字]]></title>
    <url>%2Fposts%2Fce0f712d%2F</url>
    <content type="text"><![CDATA[本文最初来源，在此基础上做了部分修改、调整。liuxiaopengJava 并发编程：volatile的使用及其原理volatile作用在《Java并发编程：核心理论》一文中，我们已经提到过可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchronized原理有了解的话，应该知道Synchronized是一个比较重量级的操作，对系统的性能有比较大的影响，所以，如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。而volatile关键字就是Java中提供的另一种解决可见性和有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。volatile使用场景防止重排序我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁（DCL）的方式来实现。其源码如下：1234567891011121314151617public class Singleton &#123; public static volatile Singleton singleton; /** * 构造函数私有，禁止外部实例化 */ private Singleton() &#123;&#125;; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125;现在我们分析一下为什么要在变量singleton之前加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤： 1. 分配内存空间。 2. 初始化对象。 3. 将内存空间的地址赋值给对应的引用。但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程： 1. 分配内存空间。 2. 将内存空间的地址赋值给对应的引用。 3. 初始化对象 如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。实现可见性可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用：12345678910111213141516171819202122232425262728293031323334353637public class VolatileTest &#123; int a = 1; int b = 2; public void change() &#123; a = 3; b = a; &#125; public void print() &#123; System.out.println(&quot;b=&quot; + b + &quot;;a=&quot; + a); &#125; public static void main(String[] args) &#123; while (true) &#123; final VolatileTest test = new VolatileTest(); new Thread(() -&gt; &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test.change(); &#125;).start(); new Thread(() -&gt; &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test.print(); &#125;).start(); &#125; &#125;&#125;直观上说，这段代码的结果只可能有两种：b=3;a=3 或 b=2;a=1。不过运行上面的代码（可能时间上要长一点），你会发现除了上两种结果之外，还出现了第三种结果：为什么会出现b=3;a=1这种结果呢？正常情况下，如果先执行change方法，再执行print方法，输出结果应该为b=3;a=3。相反，如果先执行的print方法，再执行change方法，结果应该是 b=2;a=1。那b=3;a=1的结果是怎么出来的？原因就是第一个线程将值a=3修改后，但是对第二个线程是不可见的，所以才出现这一结果。如果将a和b都改成volatile类型的变量再执行，则再也不会出现b=3;a=1的结果了。保证原子性volatile只能保证对单次读/写的原子性。这个问题可以看下JLS中的描述：17.7 Non-Atomic Treatment of double and longFor the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.Writes and reads of volatile long and double values are always atomic.Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency’s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。关于volatile变量对原子性保证，有一个问题容易被误解。现在我们就通过下列程序来演示一下这个问题：12345678910111213141516171819202122public class VolatileTest &#123; volatile int i; public void addI() &#123; i++; &#125; public static void main(String[] args) throws InterruptedException &#123; final VolatileTest test01 = new VolatileTest(); for (int n = 0; n &lt; 1000; n++) &#123; new Thread(() -&gt; &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test01.addI(); &#125;).start(); &#125; Thread.sleep(10000);//等待10秒，保证上面程序执行完成 System.out.println(test01.i); &#125;&#125;大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：12993Process finished with exit code 0可能每个人运行的结果不相同。不过应该能看出，volatile是无法保证原子性的（否则结果应该是1000）。原因也很简单，i++其实是一个复合操作，包括三步骤： 1. 读取i的值。 2. 对i加1。 3. 将i的值写回内存。volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者synchronized来保证+1操作的原子性，以下代码为使用AtomicInteger对应的实现。12345678910111213141516171819202122public class VolatileTest &#123; AtomicInteger i = new AtomicInteger(0); public void addI() &#123; i.getAndAdd(1); &#125; public static void main(String[] args) throws InterruptedException &#123; final VolatileTest test01 = new VolatileTest(); for (int n = 0; n &lt; 1000; n++) &#123; new Thread(() -&gt; &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test01.addI(); &#125;).start(); &#125; Thread.sleep(10000);//等待10秒，保证上面程序执行完成 System.out.println(test01.i.intValue()); &#125;&#125;注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。volatile原理通过上面的例子，我们基本应该知道了volatile是什么以及怎么使用。现在我们再来看看volatile的底层是怎么实现的。可见性实现在前文中已经提及过，线程本身并不直接与主内存进行数据的交互，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。因此要实现volatile变量的可见性，直接从这方面入手即可。对volatile变量的写操作与普通变量的主要区别有两点： （1）修改volatile变量时会强制将修改后的值刷新的主内存中。 （2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。 通过这两个操作，就可以解决volatile变量的可见性问题。有序性实现在解释这个问题前，我们先来了解一下Java中的happen-before规则，JSR 133中对Happen-before的定义如下：Two actions can be ordered by a happens-before relationship.If one action happens before another, then the first is visible to and ordered before the second. 通俗一点说就是如果a happen-before b，则a所做的任何操作对b是可见的。（这一点大家务必记住，因为happen-before这个词容易被误解为是时间的前后）。我们再来看看JSR 133中定义了哪些happen-before规则：• Each action in a thread happens before every subsequent action in that thread.• An unlock on a monitor happens before every subsequent lock on that monitor.• A write to a volatile field happens before every subsequent read of that volatile.• A call to start() on a thread happens before any actions in the started thread.• All actions in a thread happen before any other thread successfully returns from a join() on that thread.• If an action a happens before an action b, and b happens before an action c, then a happens before c. 翻译过来为：同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则）对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则）线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则）线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。 这里我们主要看下第三条：volatile变量的保证有序性的规则。《Java并发编程：核心理论》一文中提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会对volatile变量限制这两种类型的重排序。下面是JMM针对volatile变量所规定的重排序规则表：Can Reorder2nd operation1st operationNormal Load Normal StoreVolatile LoadVolatile StoreNormal Load Normal StoreNoVolatile LoadNoNoNoVolatile storeNoNo内存屏障为了实现volatile可见性和happen-befor的语义。JVM底层是通过一个叫做“内存屏障”的东西来完成。内存屏障，也叫做内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。下面是完成上述规则所要求的内存屏障：Required barriers2nd operation1st operationNormal LoadNormal StoreVolatile LoadVolatile StoreNormal LoadLoadStoreNormal StoreStoreStoreVolatile LoadLoadLoadLoadStoreLoadLoadLoadStoreVolatile StoreStoreLoadStoreStore（1）LoadLoad 屏障执行顺序：Load1—&gt;Loadload—&gt;Load2确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。（2）StoreStore 屏障执行顺序：Store1—&gt;StoreStore—&gt;Store2确保Store2以及后续Store指令执行前，Store1操作的数据对其它处理器可见。（3）LoadStore 屏障执行顺序： Load1—&gt;LoadStore—&gt;Store2确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。（4）StoreLoad 屏障执行顺序: Store1—&gt; StoreLoad—&gt;Load2确保Load2和后续的Load指令读取之前，Store1的数据对其他处理器是可见的。最后我可以通过一个实例来说明一下JVM中是如何插入内存屏障的：12345678910111213141516171819202122232425public class MemoryBarrier &#123; int a, b; volatile int v, u; void f() &#123; int i, j; i = a; j = b; i = v; //LoadLoad j = u; //LoadStore a = i; b = j; //StoreStore v = i; //StoreStore u = j; //StoreLoad i = u; //LoadLoad //LoadStore j = b; a = i; &#125;&#125;总结总体上来说volatile的理解还是比较困难的，如果不是特别理解，也不用急，完全理解需要一个过程，在后续的文章中也还会多次看到volatile的使用场景。这里暂且对volatile的基础知识和原来有一个基本的了解。总体来说，volatile是并发编程中的一种优化，在某些场景下可以代替Synchronized。但是，volatile的不能完全取代Synchronized的位置，只有在一些特殊的场景下，才能适用volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全： 1. 对变量的写操作不依赖于当前值。 2. 该变量没有包含在具有其他变量的不变式中。]]></content>
      <categories>
        <category>Java关键字</category>
      </categories>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-爱]]></title>
    <url>%2Fposts%2F497a5083%2F</url>
    <content type="text"><![CDATA[001星河滚烫，你是人间理想。水中月是天上月，眼前人是心上人。你自月中来，星飒云中雾。情不知所起，一往而深。——汤显祖《牡丹亭》不多不多，以后还可以少吃一点。——三毛为你，千千万万遍。——卡勒德·胡赛尼月亮很亮，亮也没用，没用也亮。我喜欢你，喜欢也没用，没用也喜欢。 ——李诞她可以褪色，可以枯萎，怎样都可以，但我只要看她一眼，万般柔情，涌上心头。——《洛丽塔》别惊动我爱的人，等他自己情愿。——《圣经》002斯人如彩虹，遇上方知有。世上本无圣诞老人，所有礼物和惊喜都来自爱你的人。我这个人啊，满身阴暗，还总想着给你一点阳光。我想变得有趣，变得特别，变成你眼里的一点星光。世界没有你想象的那么坏，你过来，来我身边，我抱你。昨天很喜欢你，今天也很喜欢你，而且预感，明天也会很喜欢你。这里荒芜寸草不生，后来你来这儿走了一遭，奇迹般万物生长，这里是我的心。这个世界上有六十几亿人口，但某个瞬间，只这一个人，就能敌过千军万马，四海潮生。喜欢啊，是清风，是朝露，是脸颊红红，是千千万万人里，心里除了你再也装不下其它。003不奢望永远，所以，爱一天，珍惜一天。深情但不纠缠。人一大，碰到真心喜欢的人，第一感觉是害怕，还有自卑。真心说出的不一定是真话，那是情话。月遇从云，花遇和风，今晚上的夜空很美，我又想你。 ——太宰治就算世界荒芜，总有一个人，他会是你的信徒。 ——独木舟《深海里的星星》朝暮与年岁并往，然后与你一同行至天光。 ——河唐先生《天光》草在结它的种子，风在摇它的叶子，我们站着，不说话，就十分美好。——顾城《门前》余生不用多指教，我都听你的就是了。004因为你，我愿意成为一个更好的人。纵然，从此一别两宽，各自欢喜，你也曾写进了他的生命里，虽非经久不衰，却最浓墨重彩。藏不住的喜欢，理直气壮就好了。我喜欢你，甚于昨日，略匮明朝。特别喜欢你朝我走过来的样子，不过我很紧张，心砰砰地跳。你要做个可爱的姑娘，不烦世事，满心欢喜。我站在哪都可以，可以站在你前面，保护你；也可以站在你后面，撑起你；也可以站在你旁边，与你并肩(也可以站得远远的，远离你)。世界并不会对你温柔以待，上帝也不会对你特殊照顾，但是，我会呀。一生太短，所以遇到喜欢的人，就要认真喜欢。005外面风大，我带你回家。想陪你一起无所事事。我这个人超级好的，你可以放心喜欢。你回头。还有我呢！你最可爱！今晚月色真美！上来吧，我背你！哈哈哈，你也是个普通人，和我一样。006我寻了半生的春天，你一笑便是了。我一点也不想你，一点半再想。我想和你在一起，几天也好。在某个地方，某个时辰。 ——杜拉斯陌上开花，可缓缓归矣。玲珑骰子安红豆，入骨相思君知否。此情无计可消除，才下眉头，却上心头。春风十里不如你。愿得一心人，白首莫相离。情不知所起，一往而深。007但愿人长久，千里共婵娟。人生若只如初见。今夕何夕，见此良人。只一眼，便千秋万世。何烦五色药，尊下即丹丘。愿你垂垂老矣，我可明我心。所爱隔山海，山海皆可平。身无彩凤双飞翼，心有灵犀一点通。世间安得双全法，不负如来不负卿008说的是一辈子！差一年，一个月，一天，一个时辰，都不算一辈子！——《霸王别姬》如果再也看不到你，祝你早安，午安，晚安。——《楚门的世界》如果她打你，一定要装得很痛；如果真的很痛，要装得没事。——《我的野蛮女友》到你是我人生的一大收获。我不道别，也不跟你约定，我想我们一定能再见面的。——《东京爱情故事》我这一生都是坚定不移的唯物主义者，唯有你，我希望有来生。–《周恩来家书》醒来觉得甚是爱你。——朱生豪《朱生豪情书》我并没有喜欢哪一种类型的人 。如果我喜欢你，我喜欢的就只是你。——蔡康永答案很长，我准备用一生的时间来回答，你准备要听了吗？——林徽因人间烟火，山河远阔。无一是你，无一不是你。009若逢新雪初霁/满月当空/下面平铺着皓影/上面流转着亮银/而你带笑地向我步来/月色与雪色之间/你是第三种绝色——余光中 《绝色》这黑灯瞎火的，我贼他妈想你。即许一人以偏爱，愿尽余生之慷慨。愿有岁月可回首，且以深情共白头。思君如满月，夜夜减清辉。不知魂已断，空有梦相随；除却天边月，没人知。锦衣雪华玉颜色，回眸一笑天下倾。愿出一家之言，以结两姓之好。人生当苦无妨，良人当归即可。010一生之中一定会遇到某个人，Ta 打破你的原则，改变你的习惯，成为你的例外。结婚办理九块钱，四块五的意思就是你的另一半，那是不是等你攒够了四块五我也攒够了四块五，我们就可以结婚了。——《四块五》评论爱自己是终生浪漫的开始。他不拿手机，他手捧鲜花，将惊喜藏于身后，他翘首以盼，站在原地默默等候。爱是坚持到底的冒险，是最小的共产主义，是一种持之以恒的胜利，不断地跨越空间、时间、世界所造成的障碍。“我爱你”就意味着在这个世界上，你成为我生命的源泉。——阿兰·巴迪欧请记住每一个容易失效的特殊日子，因为你记住的本质是：我在乎你。]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>爱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-惊艳]]></title>
    <url>%2Fposts%2F922764cc%2F</url>
    <content type="text"><![CDATA[说书唱戏劝人方，三条大路走中央。善恶到头终有报，人间正道是沧桑。—— 单口相声定场诗曾以为走不出的日子，现在都回不去了。——村上春树长大了，总有那么一两次，你会为重视的人奔跑，因为是对的人，走路真的来不及。没事，只不过是恢复原状罢了，我本来就是一无所有的。——濑川初原《食灵零》能够说出的委屈，便不算委屈；能够抢走的爱人，便不算爱人。——亦舒《开到荼蘼》有人一看书就卖弄，多看几本吧，多看几本就不卖弄了。——木心你如果认识从前的我，也许你会原谅现在的我。——张爱玲《倾城之恋》希望你明白，我凡事都看得开，但并不影响我记仇。我们奋力前行，逆水行舟，被不断向后推，直至回到往昔岁月。——《了不起的盖茨比》人生天地之间，若白驹之过隙，忽然而已。——庄周逝者如斯夫，不舍昼夜。——《论语·子罕》贫穷的思维，是造成贫穷的真正原因。每一个不曾起舞的日子，都是对生命的辜负。——尼采敬这大争之世，敬这小酌之时。长大是人必经的溃烂。——塞林格远方除了遥远一无所有。——海子我妈曾经说过一句话：即使你躺倒让别人踩在你身上走，别人还是会抱怨你踩着不够舒服。所以，不用试着让所有人都开心，过好你自己的生活。张华考上了北京大学，李萍进了中等技术学校，我在百货公司当售货员，我们都有光明的前途。——新华字典1998修订本”前途“一词的例句少年的肩膀，就该这样才对嘛，什么家国仇恨，浩然正气的，都不要急，先挑起清风明月、杨柳依依和草长莺飞，少年郎的肩头，本就应当满是美好的事物啊。——烽火戏诸侯《剑来》女孩，晚安，你要早睡，才会有一天找到另一个也喜欢早睡的男孩，拥抱着你入睡，在你耳边呢喃一句晚安。只有孤独的灵魂，才会越晚越清醒。女孩，你听到吗，晚安。——阿句句《全世界失眠》想生个女儿，头发顺长，肉薄心窄，眼神忧郁。用牛奶，豆浆，米汤和可口可乐浇灌，一二十年后长成祸水。——冯唐《北京北京》有朝一日会成为被喜欢的人觉得大吃一惊，被讨厌的人刮目相看的人——网易云热评你对纹身的女人怎么看？你对她有偏见？我喜欢的女性是多元的，拒绝“女人就应该活成女人的样子”“年纪这么大了，还这么有少女感”“女人过了多少岁就没价值了，类似这样的话。我认真对待我自己，认真对待年龄留下的饱满痕迹，我所有的经历构造了现在的我，我无需被其他定义，无需被教导成“女孩应该有的样子”我只是我而已。也没有什么热衷的东西，感觉追不上就悄悄走开了。生活没那么复杂，种豆子和相思或许都得瓜。你敢试，世界就敢答 。有时候你问的问题对方一直在闪躲，那就是在委婉地告诉你，真实的回答很残忍。你必须只有内心丰富，才能摆脱这些生活表面的相似。贪安稳就没有自由，要自由就要历些危险。只有这两条路。鲁迅不能听命于自己者，就要受命于他人。——尼采《查特拉斯如是说》若是看到自己周围一群拙劣的追随者以及同伴，首要的正确反省是：自己做得还不够卓越。幸运的人一生都被童年治愈，不幸的人一生都在治愈童年。她那时候还太年轻，不知道所有命运馈赠的礼物，早已经在暗中标好了价格。——《断头王后》单是聪明还不够，还应有足够的聪明以避免过度聪明。——莫洛瓦我们始终有一种错觉，以为我们的感情源自于我们自己的内心。——古斯塔夫·勒庞 《乌合之众》人一到群体中，智商就严重降低，为了获得认同，个体愿意抛弃是非，用智商去换取那份让人倍感安全的归属感。——古斯塔夫·勒庞 《乌合之众》没有人帮你，说明你一个人可以。我要再和生活死磕几年。要么我就毁灭，要么我就注定铸就辉煌。如果有一天，你发现我在平庸面前低了头，请向我开炮。——杰克·凯鲁亚克《在路上》正因为众人畏惧死亡，死亡这个事件里，意外率先完成的人，往往被迫伟大。与其互为人间，不如自成宇宙。希望每个感觉在黑暗里往下沉的人，都能找到再浮起来的力量。因为拥有过的很少，所以根本学不会断舍离，生活里一切鸡毛蒜皮的温馨 我都想藏起来。人生的意义是什么？是在生命里偶尔感到超出人的一些部分。一无所有来，一无所有走。中间的过程里，说“失去”都是太抬举自己，借来的、还回去，摊开手心，紧握拳心，会心一击。——春夏决定我们是什么人的是：在本可以什么都不做的时候，你在做什么？几时归去，作个闲人。对一张琴，一壶酒，一溪云。 ——苏轼 行香子·述怀人易老，事多妨，梦难长。一点深情，三分浅土，半壁斜阳。 ——汤显祖情不知所起，一往而深，生者可以死，死者可以生。生而不可与死，死而不可复生者，皆非情之至也。 ——汤显祖被酒莫惊春睡重，赌书消得泼茶香。当时只道是寻常。 ——纳兰性德《浣溪沙》十步杀一人，千里不留行。事了拂衣去，深藏身与名。 ——李白《侠客行》从前幽怨应无数。铁马金戈，青冢黄昏路。一往情深深几许？深山夕照深秋雨。 ——纳兰性德《蝶恋花·出塞》一生一代一双人，争教两处销魂。相思相望不相亲，天为谁春? ——纳兰性德《画堂春·一生一代一双人》人生若只如初见，何事秋风悲画扇？等闲变却故人心，却道故人心易变。 ——纳兰性德出了这个门，有人遭遇风雪，有人逢着彩虹；有人看见虎狼，有人逢着羔羊；有人在春天里发抖，有人在冬天里歌唱。浮沉烟云，总归幻象。悲苦是蜜，全凭心酿。 ——迟子建“如果顺利的话，我会买一个公寓，养一只柯基，一只英短，孤身一人，自由且满足地度过余生。” “若是不顺呢？” “结婚生子”。多数的日子平淡无奇，灵光的颜色往往不暖。丑比美更容易散播，因为丑不需要灵魂。为了有趣而有趣，不有趣；辛于平凡的平凡，不平凡。心中萧瑟，世界就成灰色，心怀旷野，哪里都是山河。做你自己，然后去承受你为个性而付出的代价。所有人都在和所有人喝茶吃饭，往往来来，没有尽头。不被爱着并不是你的错 你需要看到这些创伤 然后，试着做你自己。爱自己是终身浪漫的开始。自信的状态是，别人怎么贬低自己都觉得放你妈的狗屁。人人情有可缘，谁也不正确。一个人，欺负最多的，往往是身边的亲人，因为开罪别人可能会让自己失去很多，而得罪这些人，可以没有一点成本。小事要忍，大事要狠，没人扶的时候自己要站稳。路是走出来的，越低谷的时候越要撑起自己，要赢得起也要输得起。一直在学走路，总有一天会站起来。外面的雷雨愈发振作，屋内的桌椅茶杯更是安宁。要是在暮春时节，看满山暴雨打落花，一定很热闹。绿蚁新醅酒，红泥小火炉，晚来天欲雪，能饮一杯无？——白居易《问刘十九》人终究会被其年少不可得之物困扰一生。你要克服懒惰，你要克服游手好闲，你要克服漫长的白日梦，你要克服一蹴而就的妄想，你要克服自以为是浅薄的幽默感。你要独立生长在这世上，不寻找不依靠，因为冷漠寡情的人孤独一生。你要坚强，振作，自立，不能软弱，逃避，害怕。不要沉溺在消极负面得情绪里，要正面阳光得对待生活和爱你的人。永远年轻，永远热泪盈眶。你才25岁，你可以成为任何你想成为的人。——《步履不停》你可以拥有一切，但不能同时。——玛丽莲·梦露每天发生在自己身上99％的事情，于别人而言根本毫无意义。——马克-鲍尔莱恩我用尽了全力，过着平凡的一生 。——《月亮与六便士》人的一切痛苦，本质上都是对自己无能的愤怒。——王小波铁甲依然在。为了逃离孤单，所刻意做的一切，反而会让人更加孤独。孤单是连续的，不孤单是间断的。孤独这两个字拆开来看，有孩童，有瓜果，有小犬，有蝴蝶，足以撑起一个盛夏傍晚间的巷子口，人情味十足。稚儿擎瓜柳棚下，细犬逐蝶窄巷中，人间繁华多笑语，惟我空余两鬓风。——孩童水果猫狗飞蝶当然热闹，可都和你无关，这就叫孤独。——林语堂春困秋乏夏打盹，睡不醒的冬三月。春生，夏糜，秋去，冬烬，春又来。夔怜弦，弦怜蛇，蛇怜风，风怜目，目怜心。恐惧有巨大的力量，甚至大过热情。蹑着猫足而至。愿娘子相离之后，重梳婵鬓美扫峨眉，巧呈窈窕之姿，选聘高官之主，解怨释结更莫相憎，一别两宽各生欢喜。——唐朝的离婚书]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>惊艳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记之孕事]]></title>
    <url>%2Fposts%2Fa28039a0%2F</url>
    <content type="text"><![CDATA[记录这个的缘由，也不是为了做什么，而是我自己发觉我的很多观念已经发生了变化，特别是关于婚姻、家庭……目前还处于比较混乱的状态，做此篇记录是为以后做准备，以后梳理起来会方便很多。正如谚语所说，罗马不是一天建成的(Rome was not built in a day)，观念也不是一下子就定型的，是一个不断变化的动态过程，甚至是一个打破重建的过程。我不敢保证我的观念一定正确，但是我会一直保持开放的态度。如果有可能，我很愿意沟通，甚至做出改变。最差的情况：即便我不愿接受，我也会给予足够的尊重。此篇作为杂记记录系列的第一篇，希望能一直做下去。现在的部分女生为什么不想生孩子？ 开始2019-06-07👤 知乎匿名用户 | 对女孩子忠告(34k👍)只是想对那些被外人催生的女孩子说：没有任何事情比你自己更重要如果你觉得生孩子会让你很有压力，那就不要去受这场折磨！他们上下嘴皮子碰了碰，都磨不掉痒劲，你要为了这群看客去怀胎十月，受累二十年？遵从自己的感受，你有什么可怕的？怕流言蜚语？怕被戳脊梁骨？你生了，他们就没有谈资了？？论人是非者，定是是非人！求求你们，勇敢一点！和爱你并且懂得尊重你的人，一起幸福地活下去！如果孩子对你的生活是锦上添花，我为你即将成为一位伟大的母亲而祝福及致敬！但如果不是，那就量力而为，不要生了痛苦/后悔！知乎匿名用户现在的部分女生为什么不想生孩子？2019-06-15👤 知乎北斗师兄 | 职业教育，有趣的小老师 | 对要孩子持保留态度(12k👍)说实话，作为一个男的，我也不想要孩子。因为我太怕自己有了孩子以后会变得跟我爸妈一样，把自己的整个人生全部寄托和希望都放在孩子身上。我爸妈的生活里只有我和我姐，他们的开心，面子，和动力全在我姐和我身上。有了我们俩之后的人生就完全失去了自我的概念，而完全都是为了我们而活。以至于现在他们年纪大了，把所有的期待都压在我身上，他们不觉得生活是自己的，他们认为自己老年最美好的生活是:儿女工作稳定，成了家，生了子，他们能够发挥余热帮忙带孙子。我绝不否认有了孩子依然能精彩的过一生，我也非常尊重很多人认为有了孩子人生才算完整这样的价值观，但我也深知受原生家庭的影响，我的性格和骨子里刻上了太多古板的东西和父母的影子。如果我有了孩子，会带着他们的影子一不小心就失去自我。我也就活这一次，懵懂少年生活里只有父母，成年之后尚未看够这世界的花样，我不想就草草的把自己的人生交给孩子。我也完全不认为自己的精神需要靠一个孩子作为寄托，老了需要依赖一个孩子来养。我希望我能按照自己的意愿体会更多的选择和可能。知乎北斗师兄www.zhihu.com/question/326634942/answer/7064176932019-06-23👤 知乎海螺面包 | 临床医疗，重症医疗学科 | 现场百态(6.2k👍)1.产妇a在床上疼的死去活来，大喊着要剖宫产，我征求了其他家属的意见，婆婆拉着儿子说 剖什么剖啊，剖宫产的小孩哪有顺产的聪明？我内心os：就您那不聪明的基因蛋孵出来也不能聪明了好么…2.产妇b生产后痔疮脱出肛门，主任直接一指禅捅了回去，还让产妇的老公戴着手套接手继续捅2个小时保证回纳成功。3.产妇c刚下手术，一个类婆婆样的中年女性飞奔到床边大喊，有奶了吗！？？？啊？？怎么还没有奶？！！！那我孙子怎么办啊？？？！4.G4P3（怀了4次生了3个）产妇d的老公和她自己都是智力障碍患者，她产后大出血、心力衰竭，住了一天icu老公就不肯积极治疗了。现在9岁的大宝在照顾新生儿和另一个在襁褓里的弟弟。5.剖宫产术后杜冷丁成瘾的产妇e以后该怎么办呢。6.剖宫产前医生是要把男方家属拉来谈话，反复告诉他们子宫只是一个器官，而我们只会优先抢救产妇，希望你们在签字的时候不要犹豫耽误时间。抖音上常看到在产房外捧着花焦急等待的老公，可我看到的全是事不关己在产床旁打王者农药的男人。也许有好的，但是极少吧。有些人玩游戏也就罢了，老婆疼的死去活来的还在说风凉话。“你都当妈了还怕疼？”“谁生孩子不这样，怎么就你娇气？”“那剖宫产多贵啊！”每个人怀了孕躺在那张产床上就不再是一个能把自尊放在首位的人了吧，压力性尿失禁，耻骨分离，再也无法恢复的身材和满肚皮的妊娠纹，真的每个人都能有如此的奉献精神么？20～30岁是生育黄金期，但是人为了什么而孕育新的生命这个问题，年轻人真的能想明白吗?知乎海螺面包现在的部分女生为什么不想生孩子？2019-07-10👤 知乎榛禾木 | 零售 | 丁克亲答(30k👍)1、我们不喜欢小孩，讨厌小孩，嫌小孩麻烦。对待小孩没有耐心，听见婴儿啼哭和小孩尖叫也会很烦躁。出去吃饭遇到奇葩的熊家庭，老婆也会发发朋友圈抱怨，借此也让催生的人看看我们的态度。我们承认的确有教育得出色的孩童，不过就像遇见别人家漂亮的小狗一样，我也许愿意摸，愿意玩，但自己不愿意养。对孩子也是如此。2、不接受目前流行的生育观。生孩子已经变成了“别人家生了，我们家也应该有”，或者“时间到了，应该要生了”的事。如果不生，最多说不生孩子的女人是不完整的女人，左耳进右耳出。在我们当地，如果生了一个，大概率还会被催生二胎。生了以后两边父母很难做到完全不插手，各种神秘不可言说状掏出来“为你好”的民间偏方，油腻的不放盐的汤水，奇葩的月子禁忌和月子餐，育儿观冲突下增加的矛盾。老婆有大量的适龄同学朋友，这样的例子多得已经看到麻木，女性生孩子十个月脱一层皮，养孩子十个月又是脱一层皮，男人能有什么损失，该上班还是上班，最多晚上被起夜喂奶的老婆带醒了。3、不愿意牺牲家人的生活质量。我俩的收入尚可，每年纯消费20万以上在这个包邮区的二线城市已经让自己过得很舒服，自住市区的联排，两边父母还有市郊景区的独栋别墅和市区的公寓，均无贷款，目前的生活水平我们都已满足。父母已经退休，我俩也无非几十年好光景，只想珍惜身边人，照顾父母度过舒适的晚年，不啃老，不让他们带孩子，也不至于生病时自责影响后辈的生活，所有的财产都能用在自己身上，无论养老还是救命。我们也是善良的人，如果有孩子，也会呵护他成长，在他18岁前尽到家长的责任，18岁后提供适当的辅助。但既然选择丁克，自然也没法在一个根本不存在的，虚无的“孩子”上产生感情，为他奉献。就算这是自私吧，我牺牲了一个薛定谔的孩子，只想和在世的家人走完一生。4、害怕生育风险。老婆是个胆小的人，怕疼，怕死，怕变丑，怕很多。她不想生，正好我也不想要，就这么简单，我可做不出逼迫老婆传宗接代的事。不生孩子的老婆还保持少女模样，脸上满满的胶原蛋白。出去吃个烧烤，穿连衣裙扎着双马尾手平放在桌上，扑察扑察眨着大眼睛等吃的，店主说：“老板带女儿出来吃烧烤啊？”把我老婆乐了一天。生育前后未知的变数，我们不想承担。看到朋友带小孩看病，这个发烧那个感冒的，陪床的过程都觉得心累。我自认从小已经是不让家长操心的孩子了，但也是生过病的人。当我肝囊肿住院开刀时，我爸面对手术风险同意书拿着笔呆滞了5分钟，他后来说很怕养了20年的孩子就这么没了，还哭了。我们不想面对无力掌握的伤心事，情愿从源头上断了这个可能。5、不想变成自己讨厌的那种人。老婆说以前某些挺正常的同学，还跟她玩得挺好的，一生完孩子，智商都好像生掉了。有在朋友圈里每天打卡乳头堵不堵的；有辞了教职闲在家里带孩子做“直销”，直播给亲儿子吃她代理的“产品”证明安全有效的；有隔了几百公里咸吃萝卜淡操心教育我们不该养猫，应该生孩子的。老婆亲戚家的女孩，饭桌上用手抓菜，敲碗碟，尖叫，一桌子大人不制止还要笑眯眯地哄，养而不教，养来何用。这是做人太假还是做人太傻。以我俩养猫时百般溺爱，把猫宠上天的情形来看，我们也是失败的父母，也有几率变成那样的人，还是不趟这水了。6、见过太多孩子让人寒心的事，更坚定养老靠自己的信念。仅仅我俩的家族里，就出了好几个例子。有搞直销，让患尿毒症的亲妈每月花6000元问她买产品喝来治病的表姐，我姨妈去世前身上只有2000元了。有参与诈骗，全家还几百万债的远房弟弟，连75岁的老奶奶都要接活计给孙子还债。有考上公务员，傍上小老板家女儿，逼爸妈掏空全部积蓄买房，然后不理睬他们的另一个弟弟。有酒后骑电动车撞了脑袋后瘫痪的堂哥。也有理所应当地女儿一出生就养在爸妈房里，现在大了就占了房子，和妻女住，让爸妈在附近租房的上海弟弟。老婆的外婆要住进养老院，三个舅舅都不愿出钱，还是我岳母出的钱。这样活生生的例子里，中老年的父母半生都勤劳温和，可以说都是好人，在一夜间失去了所有，眼神呆滞好像梦里，恰恰是这些身上掉下的骨肉，从小到大有礼貌的乖孩子，给了他们意想不到的彻底一击。我知道有人急着反驳这条，说大多数子女还是好的，但那是别处的事，并不改变以上已经客观真实发生了的事，对我们选择造成的负面影响。7、我和老婆从大学恋爱走到现在，十年来一直是黏在一块的，也是彼此的初恋。现在一起做生意也是并排坐着，白天夜晚24小时都不分离，与多数各自上班的夫妻真实相处时间来比较，我们算是结婚20多年了。过年也没有各自回家的说法，向来同手同脚行动，每天有说不完的开心话，在家也要亲亲抱抱举高高，出门就是手拉手走。我不烟不酒，她不施粉黛，我俩的脾气性格三观品味都极其相似，彼此爱慕尊重，可以参考我的签名。对我们来说感情已经到了高度，不需要依赖生孩子来维系婚姻，更不需要二人世界里出现一个不稳定因素。我们都不愿意因为培养孩子时难免的心急心切，分歧争执，破坏夫妻感情。8、阶层固化之下，一代胜一代的希望越发渺茫，家家户户都在拼了命送孩子往上爬，但我觉得大多数将来只能依靠父母的遗产留在现有阶层里。因为工作关系我经常接触各类学校，老师和家长，给我的总体感觉就是累，那种被逼着集体忙碌的无力感，为了孩子创造更多有利条件的紧迫感，和一件耗费时间精力巨大的工程开了头不得不继续下去的压力感。像打怪升级一样，25年后感觉到顶级了，系统又给开了新的25年的带孙子关卡。我和老婆都是清高心傲的人，不想同“宝妈宝爸”们一样甘愿付出，不愿屈服于某个设定。9、我俩都是独生子女，并且除了父母对其他亲戚血缘十分淡漠，也没有家族传承的旧观念和传宗接代的使命感，同时也是无神论者。对于什么绝后，断代的言论只会觉得无聊无趣，信则有不信则无，仅仅往上数四代的老祖宗，我不认识他，他不知道我，有了后代又怎样，我只是个普通人，几代以后连名字都湮灭了。我一生奉公守法爱国爱家，灾荒捐过款，街边救过猫，已经对得起家人和自己的良心，又不为别人而活，也无惧别人的妄言。10、我的父母，她的父母，都同意了我们丁克。我爸说他17岁开始当兵，半生为国半生为家，都没有好好为自己过，希望我和老婆怎么开心怎么过。岳父母曾经催生过，老婆态度坚决，我又和她一个鼻孔出气的，慢慢想通了也就作罢。如今家宅安宁，大家欢喜，我爸妈打牌炒股旅游钓鱼，也很疼爱她。她爸妈也很疼我，还养了个胖橘公猫当小儿子养，早上会叫它“去喊姐姐起床”，然后小舅子来挠门。一大家6个人照样开开心心过，老人不用带小孩，60岁的人精神气质都像年轻了十几岁。他们大把的退休金都能花在自己身上，也能有个安定轻松的晚年，还生劳什子孩子。知乎榛禾木现在的部分女生为什么不想生孩子？现在的部分女生为什么不想生孩子？ 结束(这个问题回答摘录至此告一段落，以后可能会有修改更新，更多回答可以参看知乎)2019-07-14👤 一叶舟 | 心理学本硕，国家二级咨询师这周我将正式迈入孕37周+的大门，足月了，要随时准备好发动了。我那个朴实无华的老公，正穿着大裤衩吭哧吭哧地收拾着待产包，有一搭没一搭地跟我聊着天。我笑话他耷拉着的那点肚腩，是二胎爹的幸福肥，要他仔细着别弯腰憋出了屁。他回应我的是老大今天还没拉臭，要不要给喂点西瓜汁。看着他仔细地在大包的侧兜里塞进了两小瓶开塞露，我突然一下涌出了眼泪。也是，只有他收拾待产包，才会知道我要用到什么。生老大时，大夫交代顺产之后必须尽早排尿排便，以免引起尿液滞留，导致类似于子宫移位乃至出血的可怕事情。护士还要求，产后第一次的尿液要接在盆里，等她们来检查。于是我老公就端着尿盆蹲在卫生间里，吹着口哨，放着水龙头，等我排尿。进出卫生间三次之后，终于“哗啦”一声，完成任务，我俩不自觉地捏了下对方的手，相视一笑，像是什么大事成功了一样。那时我想起我们恋爱时第一次一起外出，在宾馆的卫生间里我尴尬地满地转圈，因为我怕尿出来呼啦啦的声音影响了我精心打扮出的女神形象。一叶舟 | 曾奇峰心理工作室穿越了“屎尿屁”之后，我们是什么样的伴侣？]]></content>
      <categories>
        <category>生活杂记</category>
      </categories>
      <tags>
        <tag>孕事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[趣味生活简史]]></title>
    <url>%2Fposts%2F61505f7b%2F</url>
    <content type="text"><![CDATA[行至衣食住行处 坐看世事风云起内容简介本书是《万物简史》作者最新扛鼎之作、其创作灵感源自作者一次石破天惊的发现:房屋不是躲避历史的避难所、而是历史的最终归宿。在作者看来，无论世界上发生了什么，不管人们发现了什么，创造了什么，或激烈争夺了什么，最终都会以这种或那种方式投射到你的家里。战争、饥荒、工业革命、启蒙运动……这些看似与我们相距遥远的历史或许就隐藏在你的沙发里和五斗橱里，在你窗帘的皱褶里，在你松软的枕头里，在你家墙上的油漆里，在你家的自来水管道乃至抽水马桶里。于是，作者拿定主意要在自己的房屋里转转，他要在不出家门的情况下引领我们做一次有关世界历史的美妙远足。在作者的生花妙笔之下，卫生间是一部个人卫生的历史，厨房是一部烹调的历史，卧室则成了一部爱情、死亡和睡觉的历史。作者还梳理了从建筑学到电力学，从考古学到园艺学，从食物贮藏到流行病、从香料贸易到埃菲尔铁塔，从女性时装到室内装潢等方面的演变脉络，撰写了一部包罗万象的人类居家生活简史。作者以饱满的好奇心、绝妙的智慧心，独具一格的叙事腔调将《万物简史》脸炙人口的风格延续至本书的字里行间，成就了这部思想性与趣味性兼具的神奇之书。作者简介👤 比尔·布莱森，享誉世界的作家。1951年出生于美国艾奥瓦州，后定居英国，曾任职于《泰晤士报》与《独立报》，同时也为《纽约时报》、《国家地理杂志》等刊物撰文。2005年，他被任命为英国久负盛名的杜伦大学校长，并且被众多大学授予荣誉学位。2006年12月，为表彰他在文学上的杰出贡献，英国女王伊丽莎白授予他大英帝国官佐勋章（OBE）。布莱森擅长用不同的眼光来看待他所游历的世界，在他的书里，英国式的睿智幽默与美国式的搞笑绝妙地融合在了一起。他的尖刻加上他的博学，让他的文字充满了幽默、机敏和智慧，使他自己成为“目前活在世上的最有趣的旅游文学作家”（《泰晤士报》）。目录第1册前言当你从一个崭新的角度来观察一个你非常熟悉的世界时，你心里总是觉得很兴奋。第一章 | 现代生活的序幕以1851年5月1日在伦敦开幕的“万国工业博览会展览馆”为标志,现代生活的序幕由此拉开,电灯、电话、电报、抽水马桶、麻醉术、室内管道、煤气照明、制冷、汽车、飞机、摩天大楼如雨后春笋般冒出来。突然之间,有史以来第一次,在大多数人的生活当中什么都不缺，到处是一片生机勃勃的景象。戴维·坎那戴恩写到，到世纪之交的时候，“一代精英都不在教堂内而在教堂外”。第二章 | 居家的气息从古罗马人洞穴到普通住宅再到现代豪宅，居家生活的历史就是一部不断追求舒适的历史。你也许会有点吃惊地想到，对于这栋房子或任何其他房子来说，没有哪个部件的出现是必然的。一切都得经过思考——门呀，窗呀，烟囱呀，楼梯呀——其中许多经过了长时间的试验，比你想象的时间还要长得多。在最初99%的历史里，人类没有干多少事，除了繁衍后代，生存下来。从植物中获取食物是一项艰苦的工作。把小麦、稻谷、玉米、大麦和其他草类转变成主食是人类历史上一个伟大的成就，但也是一个意料之外的成就。这一切又使我们想到，我们对古人的生活方式和习惯知道得如此之少，甚至连想象都不敢想象。带着那种想法，我们终于要走进房子，并开始认识到，我们对里面的事情也是知道得如此之少。第三章 | 门厅没有哪间屋子的地位在历史上落得比门厅更靠后。门厅现在是擦鞋底、挂帽子的地方，而曾经却是住宅里最重要的屋子。直到烟囱问世，使得房子一层一层往上发展成了可能，从那之后，人们开始有了隐私和个人空间的概念，而房间的空间拓展正是建立在人们对效用和隐私不断改变的看法之上的。生活很艰难。在整个中世纪，每个人在一生中要把相当多的时间完全用来求生存，饥荒是司空见惯的。中世纪的世界是个没有储备的世界。第四章 | 厨房值得注意的是，维多利亚时代的人的胃口其实还是比较克制的。暴饮暴食的黄金时代，实际上是在18世纪。那是约翰牛时代，是有史以来哪个国家也没有创造出过的面色最红、吃得过多、随时会得冠心病的形象，为的是给别的国家留下个好印象。在18世纪的最初10年里，英国历史上两位最胖的君主花了大量的精力来吃，这也许不是偶然的。这类事情吸引报界的注意力，恰恰说明它们是个别事件，而不是惯常现象。令人感到意外的是，在很长时间里，开罐头仍是个严重的障碍。杰斐逊在食物方面还是个伟大的冒险家。他有许多别的成就，其中，他在美国是把土豆切成长条进行油炸的第一人。无法掌握自己饮食的人也往往确实吃得很差。许多比较穷的人的饮食是相当单调的。第五章 | 洗碟间和食品库在住宅的设计过程中，越来越注意把仆人挡在看不见的地方，与主人家隔开一段距离，除了绝对需要以外。厨房刚够放一张桌子和两把椅子，连在一起的洗碟间和食品库的空间更小，因为很大程度上那里是仆人们的天地。这无疑是个很怪的世界，仆人构成了人类的一个阶级，从根本上说，他们的存在是为了确保人类的另一个阶级在想要什么时，几乎马上就能伸手拿到什么。仆人构成了人类的一个阶级，从根本上说，他们的存在是为了确保人类的另一个阶级在想要什么时，几乎马上就能伸手拿到什么。仆人们做了所有这一切，受到的待遇往往是很可怕的。主人可以摆布仆人，仆人也同样可以摆布主人。第2册第六章 | 保险丝盒我们忘了，在发明电以前，世界上的光线是多么暗淡。一支蜡烛—支好的蜡烛—所提供的照度，勉强相当于一盏100电灯1%的照度。打开你家的冰箱门，里面射出的光比18世纪大多数家庭享有的光的总和还多。在历史的大部分时间里，夜晚的世界确实是个很黑暗的地方。他们开始制造容量为40加仑的专用油桶。直到今天，这种桶仍然是石油的标准计量单位。煤气灯提供极好的总体照明。它使阅读、打牌甚至交谈更加惬意……人们看书看得更多，睡觉睡得更晚。技术进步提高了光的质量，但也增加了火灾的风险。在最初几年里，没有人会想到插头和插座。因此，任何家用电器都必须直接接到系统上。爱迪生的天才并不在于发明了电灯，而在于创造了以商业规模生产和供应电灯的方法。而后者是一项大得多的、更富于挑战性的事业。第七章 | 起居室若要领会舒适的家庭生活的精神，没有哪里比得上个有着奇特名字的地方:起居室(drawing room)这个词是一个古老得多的词 withdrawing room的缩略形式，意思是“一处家人可以离开家里的其他人以享有更多隐私的空间”。这个词根本没有在英语里完全扎根和得到广泛使用，到14世纪中叶，除了在最上流的社会里以外，这个词被sitting room取而代之。第八章 | 餐厅出现餐厅的原因，不是大家突然想要在一个专门的地方吃饭，总的说来是由于家里女主人的一个简单的愿望，她不想让漂亮的装有软垫的新家具沾上油污。我们最近发现，这类家具价钱很贵，得意的主人不愿意看到任何人在上面擦手指。餐厅的到来标志着一种变化，不仅是摆饭地方的变化，而且是吃饭方式和吃饭时间的变化。人体需要维生素和矿物质，这是一门学问，要过相当长的时间才搞明白。即使今天，要是你开始掉头发，或者脚踝肿的厉害，你首先想到的不大可能是最近吃了什么，你更不会想一想你没有吃什么。饮食不当不光是坏血病的原因，也是一系列普通疾病的原因，认识到这一点是个相当缓慢的过程。维生素K跟字母顺序毫无关系。它之所以叫维生素K，是因为发现这种维生素的人、丹麦的亨里克·丹根据它在血液凝结过程中的作用，管它叫”凝血维生素(Koagulations vitamin)“。泛酸和生物素这两种维生素没有数字编号，这很大程度上是因为它们从来没有给我们制造过麻烦。氯化钠是一种很怪的物质，它由两种及其活跃的元素组成：氯、钠。钠和氯是矿物界的地狱天使，然而氯化钠却是一种无毒的食用盐。没有香料死不了人，但为了香料死了好多人。制造商做了实验，增加了齿尖的数量——有时候多大6个——最后在19世纪末确定为4个，因为4个齿尖的叉子人们用起来似乎最自在。过去人们的大部分卡路里都是在早餐时间和中午摄入的，晚餐时间只是补充少量食物，然而现在，那样的摄入方法几乎完全颠倒了过来。第九章 | 地下室原先，地下室主要用作存放煤的地方。今天，里面放着锅炉、不用的衣箱、不合时节的体育器材以及许多贴了封条的纸板箱。那些箱子几乎永远不会再打开，但每次搬家都要小心翼翼地从一栋房子搬到另一栋房子，认为有一天会有人想要一些已经在箱子里放了25年的要儿衣服。它不是个很合意的场所，但也有个补过的优点:让你了解一点房子上层建筑的情况。通过阅读、咨询、凭借灵感进行的实验，他们成功地设计并监督完成了新大陆有史以来最伟大的工程，他们成为历史上第一批通过开掘运河来学会怎么开掘运河的人。第3册第十章 | 过道过道是寓所里最不合意、最阴暗的地方，因为它没有窗户，必须借助从邻近房间开着的门里透进来的任何自然光线。靠近过道中间的地方，有一扇可以关的门——在早先的年代，这门无疑是关着的——把住宅的服务区和对面的私人区分隔开。房子完工的时候，不可能有它。它显然是为了放置在1851年还没有的某种东西才设计的，而那个东西将会改变世界，改变的速度将超出任何人的想象。第十一章 | 书房虽然“书房”这个名字使它听起来像个了不起的地方，但实际上只是个名字好听的贮藏室而已，即使在天气暖和的月份里，里面也是又暗又冷，你都不想在里面久留。如今，书房是旧家具和旧画片的最后避难所—这些东西夫妻的一方十分欢，另一方却乐意看到将其付之一炬。我们现在去那里的理由几乎只有一条，那就是检查一下捕鼠夹。很有可能，历史上爆发的最严重的鼠疫似乎跟大家鼠毫无关系，至少在英国是这样。很少有人喜欢蝙蝠，这确实是很不幸的，因为蝙蝠干的好事要比坏事多得多。世界上的蝙蝠数量，要比大多数人知道的多得多。实际上，全部哺乳动物种类总共大约1100种，其中大约1/4是蝙蝠。从大小方面说，小到熊蜂蝙蝠——名副其实，它们不过熊蜂那么大，因而是最小的哺乳动物，大到澳大利亚和南亚的翼展达6英尺的巨大狐蝠，应有尽有。哪里的事态都有可能变得越来越糟，而且糟得多。第十二章 | 花园对于许多人来说，今天所谓的园艺就是草坪，几乎不指任何别的东西。美国的草坪所占的面积为5万平方英里，超过了任何一种农作物。家庭草坪里的绿草要做的事，和自然界的野草是一样的，那就是长到大约2英尺高，开花，枯黄，死亡。对于我们大多数人来说，养一个漂亮的草坪，几乎是我们所干的最不绿色的事情，这是极具讽刺意味的。任何形式的侵入他人地界，不管多么无辜，多么轻微，势必会被看成是恶意的。对我们大多数人来说，养一个漂亮的草坪，几乎是我们干的最不绿色的事情，这是极具讽刺意味的。第十三章 | 紫色屋把它叫作紫色屋没有别的理由，只因为我们搬进去住的时候，那间屋子的墙壁是漆成那种颜色的。在原先的图纸上，它本来标着“客厅”两个字，但后来在调整的过程中把那个重要房间移到了隔壁。在那次调整中，仆人们没了拟建的“配餐室”，而给了马香先生一间宽敞的餐厅。不管叫什么名字，反正这间屋子是打算用作一种客厅的，很可能是用来接待喜欢的客人。实际情况并不是那样一丝不差的，建筑风格不会仅仅因为一位君主的死去而改变，也不会因为一个朝代很长而保持不变。它是世界的最后一栋房子，它的前面是一块未经探索的大陆，它的背后是整个已知的世界。这栋房子背向那个旧世界，眺望那个空荡荡的未知的新世界。实际上什么东西都得从一个远方的代理商那里订货。什么要求都得说得清清楚楚，但最终你还得依赖一个陌生人的判断力和诚实的服务，让人失望的可能性是很大的。第十四章 | 楼梯现在，我们来到了这栋房子里最危险的部分。实际上，无论在哪里，这都是最可能出现险情的环境之楼梯。谁也不知道楼梯到底有多危险，因为说来也怪，这方面的记录很少。据最保守的统计，在造成偶然死亡的最常见的原因当中，在楼梯上摔倒排在第二位，落在车祸后面，但遥遥领先于溺死、烧死和其他可怕的不幸事故。楼梯的安全问题不是一个而是两个问题：“要避免引发事故的情况出现；要设计这样的楼梯：万一发生事故时，能把伤痛降低到最低程度。”虽然白色在整个19世纪不断地有所改善，但直到20世纪40年代，由于在涂料里添加了氧化钛，才有了真正鲜亮和耐久的白色。……耐久的深黑色颜料是从焦油和沥青中提炼出来的，19世纪末以前还不容易弄得到。现在，我们可以走上楼梯，来到一个房间。它也许从来没有真正毒死过什么人，但它很可能是带来痛苦和绝望的地方。它所带来的痛苦和绝望，要超过家里所有别的房间所带来的痛苦和绝望的总和。第4册第十五章 | 卧室卧室是个古怪的地方，我们在这里待的时间最长，干的事情最少，而且大多数情况下是悄悄地、无意识地干的，家里没有哪个地方能与之相比。然而，生活中许多影响最大、持续最久的不幸之事恰恰发生在卧室里。要是你快要死去或身体不舒服，精疲力竭，性功能不正常，眼泪汪汪，焦虑万分，因情绪低落而不想见人，要不然就心里不大平静和不大高兴，卧室很可能就是能找到你的地方。许多病人没有死在手术台上，却死于一种因感染而更加持久、更加剧烈的痛苦。在现代社会到来之前，即使没有外科医生令人生畏的干预，人也是在以多种方式死亡。第十六章 | 卫生间自从toilet这个词问世以后，它所经历的变化之多，也许是英语里哪个词都比不上的。起初，大约在1540年，它指的是一种布，呈缩略形式toile。现在toile依然用来指一种亚麻织物。然后，它的意思变成了用于梳妆台上的一种布。接着，它的意思变成了梳妆台上的物品。接着，它的意思变成了梳妆台本身，然后变成了穿戴的动作，然后变成了一边穿戴一边接待客人的动作，然后变成了梳妆室，然后变成了靠近卧室的任何隐蔽房间，然后变成了用作厕所的屋子，最后变成了厕所本身。对许多文化来说，讲究清洁和普遍重视个人卫生在很长时间里一直是很重要的，因此很难知道从何谈起。到18世纪，若要洗个澡，最可靠的办法是发神经病。然后，人家会用水把你浇个够。在不讲卫生、没有抗生素的世界里，造成大批人死亡的传染病是经常发生的。在19世纪，各种各样的情况都会让人送了性命。第十七章 | 梳妆室对于任何有理性的人来说，时尚往往是一件几乎无法捉摸的事。在许多历史时期——也许在大多数历史时期——时尚的全部推动力看起来似乎一直是可笑至极的。要是同时还能觉得不舒服至极，那就是更大的成功了。穿着不实用的衣服，是一种表明某人不必干体力活的方式。在整个历史上，在许多文化里，这一般都要比穿着舒服重要得多。穿着不实用的衣服，是一种表明某人不必干体力活的方式。詹妮纺纱机不是像常说的那样是以他女儿的名字命名的，“詹妮”是个北方用于，意思是“机械”。阿克莱特是工业革命早期所有人物中最没有意思、最没有创造能力的人，却又是最成功的人。历史上也许还从来没有哪个人，能像发明轧棉机的伊莱·惠妮特那样，以一项简单、善意的发明产生如此普遍的繁荣、个人的失望，并在无意中给许多人带来苦难。胸罩(brassiere)一词源于法语，意思是“上臂”，由查尔斯·R·德伯瓦公司首次使用。第十八章 | 幼儿房在现代社会之前，儿童不但不受重视，而且实际上还不大讨人喜欢。把爱投资在小孩子身上是如此危险，如此不划算——无论在哪里，爱是不能给的，都把它看成是毫无意义地浪费精力。感情压根儿谈不上。按照她令人寒心的看法，孩子只是“一种产品”而已。事实上，从怀胎十月起，生命里充满了危险。对母婴双方来说，最危险的关口是分娩本身。对孩子来说，出生仅仅是开始。早在1847年，维也纳有一位名叫伊格纳茨·泽梅尔魏斯的医生已经意识到，只要医院的工作人员在稍稍加氯的水里洗洗手，各种死亡便会大幅度下降，但对他的话几乎谁也不加理会。还要再过几十年，才会普遍采取消毒措施。据报道，有的孩子累得连吃饭的力气都没有，有时候嘴里还含着食物就睡着了。第十九章 | 阁楼我们的故事是从这个阁楼讲起的，现在，我们重新来到这个位于房屋顶部的地方，我们的这次足不出户探寻人类居家生活历程的美妙远足，到这里也就将画上一个圆满的句号，有朝一日—别以为这是遥远的一天——在60亿左右不大富裕的人当中，许多人势必会要求拥有我们今天拥有的东西，而且要像我们容易得到那样容易得到它们。那就意味着要求这颗星球能方便地甚至大方地给予更多的资源。最具讽刺意味的可能是，如果为了过得舒适和快乐而无休止地索取，我们会制造出一个既不舒适又无快乐可言的世界。在这一切变化中，具有讽刺意味的是，正当世界对大多数人来说变得更加惬意，如灯光更加明亮、管子更加可靠、休闲机会更多、需求得到更大程度的满足、娱乐活动更加丰富时,对马香先生这样的人来说,世界正在分崩离析。最具讽刺意味的可能是，如果为了过得舒适和快乐而无休止地索取，我们会制造出一个既不舒适又无快乐可言的世界。感悟以前的生活条件是如此的艰苦，人们又是如此的愚蠢，可是人类还是走到了现在，而且越来越好。这是多么得不容易，要学会珍惜，要学会谦虚，难保后来的人们不会像看傻子一样看着你。这本书共计4册，可以当做睡前读物随手翻翻，偶尔还刷新之前在历史课本上看到的故事。讲真，以前皇帝或贵族过得生活肯定没有现在那么方便、那么舒服，历史在不断进步，未来虽然曲折，总会向着好的方面发展。要心怀希望，冲呀！！！🐷]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>趣味生活简史</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[体重记录]]></title>
    <url>%2Fposts%2Fe93199a0%2F</url>
    <content type="text"><![CDATA[var myChart=echarts.init(document.getElementById("echarts9643")),option={tooltip:{trigger:"axis"},title:{show:!0,text:"日常体重记录"},legend:{data:["体重"]},toolbox:{show:!0,orient:"horizontal",x:"right",y:"top",color:["#1e90ff","#22bb22","#4b0082","#d2691e"],backgroundColor:"rgba(0,0,0,0)",borderColor:"#ccc",borderWidth:0,padding:5,showTitle:!0,feature:{mark:{show:!0,title:{mark:"辅助线-开关",markUndo:"辅助线-删除",markClear:"辅助线-清空"},lineStyle:{width:1,color:"#1e90ff",type:"dashed"}},dataZoom:{show:!0,title:{dataZoom:"区域缩放",dataZoomReset:"区域缩放-后退"}},magicType:{show:!0,title:{line:"动态类型切换-折线图",bar:"动态类型切换-柱形图",stack:"动态类型切换-堆积",tiled:"动态类型切换-平铺"},type:["line","bar","stack","tiled"]},restore:{show:!0,title:"还原",color:"black"},saveAsImage:{show:!0,title:"保存为图片",type:"jpeg",lang:["点击本地保存"]},myTool:{show:!0,title:"自定义扩展方法",icon:"image://../asset/ico/favicon.png",onclick:function(){alert("myToolHandler")}}}},calculable:!0,dataZoom:{show:!0,realtime:!0,start:20,end:80},xAxis:{type:"category",boundaryGap:!1},yAxis:{type:"value",min:60,axisLabel:{formatter:"{value} (kg)"}},series:[{name:"体重",type:"line",data:[{name:"2019-02-10",value:["2019-02-10",65]},{name:"2019-03-10",value:["2019-03-10",67.5]},{name:"2019-03-23",value:["2019-03-23",68.75]},{name:"2019-03-24",value:["2019-03-24",68.25]},{name:"2019-03-30",value:["2019-03-30",69.35]},{name:"2019-04-01",value:["2019-04-01",67.8]},{name:"2019-04-02",value:["2019-04-02",67.3]},{name:"2019-04-07",value:["2019-04-07",67.9]},{name:"2019-04-09",value:["2019-04-09",68.9]},{name:"2019-04-11",value:["2019-04-11",69.05]},{name:"2019-04-12",value:["2019-04-12",68.3]},{name:"2019-04-14",value:["2019-04-14",67.2]},{name:"2019-04-15",value:["2019-04-15",69.25]},{name:"2019-04-18",value:["2019-04-18",68.35]},{name:"2019-04-22",value:["2019-04-22",68.4]},{name:"2019-04-23",value:["2019-04-23",67.75]},{name:"2019-04-24",value:["2019-04-24",68.45]},{name:"2019-04-26",value:["2019-04-26",67.5]},{name:"2019-04-27",value:["2019-04-27",67.6]},{name:"2019-04-28",value:["2019-04-28",67.65]},{name:"2019-04-29",value:["2019-04-29",67.1]},{name:"2019-04-30",value:["2019-04-30",66.75]},{name:"2019-05-02",value:["2019-05-02",68.5]},{name:"2019-05-04",value:["2019-05-04",66.4]},{name:"2019-05-07",value:["2019-05-07",68.3]},{name:"2019-05-08",value:["2019-05-08",67.7]},{name:"2019-05-09",value:["2019-05-09",67.35]},{name:"2019-05-11",value:["2019-05-11",66.6]},{name:"2019-05-12",value:["2019-05-12",67.4]},{name:"2019-05-13",value:["2019-05-13",66.95]},{name:"2019-05-14",value:["2019-05-14",67.55]},{name:"2019-05-16",value:["2019-05-16",67]},{name:"2019-05-18",value:["2019-05-18",68.4]},{name:"2019-05-19",value:["2019-05-19",66.4]},{name:"2019-05-20",value:["2019-05-20",67.4]},{name:"2019-05-21",value:["2019-05-21",66.8]},{name:"2019-05-22",value:["2019-05-22",67.65]},{name:"2019-05-23",value:["2019-05-23",67.4]},{name:"2019-05-24",value:["2019-05-24",67.5]},{name:"2019-05-25",value:["2019-05-25",67.4]},{name:"2019-05-26",value:["2019-05-26",67.4]},{name:"2019-05-27",value:["2019-05-27",67.3]},{name:"2019-05-28",value:["2019-05-28",67.4]},{name:"2019-05-30",value:["2019-05-30",65.95]},{name:"2019-06-02",value:["2019-06-02",66.95]},{name:"2019-06-03",value:["2019-06-03",67]},{name:"2019-06-04",value:["2019-06-04",67.5]},{name:"2019-06-05",value:["2019-06-05",68.35]},{name:"2019-06-06",value:["2019-06-06",67.6]},{name:"2019-06-07",value:["2019-06-07",67.9]},{name:"2019-06-09",value:["2019-06-09",67.55]},{name:"2019-06-11",value:["2019-06-11",67.25]},{name:"2019-06-13",value:["2019-06-13",67.6]},{name:"2019-06-14",value:["2019-06-14",67.25]},{name:"2019-06-15",value:["2019-06-15",66.7]},{name:"2019-06-16",value:["2019-06-16",66.15]},{name:"2019-06-18",value:["2019-06-18",67.5]},{name:"2019-06-19",value:["2019-06-19",65.55]},{name:"2019-06-22",value:["2019-06-22",67.5]},{name:"2019-06-23",value:["2019-06-23",66.8]},{name:"2019-06-26",value:["2019-06-26",67.55]},{name:"2019-06-28",value:["2019-06-28",66.75]},{name:"2019-06-29",value:["2019-06-29",66.2]},{name:"2019-07-03",value:["2019-07-03",68.45]},{name:"2019-07-05",value:["2019-07-05",68.35]},{name:"2019-07-07",value:["2019-07-07",67.75]},{name:"2019-07-08",value:["2019-07-08",69.2]},{name:"2019-07-10",value:["2019-07-10",68.75]},{name:"2019-07-11",value:["2019-07-11",68.15]},{name:"2019-07-13",value:["2019-07-13",67.95]},{name:"2019-07-15",value:["2019-07-15",62.3]},{name:"2019-07-16",value:["2019-07-16",68.05]},{name:"2019-07-17",value:["2019-07-17",67.35]},{name:"2019-07-18",value:["2019-07-18",67]},{name:"2019-07-19",value:["2019-07-19",62.35]},{name:"2019-07-21",value:["2019-07-21",66.95]},{name:"2019-07-22",value:["2019-07-22",66.65]},{name:"2019-07-24",value:["2019-07-24",68.45]},{name:"2019-07-25",value:["2019-07-25",67.8]},{name:"2019-07-26",value:["2019-07-26",67.2]},{name:"2019-07-27",value:["2019-07-27",67.35]},{name:"2019-07-29",value:["2019-07-29",67.8]},{name:"2019-07-31",value:["2019-07-31",66.85]},{name:"2019-08-04",value:["2019-08-04",66.95]},{name:"2019-08-06",value:["2019-08-06",67.8]}]}]};myChart.setOption(option)]]></content>
      <categories>
        <category>日常生活</category>
      </categories>
      <tags>
        <tag>体重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新记录]]></title>
    <url>%2Fposts%2F77b56474%2F</url>
    <content type="text"><![CDATA[时间更新说明2019-07-13内容补充：更新记录2019-07-13功能添加：点击效果2019-07-05功能优化：博客链接2019-07-03内容补充：关于我2019-07-02功能添加：网站运行时间2019-07-01功能添加：文字统计、阅读时间统计2019-06-25功能添加：Hexo博客初始化。]]></content>
      <categories>
        <category>Muhouer&#39;s blog</category>
      </categories>
      <tags>
        <tag>更新记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客SEO优化之链接优化]]></title>
    <url>%2Fposts%2Fa8db5a9b%2F</url>
    <content type="text"><![CDATA[写在前面默认的permalinkpermalink: :year/:month/:day/:title/缺点如下命名方式层次过多，爬虫会嫌麻烦。对于中文命名，如果要引用自己的链接，会重新编码成好长一串，超级麻烦。中文链接在百度Google权重很低。解决办法有没有其他办法呢？实在想不出来了，还是因为我比较懒，喜欢现成的。皇天不负有心人，通过一番搜索，终于找到一个插件hexo-abbrlink。注意之前如果有做评论或访问计数配置的，会全部失效,一切重头开始。hexo-abbrlink实现思路对标题+时间进行md5然后再转base64，保存在front-matter中。如何安装添加插件到hexo:1npm install hexo-abbrlink --save修改config.yml文件中的永久链接：1permalink: posts/:abbrlink/ # “posts/” 可自行更换两种设置：alg - 算法（）rep - Represent（生成的链接可以以十六进制或十六进制值表示）1234# abbrlink configabbrlink: alg: crc32 # 算法(Algorithm):目前支持crc16和crc32，默认为crc16 rep: hex # 表示(Represent):生成的链接可以以十六进制或十进制值表示，默认十进制示例生成的链接如下所示:12345crc16 &amp; hexhttps://post.zz173.com/posts/66c8.htmlcrc16 &amp; dechttps://post.zz173.com/posts/65535.html12345crc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://post.zz173.com/posts/1690090958.html局限性crc16的最大帖子数为65535。(对于个人博客网站，这个数字还算不错)更多信息hexo-abbrlink介绍参考资料https://github.com/Rozbo/hexo-abbrlink#limitation]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>SEO优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作2年感悟]]></title>
    <url>%2Fposts%2Fd3b108fe%2F</url>
    <content type="text"><![CDATA[写在前面从2017年7月开始工作，至今已有2年。工作已是第二份工作，之前一直有思考，不过没有记录，以后要养成记录的习惯，这是个好习惯。……(太矫情，写完之后，中间部分全部删了🙃)最后以后在职场上一定注意：自信，一定要自信，即便你能力或技术不是很好。不会的一定去查、去问，不能憋在那避而不谈。能利用的资源一定要利用，那样会节省很多不必要的力气。资历老说话就是好使、众人拾材火焰高。不能忘记学习、成长，工作不是你的全部，除了工作以外，一定要坚持学习，时间会证明：一点点成长最后会给你带来意想不到的收获。]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub搭建一个自己的hexo博客]]></title>
    <url>%2Fposts%2F9fe43db6%2F</url>
    <content type="text"><![CDATA[写在前面一直想搭建一个个人博客，无奈有拖延症，一直拖到现在。为什么开始做了呢？最近压力很大，为了防止乱花钱，给自己找点事做。于是，兜兜转转又回到搭建博客的事，来来回回看了很多静态博客(纠结症)，比如docsify、VuePress等等，最终还是选择了hexo，毕竟这也算是我静态博客的启蒙，不能忘本，第一个系列当然给Hexo.本地部署过程环境关于node、npm、git等的安装，在这里先不展开，以后抽空补上。安装 hexo 客户端1npm install -g hexo-cli创建hexo的文件夹(文件夹名称hexo可修改为其他)12cd hexo # hexo 改为自己命名的文件夹名称hexo init # hexo 初始化选择主题hexo本身自带 landscape 主题，不过个人觉得比较丑，改为了比较简约的next 主题。接下来主题均基于next主题下载主题1git clone https://github.com/iissnan/hexo-theme-next修改 theme编辑 hexo/_config.yml，找到 theme 那一行配置，修改为 next本地启动看看安装完之后，我们可以在本地启动看看博客初始化的效果。生成静态文件1hexo ghexo 最终运行的是静态文件，包括js，css和html等，这些文件统一放在 public 文件夹。安装 hexo-server1npm install hexo-server --save启动 server1hexo s在浏览器打开 localhost:4000，会看到一个 Hello World的页面。恭喜你，部署成功。添加“分类”，“关于”和“标签”菜单到此已经把博客安装好了，不过要想看起来更好点，还需要做些其他配置。取消 tags、about、categories 注释在主题配置文件next/_config.yml 在menu下去掉tags、about、categories 注释。创建 tags，about，categories在 hexo 文件夹下执行以下shell命令1hexo new page tags会在 source 文件夹生成 tags 文件夹，编辑里面的 index.md ，添加12type: &quot;tags&quot;comments: false安装同样操作即可添加 categories；添加about相对简单，不需要修改 md 文件的 type，因为tags、categories是特殊目录类型，about只是简单的一个 md。为文章添加标签和分类在文章 md 文件开头 title 的下面，增加类似，就可以归类到tag和 category123456789101112131415tags: #文章标签可，空，多标签请用格式[tag1,tag2,tag3]，如下，注意!!&quot;tags:&quot;后面有个空格tags: [tag1, tag2, tag3, ...]# 下面这种方式似乎仅限于hexo 3.0，应该包括以上吧...tags: - tags1- tags2- ...# 这种方式似乎仅限于hexo 3.0，应该包括以上吧...categories: - tags_level_1- tags_level_2- tags_level_3- ...添加头像图片在 hexo/_config.yml 找到配置 avatar，增加图片路径，注意图片类型要对的上。1avatar: /images/avatar.jpeg新建文章1hexo new post new1就会在 source/_post 文件夹下生成 new1.md 文件，编辑 md 文件即可。这里为什么是 post ？这里涉及 hexo 的模版行为，在 scaffolds 目录下初始定义了3个模板，draft、page、post，文章就是用到了 post。部署到Github本地服务起来之后，基本信息无误，可以先尝试部署到 GitHub 上，之后再慢慢迭代，总会变得更好！github上新建一个仓库登录github后，在界面右上角用户信息点击左边的加号，新建一个repository然后给新建的仓库起个名字，注意：这个名字必须跟用户名一致，github才会默认设置成用户的博客。必须选择public，否则即便部署完成访问也会404。将本地搭建好的hexo发布到github下面是在项目中生成静态文件的命令：1$ hexo generate简写，结果是一样的1$ hexo g执行完以上代码，会在项目的根目录下生成public文件夹安装插件1npm install hexo-deployer-git --save修改网站配置文件_config.yml,添加deploy信息1234deploy: type: git repo: git@github.com:muhouer/muhouer.github.io.git branch: master上面的repo的配置信息，替换成自己的项目名字设置SSH Keys先检查机器上是否已经存在id_rsa.pub文件1$ ls -al ~/.ssh不存在的话执行以下命令生成，一路回车即可。1$ ssh-keygen -t rsa -C &quot;xxxxxx@xxx.com&quot; # 改成自己的邮箱复制id_rsa.pub文件内容，在GitHub的 settings 中，点选 SSH keys，添加一个 key，将内容粘贴进去。测试是否添加成功，在刚刚的机器上输入，配置成功会有类似如下提示，至此本地跟远程github的连接已经建立1ssh -T git@github.com在项目中，直接生成静态文件，上传就可以了：123$ hexo clean //清除缓存文件db.json和已生成的静态文件public$ hexo g //生成网站静态文件到默认设置的public文件夹$ hexo d //部署网站到设定的仓库部署完成之后，访问 https://muhouer.github.io/ ,改成你自己的地址即可访问。小结以上就是在GitHub上搭建一个自己的hexo博客的大致过程，目前还是比较简单，接下来几篇将会记录一下next主题的相关配置以及文章美化方面的内容，以防记性不好，最近老是健忘。参考资料http://durant35.github.io/2016/07/16/hexo_hexo%E5%88%86%E7%BA%A7%E7%9B%AE%E5%BD%95%E4%B8%8E%E5%A4%9A%E6%A0%87%E7%AD%BE/https://github.com/hexojs/hexohttps://albenw.github.io/posts/3454819c/https://segmentfault.com/a/1190000018250408?utm_source=tag-newesthttps://www.cnblogs.com/kex1n/p/5229493.html]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
  </entry>
</search>

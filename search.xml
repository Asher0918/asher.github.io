<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PostgreSQL简介]]></title>
    <url>%2Fposts%2Fb81a5cf5%2F</url>
    <content type="text"><![CDATA[简介PostgreSQL 是一个功能强大、特性丰富、结构复杂的开源关系型数据库，它的起源可以追溯到1986年，当时它是加州大学伯克利分校 POSTGRES 项目的一部分。安装macOS安装使用 HomeBrew 安装默认的版本可能会比较低，可以下载安装包进行安装，参考第二种方式。1234567$ brew search postgresql==&gt; Formulaepostgresql postgresql@10 postgresql@9.4 postgresql@9.5 postgresql@9.6==&gt; Casksnavicat-for-postgresql navicat-for-postgresql$ brew install postgresql@10下载 Postgres.app 再安装参考 postgresapp 官网Windows安装进入 下载地址，选择相应的版本下载安装即可。CentOS安装通过 yum 进行安装详细可参考 Linux下的安装123456$ yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm$ yum install postgresql11$ yum install postgresql11-server # 可选$ /usr/pgsql-11/bin/postgresql-11-setup initdb # 初始化，可选$ systemctl enable postgresql-11 # 允许自启动，可选$ systemctl start postgresql-11 # 启动下载 rpm 包安装123456789# 安装相应PG版本$ rpm -ivh pgdg-centos-XXX.rpm# 更新库$ yum update# 安装相应的版本，包括常用的pgadmin工具$ yum --enablerepo=pgdgXX install postgresqlXX-server pgadmin3_XX postgresqlXX-contrib# 配置PATH环境变量，并使之生效$ cat /etc/profile$ source /etc/profile源码安装直接从官网 PostgreSQL 下载相应版本的源码包。1234567891011121314151617# 新建PG专用的用户$ groupadd postgres$ useradd -g postgres postgres# 解压编译$ tar -xf postgresql-X.X.X.tar.bz2 &amp;&amp; cd postgresql-X.X.X$ ./configure --prefix=/opt/postgre$ make$ make install# 编译contrib目录下的一些工具$ cd contrib &amp;&amp; make$ make install# 绑定数据库文件存储目录$ export PGDATA=/home/xxx/Workspace/databases/postgre/data$ /opt/postgre/bin/initdb -D $PGDATA# 启动、停止数据库$ /opt/postgre/bin/pg_ctl -D $PGDATA -l logfile start$ /opt/postgre/bin/pg_ctl -D $PGDATA -l logfile stop添加用户和数据库初次安装后，默认生成一个名为 postgres 的数据库和一个名为 postgres 的数据库用户，同时还生成了一个名为 postgres 的 Linux 系统用户。使用PostgreSQL控制台新增用户123456789$ sudo adduser newdbuser # 新建一个Linux新用户$ sudo su - postgres # 切换用户$ psql # 登录PostgreSQL控制台,相当于系统用户postgres以同名数据库用户的身份，登录数据库，不用输入密码$ # 为postgres用户设置一个密码postgres=# \password postgres postgres=# CREATE USER newdbuser WITH PASSWORD 'password'; -- 创建数据库用户newdbuserpostgres=# CREATE DATABASE newdb OWNER newdbuser; -- 创建用户数据库newdb，并指定所有者为newdbuser。postgres=# GRANT ALL PRIVILEGES ON DATABASE newdb to newdbuser;-- 将newdb数据库的所有权限都赋予newdbuserpostgres=# \q使用shell命令行新增用户123456$ sudo -u postgres createuser --superuser newdbuser # 创建数据库用户 newdbuser，并指定其为超级用户$ sudo -u postgres psql # 登录数据库控制台$ # 设置 newdbuser 用户的密码，完成后退出控制台postgres=# \password newdbuser postgres=# \q$ sudo -u postgres createdb -O newdbuser newdb # 创建数据库 newdb，并指定所有者为 newdbuser控制台常见命令123456789\h：查看SQL命令的解释，比如\h select。\?：查看psql命令列表。\l：列出所有数据库。\c [database_name]：连接其他数据库。\d：列出当前数据库的所有表格。\d [table_name]：列出某一张表格的结构。\du：列出所有用户。\e：打开文本编辑器。\conninfo：列出当前数据库和连接的信息。基本数据库操作12345678910111213141516171819202122# 创建新表CREATE TABLE xxx_tb(name VARCHAR(20), create_date DATE);# 插入数据INSERT INTO xxx_tb(name, create_date) VALUES('xxx', '2019-09-25');# 查询记录SELECT * FROM xxx_tb;# 更新记录UPDATE xxx_tb set name = 'yyy' WHERE name = 'xxx';# 删除记录DELETE FROM xxx_tb WHERE name = 'yyy' ;# 添加表列ALTER TABLE xxx_tb ADD mobile_phone VARCHAR(11);# 更新表结构ALTER TABLE xxx_tb ALTER COLUMN create_date SET NOT NULL;# 更改列名ALTER TABLE xxx_tb RENAME COLUMN create_date TO create;# 删除列ALTER TABLE xxx_tb DROP COLUMN mobile_phone;# 更改表名ALTER TABLE xxx_tb RENAME TO backup_xxx_tb;# 删除表DROP TABLE IF EXISTS backup_xxx_tb;日志查看PostgreSQL 日志分为三类，分别是 pg_log、pg_xlog 和 pg_clog，一般保存在 $PGDATA 对应的目录下。pg_log —— 数据库运行日志，默认开启，可以通过配置 $PGDATA/postgresql.conf 。这个日志一般是记录服务器与DB的状态，比如各种Error信息，定位慢查询SQL，数据库的启动关闭信息，发生checkpoint过于频繁等的告警信息，诸如此类。linux自带的路径一般在 /var/log/postgres 下面。该日志有.csv格式和.log。个人建议用前一种，因为一般会按大小和时间自动切割，毕竟查看一个巨大的日志文件比查看不同时间段的多个日志要难得多。另外这种日志是可以被清理删除，压缩打包或者转移，同时并不影响DB的正常运行。当我们有遇到DB无法启动或者更改参数没有生效时，第一个想到的就是查看这个日志。pg_xlog —— WAL日志，强制开启。记录的 PostgreSQL 的 WAL 信息，也就是一些事务日志信息(transaction log)，默认单个大小是16M，源码安装的时候可以更改其大小。这些信息通常名字是类似’000000010000000000000013’这样的文件，这些日志会在定时回滚恢复(PITR)，流复制(Replication Stream)以及归档时能被用到，这些日志是非常重要的，记录着数据库发生的各种事务信息，不得随意删除或者移动这类日志文件，不然你的数据库会有无法恢复的风险当你的归档或者流复制发生异常的时候，事务日志会不断地生成，有可能会造成你的磁盘空间被塞满，最终导致DB挂掉或者起不来。遇到这种情况不用慌，可以先关闭归档或者流复制功能，备份 pg_xlog 日志到其他地方，但请不要删除。然后删除较早时间的的 pg_xlog，有一定空间后再试着启动 Postgres。pg_clog —— 事务提交日志，记录事务的元数据，强制开启。pg_clog 这个文件也是事务日志文件，但与 pg_xlog 不同的是它记录的是事务的元数据(metadata)，这个日志告诉我们哪些事务完成了，哪些没有完成。这个日志文件一般非常小，但是重要性也是相当高，不得随意删除或者对其更改信息。配置文件*pg_hba.conf *—— 客户端访问和认证受到标准的 PostgreSQL 的基于主机的认证文件的控制。其中的认证文件即 是 pg_hba.conf。一般格式是一组记录，每行一个。一个记录由多个被空格或者制表符分隔的域组成。如果域值被加上引号，域可以包含空格。记录不能跨越多行。配置的具体含义可以参考 pg_hba.conf文件说明与配置。postgresql.conf —— 配置文件主要影响这服务器实例的基本行为，比如允许的连接数，操作允许占用的最大内存数，指定哪些用户可以用何种方式连接到数据库等等。当然这一切在数据库安装好时都有一个默认值，但是如果你需要对你的数据库进行定制的话，可以对这些数值进行符合需求的修改。配置的具体含义可以参考 PostgreSQL 配置文件postgresql.conf。防火墙、SELinux 设置PostgreSQL 默认使用 5432 端口，也可以在 postgresql.conf 文件中设置，可以使用如下命令开启防火墙端口。123456# 暂时有效$ firewall-cmd --add-port=5432/tcp# 永久生效$ firewall-cmd --permanent --add-port=5432/tcp# 在iptables中开启$ iptables -A INPUT -p tcp --dport 5432 -m state --state NEW,ESTABLISHED -j ACCEPT如果开启了 SELinux 服务，可能会在使用中遇到各种各样的权限问题。123456# 修改数据库的存放位置，必须添加一些新上下文来匹配新位置$ semanage fcontext -a -t postgresql_db_t "/new/location(/.*)?"# 默认端口不起作用，需要匹配postgre的端口类型为你想要的端口$ semanage port -a -t postgresql_port_t -p tcp 5433# 如果APP需要通过TCP/IP与PG交互，你需要告诉SELinux允许这个操作$ setsebool -P httpd_can_network_connect_db on其他PostgreSQL 诞生于学院派，没有局限于当时的一些硬件条件，MySQL 发展自程序员的业余作品，为当时的小内存小外存的硬件条件做了特殊的处理，随着硬件的不断发展，这些处理在现在看来倒成了一个缺点。MariaDB 由 MySQL 的创始人 Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司 MySQL AB 卖给了SUN，此后，随着SUN被甲骨文收购，MySQL 的所有权也落入 Oracle 的手中。MariaDB 名称来自 Michael Widenius 的女儿 Maria 的名字。MariaDB 发展势头也很不错，对应版本和 MySQL 也基本兼容。]]></content>
  </entry>
  <entry>
    <title><![CDATA[DNS协议介绍]]></title>
    <url>%2Fposts%2F13c9dbc5%2F</url>
    <content type="text"><![CDATA[前言DNS 协议也就是在做 DNS 解析时，客户端与服务端之间的通信协议。DNS 协议建立在 UDP 或 TCP 协议之上，默认使用 53 号端口。客户端默认通过 UDP 协议进行通讯，但是由于广域网中不适合传输过大的 UDP 数据包，因此规定当报文长度超过了 512 字节时，应转换为使用 TCP 协议进行数据传输。详见 RFC1035 4.MESSAGES 部分。客户端认为 UDP 响应包长度可能超过 512 字节，主动使用 TCP 协议；客户端使用 UDP 协议发送 DNS 请求，服务端发现响应报文超过了 512 字节，在截断的 UDP 响应报文中将 TC 设置为 1 ，以通知客户端该报文已经被截断，客户端收到之后再发起一次 TCP 请求。报文格式整个报文的格式如下，包括了五部分组成。1234567891011+---------------------+| Header | 报文头，定义了报文是请求还是应答、错误码以及其它的一些标志位+---------------------+| Question | 查询请求，包括查询类型(QTYPE)、查询类(QCLASS) 以及查询的域名(QNAME)+---------------------+| Answer | 应答资源记录(RRs)+---------------------+| Authority | 授权资源记录(RRs)+---------------------+| Additional | 附加信息资源记录(RRs)+---------------------+报文头123456789101112131415 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| ID |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+|QR| Opcode |AA|TC|RD|RA| Z | RCODE |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| QDCOUNT |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| ANCOUNT |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| NSCOUNT |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| ARCOUNT |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+字段含义如下:字段备注ID16Bits ，用于生成任何类型的查询。响应报文会原样带回，用于客户端区分不同的请求应答。QR1Bits，请求 (0 Question) ，应答 (1 Response)。Opcode4Bits，设置查询的种类，0 标准查询 QUERY、1 反向查询 IQUERY、2 服务器状态查询 STATUS、3~15 保留。响应报文会原样带回。AA1Bits，授权应答(AuthoritativeAnswer)，响应报文生效，用于标示服务器响应报文是否为授权服务器返回的结果，可能是在本地 Cache 的缓存。TC1Bits，截断(TrunCation)，报文因为超过了允许的长度，导致被截断。RD1Bits，用于请求中，期望使用递归查询。RA1Bits，用于响应中，如果服务器支持递归查询则设置为 1 ，否则设置为 0 。RCODE4Bits，应答码(ResponseCode)，会在响应报文中设置。含义如下：0 没有错误；1 报文格式错误(Format Error)，服务器解析请求报文时报错；2 服务器失败(Server Failure)，因为服务器的原因导致没办法处理这个请求；3 名字错误(Name Error)，只对授权域名解析服务器有意义，解析的域名不存在；4 没有实现(Not Implemented)，域名服务器不支持查询类型；5 拒绝(Refused)，由于服务器设置的策略拒绝给出应答，通常是安全的配置；6-15 保留值，暂未使用。QDCOUNT无符号16位整数，表示报文请求段中的问题记录数。ANCOUNT无符号16位整数，表示报文回答段中的回答记录数。NSCOUNT无符号16位整数，表示报文授权段中的授权记录数。ARCOUNT无符号16位整数，表示报文附加段中的附加记录数。为加快 DNS 的查询速度，一般会在服务端缓存一段时间，所以有可能 DNS 会返回缓存在 Cache 中的内容，那么此时就会将 AA 响应设置为 0 ，也就是是这里显示的 Non-authoritative answer 。查询请求用来标识，查询的请求参数，同时需要在头中设置 QDCOUNT 这个字段。1234567891011 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| |/ QNAME // /+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| QTYPE |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| QCLASS |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+字段含义如下:字段注释QNAME域名被表示为标签序列，每个标签包含一个字节表示后续字符串长度，以及这个字符串，以0长度和空字符串来表示域名结束。请注意，此字段可能是奇数个字节，不需要进行边界填充对齐。QTYPE2个字节，表示查询类型，取值可以为任何可用的类型值，以及通配码来表示所有的资源记录。QCLASS2个字节，表示查询的协议类，比如，IN代表Internet其它递归查询 VS. 迭代查询在递归查询模式下，DNS 服务器在接收到客户机请求时，必须使用一个准确的查询结果回复客户机。也就意味着，如果 DNS 服务器本地没有缓存所查询的 DNS 信息，那么该服务器会询问其它服务器，并将返回的查询结果提交给客户机。而在使用迭代查询时，DNS 服务器会向客户机提供其它能够解析查询请求的 DNS 服务器地址。也就是说，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台 DNS 服务器地址，客户机需要再向这台 DNS 服务器提交请求，依次循环直到返回查询的结果为止。也就是说，关键的区别是由谁去查询最终的结果。DDoS发送大量的 DNS 递归查询会消耗服务端的一定资源，所以，只需要将发送的报文设置一个 RD 标志位即可。当发送垃圾查询时，例如不存在的域名，必然会导致查询很慢。]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么数据库设计中要使用long来替换Date类型]]></title>
    <url>%2Fposts%2Fc0f0d722%2F</url>
    <content type="text"><![CDATA[对数据库中的记录进行操作的时候，牵涉到对时间数据的处理，比如创建时间、修改时间等，一般使用 long 类型代替 Date 、Timestamp。比如 Mybatis 的池连接类 PooledConnection：123private long checkoutTimestamp; // 检查时间戳private long createdTimestamp; // 创建时间戳private long lastUsedTimestamp; // 最后一次使用时间戳MySQL、SQL Server中的表示时间的类型Date——日期。格式：YYYY-MM-DD。占用三个字节。Datetime——日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS。1000-01-01 00:00:00 ~ 9999-12-31 23:59:59，占用8个字节。适合用来记录数据的原始的创建时间。Timestamp——日期+时间，使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS。占用4个字节，&#39;1970-01-01 00:00:01&#39; UTC ~ &#39;2038-01-09 03:14:07&#39; UTC，适合用来记录数据的最后修改时间，只要更改记录中其他字段的值，timestamp字段的值都会被自动更新。bigint——表示从-2^63 (-9,223,372,036,854,775,808) 到 2^63-1 (9,223,372,036,854,775,807)，占用8个字节。Java 中表示时间的类型Java 中对时间处理的类比较混乱，处理时间的类有：java.util.Date、java.sql.Date 、java.sql.Time 、java.sql.Timestamp、java.util.Calendar 、java.util.TimeZone。使用过程中存在以下问题：获取当前时间时，各个地区在同一个时间点会有不同的时间表示。将 java.util.Date 转为 java.sql.Date 时候，日期的时分秒会被去掉，数据的精度发生了变化。而 JDBC 中定义接口时候，用的是 java.sql.Date，而我们常常用到的 Date 都是 java.util.Date，这往往导致一些转换过程中发生误差。java.sql.Date在JDBC接口中使用，如果对其进行修改，JDBC 接口规范也要改，那么将引发各个数据库厂商对数据库驱动也要改，这是不可接受的。java.sql.Timestamp 类，它保持了日期数据原有的精度。可以实现和 java.util.Date 的无损转换。但是 Timestamp 这个类在一些预定义SQL中常常会出问题。解决办法将 Date 类型转换为 long 类型。这样一来：有利于计算时间差方便 Java 与数据库之间的传输通过 long now = System.currentTimeMillis() 获得当前时间的 long 类型 也可以通过 Date date1=new Date() 来获得当前时间，再用 long time = date.getTime() 将其转化为 long类型。然后在数据库中的相应字段设置类型为 bigint 即可，在数据库中取得数据后，可以在转为相应的时间格式。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[抽象队列与阻塞队列解析]]></title>
    <url>%2Fposts%2Fee5f9e9d%2F</url>
    <content type="text"><![CDATA[抽象队列AbstractQueue 是个抽象类，继承 AbstractCollection，实现 Queue 接口。其中 AbstractCollection 也是个抽象类，实现了 Collection 接口。所以 AbstractQueue 实现了集合的方法，和常用的 ArrayList 等类似。12345public abstract class AbstractQueue&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Queue&lt;E&gt; &#123; // 被子类使用的构造器 protected AbstractQueue() &#123; &#125;&#125;AbstractQueue 还实现 Queue 接口，Queue 源码如下：12345678910111213141516171819public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; // 将元素 e 插入队列尾部，插入成功返回 true。如果在超出 JVM 限制的时候用 add 方法会抛出异常 boolean add(E e); // 将元素 e 插入队列尾部，插入成功返回 true。如果在超出 JVM 限制的时候用 offer 方法会返回false boolean offer(E e); // 检索并移除此队列的头，队列为空则抛出 NoSuchElementException E remove(); // 检索并移除此队列的头，队列为空则返回 null E poll(); // 检索但不移除此队列的头，队列为空则抛出 NoSuchElementException E element(); // 检索但不移除此队列的头，队列为空则返回 null E peek();&#125;AbstractQueue 在实现 add(E e) 方法时，调用 offer(E e) 添加失败则抛出异常 IllegalStateException(&quot;Queue full&quot;)。实现 remove() 方法时，调用 poll() 方法返回 null 则抛出异常 NoSuchElementException()。实现 element() 方法时，调用 peek() 方法返回 null 则抛出异常 NoSuchElementException()。除了以上方法外，AbstractQueue 还实现了 clear() 、addAll(Collection&lt;? extends E&gt; c) 方法。12345678910111213141516171819// 清空队列元素public void clear() &#123; while (poll() != null) ;&#125;// 将集合中的元素全部加到队列，全部添加成功则返回 true。// 如果集合为 null，则抛出空指针异常。如果集合和当前队列是一个，则抛出 IllegalArgumentException 异常public boolean addAll(Collection&lt;? extends E&gt; c) &#123; if (c == null) throw new NullPointerException(); if (c == this) throw new IllegalArgumentException(); boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified;&#125;阻塞队列在 JUC 中，BlockingQueue 很好的解决了多线程中如何高效安全“传输”数据的问题，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。接口中定义的方法如下：1234567891011121314151617181920212223242526272829303132333435public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123; // 将元素 e 插入队列尾部，参见 `Queue` 接口的 add 方法 boolean add(E e); // 将元素 e 插入队列尾部，参见 `Queue` 接口的 offer 方法 boolean offer(E e); // 将指定的元素插队列尾部，当空间不可用时会等待。 void put(E e) throws InterruptedException; // 将指定的元素插队列尾部，当空间不可用时会等待，直到超时。 boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; // 遍历并移除队列头部元素，如果队列为空则阻塞直至有元素可移除。 E take() throws InterruptedException; // take() 的超时版本 E poll(long timeout, TimeUnit unit) throws InterruptedException; // 返回此队列在理想情况下（在没有内存或资源约束的情况下）可以不阻塞地接受的元素的数目 // 如果没有内在限制，则返回&#123;@code integer.max_value&#125; int remainingCapacity(); // 检索并移除此队列的头，参见 `Queue` 接口的 remove 方法。 boolean remove(Object o); // 是否包含，参见 Collection 接口的 contains 方法。 public boolean contains(Object o); // 从队列中移除所有可用元素并将它们添加到给定集合中。 int drainTo(Collection&lt;? super E&gt; c); // 从队列中移除指定数量的可用元素并将它们添加到给定集合中。 int drainTo(Collection&lt;? super E&gt; c, int maxElements);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ArrayBlockingQueue解析]]></title>
    <url>%2Fposts%2Fc7003c14%2F</url>
    <content type="text"><![CDATA[前言ArrayBlockingQueue 是采用数组实现的有界阻塞线程安全队列。如果向已满的队列继续塞入元素，将导致当前的线程阻塞。如果向空队列获取元素，那么将导致当前线程阻塞。ArrayBlockingQueue 继承 AbstractQueue 类，实现 BlockingQueue 和 Serializable接口，关于 AbstractQueue 和 BlockingQueue 的内容可以参考 抽象队列与阻塞队列解析12public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.SerializableArrayBlockingQueue 有两个内部类，分别为 Itrs 和 Itr。其中 Itrs 内部类 Node 继承 WeakReference 类。Itr 实现了 Iterator 接口使用示例实现简单的生产者消费者模型：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ArrayBlockingQueueTest &#123; private static BlockingQueue&lt;Food&gt; queue = new ArrayBlockingQueue&lt;&gt;(2); // 生产者 class Producer implements Runnable &#123; @Override public void run() &#123; Food food = new Food(); food.setName("Apple"); try &#123; queue.put(food); System.out.println(Thread.currentThread().getName() + " provider : " + food); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // 消费者 class Consumer implements Runnable &#123; @Override public void run() &#123; try &#123; Food food = queue.take(); System.out.println(Thread.currentThread().getName() + " consumer : " + food); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // 食物 class Food &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "Food &#123;name:" + name + "&#125;"; &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new ArrayBlockingQueueTest().new Producer()).start(); &#125; new Thread(new ArrayBlockingQueueTest().new Consumer()).start(); new Thread(new ArrayBlockingQueueTest().new Consumer()).start(); &#125;&#125;其中一次执行结果如下：123456Thread-4 provider : Food &#123;name:Apple&#125;Thread-3 provider : Food &#123;name:Apple&#125;Thread-5 consumer : Food &#123;name:Apple&#125;Thread-2 provider : Food &#123;name:Apple&#125;Thread-0 provider : Food &#123;name:Apple&#125;Thread-6 consumer : Food &#123;name:Apple&#125;类结构源码分析类属性可重入锁的内容可以参考 ReentrantLock解析1234567891011121314151617181920212223/** 存放队列元素的数组 */final Object[] items;/** 取元素的下标索引 */int takeIndex;/** 存元素的下标索引 */int putIndex;/** 队列中元素的数量 */int count;/** 数据访问的重入锁 */final ReentrantLock lock;/** 取元素的等待队列条件 */private final Condition notEmpty;/** 存元素的等待队列条件 */private final Condition notFull;/** 当前活动迭代器的共享状态，如果已知不存在，则为空。允许队列操作更新迭代器状态。*/transient Itrs itrs = null;构造器构造器有三种12345678910111213141516171819202122232425262728293031323334353637383940// 初始化阻塞队列容量，默认是采用不公平重入锁public ArrayBlockingQueue(int capacity) &#123; this(capacity, false);&#125;// 使用 capacity 初始化阻塞队列容量，fair 初始化重入锁的公平与否public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125;// 在 ArrayBlockingQueue(int capacity, boolean fair) 基础上，将集合中元素加到阻塞队列中public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) &#123; // 采用 ArrayBlockingQueue(int capacity, boolean fair) 初始化阻塞队列 this(capacity, fair); final ReentrantLock lock = this.lock; lock.lock(); // 锁仅用于可见性，而不是相互排斥 try &#123; int i = 0; try &#123; for (E e : c) &#123; checkNotNull(e); // 检查非空 items[i++] = e; // 将元素加入阻塞队列 &#125; &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; throw new IllegalArgumentException(); &#125; // 更新队列中元素的数量 count = i; // 更新存元素的下标索引，i 和 capacity 相等，则从 0 开始重新计 putIndex = (i == capacity) ? 0 : i; &#125; finally &#123; lock.unlock(); &#125;&#125;内部类源码分析Itrs内部类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155class Itrs &#123; // 弱迭代器引用的链接列表节点 private class Node extends WeakReference&lt;Itr&gt; &#123; Node next; Node(Itr iterator, Node next) &#123; super(iterator); this.next = next; &#125; &#125; /** takeIndex 环绕到0的次数*/ int cycles = 0; /** 弱迭代器引用的链接列表头节点 */ private Node head; /** 用于删除过时的迭代器 */ private Node sweeper = null; // 短扫频探头 private static final int SHORT_SWEEP_PROBES = 4; // 长扫频探头 private static final int LONG_SWEEP_PROBES = 16; Itrs(Itr initial) &#123; register(initial); &#125; // 清理迭代器，查找并删除过时的迭代器。仅从迭代线程调用 void doSomeSweeping(boolean tryHarder) &#123; // assert lock.getHoldCount() == 1; // assert head != null; int probes = tryHarder ? LONG_SWEEP_PROBES : SHORT_SWEEP_PROBES; Node o, p; final Node sweeper = this.sweeper; boolean passedGo; // to limit search to one full sweep if (sweeper == null) &#123; o = null; p = head; passedGo = true; &#125; else &#123; o = sweeper; p = o.next; passedGo = false; &#125; for (; probes &gt; 0; probes--) &#123; if (p == null) &#123; if (passedGo) break; o = null; p = head; passedGo = true; &#125; final Itr it = p.get(); final Node next = p.next; if (it == null || it.isDetached()) &#123; // found a discarded/exhausted iterator probes = LONG_SWEEP_PROBES; // "try harder" // unlink p p.clear(); p.next = null; if (o == null) &#123; head = next; if (next == null) &#123; // We've run out of iterators to track; retire itrs = null; return; &#125; &#125; else o.next = next; &#125; else &#123; o = p; &#125; p = next; &#125; this.sweeper = (p == null) ? null : o; &#125; // 将新迭代器添加到跟踪迭代器的链接列表中。 void register(Itr itr) &#123; // assert lock.getHoldCount() == 1; head = new Node(itr, head); &#125; // 通知所有迭代器，并删除任何已过时的迭代器。takeIndex 环绕到0时调用 void takeIndexWrapped() &#123; // assert lock.getHoldCount() == 1; cycles++; for (Node o = null, p = head; p != null;) &#123; final Itr it = p.get(); final Node next = p.next; if (it == null || it.takeIndexWrapped()) &#123; // unlink p // assert it == null || it.isDetached(); p.clear(); p.next = null; if (o == null) head = next; else o.next = next; &#125; else &#123; o = p; &#125; p = next; &#125; if (head == null) // no more iterators to track itrs = null; &#125; // 当迭代器被移除时调用，通知所有迭代器，并删除已过时的迭代器。 void removedAt(int removedIndex) &#123; for (Node o = null, p = head; p != null;) &#123; final Itr it = p.get(); final Node next = p.next; if (it == null || it.removedAt(removedIndex)) &#123; // unlink p // assert it == null || it.isDetached(); p.clear(); p.next = null; if (o == null) head = next; else o.next = next; &#125; else &#123; o = p; &#125; p = next; &#125; if (head == null) // no more iterators to track itrs = null; &#125; // 队列为空时调用，通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。 void queueIsEmpty() &#123; // assert lock.getHoldCount() == 1; for (Node p = head; p != null; p = p.next) &#123; Itr it = p.get(); if (it != null) &#123; p.clear(); it.shutdown(); &#125; &#125; head = null; itrs = null; &#125; // 每当元素（在 takeIndex 处）退出队列时调用。 void elementDequeued() &#123; // assert lock.getHoldCount() == 1; if (count == 0) queueIsEmpty(); else if (takeIndex == 0) takeIndexWrapped(); &#125;&#125;Itr 内部类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331private class Itr implements Iterator&lt;E&gt; &#123; /** 游标，下一个next节点对应的下标，到达putIndex结束的位置为NONE */ private int cursor; /** next节点的元素值 */ private E nextItem; /** next节点的索引 */ private int nextIndex; /** 上一个节点的元素值 */ private E lastItem; /** 上一个节点的索引 */ private int lastRet; /** 记录 takeIndex */ private int prevTakeIndex; /** 记录cycles */ private int prevCycles; /** 元素不可用或未定义时的特殊索引值 */ private static final int NONE = -1; /** 元素非调用 this.remove() 被移除元素的索引值 */ private static final int REMOVED = -2; /** detached 模式特殊的 prevTakeIndex 值 */ private static final int DETACHED = -3; Itr() &#123; // assert lock.getHoldCount() == 0; lastRet = NONE; final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try &#123; if (count == 0) &#123; // assert itrs == null; cursor = NONE; nextIndex = NONE; prevTakeIndex = DETACHED; &#125; else &#123; final int takeIndex = ArrayBlockingQueue.this.takeIndex; prevTakeIndex = takeIndex; nextItem = itemAt(nextIndex = takeIndex); cursor = incCursor(takeIndex); if (itrs == null) &#123; itrs = new Itrs(this); &#125; else &#123; // 在 itrs 中注册 this itrs.register(this); // in this order // 清理迭代器，查找并删除过时的迭代器。 itrs.doSomeSweeping(false); &#125; prevCycles = itrs.cycles; // assert takeIndex &gt;= 0; // assert prevTakeIndex == takeIndex; // assert nextIndex &gt;= 0; // assert nextItem != null; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; // 是否是 detached 模式 boolean isDetached() &#123; // assert lock.getHoldCount() == 1; return prevTakeIndex &lt; 0; &#125; // 游标处理 private int incCursor(int index) &#123; // assert lock.getHoldCount() == 1; if (++index == items.length) // 从 0 开始 index = 0; if (index == putIndex) // takeIndex == putIndex index = NONE; return index; &#125; // 校验索引是否有效 private boolean invalidated(int index, int prevTakeIndex, long dequeues, int length) &#123; if (index &lt; 0) return false; int distance = index - prevTakeIndex; if (distance &lt; 0) distance += length; // 下标距离的prevTakeIndex元素数量 和 出队元素数量 比较 return dequeues &gt; distance; &#125; // 调整索引，合并自上次对此迭代器执行操作以来的所有出列。 private void incorporateDequeues() &#123; // assert lock.getHoldCount() == 1; // assert itrs != null; // assert !isDetached(); // assert count &gt; 0; final int cycles = itrs.cycles; final int takeIndex = ArrayBlockingQueue.this.takeIndex; final int prevCycles = this.prevCycles; final int prevTakeIndex = this.prevTakeIndex; // cycles和takeIndex存在不一致，需要修正 if (cycles != prevCycles || takeIndex != prevTakeIndex) &#123; final int len = items.length; // 计算出队元素的数量 long dequeues = (cycles - prevCycles) * len + (takeIndex - prevTakeIndex); // 校验下标合法性 if (invalidated(lastRet, prevTakeIndex, dequeues, len)) lastRet = REMOVED; if (invalidated(nextIndex, prevTakeIndex, dequeues, len)) nextIndex = REMOVED; if (invalidated(cursor, prevTakeIndex, dequeues, len)) cursor = takeIndex; // 进入detach模式 if (cursor &lt; 0 &amp;&amp; nextIndex &lt; 0 &amp;&amp; lastRet &lt; 0) detach(); else &#123; this.prevCycles = cycles; this.prevTakeIndex = takeIndex; &#125; &#125; &#125; // 修改detach的标志字段，并且启动itrs的清理逻辑。 private void detach() &#123; // Switch to detached mode // assert lock.getHoldCount() == 1; // assert cursor == NONE; // assert nextIndex &lt; 0; // assert lastRet &lt; 0 || nextItem == null; // assert lastRet &lt; 0 ^ lastItem != null; if (prevTakeIndex &gt;= 0) &#123; // assert itrs != null; prevTakeIndex = DETACHED; // try to unlink from itrs (but not too hard) itrs.doSomeSweeping(true); &#125; &#125; // 迭代器的 hasNext 方法 public boolean hasNext() &#123; // assert lock.getHoldCount() == 0; if (nextItem != null) return true; noNext(); // 对于没有下一个节点的迭代器，需要修正下标属性并进入detach模式。 return false; &#125; // 修正下标属性并进入detach模式 private void noNext() &#123; final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try &#123; // assert cursor == NONE; // assert nextIndex == NONE; if (!isDetached()) &#123; // assert lastRet &gt;= 0; incorporateDequeues(); // might update lastRet if (lastRet &gt;= 0) &#123; lastItem = itemAt(lastRet); // assert lastItem != null; detach(); &#125; &#125; // assert isDetached(); // assert lastRet &lt; 0 ^ lastItem != null; &#125; finally &#123; lock.unlock(); &#125; &#125; // 迭代器的 next() 方法 public E next() &#123; // assert lock.getHoldCount() == 0; final E x = nextItem; if (x == null) throw new NoSuchElementException(); final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try &#123; if (!isDetached()) incorporateDequeues(); // assert nextIndex != NONE; // assert lastItem == null; lastRet = nextIndex; final int cursor = this.cursor; if (cursor &gt;= 0) &#123; nextItem = itemAt(nextIndex = cursor); // assert nextItem != null; this.cursor = incCursor(cursor); &#125; else &#123; nextIndex = NONE; nextItem = null; &#125; &#125; finally &#123; lock.unlock(); &#125; return x; &#125; // 迭代器的 remove() 方法 public void remove() &#123; // assert lock.getHoldCount() == 0; final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try &#123; if (!isDetached()) incorporateDequeues(); // might update lastRet or detach final int lastRet = this.lastRet; this.lastRet = NONE; if (lastRet &gt;= 0) &#123; if (!isDetached()) removeAt(lastRet); else &#123; final E lastItem = this.lastItem; // assert lastItem != null; this.lastItem = null; if (itemAt(lastRet) == lastItem) removeAt(lastRet); &#125; &#125; else if (lastRet == NONE) throw new IllegalStateException(); // else lastRet == REMOVED and the last returned element was // previously asynchronously removed via an operation other // than this.remove(), so nothing to do. if (cursor &lt; 0 &amp;&amp; nextIndex &lt; 0) detach(); &#125; finally &#123; lock.unlock(); // assert lastRet == NONE; // assert lastItem == null; &#125; &#125; // 通知迭代器队列为空，或队列已无望地落在后面 void shutdown() &#123; // assert lock.getHoldCount() == 1; cursor = NONE; if (nextIndex &gt;= 0) nextIndex = REMOVED; if (lastRet &gt;= 0) &#123; lastRet = REMOVED; lastItem = null; &#125; prevTakeIndex = DETACHED; // Don't set nextItem to null because we must continue to be // able to return it on next(). // // Caller will unlink from itrs when convenient. &#125; private int distance(int index, int prevTakeIndex, int length) &#123; int distance = index - prevTakeIndex; if (distance &lt; 0) distance += length; return distance; &#125; // 所有队列移除takeIndex下标处元素的方法, 都会调用迭代器的removeAt方法，以通知其修正下标索引值。 boolean removedAt(int removedIndex) &#123; // assert lock.getHoldCount() == 1; if (isDetached()) return true; final int cycles = itrs.cycles; final int takeIndex = ArrayBlockingQueue.this.takeIndex; final int prevCycles = this.prevCycles; final int prevTakeIndex = this.prevTakeIndex; final int len = items.length; int cycleDiff = cycles - prevCycles; if (removedIndex &lt; takeIndex) cycleDiff++; final int removedDistance = (cycleDiff * len) + (removedIndex - prevTakeIndex); // assert removedDistance &gt;= 0; int cursor = this.cursor; if (cursor &gt;= 0) &#123; int x = distance(cursor, prevTakeIndex, len); if (x == removedDistance) &#123; if (cursor == putIndex) this.cursor = cursor = NONE; &#125; else if (x &gt; removedDistance) &#123; // assert cursor != prevTakeIndex; this.cursor = cursor = dec(cursor); &#125; &#125; int lastRet = this.lastRet; if (lastRet &gt;= 0) &#123; int x = distance(lastRet, prevTakeIndex, len); if (x == removedDistance) this.lastRet = lastRet = REMOVED; else if (x &gt; removedDistance) this.lastRet = lastRet = dec(lastRet); &#125; int nextIndex = this.nextIndex; if (nextIndex &gt;= 0) &#123; int x = distance(nextIndex, prevTakeIndex, len); if (x == removedDistance) this.nextIndex = nextIndex = REMOVED; else if (x &gt; removedDistance) this.nextIndex = nextIndex = dec(nextIndex); &#125; else if (cursor &lt; 0 &amp;&amp; nextIndex &lt; 0 &amp;&amp; lastRet &lt; 0) &#123; this.prevTakeIndex = DETACHED; return true; &#125; return false; &#125; // takeIndex每次循环到0时会调用该方法。 // cycle计数增加，遍历链表检查并清理过期的无效节点。 boolean takeIndexWrapped() &#123; // assert lock.getHoldCount() == 1; if (isDetached()) return true; if (itrs.cycles - prevCycles &gt; 1) &#123; // All the elements that existed at the time of the last // operation are gone, so abandon further iteration. shutdown(); return true; &#125; return false; &#125;// /** 取消调试注释. */// public String toString() &#123;// return ("cursor=" + cursor + " " +// "nextIndex=" + nextIndex + " " +// "lastRet=" + lastRet + " " +// "nextItem=" + nextItem + " " +// "lastItem=" + lastItem + " " +// "prevCycles=" + prevCycles + " " +// "prevTakeIndex=" + prevTakeIndex + " " +// "size()=" + size() + " " +// "remainingCapacity()=" + remainingCapacity());// &#125; &#125;进入detach模式的关键有3种情况：cursor == putIndex，这时候 cursor = NONE空队列cycle - preCycles &gt; 1常用操作源码分析入队12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 调用抽象队列的 add 方法public boolean add(E e) &#123; return super.add(e);&#125;// 将元素 e 插入队列尾部，不感知中断public boolean offer(E e) &#123; checkNotNull(e); // 检查元素 e 是否为空 final ReentrantLock lock = this.lock; lock.lock(); // 加锁，不感知中断 try &#123; if (count == items.length) // 队列满了，返回 false return false; else &#123; // 入队，返回 true enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;// 将元素 e 插入队列尾部，如果队列慢了则一直等待，感知中断。public void put(E e) throws InterruptedException &#123; checkNotNull(e); // 检查元素 e 是否为空 final ReentrantLock lock = this.lock; lock.lockInterruptibly(); // 加锁，感知中断 try &#123; while (count == items.length) // 队列满了，等待 notFull.await(); // 入队 enqueue(e); &#125; finally &#123; lock.unlock(); &#125;&#125;// put(E e) 超时版本，如果入队成功，则返回 truepublic boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; checkNotNull(e); long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); // 加锁，感知中断 try &#123; while (count == items.length) &#123; if (nanos &lt;= 0) return false; // notFull 的超时等待 nanos = notFull.awaitNanos(nanos); &#125; // 入队 enqueue(e); return true; &#125; finally &#123; lock.unlock(); &#125;&#125;出队123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132// 遍历并移除队列头部元素，不感知中断public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 出队：队列为空则返回 null。 return (count == 0) ? null : dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125;// 遍历并移除队列头部元素，感知中断。如果队列为空则一直等待。public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); // 加锁，感知中断 try &#123; while (count == 0) // 队列为空，等待 notEmpty.await(); // 出队：遍历并移除队列头部元素，并返回头部元素 return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125;// take() 的超时版本public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) &#123; if (nanos &lt;= 0) return null; // notEmpty 的超时等待 nanos = notEmpty.awaitNanos(nanos); &#125; // 出队：遍历并移除队列头部元素，并返回头部元素 return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125;// 返回数组中下标索引 takeIndex 对应的元素，不进行弹出。public E peek() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return itemAt(takeIndex); // 队列为空返回 null &#125; finally &#123; lock.unlock(); &#125;&#125;@SuppressWarnings("unchecked")final E itemAt(int i) &#123; return (E) items[i];&#125;// 从队列中移除元素，不感知中断public boolean remove(Object o) &#123; if (o == null) return false; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 队列非空 if (count &gt; 0) &#123; final int putIndex = this.putIndex; int i = takeIndex; do &#123; if (o.equals(items[i])) &#123; // takeIndex 对应的元素和 o 一致则移除 takeIndex 对应的元素，返回 true removeAt(i); return true; &#125; if (++i == items.length) // ++i 和数组长度相等，i 从 0 开始计 i = 0; &#125; while (i != putIndex); // i == putIndex 则终止循环 &#125; // 移除失败 return false; &#125; finally &#123; lock.unlock(); &#125;&#125;// 清空阻塞队列public void clear() &#123; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try &#123; int k = count; if (k &gt; 0) &#123; final int putIndex = this.putIndex; int i = takeIndex; do &#123; items[i] = null; if (++i == items.length) i = 0; &#125; while (i != putIndex); takeIndex = putIndex; count = 0; if (itrs != null) // 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。 itrs.queueIsEmpty(); // 查询是否有因为给定条件 notFull 正在等待的线程 for (; k &gt; 0 &amp;&amp; lock.hasWaiters(notFull); k--) // 唤醒因为给定条件 notFull 正在等待的线程 notFull.signal(); &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;// 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。void queueIsEmpty() &#123; // assert lock.getHoldCount() == 1; for (Node p = head; p != null; p = p.next) &#123; Itr it = p.get(); if (it != null) &#123; p.clear(); it.shutdown(); &#125; &#125; head = null; itrs = null;&#125;转数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 将队列转成 Object 数组public Object[] toArray() &#123; Object[] a; final ReentrantLock lock = this.lock; lock.lock(); try &#123; final int count = this.count; a = new Object[count]; int n = items.length - takeIndex; if (count &lt;= n) // putIndex 大于等于 takeIndex System.arraycopy(items, takeIndex, a, 0, count); else &#123; // putIndex 小于 takeIndex System.arraycopy(items, takeIndex, a, 0, n); System.arraycopy(items, 0, a, n, count - n); &#125; &#125; finally &#123; lock.unlock(); &#125; return a;&#125;// 将队列转成泛型数组@SuppressWarnings("unchecked")public &lt;T&gt; T[] toArray(T[] a) &#123; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try &#123; final int count = this.count; final int len = a.length; if (len &lt; count) // 泛型数组 a 长度不够，重新创建一个长度为 count 的数组 // 注意：泛型数组不能通过 T[] a = new T[count] 方式进行创建，只能通过反射进行创建 a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), count); int n = items.length - takeIndex; if (count &lt;= n) // putIndex 大于等于 takeIndex System.arraycopy(items, takeIndex, a, 0, count); else &#123; // putIndex 小于 takeIndex System.arraycopy(items, takeIndex, a, 0, n); System.arraycopy(items, 0, a, n, count - n); &#125; if (len &gt; count) // 泛型数组 a 长度大于阻塞队列元素个数， 则第 count 位清空 a[count] = null; &#125; finally &#123; lock.unlock(); &#125; return a;&#125;其他操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 获取阻塞队列元素数量public int size() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return count; &#125; finally &#123; lock.unlock(); &#125;&#125;// 获取阻塞队列剩余容量public int remainingCapacity() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return items.length - count; &#125; finally &#123; lock.unlock(); &#125;&#125;// 判断阻塞队列是否包含元素 opublic boolean contains(Object o) &#123; if (o == null) return false; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count &gt; 0) &#123; final int putIndex = this.putIndex; int i = takeIndex; do &#123; // 处理类似 remove 方法 if (o.equals(items[i])) return true; if (++i == items.length) i = 0; &#125; while (i != putIndex); &#125; return false; &#125; finally &#123; lock.unlock(); &#125;&#125;// toString 方法，结果类似 [e1.toString(), e2.toString()……]public String toString() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; int k = count; if (k == 0) return "[]"; final Object[] items = this.items; StringBuilder sb = new StringBuilder(); sb.append('['); for (int i = takeIndex; ; ) &#123; Object e = items[i]; sb.append(e == this ? "(this Collection)" : e); if (--k == 0) return sb.append(']').toString(); sb.append(',').append(' '); if (++i == items.length) i = 0; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;特殊方法将队列元素添加到集合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 将队列元素添加到集合 c，最大数量为 Integer.MAX_VALUEpublic int drainTo(Collection&lt;? super E&gt; c) &#123; return drainTo(c, Integer.MAX_VALUE);&#125;// 将队列元素添加到集合 c，最大数量为 maxElementspublic int drainTo(Collection&lt;? super E&gt; c, int maxElements) &#123; checkNotNull(c); // 检查集合是否非null if (c == this) // c 是当前队列本身 throw new IllegalArgumentException(); if (maxElements &lt;= 0) return 0; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 取 maxElements 和队列元素数量最小值 int n = Math.min(maxElements, count); int take = takeIndex; int i = 0; try &#123; while (i &lt; n) &#123; // 从队列中循环取出元素并加入集合 c 中 @SuppressWarnings("unchecked") E x = (E) items[take]; c.add(x); items[take] = null; if (++take == items.length) take = 0; i++; &#125; return n; &#125; finally &#123; // 恢复不变量，即使调用 c.add() 抛出异常 if (i &gt; 0) &#123; count -= i; // 移除并成功添加到集合后，队列剩余元素数量 takeIndex = take; // 更新 takeIndex if (itrs != null) &#123; if (count == 0) // 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。 itrs.queueIsEmpty(); else if (i &gt; take) // 移除并成功添加到集合的元素个数大于 take // 每当 takeIndex 为0时调用。通知所有迭代器，并删除任何已过时的迭代器。 itrs.takeIndexWrapped(); // 参考内部类 Itrs 的 takeIndexWrapped 实现 &#125; // 查询是否有因为给定条件 notFull 正在等待的线程 for (; i &gt; 0 &amp;&amp; lock.hasWaiters(notFull); i--) // 唤醒因为给定条件 notFull 正在等待的线程 notFull.signal(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;出队与入队123456789101112131415161718192021222324252627282930313233343536373839// 入队private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; // 唤醒因为给定条件 notEmpty 正在等待的线程 notEmpty.signal();&#125;// 出队private E dequeue() &#123; // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; @SuppressWarnings("unchecked") E x = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); // 唤醒因为给定条件 notFull 正在等待的线程 notFull.signal(); return x;&#125;void elementDequeued() &#123; // assert lock.getHoldCount() == 1; if (count == 0) // 通知所有活动迭代器,队列为空，清除所有弱引用，并取消 itrs 的链接。 queueIsEmpty(); else if (takeIndex == 0) // 通知所有迭代器，并删除任何已过时的迭代器。 takeIndexWrapped();&#125;分割迭代器1234567// jdk8新增，可用来并行遍历元素的一个迭代器public Spliterator&lt;E&gt; spliterator() &#123; // 有序、非空、线程安全 return Spliterators.spliterator (this, Spliterator.ORDERED | Spliterator.NONNULL | Spliterator.CONCURRENT);&#125;总结ArrayBlockingQueue 采用数组实现的有界阻塞线程安全队列，是规定大小的 BlockingQueue，其构造必须指定大小。其所含的对象是 FIFO 顺序排序的。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>ArrayBlockingQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StampedLock]]></title>
    <url>%2Fposts%2Fab957bc5%2F</url>
    <content type="text"><![CDATA[本文代码基于Java8前言读写锁如果使用不当，容易出现“饥饿”问题，比如在读线程非常多，写线程非常少的情况下，很容易导致写线程“饥饿”。虽然公平策略在一定程度上可以缓解这个问题，但是鱼与熊掌不可兼得，公平策略是以牺牲系统吞吐量为代价的。于是StampedLock 类应运而生，在 JDK1.8 时引入，是对读写锁 ReentrantReadWriteLock 的增强，该类提供了一些功能，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，可以更细粒度控制并发。不过该类的设计初衷是作为一个内部工具类，用于辅助开发其它线程安全组件。用得好，该类可以提升系统性能，用不好，容易产生死锁和其它莫名其妙的问题。StampedLock 类结构StampedLock 类结构如下：StampedLock 的内部类包括四个，分别为 WriteLockView、ReadLockView、ReadWriteLockView 以及 WNode。StampedLock 底层实现StampedLock 虽然不像其它锁一样定义了内部类来实现 AQS 框架，但是 StampedLock 的基本实现思路还是利用 CLH 队列进行线程的管理，通过同步状态值来表示锁的状态和类型。StampedLock 把读分为了悲观读和乐观读，悲观读就等价于 ReadWriteLock 的读，而乐观读在一个线程写共享变量时，不会被阻塞，乐观读是不加锁的。StampedLock 内部定义了很多常量，定义这些常量的根本目的和 ReentrantReadWriteLock 一样，对同步状态值按位切分，以通过位运算对State进行操作对于 StampedLock 来说，写锁被占用的标志是第8位为1，读锁使用0-7位，正常情况下读锁数目为1-126，超过126时，使用一个名为的 readerOverflow int整型保存超出数。源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class StampedLock implements java.io.Serializable &#123; private static final long serialVersionUID = -6001602636862214147L; /** CPU 核数，用于控制自旋次数 */ private static final int NCPU = Runtime.getRuntime().availableProcessors(); /** 尝试获取锁失败次数超过该值，则将其加入等待队列 */ private static final int SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 6 : 0; /** 等待队列首节点自旋获取锁失败次数超过该值，会继续阻塞 */ private static final int HEAD_SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 10 : 0; /** 等待队列首节点再次阻塞之前的最大尝试次数 */ private static final int MAX_HEAD_SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 16 : 0; /** 等待自旋锁溢出时的 yield 周期 */ private static final int OVERFLOW_YIELD_RATE = 7; // must be power 2 - 1 /** 在读锁数量溢出之前的 bit 位数 */ private static final int LG_READERS = 7; // 锁状态和标记操作的位常量 private static final long RUNIT = 1L; // 一单位读锁 private static final long WBIT = 1L &lt;&lt; LG_READERS; // 写状态标识 private static final long RBITS = WBIT - 1L; // 读状态标识 private static final long RFULL = RBITS - 1L; // 读锁的最大数量 private static final long ABITS = RBITS | WBIT; // 用于获取读写状态 private static final long SBITS = ~RBITS; // note overlap with ABITS // 锁状态初始值，避免初始化为失败值 0 private static final long ORIGIN = WBIT &lt;&lt; 1; // 取消获取方法返回的特殊值，以便调用方可以抛出 InterruptedException private static final long INTERRUPTED = 1L; // 节点状态值，和顺序有关 private static final int WAITING = -1; private static final int CANCELLED = 1; // 节点的模式，使用 int 而不是 boolean，方便计算 private static final int RMODE = 0; private static final int WMODE = 1; /** Wait nodes */ static final class WNode &#123; volatile WNode prev; volatile WNode next; volatile WNode cowait; // list of linked readers volatile Thread thread; // non-null while possibly parked volatile int status; // 0, WAITING, or CANCELLED final int mode; // RMODE or WMODE WNode(int m, WNode p) &#123; mode = m; prev = p; &#125; &#125; /** CLH 队列的头节点 */ private transient volatile WNode whead; /** CLH 队列的尾节点 */ private transient volatile WNode wtail; // 视图 transient ReadLockView readLockView; transient WriteLockView writeLockView; transient ReadWriteLockView readWriteLockView; /** 锁状态 */ private transient volatile long state; /** 读锁饱和时的额外读锁计数 */ private transient int readerOverflow; // 创建一个 StampedLock，初始是 unlocked 状态 public StampedLock() &#123; state = ORIGIN; &#125;&#125;三种锁视图三种锁视图分别为读锁视图、写锁视图、读写锁(悲观读)视图。这些视图其实是对 StamedLock 方法的封装，便于习惯了 ReentrantReadWriteLock 的用户使用。具体实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 读锁视图final class ReadLockView implements Lock &#123; // 非独占获取锁，如果需要会阻塞到可用 public void lock() &#123; readLock(); &#125; public void lockInterruptibly() throws InterruptedException &#123; readLockInterruptibly(); &#125; // 尝试获取锁 public boolean tryLock() &#123; return tryReadLock() != 0L; &#125; // 尝试获取锁，带超时时间 public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return tryReadLock(time, unit) != 0L; &#125; // 无标识释放锁 public void unlock() &#123; unstampedUnlockRead(); &#125; // 不支持 Condition public Condition newCondition() &#123; throw new UnsupportedOperationException(); &#125;&#125;// 写锁视图final class WriteLockView implements Lock &#123; public void lock() &#123; writeLock(); &#125; public void lockInterruptibly() throws InterruptedException &#123; writeLockInterruptibly(); &#125; public boolean tryLock() &#123; return tryWriteLock() != 0L; &#125; public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return tryWriteLock(time, unit) != 0L; &#125; public void unlock() &#123; unstampedUnlockWrite(); &#125; // 不支持 Condition public Condition newCondition() &#123; throw new UnsupportedOperationException(); &#125;&#125;// 读写锁(悲观读)视图final class ReadWriteLockView implements ReadWriteLock &#123; // 获取读锁 public Lock readLock() &#123; return asReadLock(); &#125; // 获取写锁 public Lock writeLock() &#123; return asWriteLock(); &#125;&#125;public interface ReadWriteLock &#123; Lock readLock(); Lock writeLock();&#125;ReadWriteLock 方法实现如下：12345678910111213// 返回读锁public Lock asReadLock() &#123; ReadLockView v; return ((v = readLockView) != null ? v : (readLockView = new ReadLockView()));&#125;// 返回写锁public Lock asWriteLock() &#123; WriteLockView v; return ((v = writeLockView) != null ? v : (writeLockView = new WriteLockView()));&#125;使用示例在使用 StampedLock 的时候，建议这样操作：乐观读时，如果有写操作修改了共享变量则升级乐观读为悲观读锁，因为这样可用避免乐观读反复的循环等待写锁的释放，造成 CPU 资源的浪费。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Point &#123; private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) &#123; // an exclusively locked method long stamp = sl.writeLock(); //获取写锁 try &#123; x += deltaX; y += deltaY; &#125; finally &#123; sl.unlockWrite(stamp); //释放写锁 &#125; &#125; double distanceFromOrigin() &#123; // A read-only method long stamp = sl.tryOptimisticRead(); //乐观读 double currentX = x, currentY = y; if (!sl.validate(stamp)) &#123; //判断共享变量是否已经被其他线程写过 stamp = sl.readLock(); //如果被写过则升级为悲观读锁 try &#123; currentX = x; currentY = y; &#125; finally &#123; sl.unlockRead(stamp); //释放悲观读锁 &#125; &#125; return Math.sqrt(currentX * currentX + currentY * currentY); &#125; void moveIfAtOrigin(double newX, double newY) &#123; // upgrade // Could instead start with optimistic, not read mode long stamp = sl.readLock(); //获取读锁 try &#123; while (x == 0.0 &amp;&amp; y == 0.0) &#123; long ws = sl.tryConvertToWriteLock(stamp); //升级为写锁 if (ws != 0L) &#123; stamp = ws; x = newX; y = newY; break; &#125; else &#123; sl.unlockRead(stamp); stamp = sl.writeLock(); &#125; &#125; &#125; finally &#123; sl.unlock(stamp); &#125; &#125;&#125;StampedLock 获取锁和释放锁的实现StampedLock 在获取锁和乐观读时，都会返回一个 stamp，解锁时需要传入这个 stamp，在乐观读时是用来验证共享变量是否被其他线程写过。StampedLock 中，等待队列的结点要比AQS中简单些，仅仅三种状态。初始状态等待中取消获取写锁写锁(独占锁)，如果获取失败则进入阻塞队列，不响应中断。返回非 0 代表成功。123456public long writeLock() &#123; long s, next; // bypass acquireWrite in fully unlocked case only return ((((s = state) &amp; ABITS) == 0L &amp;&amp; U.compareAndSwapLong(this, STATE, s, next = s + WBIT)) ? next : acquireWrite(false, 0L));&#125;(s = state) &amp; ABITS) == 0L 为 true 代表读锁与写锁均未被使用，compareAndSwapLong 表示通过 CAS 更新同步状态值 state。12345678910111213141516171819202122232425262728293031public long tryWriteLock() &#123; long s, next; return ((((s = state) &amp; ABITS) == 0L &amp;&amp; U.compareAndSwapLong(this, STATE, s, next = s + WBIT)) ? next : 0L);&#125;public long tryWriteLock(long time, TimeUnit unit) throws InterruptedException &#123; long nanos = unit.toNanos(time); if (!Thread.interrupted()) &#123; long next, deadline; if ((next = tryWriteLock()) != 0L) return next; if (nanos &lt;= 0L) return 0L; if ((deadline = System.nanoTime() + nanos) == 0L) deadline = 1L; if ((next = acquireWrite(true, deadline)) != INTERRUPTED) return next; &#125; throw new InterruptedException();&#125;public long writeLockInterruptibly() throws InterruptedException &#123; long next; if (!Thread.interrupted() &amp;&amp; (next = acquireWrite(true, 0L)) != INTERRUPTED) return next; throw new InterruptedException();&#125;获取悲观读锁悲观读锁(非独占锁)，为获得锁一直处于阻塞状态，直到获得锁为止，不响应中断。返回非 0 代表成功。123456public long readLock() &#123; long s = state, next; // bypass acquireRead on common uncontended case return ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp; U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) ? next : acquireRead(false, 0L));&#125;whead == wtail 代表队列为空 ，s &amp; ABITS) &lt; RFULL 没有写锁且读锁数小于 126 。compareAndSwapLong 表示通过 CAS 更新同步状态值 state。1234567891011121314151617181920212223242526272829303132333435363738394041424344public long tryReadLock() &#123; for (;;) &#123; long s, m, next; if ((m = (s = state) &amp; ABITS) == WBIT) return 0L; else if (m &lt; RFULL) &#123; if (U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) return next; &#125; else if ((next = tryIncReaderOverflow(s)) != 0L) return next; &#125;&#125;public long tryReadLock(long time, TimeUnit unit) throws InterruptedException &#123; long s, m, next, deadline; long nanos = unit.toNanos(time); if (!Thread.interrupted()) &#123; if ((m = (s = state) &amp; ABITS) != WBIT) &#123; if (m &lt; RFULL) &#123; if (U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) return next; &#125; else if ((next = tryIncReaderOverflow(s)) != 0L) return next; &#125; if (nanos &lt;= 0L) return 0L; if ((deadline = System.nanoTime() + nanos) == 0L) deadline = 1L; if ((next = acquireRead(true, deadline)) != INTERRUPTED) return next; &#125; throw new InterruptedException();&#125;public long readLockInterruptibly() throws InterruptedException &#123; long next; if (!Thread.interrupted() &amp;&amp; (next = acquireRead(true, 0L)) != INTERRUPTED) return next; throw new InterruptedException();&#125;获取乐观读锁相对于悲观读锁来说的，在操作数据前并没有通过 CAS 设置锁的状态，仅仅是通过位运算测试。如果当前没有线程持有写锁，则简单的返回一个非 0 的 stamp 版本信息。由于 tryOptimisticRead 并没有使用 CAS 设置锁状态，所以不需要显示的释放该锁。1234public long tryOptimisticRead() &#123; long s; return (((s = state) &amp; WBIT) == 0L) ? (s &amp; SBITS) : 0L;&#125;获取该 stamp 后在具体操作数据前还需要调用 validate 验证下该 stamp 是否已经不可用，也就是看当调用 tryOptimisticRead 返回 stamp 后，到当前时间是否有其它线程持有了写锁。如果是那么 validate 会返回 0，否者就可以使用该 stamp 版本的锁对数据进行操作。1234public boolean validate(long stamp) &#123; U.loadFence(); return (stamp &amp; SBITS) == (state &amp; SBITS);&#125;使用乐观读锁还是很容易犯错误的，必须要严谨。需要遵循相应的调用模板(判断共享变量是否已经被其他线程写过，如果被写过则升级为悲观读锁)，防止出现数据不一致的问题。释放锁锁释放需要锁状态和 stamp 匹配，才能释放对应的锁。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 如果锁状态和 stamp 匹配，则释放写锁public void unlockWrite(long stamp) &#123; WNode h; if (state != stamp || (stamp &amp; WBIT) == 0L) throw new IllegalMonitorStateException(); state = (stamp += WBIT) == 0L ? ORIGIN : stamp; if ((h = whead) != null &amp;&amp; h.status != 0) release(h);&#125;// 如果锁状态和 stamp 匹配，则释放读锁public void unlockRead(long stamp) &#123; long s, m; WNode h; for (;;) &#123; if (((s = state) &amp; SBITS) != (stamp &amp; SBITS) || (stamp &amp; ABITS) == 0L || (m = s &amp; ABITS) == 0L || m == WBIT) throw new IllegalMonitorStateException(); if (m &lt; RFULL) &#123; if (U.compareAndSwapLong(this, STATE, s, s - RUNIT)) &#123; if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0) release(h); break; &#125; &#125; else if (tryDecReaderOverflow(s) != 0L) break; &#125;&#125;// 如果锁状态和 stamp 匹配，则释放相关模式的锁public void unlock(long stamp) &#123; long a = stamp &amp; ABITS, m, s; WNode h; while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123; if ((m = s &amp; ABITS) == 0L) break; else if (m == WBIT) &#123; if (a != m) break; state = (s += WBIT) == 0L ? ORIGIN : s; if ((h = whead) != null &amp;&amp; h.status != 0) release(h); return; &#125; else if (a == 0L || a &gt;= WBIT) break; else if (m &lt; RFULL) &#123; if (U.compareAndSwapLong(this, STATE, s, s - RUNIT)) &#123; if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0) release(h); return; &#125; &#125; else if (tryDecReaderOverflow(s) != 0L) return; &#125; throw new IllegalMonitorStateException();&#125;释放读锁、写锁的 “try” 版本，即“一次性”版本1234567891011121314151617181920212223242526public boolean tryUnlockWrite() &#123; long s; WNode h; if (((s = state) &amp; WBIT) != 0L) &#123; state = (s += WBIT) == 0L ? ORIGIN : s; if ((h = whead) != null &amp;&amp; h.status != 0) release(h); return true; &#125; return false; &#125; public boolean tryUnlockRead() &#123; long s, m; WNode h; while ((m = (s = state) &amp; ABITS) != 0L &amp;&amp; m &lt; WBIT) &#123; if (m &lt; RFULL) &#123; if (U.compareAndSwapLong(this, STATE, s, s - RUNIT)) &#123; if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0) release(h); return true; &#125; &#125; else if (tryDecReaderOverflow(s) != 0L) return true; &#125; return false; &#125;锁转换StampedLock 读写锁之间可以互相转换，可以更细粒度控制并发。包括三种转换：转换成写锁转换成悲观读锁转换成乐观读锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 尝试转换成写锁public long tryConvertToWriteLock(long stamp) &#123; long a = stamp &amp; ABITS, m, s, next; while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123; if ((m = s &amp; ABITS) == 0L) &#123; if (a != 0L) break; if (U.compareAndSwapLong(this, STATE, s, next = s + WBIT)) return next; &#125; else if (m == WBIT) &#123; if (a != m) break; return stamp; &#125; else if (m == RUNIT &amp;&amp; a != 0L) &#123; if (U.compareAndSwapLong(this, STATE, s, next = s - RUNIT + WBIT)) return next; &#125; else break; &#125; return 0L;&#125;// 尝试转换成悲观读锁public long tryConvertToReadLock(long stamp) &#123; long a = stamp &amp; ABITS, m, s, next; WNode h; while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123; if ((m = s &amp; ABITS) == 0L) &#123; if (a != 0L) break; else if (m &lt; RFULL) &#123; if (U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) return next; &#125; else if ((next = tryIncReaderOverflow(s)) != 0L) return next; &#125; else if (m == WBIT) &#123; if (a != m) break; state = next = s + (WBIT + RUNIT); if ((h = whead) != null &amp;&amp; h.status != 0) release(h); return next; &#125; else if (a != 0L &amp;&amp; a &lt; WBIT) return stamp; else break; &#125; return 0L;&#125;// 尝试转换成乐观读锁public long tryConvertToOptimisticRead(long stamp) &#123; long a = stamp &amp; ABITS, m, s, next; WNode h; U.loadFence(); for (;;) &#123; if (((s = state) &amp; SBITS) != (stamp &amp; SBITS)) break; if ((m = s &amp; ABITS) == 0L) &#123; if (a != 0L) break; return s; &#125; else if (m == WBIT) &#123; if (a != m) break; state = next = (s += WBIT) == 0L ? ORIGIN : s; if ((h = whead) != null &amp;&amp; h.status != 0) release(h); return next; &#125; else if (a == 0L || a &gt;= WBIT) break; else if (m &lt; RFULL) &#123; if (U.compareAndSwapLong(this, STATE, s, next = s - RUNIT)) &#123; if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0) release(h); return next &amp; SBITS; &#125; &#125; else if ((next = tryDecReaderOverflow(s)) != 0L) return next &amp; SBITS; &#125; return 0L;&#125;性能对比和 ReadWritLock相比，在一个线程情况下，是读速度其4倍左右，写是1倍。和 ReadWritLock相比，六个线程情况下，读性能是其几十倍，写性能也是近10倍左右。和 ReadWritLock相比，吞吐量提高总结StampedLock 提供的读写锁与 ReentrantReadWriteLock 类似，前者不支持重入，不支持条件变量，也就是没 Condition。不过前者通过提供乐观读锁在多线程多读的情况下能提供更好的性能，这是因为获取乐观读锁时候不需要进行 CAS 操作设置锁的状态，而只是简单的测试状态。writeLock() 或者 readLock() 获得锁之后，线程还没执行完就被 interrupt() 的话，会导致 CPU 飙升。另外，StampedLock 使用时要特别小心，避免锁重入的操作，在使用乐观读锁时也需要遵循相应的调用模板，防止出现数据不一致的问题。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>StampedLock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtomicInteger解析]]></title>
    <url>%2Fposts%2F4f6208ca%2F</url>
    <content type="text"><![CDATA[本文代码基于 JDK 8前言AtomicInteger 是 Integer 类型的线程安全原子类，可以在应用程序中以原子方式更新 int 值，是 atomic 框架中经常使用的原子类。AtomicInteger 使用示例12345678910111213141516171819202122232425262728public class AtomicTest &#123; public static AtomicInteger atomicRace = new AtomicInteger(0); public static int race = 0; public static void increase() &#123; atomicRace.incrementAndGet(); race++; &#125; private static final int THREADS_COUNT = 20; public static void main(String[] args) throws InterruptedException &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; threads[i] = new Thread(() -&gt; &#123; for (int i1 = 0; i1 &lt; 10000; i1++) &#123; increase(); &#125; &#125;); threads[i].start(); &#125; for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; threads[i].join(); &#125; System.out.println("atomic race: " + atomicRace); System.out.println(" race: " + race); &#125;&#125;执行结果如下：12atomic race: 200000 race: 114084由于自增操作并不能保证原子性，所以并发情况下 race 的值每次不太一样，而使用 AtomicInteger 可以保证自增操作原子性，使得每次结果都是 200000。AtomicInteger 底层实现AtomicInteger 继承 Number，底层是通过 Unsafe 类做 CAS 操作，来原子的更新状态值。12345678910111213141516171819202122public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // 使用 Unsafe.compareAndSwapInt 去更新状态值 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; // AtomicIntegerd 的值 private volatile int value; // 根据 initialValue 创建一个新的 AtomicInteger 对象 public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; // 创建一个新的 AtomicInteger public AtomicInteger() &#123; &#125;&#125;AtomicInteger 常用方法AtomicInteger 常用方法包括原子的加、减等，类似 i++、++i、i–、–i 操作。12345678910111213141516171819202122232425262728293031323334353637383940// 获取当前值public final int get() &#123; return value;&#125;// 将 newValue 设置为当前值public final void set(int newValue) &#123; value = newValue;&#125;// 原子的将旧状态值设置为 newValue 并返回旧状态值public final int getAndSet(int newValue) &#123; return unsafe.getAndSetInt(this, valueOffset, newValue);&#125;// 如果expect值和当前值相等且原子的设置当前值为 update，则返回 true，否则返回 falsepublic final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125;// 原子的将当前状态值加一，返回之前的状态值，先取后增public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125;// 原子的将当前状态值减一，返回之前的状态值，先取后减public final int getAndDecrement() &#123; return unsafe.getAndAddInt(this, valueOffset, -1);&#125;// 原子的将当前状态值加 delta，返回之前的状态值，先取后增public final int getAndAdd(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta);&#125;// 原子的将当前状态值减 delta，返回之前的状态值，先增后取public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;// 原子的将当前状态值减一，返回当前的状态值，先减后取public final int decrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, -1) - 1;&#125;// 原子的将当前状态值加 delta，返回当前的状态值，先增后取public final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta;&#125;AtomicInteger 特殊方法lazySet 方法12345// set() 方法的不可见版本public final void lazySet(int newValue) &#123; // putOrderedInt 设置值并且马上写入主存，该变量必须是 volatile 类型 unsafe.putOrderedInt(this, valueOffset, newValue);&#125;lazySet()⽅法是 set() ⽅法的不可⻅版本。通过 volatile 修饰的变量，可以保证在多处理器环境下的可⻅性，即当⼀个线程修改⼀个共 享变量时，其它线程能⽴即读到这个修改的值。volatile 的实现加了内存屏障：保证写 volatile 变量时会强制把 CPU 写缓存区的数据刷新到内存。读 volatile 变量时，使缓存失效，强制从内存中读取最新的值。由于内存屏障的存在，volatile变量还能阻⽌重排序。lazySet 内部调⽤了 Unsafe 类的 putOrderedInt ⽅法，通过该⽅法对共享变量值的改变，不⼀定能被其他线 程⽴即看到。也就是说以普通变量的操作⽅式来写变量。什么情况下需要使⽤ lazySet 呢？ 考虑下⾯这样⼀个场景：1234567AtomicInteger ai = new AtomicInteger();lock.lock();try &#123; // ai.set(1);&#125; finally &#123; lock.unlock();&#125;由于锁的存在：lock() ⽅法获取锁时，和 volatile 变量的读操作⼀样，会强制使 CPU 缓存失效，强制从内存读取变量。unlock() ⽅法释放锁时，和 volatile 变量的写操作⼀样，会强制刷新 CPU 写缓冲区，把缓存数据写到主内存。所以，上述 ai.set(1)可以⽤ ai.lazySet(1) ⽅法替换： 由锁来保证共享变量的可⻅性，以设置普通变量的⽅式来修改共享变量，减少不必要的内存屏障，从⽽提⾼ 程序执⾏的效率。weakCompareAndSet 方法weakCompareAndSet 操作仅保留了 volatile自身变量的特性，而去除了 happens-before 规则带来的内存语义。也就是说，weakCompareAndSet 无法保证处理操作目标的 volatile 变量外的其他变量的执行顺序( 编译器和处理器为了优化程序性能而对指令序列进行重新排序 )，同时也无法保证这些变量的可见性。123public final boolean weakCompareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125;在 JDK 8 及之前的版本，weakCompareAndSet 方法并没有被真正意义上的实现，目前该方法所呈现出来的效果与 compareAndSet 方法是一样的。在 JDK 9 中 compareAndSet 和 weakCompareAndSet 方法的实现有些许的不同底层调用的 native 方法的实现中，cmpxchgb 指令前都会有“lock”前缀，而在 JDK 8 中，程序会根据当前处理器的类型来决定是否为 cmpxchg 指令添加 lock 前缀，只有在 CPU 是多处理器(multi processors)的时候，会添加一个 lock 前缀)。新增 @HotSpotIntrinsicCandidate 注解，该注解是特定于 Java 虚拟机的注解。通过该注解表示的方法可能( 但不保证 )通过 HotSpot VM 自己来写汇编或IR编译器来实现该方法以提供性能。AtomicInteger 新增方法在 JDK 8 中，AtomicInteger 新增了一些方法，使用 JDK 8 的函数式接口。不过这些函数应该是无副作用的，因为当尝试的更新时，如果由于线程争用更新失败，可能会重新应用它。1234567891011121314151617181920212223242526272829303132333435363738394041// 原子的将给定函数的结果更新当前值，并返回旧值。public final int getAndUpdate(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); // 将此运算符 applyAsInt 应用于给定的操作数 prev next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return prev;&#125;// 原子的将函数的结果更新当前值，并返回新值。public final int updateAndGet(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return next;&#125;// 原子的将函数的结果和 x 的计算结果更新当前值，并返回新值。public final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) &#123; int prev, next; do &#123; prev = get(); next = accumulatorFunction.applyAsInt(prev, x); &#125; while (!compareAndSet(prev, next)); return prev;&#125;// 原子地根据给定函数的结果和 x 的计算结果更新当前值public final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) &#123; int prev, next; do &#123; prev = get(); // 将此运算符 applyAsInt 应用于给定的操作数 prev next = accumulatorFunction.applyAsInt(prev, x); &#125; while (!compareAndSet(prev, next)); return next;&#125;AtomicInteger 溢出问题使用了 AtomicInteger 的 incrementAndGet 方法不断的增加，如果 AtomicInteger 增加到了2147483647 (即) 再加一，AtomicInteger 的值会变成负数 -2147483648。如果不对其作出处理，当资源数目不断累积超过最大值变成负数的时候。比如可以在 AtomicInteger 变量达到最大值的时候，转为零重新开始计数，并保证 AtomicInteger 在多线程环境下的原子性。1234567891011121314151617181920212223private final AtomicInteger i = new AtomicInteger(0);public final int incrementAndGet() &#123; int current; int next; do &#123; current = this.i.get(); next = current &gt;= Integer.MAX_VALUE ? 0 : current + 1; &#125; while (!this.i.compareAndSet(current, next)); return next;&#125;public final int decrementAndGet() &#123; int current; int next; do &#123; current = this.i.get(); next = current &lt;= 0 ? Integer.MAX_VALUE : current - 1; &#125; while (!this.i.compareAndSet(current, next)); return next;&#125;总结AtomicInteger 使用非阻塞算法实现并发控制，在一些高并发程序中非常适合，但并不代表每一种场景都适合，不同场景要使用使用不同的数值类。比如 AtomicBoolean、AtomicLong 等。AtomicIntegerArray 或 AtomicLongArray 操作类似，不过它们对应的数组，操作的是数组中的某个元素，通过索引对值进行操作。其他 Atomic 类AtomicReference可以原子更新的对象引用。和 AtomicInteger 类似，少了一些数字类型的“加”、”减”操作，支持泛型，具体含义和方法名息息相关，具体实现和 AtomicInteger 也类似。AtomicReferenceArray 则和 AtomicIntegerArray 类似。1234567891011121314151617181920212223242526public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123; private static final long serialVersionUID = -1848883965231344442L; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicReference.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile V value; // 根据 initialValue 创建一个 AtomicReference 对象 public AtomicReference(V initialValue) &#123; value = initialValue; &#125; /** * Creates a new AtomicReference with null initial value. */ // 创建一个空 AtomicReference 对象，value 为 null public AtomicReference() &#123; &#125;&#125;方法如下。12345678910111213141516171819202122public final V get();public final void set(V newValue);public final void lazySet(V newValue);public final boolean compareAndSet(V expect, V update);public final boolean weakCompareAndSet(V expect, V update);@SuppressWarnings("unchecked")public final V getAndSet(V newValue);public final V getAndUpdate(UnaryOperator&lt;V&gt; updateFunction);public final V updateAndGet(UnaryOperator&lt;V&gt; updateFunction);public final V getAndAccumulate(V x, BinaryOperator&lt;V&gt; accumulatorFunction);public final V accumulateAndGet(V x, BinaryOperator&lt;V&gt; accumulatorFunction);public String toString();AtomicIntegerFieldUpdater基于反射的实用工具，可以对指定类的指定 volatile int 字段进行原子更新。此类用于原子数据结构，该结构中同一节点的几个字段都独立受原子更新控制。此类中 compareAndSet方法的保证弱于其他原子类中该方法的保证。因为此类不能确保所有使用的字段都适合于原子访问目的，所以对于相同更新器上的 compareAndSet 和 set 的其他调用，它仅可以保证原子性和可变语义。有如下限制：操作的 int 字段必须是基本类型数据，用volatile修饰，不能是包装类型，int、long就可以，但是不可以是Integer和Long；必须是实例变量，不可以是类变量；必须是可变的变量，不能是final修饰的变量。示例如下：定义一个 Person 类，有一个 id 字段123456789101112131415public class Person &#123; volatile int id; public Person(int id) &#123; this.id = id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getId() &#123; return id; &#125;&#125;修改 id 字段12345678910111213public static void main(String[] args) &#123; // 指定 Person 对象和 id 字段 AtomicIntegerFieldUpdater&lt;Person&gt; personAtomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Person.class, "id"); Person person = new Person(99999); personAtomicIntegerFieldUpdater.compareAndSet(person, 99999, 99999); System.out.println("id=" + person.getId()); Person person1 = new Person(99999); personAtomicIntegerFieldUpdater.incrementAndGet(person1); System.out.println("id=" + person1.getId()); IntBinaryOperator intBinaryOperator = (left, right) -&gt; left+right; personAtomicIntegerFieldUpdater.getAndAccumulate(person1, 1, intBinaryOperator); System.out.println("id=" + person1.getId());&#125;从示例来看，具体操作和 AtomicInteger 操作起来其实和是一样的。只不过操作之前需要指定对哪个对象的哪个字段进行操作。AtomicStampedReference在运用 CAS 做锁释放操作中有一个经典的 ABA问题：在线程1准备用 CAS 将变量的值由A替换为B之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行 CAS 时发现变量的值仍然为A，所以 CAS 成功。但实际上这时的现场已经和最初不同了，尽管 CAS 成功，但可能存在潜藏的问题12345678910111213141516171819202122public class AtomicStampedReference&lt;V&gt; &#123; // 内部 Pair 类，一个[reference, stamp]元组 。 private static class Pair&lt;T&gt; &#123; final T reference; // 版本戳 final int stamp; private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125; &#125; private volatile Pair&lt;V&gt; pair; // 根据初始 initialRef 和 initialStamp 创建一个 AtomicStampedReference 对象 public AtomicStampedReference(V initialRef, int initialStamp) &#123; pair = Pair.of(initialRef, initialStamp); &#125;&#125;各种乐观锁的实现中通常都会用版本戳 version 来对记录或对象标记，避免并发操作带来的问题，在 Java 中，AtomicStampedReference&lt;V&gt;也实现了这个作用，它通过包装 [E,Integer] 的元组来对对象标记版本戳 stamp，从而避免 ABA 问题。AtomicMarkableReference 与 AtomicStampedReference ，不过前者版本戳 final int stamp 变成了 final boolean mark。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>AtomicInteger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal分析]]></title>
    <url>%2Fposts%2F90bf09a1%2F</url>
    <content type="text"><![CDATA[本文代码基于Java8前言ThreadLocal 的官方API解释为：该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。ThreadLocal 提供了一种访问某个变量的特殊方式：访问到的变量属于当前线程，即保证每个线程的变量不一样，而同一个线程在任何地方拿到的变量都是一致的，这就是所谓的线程隔离。如果要使用 ThreadLocal ，通常定义为 private static 类型，最好是定义为 private static final 类型。即 ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。ThreadLocal 类结构ThreadLocal 类结构如下：ThreadLocalMap、SuppliedThreadLocal 是 ThreadLocal 内部类，且 SuppliedThreadLocal 继承自 ThreadLocal， Entry 是 ThreadLocalMap 内部类。1234567891011public class ThreadLocal&lt;T&gt; &#123; // 下一个哈希值 private final int threadLocalHashCode = nextHashCode(); // 下一个要给出的哈希值，原子更新，从 0 开始。 private static AtomicInteger nextHashCode = new AtomicInteger(); // 连续生成的散列码之间的差异：将隐式顺序线程局部id转换为近似最优分布的乘法散列值，以获得两个大小表的幂。 private static final int HASH_INCREMENT = 0x61c88647; // 构造函数 public ThreadLocal() &#123; &#125;&#125;ThreadLocalMap 实现ThreadLocalMap 是一个定制的散列映射，仅适用于维护线程本地值。该类是包私有的，允许在 Thread 类中声明字段。在 ThreadLocal 类之外不做任何操作。为了帮助处理占用内存大和存活时间长的用法，哈希表 Entry 使用弱引用作为键。但是，由于不使用引用队列，因此只有当表开始耗尽空间时，才保证删除过时的条目。每个线程可能有多个 ThreadLocal，同一线程的各个ThreadLocal 存放于同一个 ThreadLocalMap 中。12345678static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** 和当前 ThreadLocal 有关 */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125;ThreadLocalMap 具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277static class ThreadLocalMap &#123; // 哈希表 Entry static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** 该值和当前 ThreadLocal 对象有关 */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; // 哈希表初始容量，必须是 2 的指数 private static final int INITIAL_CAPACITY = 16; // Entry表，需要的时候会调整表大小，表大小一定是 2 的指数。 private Entry[] table; // 表中 Entry 数量 private int size = 0; // Entry表大小调整的阈值，默认是 0 private int threshold; // Default to 0 // 设置阈值为表长度的 2/3 private void setThreshold(int len) &#123; threshold = len * 2 / 3; &#125; // 获取下一个 index，i+1&lt;len 则返回 i + 1，否则返回 0 private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; // 获取上一个 index，i - 1 &gt;= 0 则返回 i-1，否则返回 len-1 private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1); &#125; /** ThreadLocalMap 构造函数 */ ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; // 创建大小为 INITIAL_CAPACITY 的 Entry表 table = new Entry[INITIAL_CAPACITY]; // 根据 firstKey 的哈希值和初始容量获取元素 index int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); // 设置表的元素 table[i] = new Entry(firstKey, firstValue); size = 1; // 设置表大小调整阈值 setThreshold(INITIAL_CAPACITY); &#125; /** 根据 parentMap 构造 ThreadLocalMap */ private ThreadLocalMap(ThreadLocalMap parentMap) &#123; Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j &lt; len; j++) &#123; Entry e = parentTable[j]; if (e != null) &#123; @SuppressWarnings("unchecked") ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get(); if (key != null) &#123; Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode &amp; (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; &#125; &#125; &#125; &#125; /** 根据 key 获取 Entry */ private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; // 在其直接哈希槽中找不到密钥时使用的GetEntry方法。 private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null; &#125; /** ThreadLocalMap set 方法 */ private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; /** 从 ThreadLocalMap 中移除 key */ private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; e.clear(); expungeStaleEntry(i); return; &#125; &#125; &#125; // 用指定 key 的项替换 set 操作期间遇到的过时项 private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125; // 通过重新清除位于过时槽和下一个空槽之间的任何可能发生冲突的条目来删除过时的条目 private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i; &#125; // 试探性地扫描一些单元格以查找过时的条目。 private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed; &#125; /** 重新哈希 */ private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize(); &#125; /** 调整 Entry 表大小，大小变为原来的 2 倍 */ private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab; &#125; /** 删除表中所有过时的项 */ private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) expungeStaleEntry(j); &#125; &#125;&#125;SuppliedThreadLocal 实现SuppliedThreadLocal 是 JDK8 新增的内部类，只是扩展了 ThreadLocal 的初始化值的方法而已，允许使用 JDK8 新增的 Lambda 表达式赋值。需要注意的是，函数式接口 Supplier 不允许为 null。12345678910111213141516static final class SuppliedThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123; // Supplier容器 private final Supplier&lt;? extends T&gt; supplier; // SuppliedThreadLocal 构造方法 SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123; // supplier == null 会抛出空指针异常 this.supplier = Objects.requireNonNull(supplier); &#125; @Override protected T initialValue() &#123; // 调用get()方法，此时会调用对象的构造方法，即获得到真正对象 // 每次get都会调用构造方法，即获取的对象不同 return supplier.get(); &#125;&#125;ThreadLocal 的基本方法ThreadLocal 的基本方法包括取值、设置初始值、赋值、移除等1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 取值public T get() &#123; Thread t = Thread.currentThread(); // 根据当前线程获取本地线程 Map ThreadLocalMap map = getMap(t); if (map != null) &#123; // 本地线程Map不为空 // 获取当前对象对应的本地线程 Map 的 Entry 对象 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; // Entry 对象不为空 @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; // 设置初始值后返回初始值 return setInitialValue();&#125;// 设置初始值private T setInitialValue() &#123; // 继承 ThreadLocal 后重写，参考 SuppliedThreadLocal T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else // 本地线程 Map 不存在则创建 createMap(t, value); return value;&#125;// 创建本地线程 Mapvoid createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;// 赋值public void set(T value) &#123; Thread t = Thread.currentThread(); // 获取当前对象对应的本地线程 Map ThreadLocalMap map = getMap(t); if (map != null) // 覆盖 map.set(this, value); else // 本地线程 Map 不存在则创建 createMap(t, value);&#125;// 移除public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125;// 创建线程局部变量。变量的初始值是通过调用&#123;@code supplier&#125;上的&#123;@code get&#125;方法来确定的。public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) &#123; return new SuppliedThreadLocal&lt;&gt;(supplier);&#125;使用场景变量有局部的还有全局的，局部变量没什么好说的，一涉及到全局，那自然就会出现多线程的安全问题，要保证多线程安全访问，不出现脏读脏写，那就要涉及到线程同步了。而 ThreadLocal 相当于提供了介于局部变量与全局变量中间的这样一种线程内部的全局变量。当我们只想在本身的线程内使用的变量，可以用 ThreadLocal 来实现，并且这些变量是和线程的生命周期密切相关的，线程结束，变量也就销毁了。 ThreadLocal 不是为了解决线程间的共享变量问题的，如果是多线程都需要访问的数据，那需要用全局变量加同步机制。线程中处理一个非常复杂的业务，可能方法有很多，那么，使用 ThreadLocal 可以代替一些参数的显式传递；在一些多线程的情况下，如果用线程同步的方式，当并发比较高的时候会影响性能，可以改为 ThreadLocal 的方式，例如高性能序列化框架 Kyro 就要用 ThreadLocal 来保证高性能和线程安全；线程内上下文管理器、数据库连接等可以用到 ThreadLocal ;用来存储用户 Session。Session 的特性很适合 ThreadLocal ，因为 Session 之前当前会话周期内有效，会话结束便销毁。内存泄漏问题ThreadLocal 的不正确使用会导致内存泄漏。实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。JVM 利用调用 remove、get、set 方法的时候，会清除线程 ThreadLocalMap 里所有 key 为 null 的 value，回收弱引用。所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap 中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。当使用静态 ThreadLocal 的时候，延长 ThreadLocal 的生命周期，那也可能导致内存泄漏。因为，静态变量在类未加载的时候，它就已经加载，当线程结束的时候，静态变量不一定会回收。ThreadLocal 出现内存泄漏条件：ThreadLocal 引用被设置为 null，且后面没有 set、get、remove 操作。线程一直运行，不停止。（线程池）触发了垃圾回收。（Minor GC或Full GC）如何避免内存泄漏：ThreadLocal 声明为 private final。 private 与 final 尽可能不让他人修改变更引用，最好不要声明为静态的。ThreadLocal 使用后务必调用 remove 方法。最简单有效的方法是使用后将其移除。总结ThreadLocalMap 并不是为了解决线程安全问题，而是提供了一种将实例绑定到当前线程的机制，类似于隔离的效果。每个线程维护一个 ThreadLocalMap 的映射表，映射表的 key 是 ThreadLocal 实例本身，value 是要存储的副本变量。ThreadLocal 实例本身并不存储值，它只是提供一个在当前线程中找到副本值的 key。ThreadLocal 设计的初衷是为了解决多线程编程中的资源共享问题。对比 synchronized，synchronized 采取的是“以时间换空间”的策略，本质上是对关键资源上锁，让大家排队操作。而 ThreadLocal 采取的是“以空间换时间”的思路，为每个使用该变量的线程提供独立的变量副本，在本线程内部，它相当于一个“全局变量”，可以保证本线程任何时间操纵的都是同一个对象。ThreadLocal 类最重要的一个概念是，其原理是通过一个 ThreadLocal 的静态内部类 ThreadLocalMap 实现，但是实际中，ThreadLocal 不保存 ThreadLocalMap，而是有每个 Thread 内部维护 ThreadLocal.ThreadLocalMap threadLocals 一份数据结构。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantReadWriteLock解析]]></title>
    <url>%2Fposts%2Fcb5cf479%2F</url>
    <content type="text"><![CDATA[本文代码基于Java8前言ReentrantReadWriteLock 是 Lock 的另一种实现方式， ReentrantLock 是一个排他锁，同一时间只允许一个线程访问，而 ReentrantReadWriteLock 允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。读写锁内部维护了两个锁，一个用于读操作，一个用于写操作。所有 ReadWriteLock 实现都必须保证 writeLock 操作的内存同步效果也要保持与相关 readLock 的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。ReentrantReadWriteLock 支持以下功能：支持公平和非公平的获取锁的方式；支持可重入。读线程在获取了读锁后还可以获取读锁，写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；读取锁和写入锁都支持锁获取期间的中断；支持 Condition 。仅写入锁提供了一个 Conditon 实现，读取锁不支持 Conditon 。readLock().newCondition() 会抛出 UnsupportedOperationException。ReentrantReadWriteLock 类结构12345678910111213141516171819202122232425public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable &#123; private static final long serialVersionUID = -6992448646407690164L; /** 内部类提供读取锁 */ private final ReentrantReadWriteLock.ReadLock readerLock; /** 内部类提供写入锁 */ private final ReentrantReadWriteLock.WriteLock writerLock; /** 执行所有同步机制 */ final Sync sync; // 锁默认是非公平模式 public ReentrantReadWriteLock() &#123; this(false); &#125; // 支持指导锁公平模式 public ReentrantReadWriteLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); &#125; // 获取写入锁 public ReentrantReadWriteLock.WriteLock writeLock() &#123; return writerLock; &#125; // 获取读取锁 public ReentrantReadWriteLock.ReadLock readLock() &#123; return readerLock; &#125;&#125;其中Sync 、FairSync、NonfairSync、ReadLock、WriteLock 是 ReentrantReadWriteLock 的内部类，Sync 继承自 AbstractQueuedSynchronizer ，而 FairSync、NonfairSync 继承 Sync，分别对应公平锁和非公平锁。ThreadLocalHoldCounter 、HoldCounter是 Sync的内部类。Sync 锁Sync 也是一个继承于AQS的抽象类。Sync 也包括公平锁 FairSync 和非公平锁 NonfairSync。sync 对象是 FairSync 和 NonfairSync 中的一个，默认是 NonfairSync。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 6317671515068378041L; /** Lock 状态逻辑上分为两个无符号 short 类型： * 1. 低位表示独占（writer）锁写入计数 * 2. 高位表示共享（reader）锁读取次数 */ static final int SHARED_SHIFT = 16; static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT); static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1; static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1; /** 返回共享（reader）锁被持有次数 */ static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125; /** 返回独占（writer）锁被持有次数 */ static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125; // 持有计数器：每个线程持有锁的次数 static final class HoldCounter &#123; int count = 0; // 为了避免垃圾滞留(garbage retention)，使用 id 而不是引用 final long tid = getThreadId(Thread.currentThread()); &#125; // 本地线程持有锁的计数器 static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; &#123; public HoldCounter initialValue() &#123; return new HoldCounter(); &#125; &#125; // 当前线程持有的可重入读锁数。每当线程的读取保持计数降至0时删除。 private transient ThreadLocalHoldCounter readHolds; // 成功获取读锁的最后一个线程的保持计数器 private transient HoldCounter cachedHoldCounter; // 第一个获取读锁的线程 private transient Thread firstReader = null; private transient int firstReaderHoldCount; Sync() &#123; readHolds = new ThreadLocalHoldCounter(); setState(getState()); // 确保读取锁持有次数可见 &#125; // 如果当前线程尝试获取读锁，且在其他情况下有资格获取该锁，但由于超过其他等待线程的策略而应该阻塞，则返回true。 abstract boolean readerShouldBlock(); // 如果当前线程尝试获取写锁，且在其他情况下有资格获取该锁，但由于超过其他等待线程的策略而应该阻塞，则返回true。 abstract boolean writerShouldBlock(); // 释放写锁 protected final boolean tryRelease(int releases) &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int nextc = getState() - releases; boolean free = exclusiveCount(nextc) == 0; if (free) setExclusiveOwnerThread(null); setState(nextc); return free; &#125; // 获取写锁 protected final boolean tryAcquire(int acquires) &#123; // 获取当前线程 Thread current = Thread.currentThread(); int c = getState(); // 获取当前状态 int w = exclusiveCount(c); // 获取写的状态 if (c != 0) &#123; // 读状态不为0，读锁已获取 // 写状态为 0 或 当前线程不是独占线程 if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error("Maximum lock count exceeded"); // 增加写状态，写锁获取成功 setState(c + acquires); return true; &#125; // 读锁未获取 if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) // 当前线程应该阻塞或通过 CAS 更新 state 为 c + acquires 失败 return false; // 设置当前线程为独占线程 setExclusiveOwnerThread(current); return true; &#125; // 释放读锁 protected final boolean tryReleaseShared(int unused) &#123; Thread current = Thread.currentThread(); if (firstReader == current) &#123; // 当前线程是第一个成功获取读锁的线程 if (firstReaderHoldCount == 1) // 线程读锁数量为1，那么第一个成功获取读锁的线程置为null firstReader = null; else // 线程读锁数量减一 firstReaderHoldCount--; &#125; else &#123; // 从缓存中获取当前线程的读锁数量 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); int count = rh.count; // 当前线程的读锁数量 if (count &lt;= 1) &#123; // 从本地线程移除读锁线程 readHolds.remove(); if (count &lt;= 0) // 无读锁可以释放 throw unmatchedUnlockException(); &#125; // 线程读锁数量减一 --rh.count; &#125; for (;;) &#123; int c = getState(); int nextc = c - SHARED_UNIT; // state读锁状态减一 if (compareAndSetState(c, nextc)) // Releasing the read lock has no effect on readers, // but it may allow waiting writers to proceed if // both read and write locks are now free. return nextc == 0; // 如果state为0，表示无锁状态，返回true &#125; &#125; // 获取读锁 protected final int tryAcquireShared(int unused) &#123; // 获取当前线程 Thread current = Thread.currentThread(); int c = getState(); // 获取当前状态态 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) // 写状态不为 0 且当前线程是独占线程 return -1; int r = sharedCount(c); // 获取读状态 if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; // 读锁线程不阻塞、读取锁的共享计数未超过限制且通过 CAS 获取锁失败 if (r == 0) &#123; // 读状态为 0 firstReader = current; //当前线程是第一个成功获取读锁的线程 firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; // 当前线程是第一个成功获取读锁的线程 firstReaderHoldCount++; // 持有读锁数量加一 &#125; else &#123; // 从缓存中获取当前线程的读锁数量 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) // 缓存读锁为 null 或当前线程的 id 不等于缓存线程 id cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) // 将读锁线程加到本地线程 readHolds.set(rh); rh.count++; // 持有读锁数量加一 &#125; return 1; &#125; // 读锁线程阻塞等待 // 读取锁的共享计数超过限制 // 通过 CAS 获取锁失败 return fullTryAcquireShared(current); &#125; // 如果读锁线程阻塞等待、读取锁的共享计数超过限制、通过 CAS 获取锁失败，则通过该方法获取读锁 final int fullTryAcquireShared(Thread current) &#123; // HoldCounter rh = null; for (;;) &#123; int c = getState(); // 获取当前状态 if (exclusiveCount(c) != 0) &#123; // 写锁已经被获取 if (getExclusiveOwnerThread() != current) // 当前线程不是独占线程 return -1; &#125; else if (readerShouldBlock()) &#123; // 读锁线程阻塞等待 // Make sure we're not acquiring read lock reentrantly if (firstReader == current) &#123; // assert firstReaderHoldCount &gt; 0; &#125; else &#123; // 当前线程不是 firstReader if (rh == null) &#123; // 获取缓存读锁数量 rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) &#123; rh = readHolds.get(); if (rh.count == 0) readHolds.remove(); &#125; &#125; if (rh.count == 0) return -1; &#125; &#125; // 如果读锁数量超过 MAX_COUNT，则抛出异常。 if (sharedCount(c) == MAX_COUNT) throw new Error("Maximum lock count exceeded"); if (compareAndSetState(c, c + SHARED_UNIT)) &#123; // 通过 CAS 获取锁成功 if (sharedCount(c) == 0) &#123; // 当前读锁数量为 0 firstReader = current; // 当前线程设置为 firstReader firstReaderHoldCount = 1; // firstReader 计数初始化 &#125; else if (firstReader == current) &#123; // 当前线程是 firstReader firstReaderHoldCount++; // firstReader 计数加一 &#125; else &#123; // 获取缓存读锁数量 if (rh == null) rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; // 读锁数量加一 cachedHoldCounter = rh; // cache for release &#125; return 1; &#125; &#125; &#125; // 创建并返回 Condition 对象 final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; // 获取读锁数量 final int getReadHoldCount() &#123; if (getReadLockCount() == 0) return 0; Thread current = Thread.currentThread(); // 当前线程是首次成功获取读锁的线程 if (firstReader == current) return firstReaderHoldCount; // 获取缓存读锁数量 HoldCounter rh = cachedHoldCounter; if (rh != null &amp;&amp; rh.tid == getThreadId(current)) return rh.count; int count = readHolds.get().count; if (count == 0) readHolds.remove(); return count; &#125; // 反序列化方法，将当前 state 重置为 0 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); readHolds = new ThreadLocalHoldCounter(); setState(0); // reset to unlocked state &#125;&#125;公平锁和非公平锁实现和互斥锁 ReentrantLock 一样，读写锁也分为公平锁和非公平锁。公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数是不同的。12345678910111213141516171819202122232425262728293031323334353637383940414243// 非公平锁static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -8159625535654395037L; final boolean writerShouldBlock() &#123; // 总是不阻塞 return false; // writers can always barge &#125; final boolean readerShouldBlock() &#123; // 只要该非公平读锁对应的线程不为 null，则返回 true。 return apparentlyFirstQueuedIsExclusive(); &#125;&#125;// AQS 中实现final boolean apparentlyFirstQueuedIsExclusive() &#123; Node h, s; return (h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp; !s.isShared() &amp;&amp; s.thread != null;&#125;// 公平锁static final class FairSync extends Sync &#123; private static final long serialVersionUID = -2274990926593161451L; final boolean writerShouldBlock() &#123; // 如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。 return hasQueuedPredecessors(); &#125; final boolean readerShouldBlock() &#123; // 如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。 return hasQueuedPredecessors(); &#125;&#125;// AQS 中实现public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125;readerShouldBlock 的本质就是在检测这次获取读锁资源的操作时，AQS 的等待队列中是否已经有写锁了。如果已经有写锁，那么要判断写锁是不是本线程，是本线程可以做锁降级。不是本线程就执行fullTryAcquireShared；如果没有写锁，就可以继续执行，做 r&lt;MAX_COUNT 判断。对公平锁而言，!readerShouldBlock() 就是 !hasQueuedPredecessors()， h == t || ((s = h.next)!=null &amp;&amp; s.thread == Thread.currentThread())h==t 说明Node的等待队列为空(s = h.next)!=null &amp;&amp; s.thread == Thread.currentThread() 说明等待队列中有值且是本线程申请锁资源。满足以上2点的任何一个，可以申请读锁，继续执行下面的 r&lt;MAX_COUNT 判断。ReadLock 与 WriteLock读锁读锁是一个可重入的共享锁，获取读锁的思想(即 lock()的步骤)，是先通过 tryAcquireShared() 尝试获取共享锁。尝试成功的话，则直接返回；尝试失败的话，则通过 doAcquireShared() 不断的循环并尝试获取锁，若有需要，则阻塞等待。doAcquireShared() 在循环中每次尝试获取锁时，都是通过 tryAcquireShared() 来进行尝试的。释放读锁的思想(即 unlock()的步骤)，是先通过 tryReleaseShared() 尝试释放共享锁。尝试成功的话，则通过doReleaseShared() 唤醒“其他等待获取共享锁的线程”，并返回true；否则的话，返回 flase。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public static class ReadLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = -5992448646407690164L; private final Sync sync; // 读锁构造函数 protected ReadLock(ReentrantReadWriteLock lock) &#123; sync = lock.sync; &#125; // 获取读锁，不感知中断 public void lock() &#123; // 参考 AQS 获取共享锁方法 acquireShared sync.acquireShared(1); &#125; //获取读锁，感知中断 public void lockInterruptibly() throws InterruptedException &#123; // 参考 AQS 获取共享锁方法 acquireSharedInterruptibly sync.acquireSharedInterruptibly(1); &#125; // 尝试获取锁 public boolean tryLock() &#123; return sync.tryReadLock(); &#125; // 尝试获取读锁 final boolean tryReadLock() &#123; Thread current = Thread.currentThread(); for (;;) &#123; int c = getState(); //当前状态 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) // 写锁已经被持有且当前线程不是独占线程 return false; int r = sharedCount(c); // 获取读锁数量 if (r == MAX_COUNT) throw new Error("Maximum lock count exceeded"); // 通过 CAS 获取锁 if (compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; // 写锁未被获取 firstReader = current; // 设置当前线程为 firstReader firstReaderHoldCount = 1; // firstReader 计数初始化 &#125; else if (firstReader == current) &#123; // 当前线程是 firstReader firstReaderHoldCount++; // firstReader 计数加一 &#125; else &#123; // 从缓存获取读锁数量 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return true; &#125; &#125; &#125; // 尝试获取读锁，感知中断且有超时时间 public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); &#125; // 释放读锁 public void unlock() &#123; sync.releaseShared(1); &#125; // 创建并返回 Condition，读锁不支持该操作 public Condition newCondition() &#123; throw new UnsupportedOperationException(); &#125;&#125;写锁写锁是一个可重入的排它锁。如果当前线程获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static class WriteLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = -4992448646407690164L; private final Sync sync; // 写锁构造函数 protected WriteLock(ReentrantReadWriteLock lock) &#123; sync = lock.sync; &#125; // 获取写锁，感知中断 public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; // 获取写锁，不感知中断 public boolean tryLock( ) &#123; return sync.tryWriteLock(); &#125; // 获取写锁 final boolean tryWriteLock() &#123; Thread current = Thread.currentThread(); int c = getState(); //获取当前状态 if (c != 0) &#123; int w = exclusiveCount(c); // 获取写状态 if (w == 0 || current != getExclusiveOwnerThread()) // 写状态为0 或 当前线程不是独占线程 return false; if (w == MAX_COUNT) // 写状态超过 MAX_COUNT throw new Error("Maximum lock count exceeded"); &#125; // 通过 CAS 获取锁失败 if (!compareAndSetState(c, c + 1)) return false; // 设置当前线程为独占线程 setExclusiveOwnerThread(current); return true; &#125; // 获取写锁，感知中断且有超时时间 public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; // 参考 AQS 的获取排它锁方法 tryAcquireNanos return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; // 释放排它锁 public void unlock() &#123; // 参考 AQS 的释放排它锁方法 release sync.release(1); &#125; // 创建并返回 Condition 对象 public Condition newCondition() &#123; return sync.newCondition(); &#125; // 判断当前线程是否是独占线程 public boolean isHeldByCurrentThread() &#123; return sync.isHeldExclusively(); &#125; // 获取写锁数量 public int getHoldCount() &#123; return sync.getWriteHoldCount(); &#125;&#125;使用示例利用重入来执行升级缓存后的锁降级锁降级指的是写锁降级成为读锁。锁降级是指把持住当前拥有的写锁的同时，再获取到读锁，随后释放写锁的过程。锁降级的意义在于：在一边读一边写的情况下感知数据变化并提高性能。首先写锁是独占的，读锁是共享的，然后读写锁是线程间互斥的，锁降级的前提是所有线程都希望对数据变化敏感，但是因为写锁只有一个，所以会发生降级。如果先释放写锁，再获取读锁，可能在获取之前，会有其他线程获取到写锁，阻塞读锁的获取，就无法感知数据变化了。所以需要先hold住写锁，保证数据无变化，获取读锁，然后再释放写锁。如果长时间用写锁独占，对于某些高响应的应用是不允许的。12345678910111213141516171819202122232425262728class CachedData &#123; Object data; volatile boolean cacheValid; //缓存是否有效 ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); void processCachedData() &#123; rwl.readLock().lock(); //获取读锁 //如果缓存无效，更新cache;否则直接使用data if (!cacheValid) &#123; //获取写锁前须释放读锁 rwl.readLock().unlock(); rwl.writeLock().lock(); // Recheck state because another thread might have acquired // write lock and changed state before we did. if (!cacheValid) &#123; data = ... cacheValid = true; &#125; // Downgrade by acquiring read lock before releasing write lock // 锁降级，在释放写锁前获取读锁 rwl.readLock().lock(); rwl.writeLock().unlock(); // Unlock write, still hold read &#125; use(data); rwl.readLock().unlock(); //释放读锁 &#125;&#125;使用 ReentrantReadWriteLock 来提高 Collection 的并发性通常在 collection 数据很多，读线程访问多于写线程并且附带操作的开销高于同步开销时尝试这么做。123456789101112131415161718192021222324252627282930313233343536373839404142public class RWDictionary &#123; private final Map&lt;String, Data&gt; m = new HashMap&lt;&gt;(); private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); private final Lock r = rwl.readLock(); //读锁 private final Lock w = rwl.writeLock(); //写锁 public Data get(String key) &#123; r.lock(); try &#123; return m.get(key); &#125; finally &#123; r.unlock(); &#125; &#125; public String[] allKeys() &#123; r.lock(); try &#123; return m.keySet().toArray(new String[0]); &#125; finally &#123; r.unlock(); &#125; &#125; public Data put(String key, Data value) &#123; w.lock(); try &#123; return m.put(key, value); &#125; finally &#123; w.unlock(); &#125; &#125; public void clear() &#123; w.lock(); try &#123; m.clear(); &#125; finally &#123; w.unlock(); &#125; &#125;&#125;总结相对于排他锁，读写锁提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时 ReentrantReadWriteLock 能够提供比排他锁更好的并发性和吞吐量。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>ReentrantReadWriteLock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore解析]]></title>
    <url>%2Fposts%2Fe73eaf42%2F</url>
    <content type="text"><![CDATA[前言Semaphore 是JDK1.5的 java.util.concurrent 并发包中提供的一个并发工具类。所谓 Semaphore 即 信号量 的意思。这个叫法并不能很好地表示它的作用，更形象的说法应该是 许可证管理器 。Semaphore 是一个计数信号量。从概念上将，Semaphore 包含一组许可证。如果有需要的话，每个 acquire() 方法都会阻塞，直到获取一个可用的许可证。每个 release() 方法都会释放持有许可证的线程，并且归还 Semaphore 一个可用的许可证。实际上并没有真实的许可证对象供线程使用，Semaphore 只是对可用的数量进行管理维护。Semaphore类结构Semaphore 类结构如下：其中Sync、FairSync、NonfairSync 是 Semaphore 的内部类。FairSync、NonfairSync 均继承自 Sync ：12345678910111213141516171819202122232425262728293031323334// NonFair versionstatic final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L; NonfairSync(int permits) &#123; super(permits); &#125; // 共享式获取同步状态 protected int tryAcquireShared(int acquires) &#123; // 无论当前线程是不是在 CLH 队列的头部，它都会直接获取信号量。 return nonfairTryAcquireShared(acquires); &#125;&#125;// Fair versionstatic final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; FairSync(int permits) &#123; super(permits); &#125; // 共享式获取同步状态 protected int tryAcquireShared(int acquires) &#123; // 如果当前线程不在 CLH 队列的头部，则排队等候。 for (;;) &#123; if (hasQueuedPredecessors()) // 判断当前线程是不是在 CLH 队列的头部 return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125;&#125;Sync 继承自 AbstractQueuedSynchronizer 。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 1192457210091910933L; Sync(int permits) &#123; setState(permits); &#125; final int getPermits() &#123; return getState(); &#125; // 非公平模式共享式获取同步状态 final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; // 共享式释放同步状态 // “非公平信号量许可的释放(release)”与“公平信号量许可的释放(release)”是一样的。 protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error("Maximum permit count exceeded"); if (compareAndSetState(current, next)) return true; &#125; &#125; // 减少许可数 final void reducePermits(int reductions) &#123; for (;;) &#123; int current = getState(); int next = current - reductions; if (next &gt; current) // underflow throw new Error("Permit count underflow"); if (compareAndSetState(current, next)) return; &#125; &#125; // 获取并返回立即可用的所有许可 final int drainPermits() &#123; for (;;) &#123; int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; &#125; &#125;&#125;Semaphore 构造方法构造方法分为两种，如下：12345678// 创建具有给定的许可数和非公平模式的 Semaphorepublic Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;// 创建具有给定的许可数和指定是否公平模式的 Semaphorepublic Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125;Semaphore 获取、释放许可的方法获取、释放许可的方法分为两大类，如下：12345678910111213141516171819202122/** * 阻塞方法： * 1. 无许可能够获得，则会一直等待，直到获得许可。 * 2. 在释放许可之前，必须先获获得许可。 */public void acquire() throws InterruptedException; // 获取一个许可public void acquire(int permits) throws InterruptedException; // 获取permits个许可public void release(); // 释放一个许可public void release(int permits); // 释放permits个许可/** * 非阻塞方法： * 立即获取执行结果 *///尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire();//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回falsepublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire(int permits); //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回falsepublic boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException;Semaphore的其他方法其他方法包括获取当前可用许可数、获取队列正在等待许可的线程数目、是否是公平模式等，如下：1234567891011121314151617// 返回此信号量中当前可用的许可数。public int availablePermits();// 返回正在等待获取的线程的估计数目。public int getQueueLength();// 获取并返回立即可用的所有许可。public int drainPermits();// 查询是否有线程正在等待获取。public boolean hasQueuedThreads();// 如果此信号量的公平设置为 true，则返回 true。public boolean isFair();// 返回标识此信号量的字符串，以及信号量的状态。public String toString();// 返回一个 collection，包含可能等待获取的线程。protected Collection&lt;Thread&gt; getQueuedThreads();// 根据指定的缩减量减小可用许可的数目。protected void reducePermits(int reduction);Semaphore的使用Semaphore 经常用于限制获取某种资源的线程数量。以请求总数为 6，并发执行的线程数为 2 为例：12345678910111213141516171819202122232425262728293031323334353637public class SemaphoreDemo &#123; // 请求总数 public static int clientTotal = 6; // 并发执行的线程数 public static int threadTotal = 2; // 随机数 public static Random random = new Random(); public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; final int count = i; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(1); System.out.println("处理请求 " + count + " 前，当前许可证数量：" + semaphore.availablePermits()); resolve(count); System.out.println("处理请求 " + count + " 中，正在等待许可证的请求数量：" + semaphore.getQueueLength()); semaphore.release(1); System.out.println("处理请求 " + count + " 后，当前许可证数量：" + semaphore.availablePermits()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); &#125; executorService.shutdown(); &#125; private static void resolve(int i) throws InterruptedException &#123; System.out.println("请求 " + i + " 开始处理"); int r = random.nextInt(i + 3) + 2; System.out.println("请求 " + i + "处理" + r + "秒"); Thread.sleep(1000 * r); System.out.println("请求 " + i + " 结束处理"); &#125;&#125;执行结果如下：123456789101112131415161718192021222324252627282930313233343536处理请求 0 前，当前许可证数量：0处理请求 1 前，当前许可证数量：0请求 0 开始处理请求 1 开始处理请求 0处理4秒请求 1处理2秒请求 1 结束处理处理请求 1 中，正在等待许可证的请求数量：4处理请求 1 后，当前许可证数量：1处理请求 2 前，当前许可证数量：0请求 2 开始处理请求 2处理5秒请求 0 结束处理处理请求 0 中，正在等待许可证的请求数量：3处理请求 0 后，当前许可证数量：1处理请求 3 前，当前许可证数量：0请求 3 开始处理请求 3处理6秒请求 2 结束处理处理请求 2 中，正在等待许可证的请求数量：2处理请求 2 后，当前许可证数量：1处理请求 4 前，当前许可证数量：0请求 4 开始处理请求 4处理2秒请求 4 结束处理处理请求 4 中，正在等待许可证的请求数量：1处理请求 4 后，当前许可证数量：1处理请求 5 前，当前许可证数量：0请求 5 开始处理请求 5处理7秒请求 3 结束处理处理请求 3 中，正在等待许可证的请求数量：0处理请求 3 后，当前许可证数量：1请求 5 结束处理处理请求 5 中，正在等待许可证的请求数量：0处理请求 5 后，当前许可证数量：2当释放许可参数变成 2，即从 semaphore.release(1) 变成 semaphore.release(2)。执行结果如下：123456789101112131415161718192021222324252627282930313233343536处理请求 0 前，当前许可证数量：0请求 0 开始处理请求 0处理4秒处理请求 1 前，当前许可证数量：0请求 1 开始处理请求 1处理3秒请求 1 结束处理处理请求 1 中，正在等待许可证的请求数量：4处理请求 1 后，当前许可证数量：2处理请求 2 前，当前许可证数量：1请求 2 开始处理处理请求 3 前，当前许可证数量：0请求 3 开始处理请求 3处理4秒请求 2处理5秒请求 0 结束处理处理请求 0 中，正在等待许可证的请求数量：2处理请求 0 后，当前许可证数量：2处理请求 4 前，当前许可证数量：1请求 4 开始处理处理请求 5 前，当前许可证数量：0请求 5 开始处理请求 5处理8秒请求 4处理2秒请求 4 结束处理处理请求 4 中，正在等待许可证的请求数量：0处理请求 4 后，当前许可证数量：2请求 3 结束处理处理请求 3 中，正在等待许可证的请求数量：0处理请求 3 后，当前许可证数量：4请求 2 结束处理处理请求 2 中，正在等待许可证的请求数量：0处理请求 2 后，当前许可证数量：6请求 5 结束处理处理请求 5 中，正在等待许可证的请求数量：0处理请求 5 后，当前许可证数量：8]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock解析]]></title>
    <url>%2Fposts%2Fb376c662%2F</url>
    <content type="text"><![CDATA[本文代码基于Java8前言Reentrant 可重入的;重入;可再入的。即再次进入的意思，entrant: 新职员;新生;新会员;新成员。JDK 中独占锁的实现除了使用关键字 synchronized 外,还可以使用 ReentrantLock。虽然在性能上ReentrantLock 和 synchronized 没有什么区别，但 ReentrantLock 相比 synchronized 而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。即 ReentrantLock 粒度更小。ReentrantLock 是独占锁且可重入的。ReentrantLock 可以实现公平锁。ReentrantLock 可以响应中断。ReentrantLock 提供了获取锁超时等待。ReentrantLock 结合 Condition 接口可以实现线程间的等待通知机制。ReentrantLock 类结构1234567891011public class ReentrantLock implements Lock, java.io.Serializable &#123; // 默认非公平可重入锁 public ReentrantLock() &#123; sync = new NonfairSync(); &#125; // 指定可重入锁公平模式 public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125;&#125;其中Sync 、FairSync、NonfairSync是 ReentrantLock 的内部类，Sync 继承自 AbstractQueuedSynchronizer ，而 FairSync、NonfairSync 继承 Sync，分别对应公平锁和非公平锁。Sync 内部类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; // 执行锁操作，由子类实现 abstract void lock(); // 执行非公平 tryLock() final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 利用 CAS 来更新 state 的状态 if (compareAndSetState(0, acquires)) &#123; // 设置当前线程拥有独占访问权限 setExclusiveOwnerThread(current); return true; &#125; &#125; // 获取拥有独占访问权限的线程和当前线程比较 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; // 溢出 if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); // 设置新状态 setState(nextc); return true; &#125; return false; &#125; protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; // 拥有独占访问权限的线程不是当前线程，抛出 IllegalMonitorStateException if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; // 清空拥有独占访问权限的线程 setExclusiveOwnerThread(null); &#125; // 设置新状态 setState(c); return free; &#125; // 当前线程是否拥有独占访问权限 protected final boolean isHeldExclusively() &#123; // While we must in general read state before owner, // we don't need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); &#125; // 创建 Condition 对象 final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; // 获取拥有独占访问权限的线程 final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; // 获取当前状态 final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; // 是否锁住 final boolean isLocked() &#123; return getState() != 0; &#125; // 解序列化，将状态重置为 0，即锁释放状态 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125;&#125;NonfairSync、FairSync 内部类线程会重复获取锁。如果申请获取锁的线程足够多，那么可能会造成某些线程长时间得不到锁。这就是非公平锁的“饥饿”问题。公平锁是指当锁可用时，在锁上等待时间最长的线程将获得锁的使用权，而非公平锁则随机分配这种使用权。和synchronized 一样，默认的 ReentrantLock 实现是非公平锁，因为相比公平锁，非公平锁性能更好。当然公平锁能防止饥饿，某些情况下也很有用。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 非公平锁static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; // 锁实现 final void lock() &#123; // 利用 CAS 来更新 state 的状态为1 if (compareAndSetState(0, 1)) // 设置当前线程拥有独占访问权限，随机分配 setExclusiveOwnerThread(Thread.currentThread()); else // AQS 的 acquire() acquire(1); &#125; // 参考上文 Sync 的 nonfairTryAcquire 实现 protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125;// 公平锁static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; // 锁实现 final void lock() &#123; // AQS 的 acquire() acquire(1); &#125; // 尝试获取锁，和 AQS 的 nonfairTryAcquire 相比，多了判断队列有没有前置节点。 protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 队列没有前置节点，且成功利用 CAS 来更新 state 的状态为 acquires // if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; // 设置当前线程拥有独占访问权限 setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125;&#125;ReentrantLock 提供的方法ReentrantLock 锁方法ReentrantLock 和 synchronized 都是独占锁。不同的是 ReentrantLock 需要手动加锁和解锁，且解锁的操作尽量要放在 finally 代码块中，保证线程正确释放锁。ReentrantLock 操作较为复杂，但是因为可以手动控制加锁和解锁过程，在复杂的并发场景中能派上用场。synchronized 加锁解锁的过程是隐式的，用户不用手动操作，优点是操作简单，但显得不够灵活。一般并发场景使用 synchronized 就足够。ReentrantLock 和 synchronized 都是可重入的。synchronized 因为可重入，所以可以放在被递归执行的方法上，且不用担心线程最后能否正确释放锁。而 ReentrantLock 在重入时要却确保重复获取锁的次数必须和重复释放锁的次数一样，否则可能导致其他线程无法获得该锁。1234567891011121314151617181920212223242526// 加锁，分别调用公平锁和非公平锁的加锁方法public void lock() &#123; sync.lock();&#125;// 中断敏感的加锁，参考 AQS 的 acquireInterruptibly 方法public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1);&#125;// 非公平模式加锁，参考 Sync 的 nonfairTryAcquire 方法public boolean tryLock() &#123; return sync.nonfairTryAcquire(1);&#125;// 尝试加锁直至超时，参考 AQS 的 tryAcquireNanos 方法// 使用该方法配合失败重试机制可以用来解决死锁问题public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout));&#125;// 解锁public void unlock() &#123; sync.release(1);&#125;Condition 相关方法Condition 由 ReentrantLock 对象创建，并且可以同时创建多个。Condition 接口在使用前必须先调用ReentrantLock 的 lock() 方法获得锁。之后调用 Condition 接口的 await() 将释放锁，并且在该Condition 上等待，直到有其他线程调用 Condition 的 signal() 方法唤醒线程。123456789101112131415161718192021222324252627282930// 创建 Conditionpublic Condition newCondition() &#123; return sync.newCondition();&#125;// 查询在给定条件下，是否有线程在等待public boolean hasWaiters(Condition condition) &#123; if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException("not owner"); return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);&#125;// 查询在给定条件下，等待线程队列的长度public int getWaitQueueLength(Condition condition) &#123; if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException("not owner"); return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition);&#125;// 查询在给定条件下，所有等待线程protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition) &#123; if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException("not owner"); return sync.getWaitingThreads((AbstractQueuedSynchronizer.ConditionObject)condition);&#125;除了锁方法和 Condition 相关方法外，还有一些判断是否是公平锁、是否加锁、获取阻塞队列长度、当前队列是否独占等方法，比较简单参考源码即可。ReentrantLock 使用示例基于官方示例123456789101112131415161718192021222324252627282930313233343536373839import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ReentrantLockTest &#123; // 公平锁 public static Lock lock = new ReentrantLock(true); public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new ThreadDemo(i)).start(); &#125; &#125; static class ThreadDemo implements Runnable &#123; Integer id; public ThreadDemo(Integer id) &#123; this.id = id; &#125; @Override public void run() &#123; try &#123; TimeUnit.MILLISECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 2; i++) &#123; lock.lock(); System.out.println("获得锁的线程：" + id); lock.unlock(); &#125; &#125; &#125;&#125;如果是公平锁，线程几乎是轮流的获取到了锁。12345678910获得锁的线程：1获得锁的线程：2获得锁的线程：3获得锁的线程：1获得锁的线程：2获得锁的线程：3获得锁的线程：4获得锁的线程：4获得锁的线程：0获得锁的线程：0如果是非公平锁，线程会重复获取锁。12345678910获得锁的线程：4获得锁的线程：4获得锁的线程：1获得锁的线程：1获得锁的线程：2获得锁的线程：2获得锁的线程：3获得锁的线程：3获得锁的线程：0获得锁的线程：0结合 Condition 实现等待通知机制使用 synchronized 结合 Object 上的 wait() 和 notify() 方法可以实现线程间的等待通知机制。ReentrantLock 结合 Condition 接口同样可以实现这个功能，而且相比前者使用起来更清晰也更简单。使用Condition 实现简单的阻塞队列，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.LinkedList;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ConditionBlockingQueue&lt;E&gt; &#123; // 阻塞队列最大容量 int size; // 可重入锁 ReentrantLock lock = new ReentrantLock(); // 队列底层实现 LinkedList&lt;E&gt; list = new LinkedList&lt;&gt;(); // 队列满时的等待条件 Condition notFull = lock.newCondition(); // 队列空时的等待条件 Condition notEmpty = lock.newCondition(); public ConditionBlockingQueue(int size) &#123; this.size = size; &#125; public void enqueue(E e) throws InterruptedException &#123; lock.lock(); try &#123; // 队列已满,在 notFull 条件上等待 while (list.size() == size) &#123; notFull.await(); &#125; list.add(e); // 加入链表末尾 notEmpty.signal(); // 通知在 notEmpty 条件上等待的线程 &#125; finally &#123; lock.unlock(); &#125; &#125; public E dequeue() throws InterruptedException &#123; E e; lock.lock(); try &#123; // 队列为空,在 notEmpty 条件上等待 while (list.size() == 0) &#123; notEmpty.await(); &#125; e = list.removeFirst(); // 移除链表首元素 notFull.signal(); // 通知在 notFull 条件上等待的线程 return e; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;总结ReentrantLock 是可重入的独占锁。比 synchronized 功能更加丰富，控制粒度更小，支持公平锁实现，支持中断响应以及超时等待…… ReentrantLock 还可以配合一个或多个 Condition 条件方便的实现等待通知机制。不过需要手动加锁和解锁，且解锁的操作尽量要放在 finally 代码块中，保证线程正确释放。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS同步器解析]]></title>
    <url>%2Fposts%2Fcdbd94c4%2F</url>
    <content type="text"><![CDATA[本文代码基于Java8前言AQS (AbstractQueuedSynchronizer) 提供了基于 FIFO 队列机制的模板，可以用来实现阻塞锁以及相关的同步锁 (semaphores, events等)，是构建 Java 同步组件的基础。自定义子类通过继承 AQS 类，实现它的抽象方法来管理同步状态。AQS 提供了大量的模板方法来实现同步，主要是分为三类：独占式获取、释放同步状态。共享式获取、释放同步状态查询同步队列中的等待线程情况。123public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable继承关系及 public 方法如下图所示需要自定义同步组件实现的方法基于 AQS 实现的自定义同步组件主要有五种倒计时器：CountDownLatch.Sync——CountDownLatch解析信号量：Semaphore.Sync——Semaphore解析重入锁：ReentrantLock.Sync——ReentrantLock解析读写锁：ReentrantReadWriteLock.Sync ——ReentrantReadWriteLock解析线程池执行器：ThreadPoolExecutor.Worker123456789101112131415161718192021// 独占式获取同步状态protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125;// 独占式释放同步状态protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125;// 共享式获取同步状态protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125;// 共享式释放同步状态protected boolean tryReleaseShared(int arg) &#123; throw new UnsupportedOperationException();&#125;// 如果当前（调用）线程以独占方式持有同步，则返回&#123;@code true&#125;// 每次调用非等待的方法时都会调用此方法。（等待方法改为调用&#123;@link release&#125;。）protected boolean isHeldExclusively() &#123; throw new UnsupportedOperationException();&#125;独占式独占式，同一时刻仅有一个线程持有同步状态。在 AQS 中维护着一个 FIFO 的同步队列，当线程获取同步状态失败后，则会加入到这个 CLH 同步队列的对尾并一直保持着自旋。在 CLH 同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出 CLH 同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。独占式获取同步状态acquire(int arg) 方法是 AQS 提供的模板方法，该方法为独占式获取同步状态，忽略中断，即线程获取同步状态失败加入到 CLH 同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;tryAcquire(int arg) 去尝试获取锁，获取成功则设置锁状态并返回 true，否则返回 false。该方法需要自定义同步组件实现，该方法必须要保证线程安全的获取同步状态。如果 tryAcquire(int arg) 返回 false 即获取同步状态失败，则调用 addWaiter(Node mode) 将当前线程加入到 CLH 同步队列尾部。acquireQueued(final Node node, int arg) : 当前线程会根据公平性原则来进行阻塞等待，直到获取锁为止，并且返回当前线程在等待过程中有没有中断过。selfInterrupt() 会产生一个中断。acquireQueued(final Node node, int arg) 是一个自旋的过程，也就是说当前线程(Node) 进入同步队列后，当前线程会一直尝试获取同步状态，当前驱节点是头节点并且获取锁成功才会退出。其中只有其前驱节点为头结点才能够尝试获取同步状态，原因有二：1.保持 FIFO 同步队列原则。2.头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。具体实现如下：12345678910111213141516171819202122232425final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; // 中断标志 for (;;) &#123; //当前线程的前驱节点 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 前驱节点是头节点并且获取锁成功 setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; // 获取失败，线程等待 &amp;&amp; 检查中断 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) // 置中断标志位true interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;具体流程如下：12345678910111213141516171819【tryAcquire 获取锁--失败--&gt;【addWaiter 生成 Node 节点并将当前线程加入 CLH 同步队列】 | |&lt;------------------------------- | *** | | * | | 【acquireQueued 判断前驱节点是否是头节点】--否-- 线程被中断或前驱节点被释放 | | | | | 是 【acquireQueued 线程进入线程等待】 | | * | *** *** | * | | 【acquireQueued 获取锁成功】---失败-- | | | 成功 | | | *** | * *** 【设置当前节点为头节点】 * | 结束&lt;----------------------------独占式中断获取同步状态AQS 提供了 acquire(int arg) 以独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于 CLH 同步队列中等待着获取同步状态。为了响应中断，AQS 提供了 acquireInterruptibly(int arg) ，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常InterruptedException。1234567891011public final void acquireInterruptibly(int arg) throws InterruptedException &#123; // 校验该线程是否已经中断 if (Thread.interrupted()) // 抛出InterruptedException throw new InterruptedException(); if (!tryAcquire(arg)) // 获取同步状态 // 获取失败，执行doAcquireInterruptibly(arg) // 如果获取失败，线程等待 &amp;&amp; 检查有中断则抛出InterruptedException，和 acquireQueued 置中断标志位true不一样 doAcquireInterruptibly(arg);&#125;独占式超时获取同步状态AQS 除了提供上面两个方法外，还提供了 tryAcquireNanos(int arg,long nanos)。该方法除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回 false，否则返回 true。12345678public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); // 获取到直接返回，否则执行 doAcquireNanos(arg, nanosTimeout) return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125;超时获取同步状态最终是在 doAcquireNanos(int arg, long nanosTimeout)中实现。12345678910111213141516171819202122232425262728293031323334353637private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; // 截止时间 final long deadline = System.nanoTime() + nanosTimeout; // 生成 Node节点并当前线程加入 CLH 同步队列 final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 前驱节点是头节点获取同步状态成功 setHead(node); // 设置当前节点为头节点 p.next = null; // help GC failed = false; return true; &#125; // 剩余时间计算 nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L) return false; // 超时 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) // 获取失败，线程等待并且剩余时间大于 1000 纳秒 // 等待 nanosTimeout 纳秒，线程会直接从LockSupport.parkNanos中返回 LockSupport.parkNanos(this, nanosTimeout); // 超时非常短nanosTimeout&lt;=spinForTimeoutThreshold，AQS会进行无条件的快速自旋。 if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;独占式释放同步状态当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。AQS 提供了 release(int arg) 来释放同步状态。1234567891011public final boolean release(int arg) &#123; // 调用自定义同步器自定义的 tryRelease(int arg) 方法来释放同步状态 if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) // 唤醒后继节点 unparkSuccessor(h); return true; &#125; return false;&#125;共享式共享式与独占式的最主要区别在于独占式同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。共享式同步状态获取AQS 提供 acquireShared(int arg) 共享式获取同步状态。123456public final void acquireShared(int arg) &#123; // 尝试获取同步状态，需要自定义同步组件实现 if (tryAcquireShared(arg) &lt; 0) // 自旋方式获取同步状态 doAcquireShared(arg);&#125;doAcquireShared(int arg) 自旋方式获取同步状态。12345678910111213141516171819202122232425262728293031private void doAcquireShared(int arg) &#123; // 创建共享式节点并将当前线程加入 CLH 同步队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; // 前驱节点为头节点 // 尝试获取同步 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // 获取成功 // 设置当前节点为头节点并检查后续进程是否可以在共享模式下等待 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; // 获取失败线程等待并检查中断 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;acquireShared(int arg) 不响应中断，与独占式类似，AQS 也提供了响应中断、超时的方法，分别是：acquireSharedInterruptibly(int arg)、tryAcquireSharedNanos(int arg,long nanos)，与独占式类似。共享式释放同步状态获取同步状态后，需要调用 releaseShared(int arg) 释放同步状态。123456789public final boolean releaseShared(int arg) &#123; // 尝试释放同步状态，需要自定义同步组件实现 if (tryReleaseShared(arg)) &#123; // 自旋释放同步状态 doReleaseShared(); return true; &#125; return false;&#125;doReleaseShared() 自旋释放同步状态。因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过 CAS (Conmpare And Swap) 和循环来完成的。1234567891011121314151617181920212223242526272829private void doReleaseShared() &#123; /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CountDownLatch解析]]></title>
    <url>%2Fposts%2F49d01824%2F</url>
    <content type="text"><![CDATA[本文代码基于Java8前言CountDownLatch ，英文翻译为倒计时锁存器，是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。也是基于 AQS，它是 AQS 的共享功能的一个实现。它主要用来保证完成某个任务的先决条件满足，是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。确保某个计算在其需要的所有资源都被初始化之后才继续执行;确保某个服务在其依赖的所有其他服务都已经启动之后才启动;等待直到某个操作所有参与者都准备就绪再继续执行。CountDownLatch 有一个正数计数器，countDown() 方法对计数器做减操作，await() 方法等待计数器达到0。所有 await 的线程都会阻塞直到计数器为0或者等待线程中断或者超时。CountDownLatch 类结构其中Sync 是 CountDownLatch 的内部类，Sync 继承自 AbstractQueuedSynchronizer 。使用 AQS state 表示 count 计数。12345678910111213141516171819202122232425262728293031private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; // 设置初始计数 Sync(int count) &#123; setState(count); &#125; // 获取当前计数 int getCount() &#123; return getState(); &#125; // 重写 AQS 的 tryAcquireShared 方法，-1 表示 count&gt;0，可以获取。 protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero // // count-1，如果 count 变为0，则唤醒所有。 for (;;) &#123; // 获取当前状态，为0表示未锁，不用释放。 int c = getState(); if (c == 0) return false; int nextc = c-1; // 利用 CAS 来更新 state 的状态，这里可能有并发，所以这也是用死循环更新的原因 // c为期望值，nextc为更新值。 if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125;&#125;CountDownLatch 构造方法使用给定的 count 构造 CountDownLatch，count 表示线程通过 await 前必须要执行的次数，count 不能小于0。1234public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count);&#125;CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch 使用完毕后，它不能再次被使用。CountDownLatch 线程等待方法await() 是通过轮询 state 的状态来判断所有的任务是否都完成。无限等待让当前线程等待直到 count 减数为0，除非线程被中断。如果 count 为0，线程将立即返回，不再阻塞等待。如果当前计数大于零，则出于线程调度目的，当前线程将禁用，并处于休眠状态，直到发生以下两种情况之一：countDown() 方法调用使得 count 减数为0；当前线程被中断 (如果被中断将会抛出 InterruptedException 异常)。1234public void await() throws InterruptedException &#123; // 参考 AQS 的 acquireSharedInterruptibly() 方法 sync.acquireSharedInterruptibly(1); &#125;超时等待使当前线程处理等待状态直到 count 减为0或者等待超时。如果当前count是0，则线程立即返回true。如果当前计数大于零，则出于线程调度目的，当前线程将禁用，并处于休眠状态，直到发生以下三种情况之一：countDown() 方法调用使得 count 减数为0；当前线程被中断 (如果被中断将会抛出 InterruptedException 异常)；等待超时。如果等待超时但是 count&gt;0，则返回 false。如果超时时间小于或等于零，方法将不会等待。12345public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; // 参考 AQS 的 tryAcquireSharedNanos() 方法 return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));&#125;CountDownLatch 其他方法12345678910111213141516171819202122232425// 倒计时，将会将count-1public void countDown() &#123; // 参考 AQS 的 releaseShared() 方法 sync.releaseShared(1);&#125;// AQS 的 releaseShared() 方法public final boolean releaseShared(int arg) &#123; // 参考 Sync 重写的 tryReleaseShared(int releases) 方法 if (tryReleaseShared(arg)) &#123; // 唤醒主线程，因为如果 state 不等于0的话，主线程一直是阻塞的。 doReleaseShared(); return true; &#125; return false;&#125;// 获取当前计数public long getCount() &#123; return sync.getCount();&#125;// 返回标识锁及其状态的字符串public String toString() &#123; return super.toString() + "[Count = " + sync.getCount() + "]";&#125;AQS 的 doReleaseShared() 方法123456789101112131415161718private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; // 至少有两个节点 int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; // 后继节点需要唤醒 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); // 唤醒后继节点 &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125;使用示例官方示例123456789101112131415161718192021222324252627282930class Driver &#123; // ... void main() throws InterruptedException &#123; CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(N); for (int i = 0; i &lt; N; ++i) // create and start threads new Thread(new Worker(startSignal, doneSignal)).start(); doSomethingElse(); // don't let run yet // 所有worker线程继续执行 startSignal.countDown(); // let all threads proceed doSomethingElse(); // 允许driver等待直到所有的worker都完成 doneSignal.await(); // wait for all to finish &#125;&#125;class Worker implements Runnable &#123; private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123; this.startSignal = startSignal; this.doneSignal = doneSignal; &#125; public void run() &#123; try &#123; startSignal.await(); // 开始信号阻止任何worker直到driver准备好 doWork(); doneSignal.countDown(); // 完成信号，计数减一 &#125; catch (InterruptedException ex) &#123;&#125; // return; &#125; void doWork() &#123; ... &#125;&#125;火箭发射示例12345678910111213141516171819202122232425262728293031323334public class CountDownLatchDemo implements Runnable&#123; static final CountDownLatch latch = new CountDownLatch(10); static final CountDownLatchDemo demo = new CountDownLatchDemo(); @Override public void run() &#123; // 模拟检查任务 try &#123; Thread.sleep(new Random().nextInt(10) * 1000); System.out.println("check complete"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //计数减一 //放在finally避免任务执行过程出现异常，导致countDown()不能被执行 latch.countDown(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ExecutorService exec = Executors.newFixedThreadPool(10); for (int i=0; i&lt;10; i++)&#123; exec.submit(demo); &#125; // 等待检查 latch.await(); // 发射火箭 System.out.println("Fire!"); // 关闭线程池 exec.shutdown(); &#125;&#125;总结CountDownLatch 主要用来保证完成某个任务的先决条件满足，是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人类愚蠢辞典]]></title>
    <url>%2Fposts%2Fc6491e95%2F</url>
    <content type="text"><![CDATA[习惯的力量与其愚蠢度成正比。我们在个人与社会生活中，总会用同样的方式思考以及做同样的事。对于银行来说，25% 就已经是高利贷的标准了。而一些酒吧、饭店来说，它们宣称出于对”卫生问题“的重视不提供直饮水，转而以高达10倍价格向它们愚蠢的顾客推销瓶装水。人类的不忠行为远比我们愚蠢地自认为的要多。实际上，男性会偏向于夸大性伴侣的数量，而女性则会倾向于隐藏。不忠行为是对反自然的一夫一妻制进行的自然修正过程。往生世界，相信死后我们会有跟活着时一样的烦恼。”保护地球“是很愚蠢的：充其量是我们自己有点儿危险罢了。早在25亿年前，光合作用就已经对地球环境的构成造成了更甚于今日的剧烈变化，即所谓的”大氧化事件“。然而，我们地球通过一项调整成功挽救了自己：消灭厌氧生物，并养育需氧生物，也就是人类本身。通常，人们愚蠢地认为爱动物就是喜欢小猫小狗，不忍观看斗牛或海豹被屠杀的画面。极少人意识到，真正的问题存在于动物被用于饮食和实验造成的权益侵害。愚蠢的种族主义者虽然目标常常变化，但本质永远是不变的。斯特金定律：90%的东西都是无意义的废物。愚蠢的人有两种截然相反的行事方式，却总能殊途同归，制造麻烦。要么让那些明智的人生活难以为继，无法施展抱负；要么为害群之马铺平道路，帮助他们达成危害大业。同样的习惯，于自身都很正常，到了别人那里就怎么看怎么别扭。我们愚蠢无知的程度，恰如我们自以为的智慧狡黠一般。在任意一群人里，蠢人的比例是固定的，即使是在诺贝尔奖获得者中。翡翠行业根本没有赌石这种说法，一堆一堆的专业人士用专业的设备一轮一轮的筛选，根本不需要赌，因为石头的出身是透明的。一旦我们陷于嫉妒的情绪，我们往往只看到对方的长处，忽略了自己的优势。也无法看到自己拥有的资源。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>愚蠢</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaBean]]></title>
    <url>%2Fposts%2F207a79f8%2F</url>
    <content type="text"><![CDATA[JavaBean 定义在 Java 中，有很多class的定义都符合这样的规范：若干private实例字段；通过public方法来读写实例字段。12345678910public class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;如果读写方法符合以下这种命名规范：1234// 读方法:public Type getXyz()// 写方法:public void setXyz(Type value)那么这种class被称为JavaBeanJavaBean 是一种 Java 语言写成的可重用组件。为写成 JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性。众所周知，属性名称符合这种模式，其他 Java 类可以通过自身机制发现和操作这些 JavaBean 的属性。JavaBean 更多的是一种规范，即包含一组 set 和 get 方法的 Java 对象。JavaBean 主要用来传递数据，即把一组数据组合成一个 JavaBean 便于传输。枚举 JavaBean 属性内省(Introspector) 是 Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。调用 Introspector.getBeanInfo() 方法，得到的 BeanInfo 对象封装了把这个类当做 JavaBean 看的结果信息，即属性的信息。调用 BeanInfo 的 getPropertyDescriptors()，可以获得属性的描述，可以采用遍历 BeanInfo 的方法，来查找、设置类的属性。1234567891011121314151617181920212223242526272829303132333435public class IntrospectorTest &#123; public static void main(String[] args) throws Exception &#123; Person person = new Person(); BeanInfo info = Introspector.getBeanInfo(Person.class); for (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123; if (pd.getName().equals("name"))&#123; Method methodSetName = pd.getWriteMethod(); methodSetName.invoke(person, "Freya"); Method methodGetName = pd.getReadMethod(); System.out.println(methodGetName.invoke(person, null)); &#125; &#125; &#125; static class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125;&#125;内省操作非常的繁琐，所以 Apache 开发了一套简单、易用的API来操作 Bean 的属性——BeanUtils工具包。注意：应用的时候还需要一个 logging包123456&lt;!-- https://mvnrepository.com/artifact/commons-beanutils/commons-beanutils --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt;&lt;/dependency&gt;使用 BeanUtils 示例如下：123456789101112public static void main(String[] args) throws Exception &#123; Person person = new Person(); BeanUtils.setProperty(person, "name", "Freya"); BeanUtils.setProperty(person, "age", 17); BeanUtils.setProperty(person, "id", 1011); System.out.println(BeanUtils.getProperty(person, "name")); System.out.println("get name type:" + BeanUtils.getProperty(person, "name").getClass().getName()); System.out.println(BeanUtils.getProperty(person, "age")); System.out.println("get age type:" + BeanUtils.getProperty(person, "age").getClass().getName()); // get age type:java.lang.String System.out.println("get age type:" + PropertyUtils.getProperty(person, "age").getClass().getName()); // get age type:java.lang.Integer&#125;设置属性的值，例如，BeanUtils.setProperty(person, “age”, 8)，参数是字符串或基本类型自动包装。设置属性的值是字符串，获得的值也是字符串，不是基本类型。PropertyUtils 类和 BeanUtils 不同在于，运行 getProperty、setProperty 操作时，没有类型转换，使用属性的原有类型或者包装类。VO、DTO、POJO、DTO、BO的区别VOvalue object值对象，主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象。然后用一个 VO 对象在控制层与视图层进行传输交换。DTOData Transfer Object 数据传输对象，经过处理后的PO，可能增加或者减少PO的属性。主要用于远程调用等需要大量传输对象的地方。比如我们一张表有100个字段，那么对应的 PO 就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。POJOPlain Ordinary Java Object，是一个简单的普通的Java对象。简单 Java 对象是一种概念或者接口，身份及作用随环境变化而变化。POJO 有一些private的参数作为对象的属性。然后针对每个参数定义了get和set方法作为访问的接口。它不包含业务逻辑或持久逻辑等，但不是JavaBean、EntityBean等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。POJO对象有时也被称为Data对象，大量应用于表现现实中的对象。一个POJO持久化以后就是PO。直接用它传递、传递过程中就是DTO。直接用来对应表示层就是VO。DAOPO持久化到数据库是要进行相关的数据库操作的(CRUQ)，这些对数据库操作的方法会统一放到一个 Java 对象中，这就是DAO。BOPOJO在业务层的体现，对于业务操作来说，更多的是从业务上来包装对象，如一个User的BO，可能包括name, age, sex, privilege, group等，这些属性在数据库中可能会在多张表中，因为每一张表对应一个PO，而我们的BO需要这些PO组合起来(或说重新拼装)才能成为业务上的一个完整对象。联系POJO仅包含最简单的字段属性，没有多余的东西，它本质上就是一个普通的 JavaBean。但是在POJO的基础上，能够扩展出不同的对象。为 POJO 增加了持久化的方法（Insert、Update、Delete……）之后，POJO 就变成了 PO。为 POJO 增加了数据绑定功能之后，POJO 就变成了 View Object，即UI Model。为 POJO 增加业务逻辑的方法（比如单据审核、转帐……）之后，POJO就变成了Domain Model。POJO 还可以当作 DTO 使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java常用工具类]]></title>
    <url>%2Fposts%2F8b50b566%2F</url>
    <content type="text"><![CDATA[JDK 自带Math顾名思义，Math类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：求绝对值：12Math.abs(-1); // 1Math.abs(-2.2); // 2.2取最大或最小值：12Math.max(100, 101); // 101Math.min(1.2, 3.1); // 1.2计算x^y次方：1Math.pow(2, 10); // 1024计算√x：1Math.sqrt(2); // 1.4142135623730951计算指数与对数：123Math.exp(2); // 7.38905609893065Math.log(2); // 以 e 为底的对数 0.6931471805599453Math.log10(2); // 以 10 为底的对数 0.3010299956639812三角函数：12345Math.sin(3.14); // 0.00159...Math.cos(3.14); // -0.9999...Math.tan(3.14); // -0.0015...Math.asin(1.0); // 1.57079...Math.acos(1.0); // 0.0Math还提供了几个数学常量：12double pi = Math.PI; // 3.14159...double e = Math.E; // 2.7182818...生成一个随机数x，x的范围是0 &lt;= x &lt; 1：1Math.random(); // 0.53907... 每次都不一样Java 标准库还提供了一个 StrictMath，它提供了和 Math 几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，StrictMath 保证所有平台计算结果都是完全相同的，而 Math 会尽量针对平台优化计算速度，所以，绝大多数情况下，使用 Math 就足够了。RandomRandom用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()：123456Random r = new Random();r.nextInt(); // 245439114,每次都不一样r.nextInt(10); // 9,生成一个[0,10)之间的intr.nextLong(); // -485876652878521410,每次都不一样r.nextFloat(); // 0.6454043,生成一个[0,1)之间的floatr.nextDouble(); // 0.44460046556701727,生成一个[0,1)之间的double创建 Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。如果我们在创建 Random 实例时指定一个种子，就会得到完全确定的随机数序列：1234567891011121314Random r = new Random(12345);for (int i = 0; i &lt; 10; i++) &#123; System.out.println(r.nextInt(100));&#125;// 51// 80// 41// 28// 55// 84// 75// 2// 1// 89有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的：12SecureRandom sr = new SecureRandom();System.out.println(sr.nextInt(100));SecureRandom 无法指定种子，它使用RNG（random number generator）算法。JDK的 SecureRandom 实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：1234567891011121314public class Test&#123; public static void main(String[] args) &#123; SecureRandom sr = null; try &#123; sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器 &#125; catch (NoSuchAlgorithmException e) &#123; sr = new SecureRandom(); // 获取普通的安全随机数生成器 &#125; byte[] buffer = new byte[16]; sr.nextBytes(buffer); // 用安全随机数填充buffer System.out.println(Arrays.toString(buffer)); System.out.println(sr.nextInt()); &#125;&#125;SecureRandom 的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用 SecureRandom 来产生安全的随机数。]]></content>
      <categories>
        <category>Java</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>常用工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中大数表示]]></title>
    <url>%2Fposts%2Fd9f6149f%2F</url>
    <content type="text"><![CDATA[BigInteger在 Java 中，由 CPU 原生提供的整型最大范围是 64 位 long 型整数。使用 long 型整数可以直接通过 CPU 指令进行计算，速度非常快。如果我们使用的整数范围超过了 long 型就只能用软件来模拟一个大整数。java.math.BigInteger 就是用来表示任意大小的整数。BigInteger 内部用一个 int[] 数组来模拟一个非常大的整数：12BigInteger bi = new BigInteger("1234567890");System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000使用 BigInteger` 做运算的时候，只能使用实例方法，例如：123BigInteger i1 = new BigInteger("1234567890");BigInteger i2 = new BigInteger("12345678901234567890");BigInteger sum = i1.add(i2); // 12345678902469135780和 long 型整数运算比，BigInteger 不会有范围限制，但缺点是速度比较慢。也可以把 BigInteger 转换成 long 型：123BigInteger i = new BigInteger("123456789000");System.out.println(i.longValue()); // 123456789000System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range使用 longValueExact() 方法时，如果超出了 long 型的范围，会抛出 ArithmeticException。BigInteger 和 Integer、Long 一样，也是不可变类，并且也继承自 Number 类。因为 Number 定义了转换为基本类型的几个方法：转换为byte：byteValue()转换为short：shortValue()转换为int：intValue()转换为long：longValue()转换为float：floatValue()转换为double：doubleValue()因此，通过上述方法，可以把 BigInteger 转换成基本类型。如果 BigInteger 表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。如果 BigInteger 的值甚至超过了float的最大范围（3.4x1038），那么返回的float是什么呢？1234567public class Test&#123; public static void main(String[] args) &#123; BigInteger n = new BigInteger("999999").pow(99); float f = n.floatValue(); System.out.println(f); // Infinity &#125;&#125;BigDecimal和 BigInteger 类似，BigDecimal 可以表示一个任意大小且精度完全准确的浮点数，常用于财务计算。如果查看 BigDecimal 的源码，可以发现，实际上一个 BigDecimal 是通过一个 BigInteger 和一个 scale 来表示的，即 BigInteger 表示一个完整的整数，而 scale 表示小数位数：1234public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; &#123; private final BigInteger intVal; private final int scale;&#125;BigDecimal 也是从 Number 继承的，也是不可变对象。通过 BigDecimal 的 stripTrailingZeros() 方法，可以将一个 BigDecimal 格式化为一个相等的，但去掉了末尾0的 BigDecimal：123456789BigDecimal d1 = new BigDecimal("123.4500");BigDecimal d2 = d1.stripTrailingZeros();System.out.println(d1.scale()); // 4System.out.println(d2.scale()); // 2,因为去掉了00BigDecimal d3 = new BigDecimal("1234500");BigDecimal d4 = d1.stripTrailingZeros();System.out.println(d3.scale()); // 0System.out.println(d4.scale()); // -2如果一个 BigDecimal 的 scale() 返回负数，例如，-2，表示这个数是个整数，并且末尾有2个0。可以对一个 BigDecimal 设置它的 scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：123456789public class Main &#123; public static void main(String[] args) &#123; BigDecimal d1 = new BigDecimal("123.456789"); BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568 BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567 System.out.println(d2); System.out.println(d3); &#125;&#125;对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：123BigDecimal d1 = new BigDecimal("123.456");BigDecimal d2 = new BigDecimal("23.456789");BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入在比较两个 BigDecimal 的值是否相等时，要特别注意，使用 equals() 方法不但要求两个 BigDecimal 的值相等，还要求它们的 scale() 相等：12345BigDecimal d1 = new BigDecimal("123.456");BigDecimal d2 = new BigDecimal("123.45600");System.out.println(d1.equals(d2)); // false,因为scale不同System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2System.out.println(d1.compareTo(d2)); // 0必须使用 compareTo() 方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。]]></content>
  </entry>
  <entry>
    <title><![CDATA[序列化与反序列化]]></title>
    <url>%2Fposts%2F4522df16%2F</url>
    <content type="text"><![CDATA[序列化和反序列化序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。恰当的序列化协议不仅可以提高系统的通用性、强健性、安全性、优化系统性能，而且会让系统更加易于调试、便于扩展。概念序列化：将数据结构或对象转换成二进制串的过程，在 Java 中对应把对象转换为字节序列的过程。反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程，在 Java 中对应把字节序列恢复为对象的过程。用途把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。在网络上传送对象的字节序列。JDK 类库中的序列化API在序列化过程中，如果被序列化的类中定义了 writeObject() 和 readObject() 方法，虚拟机会试图调用对象类里的 writeObject() 和 readObject() 方法，进行用户自定义的序列化和反序列化。如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject() 方法以及 ObjectInputStream 的 defaultReadObject() 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。ObjectOutputStream 代表对象输出流，它的 writeObject(Object obj) 方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。ObjectInputStream 代表对象输入流，它的 readObject() 方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。只有实现了 Serializable 和 Externalizable 接口的类的对象才能被序列化。Externalizable 接口继承自 Serializable 接口，实现 Externalizable 接口的类完全由自身来控制序列化的行为，而仅实现 Serializable 接口的类可以采用默认的序列化方式 。1public interface Externalizable extends java.io.Serializable对象序列化步骤创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；通过对象输出流的writeObject()方法写对象。对象反序列化步骤创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；通过对象输入流的readObject()方法读取对象。1234567891011121314151617181920212223242526272829303132333435363738394041import org.apache.commons.io.IOUtils;public class SerializableDemo &#123; public static void main(String[] args) &#123; //Initializes The Object User user = new User(); user.setName("Freya"); user.setAge(17); System.out.println(user); //Write Obj to File ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream("tempFile")); oos.writeObject(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtils.closeQuietly(oos); &#125; //Read Obj from File File file = new File("tempFile"); ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(file)); User newUser = (User) ois.readObject(); System.out.println(newUser); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtils.closeQuietly(ois); try &#123; FileUtils.forceDelete(file); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;序列化版本号凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量 serialVersionUID。serialVersionUID 的取值是 Java 运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的 serialVersionUID 的取值有可能也会发生变化。1private static final long serialVersionUID如果没有指定类的 serialVersionUID，Java 编译器会自动给这个 class 进行一个摘要算法，类似于指纹算法，只要这个文件多一个空格，得到的 serialVersionUID 就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个字段后，由于没有显指定 serialVersionUID，编译器又为我们生成了一个 serialVersionUID，当然和前面保存在文件中的那个不会一样了，于是就会出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了 serialVersionUID，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原。类的 serialVersionUID 的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。显式地定义serialVersionUID有两种用途：在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的 serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的 serialVersionUID。总结Serializable 只是一个接口，本身没有任何实现。如果一个类想被序列化，需要实现Serializable接口。否则将抛出NotSerializableException异常。因为在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum、String和Serializable类型其中的任何一种。(当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。)对象的反序列化并没有调用对象的任何构造方法。序列化时，只对对象的状态进行保存，而不管对象的方法。当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化。并非所有的对象都可以序列化，比如：安全方面的原因，比如一个对象拥有 private，public 等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；serialVersionUID 是用于记录文件版本信息的，最好能够自定义。否则，系统会自动生成 serialVersionUID，文件或者对象的任何改变，都会改变 serialVersionUID，导致反序列化的失败，如果自定义就没有这个问题声明为 static 和 transient 类型的成员数据不能被序列化。因为 static 代表类的状态，transient 代表对象的临时数据。Serializable 的系统实现是采用 ObjectInputStream 和 ObjectOutputStream 实现的，调用 ObjectInputStream 和 ObjectOutputStream 时，需要对应的类实现 Serializable 接口。服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。反序列化时，恢复引用关系。该存储规则极大的节省了存储空间。123456789101112131415161718ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("tempFile"));User user = new User();//试图将对象两次写入文件out.writeObject(user);out.flush();System.out.println(new File("tempFile").length());out.writeObject(user);out.close();System.out.println(new File("tempFile").length());ObjectInputStream oin = new ObjectInputStream(new FileInputStream("tempFile"));//从文件依次读出两个文件User t1 = (User) oin.readObject();User t2 = (User) oin.readObject();oin.close(); //判断两个引用是否指向同一个对象System.out.println(t1 == t2);扩展序列化与单例模式序列化对单例的破坏使用反射可以破坏单例模式，除了反射以外，使用序列化与反序列化也同样会破坏单例。单例示例：1234567891011121314public class Singleton implements Serializable&#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (null == singleton) &#123; synchronized (Singleton.class) &#123; if (null == singleton) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125;测试序列化对单例模式的破坏：123456789101112131415161718192021222324252627public class SingletonSerializableTest&#123; public static void main(String[] args) &#123; //Write Obj to file try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile"))) &#123; oos.writeObject(Singleton.getSingleton()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //Read Obj from file File file = new File("tempFile"); Singleton newInstance = null; try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))) &#123; newInstance = (Singleton) ois.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; if (null == newInstance) &#123; System.out.println("newInstance is null"); // 不打印 &#125; //判断是否是同一个对象 System.out.println(Singleton.getSingleton() == newInstance); // false &#125;&#125;通过对 Singleton 的序列化与反序列化得到的对象是一个新的对象，这就破坏了 Singleton 的单例性。这是因为序列化会通过反射调用无参数的构造方法创建一个新的对象。防止序列化破坏单例模式在 Singleton 类中定义 readResolve 就可以解决该问题。1234567891011121314151617public class Singleton implements Serializable&#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (null == singleton) &#123; synchronized (Singleton.class) &#123; if (null == singleton) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; private Object readResolve() &#123; return singleton; &#125;&#125;在 Singleton 类中定义 readResolve 可以防止序列化破坏单例模式，实现如下：ObjectOutputStream 的 writeObject() 调用 writeObject0()，writeObject0() 里会调用 writeOrdinaryObject()。在 writeOrdinaryObject() 中会通过 hasReadResolveMethod 进行判断，如果实现了Serializable 或者 Externalizable 接口的类中包含 readResolve 则返回 true。从而调用 invokeReadResolve，通过反射的方式调用要被反序列化的类的 readResolve() 方法。12345678910if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123; Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) &#123; rep = cloneArray(rep); &#125; if (rep != obj) &#123; handles.setObject(passHandle, obj = rep); &#125;&#125;序列化与对象的深拷贝实现对象的深拷贝有以下几种方法：实现 Clonable 接口，重写 clone() 方法，这种方法没有通用性，优点在于实现简单，并且可以实现定制化。基于反射，BeanUtil、Spring 核心包提供的一个工具类，基本原理就是获取 class 实例化，再通过反射实现对象的深拷贝。基于Serialize、Deserialize 实现，这种办法比较多，本质上和反射类似，反射相当于 JVM 提供，而 Serialize 是基于上层协议。具体实现可以参考 RMI、thrift、protobuf 序列化方式。基于 Unsafe 内存，这种方法极不推荐使用，直接复制对象内存空间，容易造成内存泄露。在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。1234567891011121314151617181920public static &lt;T extends Serializable&gt; T clone(T obj)&#123; T cloneObj = null; try &#123; //写入字节流 ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream obs = new ObjectOutputStream(out); obs.writeObject(obj); obs.close(); //分配内存，写入原始对象，生成新对象 ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray()); ObjectInputStream ois = new ObjectInputStream(ios); //返回生成的新对象 cloneObj = (T) ois.readObject(); ois.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return cloneObj; &#125;也可以使用 Apache 推出的 SerializationUtils 序列化工具类SerializationUtils 功能使用序列化进行深度克隆序列化对象反序列化对象SerializationUtils 优缺点深度拷贝实现比较简单，不用实现Cloneable接口。深度拷贝效率不如实现Cloneable接口高。序列化和反序列化，是基于jdk自带的序列化，速度慢，占空间。效率不如Protostuff、Hessian、Kryo等专业序列化工具高。更深入的序列化知识可以参考: 序列化和反序列化]]></content>
      <categories>
        <category>Java</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[演化杂记]]></title>
    <url>%2Fposts%2F4b4e75fa%2F</url>
    <content type="text"><![CDATA[为什么现在的孩子越来越高、越来越胖？为什么青少年糖尿病越来越多、发病年龄越来越小？为什么越来越多的现代人患上了哮喘、过敏性鼻炎以及五花八门的食物过敏？种种“现代疾病”背后是否有个共同的“罪魁祸首”？美国著名科学家马丁布莱泽认为，在过去的几十年里，由于滥用抗生素及剖宫产，我们在不经意间已经伤害了与人类协同演化了数十万年之久的“微生物朋友”，特别是在我们的孩子们身上。这扰乱了人体内微生物的稳态，打破了人体与微生物之间的平衡，进而危害了我们孩子的代谢、免疫和认知能力。微生物所谓碳基，其实是碳氮合体，碳四氮五氧六氢一，勾结出的一类扭曲生命，柔弱而多愁善感，利用电子结合化学能繁衍生息，能量利用总量低而熵效率高，因此能一直默默不查的偷生于宇宙中而繁衍数十亿年。碳基生命需要用氧氢化合物为催化剂，所以在宇宙背景温度到373k以下时才有萌芽可能，之前没有碳基生命存在。地球上的碳基生命经过数亿年进化，于西元1900年发现光电效应，并进一步开发出硅基光电板，由此接触到硅基生命能量模式。硅基生命为镓锗合体，以硅氧为催化剂，利用光电效应直接产生能量繁衍生息。硅基以光传导能量进行代谢，低端硅基生命身体透明，有智能的高级硅基生命布满光纤，以硅氧熔沸点预测，在宇宙背景温度到2500k以下时才有萌芽可能，之前没有硅基生命存在。碳基生命西元1945年第一次核爆敲开了铁基生命的大门。铁基以核能为驱动，生命温度在铁沸点以上，以气态和离子态存在，可以说在第一个铁元素诞生的时候就有了铁基生命，铁基生命能量利用巨大，一个低端铁基生命每秒耗费的能量相当于一个广岛原子弹。铁基生命是宇宙中最耀眼的生命，信息以量子纠缠传递，可以轻易实现虫洞在星系间穿梭，是最适合宇宙级生存的生命。以能量产生和消耗方式来看，硅基生命不过是在食用铁基生命代谢出的废物－光来生存，而碳基生命则是更低等的生命，食用硅基生命的代谢产物－低端化学能来生存，这些低端化学能产生的光和热能不足以满足硅基生命的生存下限。碳基、硅基、铁基]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java线程池]]></title>
    <url>%2Fposts%2F2b9621c6%2F</url>
    <content type="text"><![CDATA[一些概念进程(Process)：计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程(Thread)：进程的组成部分，它代表了一条顺序的执行流。线程依托于进程存在，在进程之下，可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据。并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源。@UsesJava8为什么要使用线程池？使用线程池有三个好处降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是只有对线程池原理有深入的了解才能最大程度发挥线程池的作用。线程池的使用线程池的创建我们可以通过 ThreadPoolExecutor 来创建一个线程池。1234567new ThreadPoolExecutor(int corePoolSize, // 核心线程数 int maximumPoolSize, // 最大线程数 long keepAliveTime, // 线程存活时间 TimeUnit unit, // 线程存活时间的单位 BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列 ThreadFactory threadFactory, // 创建线程的工厂 RejectedExecutionHandler handler) // 拒绝策略参数解释如下：corePoolSize: 当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于核心线程数时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有核心线程。123456public int prestartAllCoreThreads() &#123; int n = 0; while (addWorker(null, true)) ++n; return n;&#125;maximumPoolSize: 线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。keepAliveTime: 线程池的工作线程空闲后，存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。unit： 可选的单位有 DAYS，HOURS，MINUTES，MILLISECONDS，MICROSECONDS，NANOSECONDS。参考TimeUnitworkQueue: 用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool() 使用了这个队列SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。PriorityBlockingQueue：一个具有优先级得无限阻塞队列。threadFactory: 可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug 和定位问题时非常又帮助。handler: 当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。CallerRunsPolicy: 调用者运行策略。当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。一般在不允许失败的、对性能要求不高、并发量较小的场景下使用。12345678public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125;AbortPolicy: 中止策略。当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程。12345678public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString()); &#125;&#125;DiscardPolicy: 丢弃策略。不触发任何动作地丢弃这个任务。如果你提交的任务无关紧要，你就可以使用它 。12345public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125;&#125;DiscardOldestPolicy: 弃老策略。如果线程池未关闭，就弹出队列头部的元素，然后尝试执行。发布消息，和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。123456789public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125; &#125;向线程池提交任务通过 execute 向线程池提交任务execute 方法没有返回值，无法判断任务知否被线程池执行成功。1234567891011121314151617181920public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); // 获取到当前有效的线程数和线程池的状态 if (workerCountOf(c) &lt; corePoolSize) &#123; // 线程数小于核心线程数 if (addWorker(command, true)) // 在addWorker中创建工作线程执行任务 return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 线程池是否处于运行状态，且是否任务插入任务队列成功 int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) // 线程池是否处于运行状态，如果不是则使刚刚的任务出队 reject(command); // 执行拒绝策略 else if (workerCountOf(recheck) == 0) addWorker(null, false); // 继续创建线程 &#125; // 插入队列不成功，且当前线程数数量小于最大线程池数量，此时则创建新线程执行任务，创建失败抛出异常 else if (!addWorker(command, false)) reject(command); // 创建线程失败执行拒绝策略&#125;通过 submit向线程池提交任务submit 方法返回一个 future ，可以通过这个 future 来判断任务是否执行成功，通过 future 的 get() 方法来获取返回值，get() 方法会阻塞住直到任务完成，而使用 get(long timeout, TimeUnit unit) 方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。1234567891011121314151617181920public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result); execute(ftask); return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask;&#125;线程池的关闭我们可以通过调用线程池的 shutdown() 或 shutdownNow() 方法来关闭线程池，但是它们的实现原理不同，shutdown 的原理是只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。shutdownNow 的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt() 方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow 会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 isTerminaed() 方法会返回 true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。线程池的监控通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用taskCount: 线程池需要执行的任务数量。completedTaskCount: 线程池在运行过程中已完成的任务数量。小于或等于taskCount。largestPoolSize: 线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。getPoolSize: 线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。getActiveCount：获取活动的线程数。通过扩展线程池进行监控。通过继承线程池并重写线程池的 beforeExecute，afterExecute 和 terminated 方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：123protected void beforeExecute(Thread t, Runnable r) &#123; &#125;protected void afterExecute(Runnable r, Throwable t) &#123; &#125;protected void terminated() &#123; &#125;线程池的配置策略根据任务性质设置通常这种设置方式是比较粗略的方式。要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：任务的性质：CPU密集型任务，IO密集型任务和混合型任务。CPU 密集型任务配置尽可能小的线程，如配置CPU数+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*CPU数。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过 Runtime.getRuntime().availableProcessors() 方法获得当前设备的CPU个数。任务的优先级：高，中和低。任务的执行时间：长，中和短。执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。任务的依赖性：是否依赖其他系统资源，如数据库连接。依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。如果使用无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。利特尔法则利特尔法则（Little’s law）是说，一个系统请求数等于请求的到达率与平均每个单独请求花费的时间之乘积。我们可以使用利特尔法则（Little’s law）来判定线程池大小。我们只需计算请求到达率和请求处理的平均时间。然后，将上述值放到利特尔法则（Little’s law）就可以算出系统平均请求数。若请求数小于我们线程池的大小，就相应地减小线程池的大小。与之相反，如果请求数大于线程池大小，事情就有点复杂了。当遇到有更多请求待处理的情况时，我们首先需要评估系统是否有足够的能力支持更大的线程池。准确评估的前提是，我们必须评估哪些资源会限制应用程序的扩展能力。最简单的情况是，我们有足够的空间增加线程池的大小。若没有的话，你不得不考虑其它选项，如软件调优、增加硬件，或者调优并增加硬件。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-甜]]></title>
    <url>%2Fposts%2Fead251ab%2F</url>
    <content type="text"><![CDATA[星星睡不着，在数人类。有一些小猫假扮成人类来跟我们相爱。我也就一般甜啦，也就半糖烤奶加泷珠。我们一块儿发会呆吧。我永远屈服于温柔，而你是温柔本身。放下你的刀，来做本王的妻子吧。每天都会有让人长胖的好事情发生。你的春日好运正在派件，请保持心情舒畅。可爱之人必遇可爱之事。希望下次喜欢和合适可以撞个满怀。你是我见一个爱一个里面最爱的一个。我要去宇宙了，回来摘星星给你。好好生活，活到夏天。这个人很懒，什么都没有留下。既然来到这个世界的话，那就稍微喜欢一下它吧。研究了一晚上宇宙，宇宙没理我。这家伙很懒，却还想留下点儿什么。一觉醒来，觉得甚是爱你。你再不来，我就要下雪了。所有的告别中，我最喜欢明天见。我马上要恋爱了，和谁不知道，先替他高兴一下。薏仁做事薏仁汤，小丁做事小叮当。既然来了就磕个头再走吧。成熟的大人会不动声色的穿上秋裤。请你一定要对号入座，我说的所有星光月亮、清泉小溪、蘸着糖的奶油和蜂蜜——这世间所有的美好事物，都只是为了形容你。你不是什么小人物，在我这里你是所有的天气和心情。我想对你做春天对樱桃树做的事。国家二级退堂鼓演奏家]]></content>
  </entry>
  <entry>
    <title><![CDATA[今天就和孩子签订一份成长协议]]></title>
    <url>%2Fposts%2F9085c4b7%2F</url>
    <content type="text"><![CDATA[作者：连岳原文链接： 今天就和孩子签订一份成长协议一想到教育，任务繁重，多数人万千愁绪，不知从何抓起。但任务越重大，起点越要轻微。一点点改变，往往就能改变事物的性质。有位家长提供了一份简单的成长协议，非常高明，值得推广：初初一看，这没什么稀奇，开学之际，父母都会对孩子提出各种成长要求。这位家长提出的要求高得多，每天提早半小时到校，这个改变，孩子就算完成度只有50%，除了早上比同学更从容，更多一点学习时间，还意味着他更早睡，更早完成作业，效率更高，作息时间的细微调整，将重组一天的时间结构。但是孩子提出了反制，这也不稀奇，当孩子被批评，被要求时，他们下意识的还击就是：那你自己如何如何。那你自己又做不到！是一句彻底激怒家长的话，羞愧、无能、耻辱、被冒犯、被伤害，一起发作，瞬间失去理智，家长将用强势地位压制孩子的反制，手段可能是物理或语言的暴力，或是各种辩解及转移话题，甚至流着泪说，要不是因为你耽误，我早就如何如何了。家长的压制当然能成功，孩子依靠你生存，这是他天然的不利。但付出的代价，却是成功教育者两大要件的丧失，一是威信，二是真诚。这两大要件相辅相成，失去其一，另外一个也成立不了。教育就是不停地讲道理，提要求。教育者本身的品德、能量令人敬佩，他讲道理事半功倍。一个天天玩手机的家长，警告孩子沉迷手机的危害，孩子当然认为你说假话。一个从不阅读，没有能力深阅读的家长，天天叨阅读的好处，必然没有任何效果，你只会学舌，他人说法的对错你都无法分辨，将一堆矛盾冲突的观点塞给孩子，他更加困惑，无所适从。家长无法对孩子隐藏自己的真面目，你若不值得尊重，第一个瞧不起你的，就是传承你DNA的孩子。一旦你放纵、无能、愚蠢、不负责任，精神上的弑父（母）就在发生。无论你多么花言巧语，教育都失效了。说话的技巧并不是教育的根本，在孩子心目中有威信的父母，怎么说都有效，说话技术好，效果更好而已。上面那位家长，接受孩子的反要求。有意无意，这迈出了质变的一小步。家长从孩子的要求中，可以发现自己忽视的缺点，那正是威信正在动摇的地方。同时有了被教育、被监督的弱势身份，在完成计划的过程中，可以体验学习与进步的艰难，不再只是轻松的动动嘴的教育者，和孩子一起学习， 一起成长，积累与交流这种经验就是不可替代的教育资源。而孩子突然有了教育者与监督者的强势身份，就像他小时候扮演老虎，他要表现得像只老虎，当他行使教育者与监督者职责时，他有了原来没有的视角与想法，这有利于他理解教育者。为了保有这份“权力”，他必须成为一个更好的学习者与履约者。我建议家长与孩子坐下来谈一谈，有意识地赋予孩子反制权，签订一份合理的、双方认同的一起成长计划，双方互为教育者与被教育者，监督者与被监督者。根据完成度，执行相应的奖罚。我知道，很多家长也有阅读计划，锻炼计划，学习计划，以及各种其他计划，但是自律性差，往往虎头蛇尾。有个无情的监督者，尤其他是你的孩子，你不能输，那么，你计划的完成度将大大提升，你的人生，因为有了和孩子一起成长的具体约定与行动，将如开挂一般。今天就订一个成长协议，虽然这对家长的要求更高了，但是一个负责任的家长，是不会怕的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java优雅之道]]></title>
    <url>%2Fposts%2Fb9a3a63c%2F</url>
    <content type="text"><![CDATA[本文作者：陈昌毅，花名常意，高德地图技术专家，2018年加入阿里巴巴，一直从事地图数据采集的相关工作。原文地址：Java 函数优雅之道导读随着软件项目代码的日积月累，系统维护成本变得越来越高，是所有软件团队面临的共同问题。持续地优化代码，提高代码的质量，是提升系统生命力的有效手段之一。软件系统思维有句话“Less coding, more thinking（少编码、多思考）”，也有这么一句俚语“Think more, code less（思考越多，编码越少）”。所以，我们在编码中多思考多总结，努力提升自己的编码水平，才能编写出更优雅、更高质、更高效的代码。本文总结了一套与 Java 函数相关的编码规则，旨在给广大Java程序员一些编码建议，有助于大家编写出更优雅、更高质、更高效的代码。这套编码规则，通过在高德采集部门的实践，已经取得了不错的成效。使用通用工具函数案例一现象描述:不完善的写法:1thisName != null &amp;&amp; thisName.equals(name);更完善的写法:1(thisName == name) || (thisName != null &amp;&amp; thisName.equals(name));建议方案:1Objects.equals(name, thisName);案例二现象描述:1!(list == null || list.isEmpty());建议方案：12import org.apache.commons.collections4.CollectionUtils;CollectionUtils.isNotEmpty(list);主要收益函数式编程，业务代码减少，逻辑一目了然；通用工具函数，逻辑考虑周全，出问题概率低。拆分超大函数当一个函数超过80行后，就属于超大函数，需要进行拆分。案例一每一个代码块必然有一个注释，用于解释这个代码块的功能。如果代码块前方有一行注释，就是在提醒你——可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。如果函数有一个描述恰当的名字，就不需要去看内部代码究竟是如何实现的。现象描述：1234567891011// 每日生活函数public void liveDaily() &#123; // 吃饭 // 吃饭相关代码几十行 // 编码 // 编码相关代码几十行 // 睡觉 // 睡觉相关代码几十行&#125;建议方案：1234567891011121314151617181920212223242526// 每日生活函数public void liveDaily() &#123; // 吃饭 eat(); // 编码 code(); // 睡觉 sleep();&#125;// 吃饭函数private void eat() &#123; // 吃饭相关代码&#125;// 编码函数private void code() &#123; // 编码相关代码&#125;// 睡觉函数private void sleep() &#123; // 睡觉相关代码&#125;案例二:每一个循环体都可以封装为一个函数。现象描述：12345678910111213// 生活函数public void live() &#123; while (isAlive) &#123; // 吃饭 eat(); // 编码 code(); // 睡觉 sleep(); &#125;&#125;建议方案：12345678910111213141516171819// 生活函数public void live() &#123; while (isAlive) &#123; // 每日生活 liveDaily(); &#125;&#125;// 每日生活函数private void liveDaily() &#123; // 吃饭 eat(); // 编码 code(); // 睡觉 sleep();&#125;案例三:每一个条件体都可以封装为一个函数。现象描述：123456789101112// 外出函数public void goOut() &#123; // 判断是否周末 // 判断是否周末: 是周末则游玩 if (isWeekday()) &#123; // 游玩代码几十行 &#125; // 判断是否周末: 非周末则工作 else &#123; // 工作代码几十行 &#125;&#125;建议方案：12345678910111213141516171819202122// 外出函数public void goOut() &#123; // 判断是否周末 // 判断是否周末: 是周末则游玩 if (isWeekday()) &#123; play(); &#125; // 判断是否周末: 非周末则工作 else &#123; work(); &#125;&#125;// 游玩函数private void play() &#123; // 游玩代码几十行&#125;// 工作函数private void work() &#123; // 工作代码几十行&#125;主要收益函数越短小精悍，功能就越单一，往往生命周期较长；一个函数越长，就越不容易理解和维护，维护人员不敢轻易修改；在过长函数中，往往含有难以发现的重复代码。同一函数内代码块级别尽量一致案例一现象描述：1234567891011// 每日生活函数public void liveDaily() &#123; // 吃饭 eat(); // 编码 code(); // 睡觉 // 睡觉相关代码几十行&#125;很明显，睡觉这块代码块，跟 eat（吃饭）和 code（编码）不在同一级别上，显得比较突兀。如果把写代码比作写文章，eat（吃饭）和code（编码）是段落大意，而睡觉这块代码块属于一个详细段落。而在 liveDaily（每日生活）这个函数上，只需要写出主要流程（段落大意）即可。建议方案：123456789101112131415public void liveDaily() &#123; // 吃饭 eat(); // 编码 code(); // 睡觉 sleep();&#125;// 睡觉private void sleep() &#123; // 睡觉相关代码&#125;主要收益函数调用表明用途，函数实现表达逻辑，层次分明便于理解；不用层次的代码块放在一个函数中，容易让人觉得代码头重脚轻。封装相同功能代码为函数案例一：封装相同代码为函数现象描述：1234567891011121314151617181920// 禁用用户函数public void disableUser() &#123; // 禁用黑名单用户 List&lt;Long&gt; userIdList = queryBlackUser(); for (Long userId : userIdList) &#123; User userUpdate = new User(); userUpdate.setId(userId); userUpdate.setEnable(Boolean.FALSE); userDAO.update(userUpdate); &#125; // 禁用过期用户 userIdList = queryExpiredUser(); for (Long userId : userIdList) &#123; User userUpdate = new User(); userUpdate.setId(userId); userUpdate.setEnable(Boolean.FALSE); userDAO.update(userUpdate); &#125;&#125;建议方案：12345678910111213141516171819202122// 禁用用户函数public void disableUser() &#123; // 禁用黑名单用户 List&lt;Long&gt; userIdList = queryBlackUser(); for (Long userId : userIdList) &#123; disableUser(userId); &#125; // 禁用过期用户 userIdList = queryExpiredUser(); for (Long userId : userIdList) &#123; disableUser(userId); &#125;&#125;// 禁用用户函数private void disableUser(Long userId) &#123; User userUpdate = new User(); userUpdate.setId(userId); userUpdate.setEnable(Boolean.FALSE); userDAO.update(userUpdate);&#125;案例二：封装相似代码为函数封装相似代码为函数，差异性通过函数参数控制。现象描述：1234567891011121314151617// 通过工单函数public void adoptOrder(Long orderId) &#123; Order orderUpdate = new Order(); orderUpdate.setId(orderId); orderUpdate.setStatus(OrderStatus.ADOPTED); orderUpdate.setAuditTime(new Date()); orderDAO.update(orderUpdate);&#125;// 驳回工单函数public void rejectOrder(Long orderId) &#123; Order orderUpdate = new Order(); orderUpdate.setId(orderId); orderUpdate.setStatus(OrderStatus.REJECTED); orderUpdate.setAuditTime(new Date()); orderDAO.update(orderUpdate);&#125;建议方案：123456789101112131415161718// 通过工单函数public void adoptOrder(Long orderId) &#123; auditOrder(orderId, OrderStatus.ADOPTED);&#125;// 驳回工单函数public void rejectOrder(Long orderId) &#123; auditOrder(orderId, OrderStatus.REJECTED);&#125;// 审核工单函数private void auditOrder(Long orderId, OrderStatus orderStatus) &#123; Order orderUpdate = new Order(); orderUpdate.setId(orderId); orderUpdate.setStatus(orderStatus); orderUpdate.setAuditTime(new Date()); orderDAO.update(orderUpdate);&#125;主要收益封装公共函数，减少代码行数，提高代码质量；封装公共函数，使业务代码更精炼，可读性可维护性更强。封装获取参数值函数案例一现象描述：1234567891011121314// 是否通过函数public boolean isPassed(Long userId) &#123; // 获取通过阈值 double thisPassThreshold = PASS_THRESHOLD; if (Objects.nonNull(passThreshold)) &#123; thisPassThreshold = passThreshold; &#125; // 获取通过率 double passRate = getPassRate(userId); // 判读是否通过 return passRate &gt;= thisPassThreshold;&#125;建议方案：12345678910111213141516171819// 是否通过函数public boolean isPassed(Long userId) &#123; // 获取通过阈值 double thisPassThreshold = getPassThreshold(); // 获取通过率 double passRate = getPassRate(userId); // 判读是否通过 return passRate &gt;= thisPassThreshold;&#125;// 获取通过阈值函数private double getPassThreshold() &#123; if (Objects.nonNull(passThreshold)) &#123; return passThreshold; &#125; return PASS_THRESHOLD;&#125;主要收益把获取参数值从业务函数中独立，使业务逻辑更清晰；封装的获取参数值为独立函数，可以在代码中重复使用。通过接口参数化封装相同逻辑案例一现象描述：1234567891011121314151617181920212223// 发送审核员结算数据函数public void sendAuditorSettleData() &#123; List&lt;WorkerSettleData&gt; settleDataList = auditTaskDAO.statAuditorSettleData(); for (WorkerSettleData settleData : settleDataList) &#123; WorkerPushData pushData = new WorkerPushData(); pushData.setId(settleData.getWorkerId()); pushData.setType(WorkerPushDataType.AUDITOR); pushData.setData(settleData); pushService.push(pushData); &#125;&#125;// 发送验收员结算数据函数public void sendCheckerSettleData() &#123; List&lt;WorkerSettleData&gt; settleDataList = auditTaskDAO.statCheckerSettleData(); for (WorkerSettleData settleData : settleDataList) &#123; WorkerPushData pushData = new WorkerPushData(); pushData.setId(settleData.getWorkerId()); pushData.setType(WorkerPushDataType.CHECKER); pushData.setData(settleData); pushService.push(pushData); &#125;&#125;建议方案：123456789101112131415161718192021222324252627// 发送审核员结算数据函数public void sendAuditorSettleData() &#123; sendWorkerSettleData(WorkerPushDataType.AUDITOR, () -&gt; auditTaskDAO.statAuditorSettleData());&#125;// 发送验收员结算数据函数public void sendCheckerSettleData() &#123; sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; auditTaskDAO.statCheckerSettleData());&#125;// 发送作业员结算数据函数public void sendWorkerSettleData(WorkerPushDataType dataType, WorkerSettleDataProvider dataProvider) &#123; List&lt;WorkerSettleData&gt; settleDataList = dataProvider.statWorkerSettleData(); for (WorkerSettleData settleData : settleDataList) &#123; WorkerPushData pushData = new WorkerPushData(); pushData.setId(settleData.getWorkerId()); pushData.setType(dataType); pushData.setData(settleData); pushService.push(pushData); &#125;&#125;// 作业员结算数据提供者接口private interface WorkerSettleDataProvider &#123; // 统计作业员结算数据 public List&lt;WorkerSettleData&gt; statWorkerSettleData();&#125;主要收益把核心逻辑从各个业务函数中抽析，使业务代码更清晰更易维护；避免重复性代码多次编写，精简重复函数越多收益越大。减少函数代码层级如果要使函数优美，建议函数代码层级在1-4之间，过多的缩进会让函数难以阅读。案例一：利用return提前返回函数现象描述：1234567891011// 获取用户余额函数public Double getUserBalance(Long userId) &#123; User user = getUser(userId); if (Objects.nonNull(user)) &#123; UserAccount account = user.getAccount(); if (Objects.nonNull(account)) &#123; return account.getBalance(); &#125; &#125; return null;&#125;建议方案：1234567891011121314151617// 获取用户余额函数public Double getUserBalance(Long userId) &#123; // 获取用户信息 User user = getUser(userId); if (Objects.isNull(user)) &#123; return null; &#125; // 获取用户账户 UserAccount account = user.getAccount(); if (Objects.isNull(account)) &#123; return null; &#125; // 返回账户余额 return account.getBalance();&#125;案例二：利用continue提前结束循环现象描述：123456789101112131415161718192021// 获取合计余额函数public double getTotalBalance(List&lt;User&gt; userList) &#123; // 初始合计余额 double totalBalance = 0.0D; // 依次累加余额 for (User user : userList) &#123; // 获取用户账户 UserAccount account = user.getAccount(); if (Objects.nonNull(account)) &#123; // 累加用户余额 Double balance = account.getBalance(); if (Objects.nonNull(balance)) &#123; totalBalance += balance; &#125; &#125; &#125; // 返回合计余额 return totalBalance;&#125;建议方案：1234567891011121314151617181920212223// 获取合计余额函数public double getTotalBalance(List&lt;User&gt; userList) &#123; // 初始合计余额 double totalBalance = 0.0D; // 依次累加余额 for (User user : userList) &#123; // 获取用户账户 UserAccount account = user.getAccount(); if (Objects.isNull(account)) &#123; continue; &#125; // 累加用户余额 Double balance = account.getBalance(); if (Objects.nonNull(balance)) &#123; totalBalance += balance; &#125; &#125; // 返回合计余额 return totalBalance;&#125;特殊说明其它方式：在循环体中，先调用案例1的函数 getUserBalance (获取用户余额)，再进行对余额进行累加。在循环体中，建议最多使用一次 continue 。如果需要有使用多次 continue 的需求，建议把循环体封装为一个函数。案例三：利用条件表达式函数减少层级请参考下一章的”案例2: 把复杂条件表达式封装为函数”主要收益代码层级减少，代码缩进减少；模块划分清晰，方便阅读维护。封装条件表达式函数案例一：把简单条件表达式封装为函数现象描述：12345678// 获取门票价格函数public double getTicketPrice(Date currDate) &#123; if (Objects.nonNull(currDate) &amp;&amp; currDate.after(DISCOUNT_BEGIN_DATE) &amp;&amp; currDate.before(DISCOUNT_END_DATE)) &#123; return TICKET_PRICE * DISCOUNT_RATE; &#125; return TICKET_PRICE;&#125;建议方案：1234567891011121314// 获取门票价格函数public double getTicketPrice(Date currDate) &#123; if (isDiscountDate(currDate)) &#123; return TICKET_PRICE * DISCOUNT_RATE; &#125; return TICKET_PRICE;&#125;// 是否折扣日期函数private static boolean isDiscountDate(Date currDate) &#123; return Objects.nonNull(currDate) &amp;&amp; currDate.after(DISCOUNT_BEGIN_DATE) &amp;&amp; currDate.before(DISCOUNT_END_DATE);&#125;案例二：把复杂条件表达式封装为函数现象描述：12345678910111213141516171819202122// 获取土豪用户列表public List&lt;User&gt; getRichUserList(List&lt;User&gt; userList) &#123; // 初始土豪用户列表 List&lt;User&gt; richUserList = new ArrayList&lt;&gt;(); // 依次查找土豪用户 for (User user : userList) &#123; // 获取用户账户 UserAccount account = user.getAccount(); if (Objects.nonNull(account)) &#123; // 判断用户余额 Double balance = account.getBalance(); if (Objects.nonNull(balance) &amp;&amp; balance.compareTo(RICH_THRESHOLD) &gt;= 0) &#123; // 添加土豪用户 richUserList.add(user); &#125; &#125; &#125; // 返回土豪用户列表 return richUserList;&#125;建议方案：1234567891011121314151617181920212223242526272829303132333435// 获取土豪用户列表public List&lt;User&gt; getRichUserList(List&lt;User&gt; userList) &#123; // 初始土豪用户列表 List&lt;User&gt; richUserList = new ArrayList&lt;&gt;(); // 依次查找土豪用户 for (User user : userList) &#123; // 判断土豪用户 if (isRichUser(user)) &#123; // 添加土豪用户 richUserList.add(user); &#125; &#125; // 返回土豪用户列表 return richUserList;&#125;// 是否土豪用户private boolean isRichUser(User user) &#123; // 获取用户账户 UserAccount account = user.getAccount(); if (Objects.isNull(account)) &#123; return false; &#125; // 获取用户余额 Double balance = account.getBalance(); if (Objects.isNull(balance)) &#123; return false; &#125; // 比较用户余额 return balance.compareTo(RICH_THRESHOLD) &gt;= 0;&#125;以上代码也可以用采用流式(Stream)编程的过滤来实现。主要收益把条件表达式从业务函数中独立，使业务逻辑更清晰；封装的条件表达式为独立函数，可以在代码中重复使用。尽量避免不必要的空指针判断本章只适用于项目内部代码，并且是自己了解的代码，才能够尽量避免不必要的空指针判断。对于第三方中间件和系统接口，必须做好空指针判断，以保证代码的健壮性。案例一: 调用函数保证参数不为空，被调用函数尽量避免不必要的空指针判断现象描述：12345678910111213141516// 创建用户信息User user = new User();... // 赋值用户相关信息createUser(user);// 创建用户函数private void createUser(User user)&#123; // 判断用户为空 if(Objects.isNull(user)) &#123; return; &#125; // 创建用户信息 userDAO.insert(user); userRedis.save(user);&#125;建议方案：1234567891011// 创建用户信息User user = new User();... // 赋值用户相关信息createUser(user);// 创建用户函数private void createUser(User user)&#123; // 创建用户信息 userDAO.insert(user); userRedis.save(user);&#125;案例二: 被调用函数保证返回不为空,调用函数尽量避免不必要的空指针判断现象描述：1234567891011121314151617181920// 保存用户函数public void saveUser(Long id, String name) &#123; // 构建用户信息 User user = buildUser(id, name); if (Objects.isNull(user)) &#123; throw new BizRuntimeException("构建用户信息为空"); &#125; // 保存用户信息 userDAO.insert(user); userRedis.save(user);&#125;// 构建用户函数private User buildUser(Long id, String name) &#123; User user = new User(); user.setId(id); user.setName(name); return user;&#125;建议方案：1234567891011121314151617// 保存用户函数public void saveUser(Long id, String name) &#123; // 构建用户信息 User user = buildUser(id, name); // 保存用户信息 userDAO.insert(user); userRedis.save(user);&#125;// 构建用户函数private User buildUser(Long id, String name) &#123; User user = new User(); user.setId(id); user.setName(name); return user;&#125;案例三：赋值逻辑保证列表数据项不为空，处理逻辑尽量避免不必要的空指针判断现象描述：12345678910111213141516171819202122232425// 查询用户列表List&lt;UserDO&gt; userList = userDAO.queryAll();if (CollectionUtils.isEmpty(userList)) &#123; return;&#125;// 转化用户列表List&lt;UserVO&gt; userVoList = new ArrayList&lt;&gt;(userList.size());for (UserDO user : userList) &#123; UserVO userVo = new UserVO(); userVo.setId(user.getId()); userVo.setName(user.getName()); userVoList.add(userVo);&#125;// 依次处理用户for (UserVO userVo : userVoList) &#123; // 判断用户为空 if (Objects.isNull(userVo)) &#123; continue; &#125; // 处理相关逻辑 ...&#125;建议方案：1234567891011121314151617181920// 查询用户列表List&lt;UserDO&gt; userList = userDAO.queryAll();if (CollectionUtils.isEmpty(userList)) &#123; return;&#125;// 转化用户列表List&lt;UserVO&gt; userVoList = new ArrayList&lt;&gt;(userList.size());for (UserDO user : userList) &#123; UserVO userVo = new UserVO(); userVo.setId(user.getId()); userVo.setName(user.getName()); userVoList.add(userVo);&#125;// 依次处理用户for (UserVO userVo : userVoList) &#123; // 处理相关逻辑 ...&#125;案例四：MyBatis查询函数返回列表和数据项不为空，可以不用空指针判断MyBatis 是一款优秀的持久层框架，是在项目中使用的最广泛的数据库中间件之一。通过对 MyBatis 源码进行分析，查询函数返回的列表和数据项都不为空，在代码中可以不用进行空指针判断。现象描述：这种写法没有问题，只是过于保守了。12345678910111213141516171819202122232425// 查询用户函数public List&lt;UserVO&gt; queryUser(Long id, String name) &#123; // 查询用户列表 List&lt;UserDO&gt; userList = userDAO.query(id, name); if (Objects.isNull(userList)) &#123; return Collections.emptyList(); &#125; // 转化用户列表 List&lt;UserVO&gt; voList = new ArrayList&lt;&gt;(userList.size()); for (UserDO user : userList) &#123; // 判断对象为空 if (Objects.isNull(user)) &#123; continue; &#125; // 添加用户信息 UserVO vo = new UserVO(); BeanUtils.copyProperties(user, vo); voList.add(vo); &#125; // 返回用户列表 return voList;&#125;建议方案：12345678910111213141516// 查询用户函数public List&lt;UserVO&gt; queryUser(Long id, String name) &#123; // 查询用户列表 List&lt;UserDO&gt; userList = userDAO.query(id, name); // 转化用户列表 List&lt;UserVO&gt; voList = new ArrayList&lt;&gt;(userList.size()); for (UserDO user : userList) &#123; UserVO vo = new UserVO(); BeanUtils.copyProperties(user, vo); voList.add(vo); &#125; // 返回用户列表 return voList;&#125;主要收益避免不必要的空指针判断，精简业务代码处理逻辑，提高业务代码运行效率；这些不必要的空指针判断，基本属于永远不执行的 Death 代码，删除有助于代码维护。内部函数参数尽量使用基础类型案例一：内部函数参数尽量使用基础类型现象描述：123456789// 调用代码double price = 5.1D;int number = 9;double total = calculate(price, number);// 计算金额函数private double calculate(Double price, Integer number) &#123; return price * number;&#125;建议方案：123456789// 调用代码double price = 5.1D;int number = 9;double total = calculate(price, number);// 计算金额函数private double calculate(double price, int number) &#123; return price * number;&#125;案例二：内部函数返回值尽量使用基础类型现象描述：1234567891011121314151617// 获取订单总额函数public double getOrderAmount(List&lt;Product&gt; productList) &#123; double amount = 0.0D; for (Product product : productList) &#123; if (Objects.isNull(product) || Objects.isNull(product.getPrice()) || Objects.isNull(product.getNumber())) &#123; continue; &#125; amount += calculate(product.getPrice(), product.getNumber()); &#125; return amount;&#125;// 计算金额函数private Double calculate(double price, double number) &#123; return price * number;&#125;建议方案：1234567891011121314151617// 获取订单总额函数public double getOrderAmount(List&lt;Product&gt; productList) &#123; double amount = 0.0D; for (Product product : productList) &#123; if (Objects.isNull(product) || Objects.isNull(product.getPrice()) || Objects.isNull(product.getNumber())) &#123; continue; &#125; amount += calculate(product.getPrice(), product.getNumber()); &#125; return amount;&#125;// 计算金额函数private double calculate(double price, double number) &#123; return price * number;&#125;此处只是举例说明这种现象，更好的方式是采用流式(Stream)编程。主要收益内部函数尽量使用基础类型，避免了隐式封装类型的打包和拆包；内部函数参数使用基础类型，用语法上避免了内部函数的参数空指针判断；内部函数返回值使用基础类型，用语法上避免了调用函数的返回值空指针判断。尽量避免返回的数组和列表为 null案例一：尽量避免返回的数组为 null ，引起不必要的空指针判断现象描述：12345678910111213141516171819202122232425262728// 调用代码UserVO[] users = queryUser();if (Objects.nonNull(users)) &#123; for (UserVO user : users) &#123; // 处理用户信息 &#125;&#125;// 查询用户函数private UserVO[] queryUser() &#123; // 查询用户列表 List&lt;UserDO&gt; userList = userDAO.queryAll(); if (CollectionUtils.isEmpty(userList)) &#123; return null; &#125; // 转化用户数组 UserVO[] users = new UserVO[userList.size()]; for (int i = 0; i &lt; userList.size(); i++) &#123; UserDO user = userList.get(i); users[i] = new UserVO(); users[i].setId(user.getId()); users[i].setName(user.getName()); &#125; // 返回用户数组 return users;&#125;建议方案：1234567891011121314151617181920212223242526// 调用代码UserVO[] users = queryUser();for (UserVO user : users) &#123; // 处理用户信息&#125;// 查询用户函数private UserVO[] queryUser() &#123; // 查询用户列表 List&lt;UserDO&gt; userList = userDAO.queryAll(); if (CollectionUtils.isEmpty(userList)) &#123; return new UserVO[0]; &#125; // 转化用户数组 UserVO[] users = new UserVO[userList.size()]; for (int i = 0; i &lt; userList.size(); i++) &#123; UserDO user = userList.get(i); users[i] = new UserVO(); users[i].setId(user.getId()); users[i].setName(user.getName()); &#125; // 返回用户数组 return users;&#125;案例二：尽量避免返回的列表为 null ，引起不必要的空指针判断现象描述：12345678910111213141516171819202122232425262728// 调用代码List&lt;UserVO&gt; userList = queryUser();if (Objects.nonNull(userList)) &#123; for (UserVO user : userList) &#123; // 处理用户信息 &#125;&#125;// 查询用户函数private List&lt;UserVO&gt; queryUser()&#123; // 查询用户列表 List&lt;UserDO&gt; userList = userDAO.queryAll(); if(CollectionUtils.isEmpty(userList)) &#123; return null; &#125; // 转化用户列表 List&lt;UserVO&gt; userVoList = new ArrayList&lt;&gt;(userList.size()); for(UserDO user : userList) &#123; UserVO userVo = new UserVO(); userVo.setId(user.getId()); userVo.setName(user.getName()); userVoList.add(userVo); &#125; // 返回用户列表 return userVoList;&#125;建议方案：1234567891011121314151617181920212223242526// 调用代码List&lt;UserVO&gt; userList = queryUser();for (UserVO user : userList) &#123; // 处理用户信息 &#125;// 查询用户函数private List&lt;UserVO&gt; queryUser()&#123; // 查询用户列表 List&lt;UserDO&gt; userList = userDAO.queryAll(); if(CollectionUtils.isEmpty(userList)) &#123; return Collections.emptyList(); &#125; // 转化用户列表 List&lt;UserVO&gt; userVoList = new ArrayList&lt;&gt;(userList.size()); for(UserDO user : userList) &#123; UserVO userVo = new UserVO(); userVo.setId(user.getId()); userVo.setName(user.getName()); userVoList.add(userVo); &#125; // 返回用户列表 return userVoList;&#125;主要收益保证返回的数组和列表不为 null , 避免调用函数的空指针判断。封装函数传入参数案例一：当传入参数过多时，应封装为参数类Java 规范不允许函数参数太多，不便于维护也不便于扩展。现象描述：12345// 修改用户函数public void modifyUser(Long id, String name, String phone, Integer age, Integer sex, String address, String description) &#123; // 具体实现逻辑&#125;建议方案：123456789101112131415161718// 修改用户函数public void modifyUser(User user) &#123; // 具体实现内容&#125;// 用户类@Getter@Setter@ToStringprivate class User&#123; private Long id; private String name; private String phone; private Integer age; private Integer sex; private String address; private String description;&#125;案例二: 当传入成组参数时，应封装为参数类既然参数成组出现，就需要封装一个类去描述这种现象。现象描述：1234// 获取距离函数public double getDistance(double x1, double y1, double x2, double y2) &#123; // 具体实现逻辑&#125;建议方案：12345678910111213// 获取距离函数public double getDistance(Point point1, Point point2) &#123; // 具体实现逻辑&#125;// 点类@Getter@Setter@ToStringprivate class Point&#123; private double x; private double y;&#125;主要收益封装过多函数参数为类，使函数更便于扩展和维护；封装成组函数参数为类，使业务概念更明确更清晰。尽量用函数替换匿名内部类的实现在匿名内部类（包括Lambda表达式）中可以直接访问外部类的成员，包括类的成员变量、函数的内部变量。正因为可以随意访问外部变量，所以会导致代码边界不清晰。首先推荐用 Lambda 表达式简化匿名内部类，其次推荐用函数替换复杂的 Lambda 表达式的实现。案例一：尽量用函数替换匿名内部类（包括Lambda表达式）的实现现象描述：123456// 发送结算数据sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; &#123; Date beginDate = DateUtils.addDays(currDate, -aheadDays); Date endDate = DateUtils.addDays(currDate, 1); return auditTaskDAO.statCheckerSettleData(beginDate, endDate);&#125;);建议方案：123456789// 发送结算数据sendWorkerSettleData(WorkerPushDataType.CHECKER, () -&gt; statCheckerSettleData(currDate, aheadDays));// 统计验收员结算数据函数private List&lt;WorkerSettleData&gt; statCheckerSettleData(Date currDate, int aheadDays) &#123; Date beginDate = DateUtils.addDays(currDate, -aheadDays); Date endDate = DateUtils.addDays(currDate, 1); return auditTaskDAO.statCheckerSettleData(beginDate, endDate);&#125;其实，还有一个更简单的办法。在调用函数 sendWorkerSettleData（发送作业员结算数据）之前计算开始日期、结束日期，就直接可以用函数auditTaskDAO.statCheckerSettleData(beginDate, endDate)代替匿名内部类实现。案例二：拆分复杂匿名内部类实现接口为多个函数类接口如果一个匿名内部类实现的接口几个函数间关联性不大，可以把这个接口拆分为几个函数式接口，便于使用 Lambda 表达式。现象描述：123456789101112131415161718192021222324// 清除过期数据cleanExpiredData("用户日志表", new CleanExpiredDataOperator() &#123; @Override public List&lt;Date&gt; queryExpiredDate(Integer remainDays) &#123; return userDAO.queryExpiredDate(remainDays); &#125; @Override public void cleanExpiredData(Date expiredDate) &#123; userDAO.cleanExpiredData(expiredDate); &#125;&#125;);// 清除过期数据函数private void cleanExpiredData(String tableName, CleanExpiredDataOperator cleanExpiredDataOperator) &#123; // 功能实现代码&#125;// 清除过期操作接口interface CleanExpiredDataOperator &#123; // 查询过期日期 public List&lt;Date&gt; queryExpiredDate(Integer remainDays); // 清除过期数据 public void cleanExpiredData(Date expiredDate);&#125;建议方案：12345678910111213141516171819// 清除过期数据cleanExpiredData("用户日志表", userDAO::queryExpiredDate,userDAO::cleanExpiredData);// 清除过期数据函数private void cleanExpiredData(String tableName, QueryExpiredDateOperator queryExpiredDateOperator, CleanExpiredDataOperator cleanExpiredDataOperator) &#123; // 功能实现代码&#125;// 查询过期日期接口interface QueryExpiredDateOperator &#123; // 查询过期日期 public List&lt;Date&gt; queryExpiredDate(Integer remainDays);&#125;// 清除过期操作接口interface CleanExpiredDataOperator &#123; // 清除过期数据 public void cleanExpiredData(Date expiredDate);&#125;主要收益定义函数并指定参数，明确规定了匿名内部类的代码边界；利用 Lambda 表达式简化匿名内部类实现，使代码更简洁。利用 return 精简不必要的代码案例一：删除不必要的 if现象描述：1234567// 是否通过函数public boolean isPassed(Double passRate) &#123; if (Objects.nonNull(passRate) &amp;&amp; passRate.compareTo(PASS_THRESHOLD) &gt;= 0) &#123; return true; &#125; return false;&#125;建议方案：1234// 是否通过函数public boolean isPassed(Double passRate) &#123; return Objects.nonNull(passRate) &amp;&amp; passRate.compareTo(PASS_THRESHOLD) &gt;= 0;&#125;案例二：删除不必要的 else现象描述：123456789// 结算工资函数public double settleSalary(Long workId, int workDays) &#123; // 根据是否合格处理 if (isQualified(workId)) &#123; return settleQualifiedSalary(workDays); &#125; else &#123; return settleUnqualifiedSalary(workDays); &#125;&#125;建议方案：12345678// 结算工资函数public double settleSalary(Long workId, int workDays) &#123; // 根据是否合格处理 if (isQualified(workId)) &#123; return settleQualifiedSalary(workDays); &#125; return settleUnqualifiedSalary(workDays);&#125;案例三：删除不必要的变量现象描述：12345678// 查询用户函数public List&lt;UserDO&gt; queryUser(Long id, String name) &#123; UserQuery userQuery = new UserQuery(); userQuery.setId(id); userQuery.setName(name); List&lt;UserDO&gt; userList = userDAO.query(userQuery); return userList;&#125;建议方案：1234567// 查询用户函数public List&lt;UserDO&gt; queryUser(Long id, String name) &#123; UserQuery userQuery = new UserQuery(); userQuery.setId(id); userQuery.setName(name); return userDAO.query(userQuery);&#125;主要收益精简不必要的代码，让代码看起来更清爽。利用临时变量优化代码在一些代码中，经常会看到 a.getB().getC()…getN() 的写法，姑且叫做“函数的级联调用”，代码健壮性和可读性太差。建议：杜绝函数的级联调用，利用临时变量进行拆分，并做好对象空指针检查。案例一：利用临时变量厘清逻辑现象描述：123456// 是否土豪用户函数private boolean isRichUser(User user) &#123; return Objects.nonNull(user.getAccount()) &amp;&amp; Objects.nonNull(user.getAccount().getBalance()) &amp;&amp; user.getAccount().getBalance().compareTo(RICH_THRESHOLD) &gt;= 0;&#125;这是精简代码控的最爱，但是可读性实在太差。建议方案：1234567891011121314151617// 是否土豪用户函数private boolean isRichUser(User user) &#123; // 获取用户账户 UserAccount account = user.getAccount(); if (Objects.isNull(account)) &#123; return false; &#125; // 获取用户余额 Double balance = account.getBalance(); if (Objects.isNull(balance)) &#123; return false; &#125; // 比较用户余额 return balance.compareTo(RICH_THRESHOLD) &gt;= 0;&#125;这个方案，增加了代码行数，但是逻辑更清晰。有时候，当代码的精简性和可读性发生冲突时，个人更偏向于保留代码的可读性。案例二：利用临时变量精简代码现象描述：1234567891011// 构建用户函数public UserVO buildUser(UserDO user) &#123; UserVO vo = new UserVO(); vo.setId(user.getId()); vo.setName(user.getName()); if (Objects.nonNull(user.getAccount())) &#123; vo.setBalance(user.getAccount().getBalance()); vo.setDebt(user.getAccount().getDebt()); &#125; return vo;&#125;这么写，大约是为了节约一个临时变量吧。建议方案：1234567891011// 构建用户函数public UserVO buildUser1(UserDO user) &#123; UserVO vo = new UserVO(); vo.setId(user.getId()); vo.setName(user.getName()); UserAccount account = user.getAccount(); if (Objects.nonNull(account)) &#123; vo.setBalance(account.getBalance()); vo.setDebt(account.getDebt()); &#125; return vo;主要收益利用临时变量厘清逻辑，显得业务逻辑更清晰；利用临时变量精简代码，看变量名称即知其义，减少了大量无用代码；如果获取函数比较复杂耗时，利用临时变量可以提高运行效率；利用临时变量避免函数的级联调用，可有效预防空指针异常。仅保留函数需要的参数案例一：删除多余的参数现象描述：12345// 修改用户状态函数private void modifyUserStatus(Long userId, Integer status, String unused) &#123; userCache.modifyStatus(userId, status); userDAO.modifyStatus(userId, status);&#125;其中，unused 参数是无用参数。建议方案：12345// 修改用户状态函数private void modifyUserStatus(Long userId, Integer status) &#123; userCache.modifyStatus(userId, status); userDAO.modifyStatus(userId, status);&#125;案例二：用属性取代对象现象描述：12345// 删除用户函数private void deleteUser(User user) &#123; userCache.delete(user.getId()); userDAO.delete(user.getId());&#125;建议方案：12345// 删除用户函数private void deleteUser(Long userId) &#123; userCache.delete(userId); userDAO.delete(userId);&#125;建议方案：调用函数时，参数对象不需要专门构建，而函数使用其属性超过3个，可以不必使用该规则。主要收益仅保留函数需要的参数，明确了调用时需要赋值的参数，避免了调用时还要去构造些无用参数。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>编程规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5简单了解]]></title>
    <url>%2Fposts%2Fc9f1aafe%2F</url>
    <content type="text"><![CDATA[什么是 MD5MD5 是 Message-Digest algorithm 5（信息-摘要算法）的缩写，被广泛用于加密和解密技术上，它可以说是文件的“数字指纹”。任何一个文件，无论是可执行程序、图像文件、临时文件或者其他任何类型的文件，也不管它体积多大，都有且只有一个独一无二的MD5信息值，并且如果这个文件被修改过，它的MD5值也将随之改变。因此，我们可以通过对比同一文件的MD5值，来校验这个文件是否被“篡改”过。MD5 用途MD5 文件传输当我们下载了一个软件以后，如果想知道下载的这个软件和网站的原始文件是否一模一样，就可以给自己下载的文件做个 MD5 校验。如果得到的 MD5 值和网站公布的相同，可确认所下载的文件是完整的。如有不同，说明你下载的文件是不完整的：要么就是在网络下载的过程中出现错误，要么就是此文件已被别人修改。为防止他人更改该文件时放入病毒，最好不要使用。一般使用 MD5 计算工具计算后，和软件网站公布得MD5码进行比对。校验值是一组16进制数，不区分大小写，校验值本身只与文件内容有关，只要文件内容不改变校验值就不变；如复制/剪切/粘贴，修改文件创建时间/访问时间，修改文件读/写/执行属性等操作都不会导致校验值发生改变。MD5 密码加密MD5 算法是不可逆的，可以应用在对密码(或者信用卡等)得加密，加密之后在数据库里面看到的密码是无用的。如果需要检验用户的密码，而是检验用户输入的密码经 md5 加密以后和数据库内的是否相符。扩展彩虹表现在的 MD5 密码数据库（彩虹表）的数据量已经非常庞大了，大部分常用密码都可以通过 MD5 摘要反向查询到密码明文。为了防止内部人员（能够接触到数据库或者数据库备份文件的人员）和外部入侵者通过MD5反查密码明文，更好地保护用户的密码和个人帐户安全（一个用户可能会在多个系统中使用同样的密码，因此涉及到用户在其他网站和系统中的数据安全），需要对 MD5 摘要结果掺入其他信息，称之为加盐。通过 md5、sha1等全球通用公开的加密算法进行反向查询网站 : https://www.cmd5.com/例如：MD5 加密+加盐在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。加盐很好理解，就是给原始密码加上特定的字符串，这样给攻击者增加攻击的成本，加盐的关键在于如何选择盐。固定字符串MD5(Password+UserName)，即将用户名和密码字符串相加再 MD5，这样的 MD5 摘要基本上不可反查。但有时候用户名可能会发生变化，发生变化后密码即不可用了（验证密码实际上就是再次计算摘要的过程）。随机字符串盐一般要求是固定长度的随机字符串，且每个用户的盐不同，比如10位，数据库可以这样存储：UsernamePasswordSaltFreya26b74fc2e533289be4dae7018806d97863UrCwJhTHAsher05e213b017e654d6edc134751bc9319f84GljVnhDT采用加密方式 MD5(MD5(password) + salt)注：以随机字符串作为盐对密码进行加盐仅仅是增加破解密码的难度，可以减少数据库泄露密码以后被破译的风险。计算文件的 MD5 校验值在命令行下，可以使用 Windows 自带的 certutil 命令来计算一个文件的校验值。certutil 支持的算法有：MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512。certutil 的使用方法非常简单，只需要执行certutil -hashfile 文件名 校验值类型，即可计算出对应文件的校验值。也可以使用 md5sums 或 hash 工具进行计算。Linux 下可以直接使用 md5sum/sha1sum/sha256sum 等命令直接计算文件的对应校验值。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP与HTTPS的区别]]></title>
    <url>%2Fposts%2F80f14f93%2F</url>
    <content type="text"><![CDATA[原文链接：HTTP 与 HTTPS 的区别基本概念HTTPHTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。HTTPSHTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。HTTPS 默认工作在 TCP 协议 443 端口，它的工作流程一般如以下方式：TCP 三次同步握手客户端验证服务器数字证书DH 算法协商对称加密算法的密钥、hash 算法的密钥SSL 安全加密隧道协商完成网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。HTTP 与 HTTPS 区别HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 SSL 握手需要的 9 个包，所以一共是 12 个包。http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。TCP 三次握手第一次握手：客户端尝试连接服务器，向服务器发送 SYN 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认。第二次握手：服务器接收客户端 SYN 包并确认（ack=j+1），同时向客户端发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。HTTPS 的工作原理我们都知道 HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议。1、客户端发起 HTTPS 请求这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。2、服务端的配置采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。3、传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。4、客户端解析证书这部分工作是有客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。5、传送加密信息这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。6、服务端解密信息服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。7、传输加密后的信息这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。8、客户端解密信息客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java关键字]]></title>
    <url>%2Fposts%2Fb960f15%2F</url>
    <content type="text"><![CDATA[Java中各种关键字 transient、instanceof、volatile、final、static 。transient一个对象只要实现了 Serializable 接口，这个对象就可以被序列化，Java 的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了 Serializable 接口，这个类的所有属性和方法都会自动序列化。然而在实际开发过程中，一个类中并不是所有属性都需要进行序列化，打个比方，如果一个用户有一些敏感信息(如密码，银行卡号等)，为了安全起见，不希望在网络操作(主要涉及到序列化操作，本地序列化缓存也适用)中被传输，这些信息对应的变量就可以加上 transient 关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。小结：一旦变量被 transient 修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。transient 关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被 transient 关键字修饰的。变量如果是用户自定义类变量，则该类需要实现 Serializable 接口。被 transient 关键字修饰的变量不再能被序列化，一个静态变量不管是否被 transient 修饰，均不能被序列化(静态变量的值不是从序列化得到，而是从 JVM 中得到)。注意：Java 中的关键字 transient 是用来标识一个属性不被序列化的，而 JPA 的 @Transient 注解是用来标识一个属性不被持久化到数据库的。若实现的是 Externalizable 接口，则没有任何东西可以自动序列化，需要在 writeExternal 方法中进行手工指定所要序列化的变量，这与是否被 transient 修饰无关。instanceof可以用来检查对象是否是特定类的实例。比如，当您有一个对超类或接口类型的对象的引用或参数，你想知道实际对象是否有其他类型（通常更具体）时，可以使用它。12345678910111213public void doSomething(Number param) &#123; if (param instanceof Double) &#123; System.out.println("param is a Double"); &#125; else if (param instanceof Integer) &#123; System.out.println("param is an Integer"); &#125; if (param instanceof Comparable) &#123; //subclasses of Number like Double etc. implement Comparable //other subclasses might not -&gt; you could pass Number instances that don't implement that interface System.out.println("param is comparable"); &#125;&#125;注意：使用 instanceof 之前不需要做 null 检查，假如 x 是 null，则 x instanceof SomeClass 就是 false。volatile参考 volatile关键字final在 Java 中，被 final 修饰代表不能被改变。final 修饰的类不能被继承，但是可以继承其他类。inal 修饰的变量在定义时，必须赋值，并且只能赋值一次final 修饰的方法不能被重写。final 修饰的引用型变量，变量的值是固定不变的。注意：对象的引用值和对象的属性值！注意：使用 final 关键字它能会提高性能，但充其量只是略微提高。还是根据实际需要去使用。static当我们通过 new 关键字去创建对象的时候，那么数据的存储空间才会被分配，类中的成员方法才能被对象所使用。有两种特殊的情况：我们通过 new 关键字创建的对象共享同一个资源，而不是说每个对象都拥有自己的数据，或者说根本就不需要去创建对象，这个资源和对象之间是没有关系的。希望某个方法不与包含它的类的任何对象联系在一起。总结下来就是说：即使没有创建对象，也能使用属性和调用方法，static 目的就是在于解决这个问题。static 可以修饰变量、方法。被 static 修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。在类被加载的时候，就会去加载被 static 修饰的部分。被 static 修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。静态变量被 static 修饰的成员变量叫做静态变量，也叫做类变量，说明这个变量是属于这个类的，而不是属于是对象，没有被 static 修饰的成员变量叫做实例变量，说明这个变量是属于某个具体的对象的。静态方法被 static 修饰的方法也叫做静态方法，因为对于静态方法来说是不属于任何实例对象的，那么就是说在静态方法内部是不能使用 this 的，因为既然不属于任何对象，那么就更谈不上 this 了。Java 嵌套类分为两种，静态嵌套类和非静态嵌套类，其中非静态嵌套类才是真正的内部类。enum参考 枚举类型]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java语法糖]]></title>
    <url>%2Fposts%2Fa0d19409%2F</url>
    <content type="text"><![CDATA[语法糖语法糖(Syntactic Sugar)，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法。这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。语法盐(Syntactic Salt)是指在计算机语言设计中，不容易产生不良代码的特性。可以为容易犯的语法错误加上的额外语法限制，比如类型检查。语法糖精也叫语法糖浆，指的是未能让编程更加方便的附加语法，一说是设计失败的语法糖。这个语法又麻烦又没用。语法海洛因，是指过于喜欢操作符重载，使得程序表面上紧凑。操作符重载就是把已经定义的、有一定功能的操作符进行重新定义，来完成更为细致具体的运算等功能。操作符重载可以将概括性的抽象操作符具体化，便于外部调用而无需知晓内部具体运算过程。我们所熟知的编程语言中几乎都有语法糖。很多人说 Java 是一个 “低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在 “Project Coin” 项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着 “高糖” 的方向发展。解语法糖语法糖的存在主要是方便开发人员使用。但其实，Java 虚拟机并不支持这些语法糖，这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。com.sun.tools.javac.main.JavaCompiler 的源码中，compile() 有一个步骤就是调用 desugar() ，这个方法就是负责解语法糖的。Java 中最常用的语法糖主要有 switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、foreach、try-with-resource、Lambda表达式等switch 支持 String 与枚举进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 switch 或者使用纯整数常量，但这也不是很差。参考 String分析泛型不同的编译器对于泛型的处理方式是不同的。通常情况下，一个编译器处理泛型有两种方式：Code specialization和 Code sharing。C++ 和 C#是使用 Code specialization 的处理机制，而 Java 使用的是 Code sharing 的处理机制。Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。也就是说，对于 Java 虚拟机来说，他根本不认识 Map&lt;String, String&gt; map这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。参考 Java泛型解析自动装箱与拆箱自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱。反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型 byte、short、char、int、long、float、double 和 boolean 对应的封装类为 Byte、Short、Character、Integer、Long、Float、Double、Boolean。1234public static void main(String[] args) &#123; int i = 10; Integer n = i; // 装箱：Integer n = Integer.valueOf(i); &#125;1234public static void main(String[] args) &#123; Integer i = 10; // Integer i = Integer.valueOf(10); int n = i; // 拆箱：int n = i.intValue(); &#125;方法变长参数可变参数 (variable arguments) 是在 Java 1.5 中引入的一个特性，它允许一个方法把任意数量的值作为参数。可变参数在被使用的时候：首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数。然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。枚举Java SE5 提供了一种新的类型-Java 的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。参考 枚举类型内部类内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。Outer.java 里面定义了一个内部类 Inner，一旦编译成功，就会生成两个完全不同的 .class 文件了，分别是 Outer.class 和 Outer$Inner.class。所以内部类的名字完全可以和它的外部类名字相同。匿名内部类也会被当作普通的类处理，只不过编译器生成它构造方法的时候，除了将外部类的引用传递了过来，还将基本数据类型的变量复制了一份过来，并把引用数据类型的变量引用也传递了过来。因此，基本数据类型的变量不能修改，不然就会跟外部的变量产生不一致，这样的话变量的传递也就变得毫无意义。final 关键字除了能让类不能被继承之外，对应到这种场景，就是让变量也不能被重新赋值。条件编译C、C++ 等许多语言提供了预处理的功能，并通过预处理来实现条件编译。Java 并没有提供类似的预处理功能，但是 Java 也可以实现条件编译。12345678private static final boolean DEBUG = true;public static void main(String[] args) &#123; if (DEBUG) &#123; System.out.println("block 1"); &#125; else &#123; System.out.println("block 2"); &#125;&#125;编译后即123public static void main(String[] args) &#123; System.out.println("block 1");&#125;断言语句断言在编译过后被转化成了语句所处类中的一个 static final boolean 字段，并在类初始化阶段借助静态语句块完成其初始化。在程序执行过程中，直接根据该字段判断断言是否开启，来决定是否执行断言检查。数值字面量支持的数字字面量表示十进制：默认的。八进制：整数之前加数字 0 来表示。十六进制：整数之前加“0x”或“0X”来表示。二进制：整数之前加“0b”或“0B”来表示。在数值字面量中使用下划线在 Java 7 中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。比如：1231_500_000 5_6.3_4 89_3___1下划线只能出现在数字中间，前后必须是数字。所以_100、0b_101是不合法的，无法通过编译。这样限制的动机就是可以降低实现的复杂度。有了这个限制，Java 编译器只需在扫描源代码的时候将所发现的数字中间的下划线直接删除就可以了。如果不添加这个限制，编译器需要进行语法分析才能做出判断。比如：_100,可能是一个整数字面量 100，也可能是一个变量名称。这就要求编译器的实现做出更复杂的改动。foreach对有实现 Iterable 接口的对象采用 foreach 语法糖的话，编译器会将这个 for 关键字转化为对目标的迭代器使用。如果要想使自己自定义的类可以采用foreach语法糖就必须实现Iterable接口。对于数组而言，其实就是转换为普通的遍历。对于实现 RandomAccess 接口的集合比如 ArrayList，应当使用最普通的 for 循环而不是 foreach 循环来遍历。实现 RandomAccess 接口的类实例，假如是随机访问的，使用普通 for 循环效率将高于使用 foreach 循环；反过来，如果是顺序访问的，则使用 Iterator 会效率更高。12345678910if (list instanceof RandomAccess) &#123; for (int i = 0; i &lt; list.size(); i++)&#123; &#125;&#125; else &#123; Iterator&lt;?&gt; iterator = list.iterable(); while (iterator.hasNext())&#123; iterator.next() &#125;&#125;try-with-resourcetry-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。编译之后会判断对象是否为 null，如果不是 null，则调用 close 函数进行资源回收。所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。不同的是 java.io.Closable 要求实现者保证 close 函数可以被重复调用。而 java.lang.AutoCloseable 的close 函数则不要求是幂等的。try-with-resources 声明在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。Lambda表达式TODO 待补充反编译javap 是 JDK 自带的反汇编器，可以查看 java 编译器为我们生成的字节码。通过它，我们可以对照源代码和字节码，从而了解很多编译器内部的工作。语法 javap [option] classjavap 命令用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。命令选项-help 输出 javap 的帮助信息。-l 输出行及局部变量表。-b 确保与 JDK 1.1 javap 的向后兼容性。-public 只显示 public 类及成员。-protected 只显示 protected 和 public 类及成员。-package 只显示包、protected 和 public 类及成员。这是缺省设置。-private 显示所有类和成员。-J[flag] 直接将 flag 传给运行时系统。-s 输出内部类型签名。-c 输出类中各方法的未解析的代码，即构成 Java 字节码的指令。-verbose 输出堆栈大小、各方法的 locals 及 args 数,以及class文件的编译版本-classpath[路径] 指定 javap 用来查找类的路径。如果设置了该选项，则它将覆盖缺省值或 CLASSPATH 环境变量。目录用冒号分隔。]]></content>
      <categories>
        <category>Java</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>语法糖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码方式杂记]]></title>
    <url>%2Fposts%2Fd6bee64%2F</url>
    <content type="text"><![CDATA[ASCII - Unicode - UTF-8ASCII因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。汉字使用的符号多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号，所以，中国制定了GB2312编码，用来把中文编进去。你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。UnicodeUnicode应运而生，Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。不过，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。这就导致 Unicode 有多种存储方式，即有许多种不同的二进制格式，可以用来表示 Unicode。如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。UTF-8互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器。很多网页的源码上会有类似 &lt;meta charset=&quot;UTF-8&quot; /&gt;的信息，表示该网页正是用的 UTF-8 编码。UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8 的编码规则很简单，只有二条：对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。1234567Unicode符号范围 | UTF-8编码方式(十六进制) | （二进制）--------------------+------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx例如：UTF-8、UTF-16、UTF-32区别UTF 意思是 Unicode 转换格式(Unicode Transform Format)， UTF-8、UTF-16、UTF-32 是为了在内存中存储字符而对 Unicode 字符编号进行编码。它们都是 Unicode 的实现方式，其中 UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。UTF-16(字符用 2 个字节或 4 个字节表示) 和 UTF-32(字符用 4 个字节表示)，不过在互联网上基本不用。UTF-16 使用 2 或 4 个字节进行存储。对于 Unicode 编号范围在 0~FFFF 之间的字符，统一用两个字节存储，无需字符转换，直接存储 Unicode 编号。对于 Unicode 字符编号在 10000-10FFFF 之间的字符，UTF16 用 4 个字节存储。UTF-32 用固定长度的字节存储字符编码，不管 Unicode 字符编号需要几个字节，全部都用 4 个字节存储，直接存储 Unicode 编号。无需经过字符编号向字符编码的转换步骤，提高效率，用空间换时间。GB2312、GBK、GB18030、GB13000之间的区别GB2312GB2312 或 GB2312-80 是中国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持 GB2312。，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。GB2312对任意一个图形字符都采用两个字节表示，并对所收汉字进行了“分区”处理，每区含有94个汉字／符号，分别对应第一字节和第二字节。这种表示方式也称为区位码。01-09区为特殊符号。16-55区为一级汉字，按拼音排序。56-87区为二级汉字，按部首／笔画排序。10-15区及88-94区则未有编码。GBKGBK即，为汉语拼音 Kuo Zhan（扩展）中“扩”字的声母。英文全称Chinese Internal Code Specification。GB2312中的全部汉字、非汉字符号。BIG5中的全部汉字。与ISO 10646相应的国家标准GB13000中的其它CJK汉字，以上合计20902个汉字。其它汉字、部首、符号，共计984个。GBK向下与GB2312 完全兼容，向上支持ISO 10646国际标准，在前者向后者过渡过程中起到的承上启下的作用。GBK 采用双字节表示，总体编码范围为8140-FEFE之间，首字节在81-FE之间，尾字节在40-FE之间，剔除XX7F一条线。GBK编码区分三部分：汉字区GBK/2：OXBOA1-F7FE，收录GB2312汉字6763个，按原序排列。GBK/3：OX8140-AOFE，收录CJK汉字6080个。GBK/4：OXAA40-FEAO，收录CJK汉字和增补的汉字8160个。图形符号区GBK/1：OXA1A1-A9FE，除GB2312的符号外，还增补了其它符号。GBK/5：OXA840-A9AO，扩除非汉字区。用户自定义区GBK区域中的空白区，用户可以自己定义字符。GBK 最初是由微软对 GB2312 的扩展，也就是CP936字码表 (Code Page 936)的扩展（原来的CP936和GB 2312-80一模一样），最初出现于Windows 95简体中文版中，由于Windows产品的流行和在大陆广泛被使用，中华人民共和国国家有关部门将其作为技术规范。注意 GBK 并非国家正式标准，只是国家技术监督局标准化司、电子工业部科技与质量监督司发布的“技术规范指导性文件”。虽然 GBK 收录了所有 Unicode 1.1 及 GB 13000.1-93 之中的汉字，但是编码方式与 Unicode 1.1 及 GB 13000.1-93 不同。仅仅是 GB2312 到 GB13000.1-93 之间的过渡方案。GBK 收录了 21886 个符号，它分为汉字区和图形符号区。汉字区包括 21003 个字符。GBK 作为对 GB2312 的扩展，在现在的 Windows 系统中仍然使用代码页 CP936 表示，但是同样的 936 的代码页跟一开始的 936 的代码页只支持 GB2312 编码不同，现在的 936 代码页支持 GBK 的编码，GBK 同时也向下兼容 GB2312 编码。GB18030GB18030，全称是中华人民共和国现时最新的内码字集，是GB18030-2000《信息技术信息交换用汉字编码字符集基本集的扩充》的修订版。GB18030 与 GB2312-1980 完全兼容，与 GBK 基本兼容，支持 GB13000 及 Unicode 的全部统一汉字，共收录汉字 70244 个。与 UTF-8 相同，采用多字节编码，每个字可以由1个、2个或4个字节组成。编码空间庞大，最多可定义161万个字符。支持中国国内少数民族的文字，不需要动用造字区。汉字收录范围包含繁体汉字以及日韩汉字GB18030 编码是一二四字节变长编码。单字节，其值从0到0x7F，与 ASCII 编码兼容。双字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x40到0xFE（不包括0x7F），与 GBK标准基本兼容。四字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节从0x81到0xFE，第四个字节从0x30到0x39。2000 年的 GB18030 取代了 GBK1.0 的正式国家标准。该标准收录了 27484 个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的 PC 平台必须支持 GB18030，对嵌入式产品暂不作要求。所以手机、MP3 一般只支持 GB2312。GB18030 在 Windows 中的代码页是 CP54936。GB13000GB13000 等同于国际标准的《通用多八位编码字符集 (UCS)》 ISO10646.1，就是等同于 Unicode 的标准，代码页等等的都使用 UTF 的一套标准。从 ASCII、GB2312、GBK 到 GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为 0。按照程序员的称呼，GB2312、GBK 到 GB18030 都属于双字节字符集 (DBCS)。URL编解码一般来说，网页URL只能使用英文、数字、还有一些特定的字符。根据网络标准RFC 1738做了硬性规定：只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!*’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。如果 URL中包括中文等字符，就必须经过编码后使用，否则传给服务器的 request URL 就会包含乱码，服务器无法正确识别。因为RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定，所以导致“URL编码”领域非常混乱。想要了解浏览器多种情况下的编码处理，可以参考阮一峰大神的关于URL编码。网址路径的编码，用的是utf-8编码。查询字符串的编码，用的是操作系统的默认编码。GET和POST方法的编码，用的是网页的编码。在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码。不同的操作系统、不同的浏览器、不同的网页字符集，将导致完全不同的编码结果，为了保证客户端只用一种编码方法向服务器发出请求，可以使用 Javascript 先对 URL 编码，然后再向服务器提交，不要给浏览器插手的机会。编码方法有三种：escape(url)、encodeURL(url)、encodeURLComponent(url)解码方法也有三种: unescape(url)、decodeURL(url)、decodeURLComponent(url)方法规则特点escape、unescape除了ASCII字母、数字、标点符号”@ * _ + - . /“以外，对其他所有字符进行编码它的作用是返回一个字符的 Unicode 编码值。现在已经不提倡使用这种方法了，它不能直接运用与 URL 编码。encodeURI（编码）decodeURI（解码）除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码encodeURI() 是 Javascript 中真正用来对 URL 编码的函数，它着眼于对整个URL 进行编码encodeURIComponent（编码）decodeURIComponent解码）在encodeURI()中不被编码的符号”; / ? : @ &amp; = + $ , #”，在encodeURIComponent()中统统会被编码与 encodeURI() 的区别是，它用于对 URL 的组成部分进行个别编码，而不用于对整个URL进行编码。12345678&gt; var url = "https://www.zhihu.com/question/342936488/answer/804030108";undefined&gt; escape(url)"https%3A//www.zhihu.com/question/342936488/answer/804030108"&gt; encodeURI(url)"https://www.zhihu.com/question/342936488/answer/804030108"&gt; encodeURIComponent(url)"https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F342936488%2Fanswer%2F804030108"Big Endian 和 Little EndianLittle-endian：将低序字节存储在起始地址（低位编址）Big-endian：将高序字节存储在起始地址（高位编址）例如，如果我们将 0x1234abcd 写入到以 0x0000 开始的内存中，则结果为：addressbig-endianlittle-endian0x00000x120xcd0x00010x340xab0x00020xab0x340x00030xcd0x12对于字节序列的存储格式，目前有两大阵营，那就是 Motorola 的 PowerPC 系列 CPU 和 Intel 的 x86 系列 CPU。PowerPC 系列采用 big endian 方式存储数据，而 x86 系列则采用 little endian 方式存储数据。所有网络协议也都是采用 big endian 的方式来传输数据的。所以有时我们也会把 big endian 方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。目前应该 little endian 是主流，因为在数据类型转换的时候（尤其是指针转换）不用考虑地址问题。Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。如果一个文本文件的头两个字节是FE FF，就表示该文件采用 big endian 方式；如果头两个字节是FF FE，就表示该文件采用 little endian 方式。如何解决乱码问题乱码本质上都是由于字符串原本的编码格式与读取时解析用的编码格式不一致导致的。网页乱码问题服务器返回的响应头 Content-Type 指明字符编码。网页内使用 meta http-equiv 标签指定字符编码。网页文件本身存储时使用的字符编码和网页声明的字符编码一致。Java代码乱码问题使用 getBytes() 方法指定编码。使用字节流时指定编码。使用 new String() 时指定编码。使用 HttpClient post请求时指定编码。1234567//请求实体HttpEntity reqEntity = new ByteArrayEntity(reqStr.getBytes("UTF-8"));httpPost.setEntity(reqEntity);//请求实体StringEntity reqEntity = new StringEntity(reqStr, Charset.forName("UTF-8"));httpPost.setEntity(reqEntity);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java中的基本类型]]></title>
    <url>%2Fposts%2F3f6a1294%2F</url>
    <content type="text"><![CDATA[分类Java 中有 8 种基本数据类型，分为三大类。字符型：char布尔型：boolean数值型：整型：byte、short、int、long浮点型：float、doubleString 不是基本数据类型，是引用类型。整型中byte、short、int、long的取值范围Java 中的整型主要包含 byte、short、int 和 long 这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。byte：byte 用 1 个字节来存储，范围为 -128(-2^7) 到 127(2^7-1)，在变量初始化的时候，byte类型的默认值为 0。short：short 用 2 个字节存储，范围为 -32768 (-2^15) 到 32767 (2^15-1)，在变量初始化的时候，short类型的默认值为0，一般情况下，因为 Java 本身转型的原因，可以直接写为 0。int：int 用 4 个字节存储，范围为 -2147483648 (-2^31) 到 2147483647 (2^31-1)，在变量初始化的时候，int类型的默认值为 0。long：long 用 8 个字节存储，范围为 -9223372036854775808 (-2^63) 到 9223372036854775807 (2^63-1)，在变量初始化的时候，long 类型的默认值为 0L 或 0l，也可直接写为 0。整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。溢出的时候并不会抛异常，也没有任何提示。所以，在程序中，使用同类型的数据进行运算的时候，一定要注意数据溢出的问题。什么是浮点型在计算机科学中，浮点是一种对于实数的近似值数值表现法，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（floating-point number）。计算机使用浮点数运算的主因，在于电脑使用二进位制的运算。例如：4÷2=2，4的二进制表示为100、2的二进制表示为010，在二进制中，相当于退一位数(100 -&gt; 010)。1 的二进制是 01，1.0/2=0.5，那么，0.5 的二进制表示应该为(0.1)，以此类推，0.25的二进制表示为0.01，所以，并不是说所有的十进制小数都能准确的用二进制表示出来，如 0.1，因此只能使用近似值的方式表达。也就是说，十进制的小数在计算机中是由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到的，这种表示方法类似于基数为 10 的科学计数法。一个浮点数a由两个数m和e来表示：a = m × be。在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd…ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1）。如果m的第一位是非0整数，m称作正规化的。有一些描述使用一个单独的符号位（s 代表+或者-）来表示正负，这样m必须是正的。e是指数。位(bit)是衡量浮点数所需存储空间的单位，通常为32位或64位，分别被叫作单精度和双精度。单精度浮点数在计算机存储器中占用 4 个字节(32 bits)，利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。比起单精度浮点数，双精度浮点数(double)使用 8 个字节(64 bits) 来存储一个浮点数。注意：由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。建议使用BigDecimal或者Long（单位为分）来表示金额。]]></content>
  </entry>
  <entry>
    <title><![CDATA[为什么Java中byte类型的取值范围为-128~127?]]></title>
    <url>%2Fposts%2Fca021682%2F</url>
    <content type="text"><![CDATA[作者：探路的淮–Ontheway原文链接：https://blog.csdn.net/qq_23418393/article/details/57421688在学习 Java 基础语法的时候，初学者的我们可能都会有这么一个疑问为什么 byte 类型的取值范围为什么是 -128 ~ 127 而不是 -127 ~ 127。01111111 表示最大的数值：127，因为第一位是符号位，所以 11111111 应该是最小的数值：-127，不是这样才对？在解释这个问题之前我们需要了解几个概念：机器数、真值、原码、反码、补码机器数、真值、原码、反码、补码机器数一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为 0，负数为 1。比如：十进制中的数 +3 ，计算机字长为 8 位，转换成二进制就是 00000011。如果是 -3 ，就是 10000011 。那么，这里的 00000011 和 10000011 就是机器数。真值因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位 1代表负，其真正数值是 -3 而不是形式值 131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。​ 例：0000 0001 的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1原码原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:​ [+1]原 = 0000 0001​ [-1]原 = 1000 0001第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]即[-127 , 127]。原码是人脑最容易理解和计算的表示方式.反码反码的表示方法是：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。​ [+1] = [00000001]原 = [00000001]反​ [-1] = [10000001]原 = [11111110]反可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算。补码补码的表示方法是:正数的补码就是其本身。负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 +1。(即在反码的基础上 +1)[+1] = [00000001]原 = [00000001]反 = [00000001]补[-1] = [10000001]原 = [11111110]反 = [11111111]补对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。为什么 byte 类型的取值范围为 -128~127？为何计算机内部不使用原码表示一个数？现在我们知道了计算机可以有三种编码方式表示一个数，对于正数因为三种编码方式的结果都相同： [+1] = [00000001]原 = [00000001]反 = [00000001]补但是对于负数: [-1] = [10000001]原 = [11111110]反 = [11111111]补可见原码，反码和补码是完全不同的。 既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即: 1-1 = 1 + (-1) = 0 ，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。于是人们开始探索 将符号位参与运算，并且只保留加法的方法。首先来看原码： 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。反码的诞生为了解决原码做减法的问题，出现了反码： 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0发现用反码计算减法，结果的真值部分是正确的。而唯一的问题其实就出现在”0”这个特殊的数值上。虽然人们理解上 +0 和 -0 是一样的，但是 0 带符号是没有任何意义的。而且会有 [0000 0000]原 和 [1000 0000]原 两个编码表示 0。补码的诞生补码的出现，解决了 0 的符号以及两个编码的问题： 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 =[0000 0001]反 + [1111 1110]反= [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原这样0用 [0000 0000] 表示，而以前出现问题的 -0 则不存在了。而且可以用 [1000 0000] 表示-128： (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补 就是 -128。但是注意因为实际上是使用以前的 -0 的补码来表示 -128, 所以 -128 并没有原码和反码表示。(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)，使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为 -127+127， 而使用补码表示的范围为 -128127。因为机器使用补码，所以对于编程中常用到的 32 位 int 类型, 可以表示范围是：-2^31~2^31-1 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。扩展计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?可以参考：https://www.cnblogs.com/zhengfengyun/p/5090601.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java泛型解析]]></title>
    <url>%2Fposts%2F4127871b%2F</url>
    <content type="text"><![CDATA[泛型是什么泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。泛型的英文是 generics，generic 的意思是通用,而翻译成中文，泛应该意为广泛，型是类型。所以泛型就是能广泛适用的类型。但泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。Object 是所有类的根类，任何类的对象都可以设置给该 Object 引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。1234567891011public class Cache&lt;T&gt; &#123; T value; public Object getValue() &#123; return value; &#125; public void setValue(T value) &#123; this.value = value; &#125;&#125;泛型的定义和使用泛型类如果一个类被 &lt;T&gt;的形式定义，那么它就被称为是泛型类。如下：1234// 尖括号 &lt;&gt;中的 T 被称作是类型参数，用于指代任何类型。其中T只是一种习惯写法。public class Test&lt;T&gt; &#123; T field1;&#125;当然，泛型类不至接受一个类型参数，它还可以这样接受多个类型参数。123456789101112public class MultiType&lt;E,T&gt; &#123; E value1; T value2; public E getValue1()&#123; return value1; &#125; public T getValue2()&#123; return value2; &#125;&#125;出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如：E ——代表 Element (在集合中使用，因为集合中存放的是元素)，或者 Exception 异常的意思T ——代表 Type（一般的任何 Java 类）K——代表 Key（键）V ——代表 Value（值），通常与 K 一起配合使用N——代表 Number（数值类型）？——表示不确定的java类型（无限制通配符类型）S、U、V——代表 2nd、3rd、4th Subtype泛型方法泛型方法与泛型类稍有不同的地方是，类型参数也就是尖括号那一部分是写在返回值前面的。&lt;T&gt;中的 T 被称为类型参数，而方法中的 T 被称为参数化类型，它不是运行时真正的参数。12345678public class Test &#123; public &lt;T&gt; void testMethod(T t)&#123; &#125; public &lt;T&gt; T testMethodWithReturn(T t)&#123; return t; &#125;&#125;泛型方法始终以自己定义的类型参数为准。即泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的。例如：泛型类的实际类型参数是 String，而传递给泛型方法的类型参数是 Integer，两者不想干。但是，为了避免混淆，如果在一个泛型类中存在泛型方法，那么两者的类型参数最好不要同名。泛型接口泛型接口和泛型类类似。12public interface Iterable&lt;T&gt; &#123;&#125;限定通配符和非限定通配符通配符的出现是为了指定泛型中的类型范围。通配符有 3 种形式。&lt;?&gt;被称作非限定通配符。&lt;? extends T&gt;被称作有上界通配符。&lt;? super T&gt;被称作有下界通配符。非限定通配符经常与容器类配合使用，它其中的 ? 其实代表的是未知类型，所以涉及到 ? 时的操作，一定与具体类型无关，类型是未知的。所以，你只能调用使用非限定通配符类中与类型无关的方法。例如：1234public void testWildCards(Collection&lt;?&gt; collection)&#123; // 只能调用 Collection 中与类型无关的方法。 // 当你调用 add() 方法时，编译会失败。&#125;限定通配符包括两种：&lt;？extends T&gt; 表示类型的上界，即类型必须为T类型或者T子类。&lt;？super T&gt; 表示类型的下界，即类型必须为T类型或者T的父类。类型擦除泛型是 Java 1.5 版本才引进的概念，在这之前是没有泛型的概念的，但显然，泛型代码能够很好地和之前版本的代码很好地兼容。这是因为，泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。通俗地讲，泛型类和普通类在 java 虚拟机内是没有什么特别的地方。1234List&lt;String&gt; strList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(); System.out.println(strList.getClass() == intList.getClass()); // true在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 &lt;T&gt;则会被转译成普通的 Object 类型，如果指定了上限如 &lt;T extends String&gt;则类型参数就被替换成类型上限。原始类型 List 和带参数类型之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查。你可以把任何带参数的类型传递给原始类型 List，但却不能把 List 传递给接受 List 的方法，因为会产生编译错误。类型擦除，它会抹掉很多继承相关的特性，这是它带来的局限性。12345public static void main(String[] args) &#123; List&lt;Integer&gt; integers = new ArrayList&lt;&gt; (); integers.add(9); integers.add("freya"); // 由于泛型的限制，编译不通过&#125;不过基于对类型擦除的了解，利用反射，我们可以绕过这个限制。12345678910111213public static void main(String[] args) &#123; List&lt;Integer&gt; integers = new ArrayList&lt;&gt; (); integers.add(9); // integers.add("freya"); try &#123; Method method = integers.getClass().getMethod("add", Object.class); method.invoke(integers, "freya"); method.invoke(integers, 10.11f); &#125; catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; System.out.println(integers); // [9, freya, 10.11]&#125;泛型类型擦除带来的局限：不能是基本类型；因为实际类型是 Object，Object 类型无法持有基本类型。不能获取带泛型类型的 Class；因为编译后它们全部都是Xxx&lt;Object&gt;。不能判断带泛型类型的类型，并不存在 Xxx&lt;String&gt;.class，而是只有唯一的 Xxx.class。不能实例化T类型，例如：new T()。泛型方法要防止重复定义方法，例如：public boolean equals(T obj)；编译器会阻止一个实际上会变成覆写的泛型方法定义。实例化 T 类型与泛型继承实例化 T 类型123456789public class Pair&lt;T&gt; &#123; private T first; private T last; public Pair() &#123; // Compile error: first = new T(); last = new T(); &#125;&#125;上述代码无法通过编译，因为构造方法的两行语句：12first = new T();last = new T();擦拭后实际上变成了：12first = new Object();last = new Object();这样一来，创建 new Pair&lt;String&gt;() 和创建 new Pair&lt;Integer&gt;() 就全部成了Object，显然编译器要阻止这种类型不对的代码。要实例化T类型，我们必须借助额外的Class参数：12345678public class Pair&lt;T&gt; &#123; private T first; private T last; public Pair(Class&lt;T&gt; clazz) &#123; first = clazz.newInstance(); last = clazz.newInstance(); &#125;&#125;上述代码借助 Class&lt;T&gt; 参数并通过反射来实例化T类型，使用的时候，也必须传入 Class&lt;T&gt;。例如：1Pair&lt;String&gt; pair = new Pair&lt;&gt;(String.class);因为传入了 Class&lt;String&gt; 的实例，所以我们借助String.class 就可以实例化 String 类型。泛型继承一个类可以继承自一个泛型类。例如：父类的类型是 Pair&lt;Integer&gt; ，子类的类型是 IntPair，可以这么继承：12public class IntPair extends Pair&lt;Integer&gt; &#123;&#125;使用的时候，因为子类 IntPair 并没有泛型类型，所以，正常使用即可：1IntPair ip = new IntPair(1, 2);前面讲了，我们无法获取 Pair&lt;T&gt; 的 T 类型，即给定一个变量Pair&lt;Integer&gt; p ，无法从 p 中获取到 Integer类型。但是，在父类是泛型类型的情况下，编译器就必须把类型 T（对IntPair来说，也就是Integer 类型）保存到子类的 class 文件中，不然编译器就不知道 IntPair 只能存取 Integer 这种类型。在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：IntPair可以获取到父类的泛型类型 Integer 。获取父类的泛型类型代码比较复杂：1234567891011121314151617181920212223242526272829303132333435public class Main &#123; public static void main(String[] args) &#123; Class&lt;IntPair&gt; clazz = IntPair.class; Type t = clazz.getGenericSuperclass(); if (t instanceof ParameterizedType) &#123; ParameterizedType pt = (ParameterizedType) t; Type[] types = pt.getActualTypeArguments(); // 可能有多个泛型类型 Type firstType = types[0]; // 取第一个泛型类型 Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType; System.out.println(typeClass); // Integer &#125; &#125;&#125;class Pair&lt;T&gt; &#123; private T first; private T last; public Pair(T first, T last) &#123; this.first = first; this.last = last; &#125; public T getFirst() &#123; return first; &#125; public T getLast() &#123; return last; &#125;&#125;class IntPair extends Pair&lt;Integer&gt; &#123; public IntPair(Integer first, Integer last) &#123; super(first, last); &#125;&#125;注意泛型类或者泛型方法中，不接受 8 种基本数据类型，需要使用它们对应的包装类。Java 不能创建具体类型的泛型数组。这是因为所有的类型信息都被擦除，程序也无法分辨一个数组中的元素类型具体是哪种类型。非限定通配符涉及的操作都基本上与类型无关，因此 JVM 不需要针对它对类型作判断，只提供了数组中的元素因为通配符原因，它只能读，不能写。如果可以使用泛型的地方，尽量使用泛型。因为它抽离了数据类型与代码逻辑，本意是提高程序代码的简洁性和可读性，并提供可能的编译时类型转换安全检测功能。部分反射API是泛型，例如：Class&lt;T&gt;，Constructor&lt;T&gt;；可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；可以通过Array.newInstance(Class&lt;T&gt;, int)创建T[]数组，需要强制转型；同时使用泛型和可变参数时需要特别小心。]]></content>
      <categories>
        <category>Java</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-念念不忘]]></title>
    <url>%2Fposts%2Fe5f2c01c%2F</url>
    <content type="text"><![CDATA[人生除了死亡，其他都是擦伤。你是在拜佛，还是在拜自己的欲望？正义的反面不是邪恶，正义的反面是别的正义。不知道发⽣了什么，是这个世界；不知道在做什么，是⾃⼰。我的任性是理所当然，别人的任性是不可原谅。如果一切祈祷都为了满足私欲，那所有的美好希望都是一种对别人的诅咒。让花谢的是⻛⾬/让花开的也是⻛⾬/但没了⻛⾬/花不会开也不会落并不是所有⼈都能轻盈地度过这⼀⽣，有些⼈，光是活着就已经竭尽全⼒。我们终其⼀⽣都想成为那个喜欢的⼈，殊不知，⼈⼈都有光彩和阴影，只是有些⼈已经学会了欣赏⾃⼰，并且接纳了阴影。没有⼀朵花，从⼀开始就是花。世界再⼤，不过是⼈与⼈之间的距离。所谓孩⼦，⼤多是在⽗⺟看不⻅的地⽅成⻓起来的。当⼥⼉捡起落叶/我看到⽣命与季节/交汇的点——⼥⼉与秋天》理正道如果房⼦没有窗户，⻔会望着谁。——《⻛适应着这个季节》晚⼭我的身体在寂静中安置⾃⼰，时刻准备着成为灵魂的故乡——《回乡偶书》⾼寒纸质信回信要等⼀个⽉， 电⼦邮件回信等⼀周， LINE回复⼀⼩时。 不⽤等待的⼈⽣真忙碌啊。你认为“谢谢”的反义词是什么？众⽣喧哗归⼀处，万物静默为⼀听。形形⾊⾊的⼈⽣，五味杂陈的故事，百转千回，令⼈回味。不必太纠结于当下，也不必太忧虑未来，当你经历过一些事情的时候，眼前的风景已经和从前不一样了。不解释就弄不懂的事，就意味着怎样解释也弄不懂。——《1Q84》总有一天，你会离开这个世界。所以这辈子要活得更加精彩。我能承受任何痛苦，只要这种痛苦有意义。遇到真正喜欢的人，你才发现之前定的标准都是空话。天裂了，去缝起。欲望本身没有对错善恶，只有当与规则碰撞，人对欲望的态度才显示出丑陋或者善良的一面。要有耐性，不要操之过急。越是心平气和，越有成绩。时时刻刻要承认自己是笨伯，不怕做笨功夫，那就不会期待太切，稍不进步就慌乱了。——傅雷北美地区有一种蝉叫做“十七年蝉”，这种蝉从幼卵变成若虫以后将钻入地下蛰伏，在阴暗的泥土与恶劣的环境中度过17年的时间，在隐忍与煎熬中经历漫长的成长历程。在这17年当中，它们早就被人遗忘，只与孤独相伴，每次蜕变的痛苦只有自己最为清楚。目的虽有，却无路可循；我们称之为路的，无非是踌躇。——卡夫卡 《误入世界》我有一壶酒，可以慰风尘。尽倾江海里，赠饮天下人。花全开了，开得到处都是，后来就很孤单。——顾城《麦田》诚觉世事尽可原谅，但不知去原谅谁。——木心凡畅言雅俗共赏者，结果都落得俗不可耐。——木心迷失的人迷失了，相逢的人会再相逢。你问人问题，她若答非所问，便已是答了，毋需再问。——木心怕什么真理无穷，进一寸有一寸的欢喜。——胡适当上帝未揭开人类的未来图景之前，人类最伟大的智慧存在于两个词中，“等待”和“希望”。白天出门的时候当个认真工作正经严肃的大人，等晚上回家的时候喝一瓶最喜欢的牛奶再打开最喜欢的动画，偷偷变回小孩子。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于减肥]]></title>
    <url>%2Fposts%2Fc8dcfc3f%2F</url>
    <content type="text"><![CDATA[作者: 三木水原文: 求求珍珠奶茶放过我吧减肥和毅力，没有半毛钱关系。很多人在减肥中，遇到的最大的障碍就是：管不住自己的嘴。总是忍不住要多吃，而且，一吃就停不下来。就像我的一位女性来访者，30+，极度自律。但是，在减肥这件事上，她却遭遇了滑铁卢。她最大的困扰就是：吃。像我一样，吃之前很理性，吃的时候管不住，事后很懊恼，伴随极度的焦虑和自责。有的时候，她还会把这份焦虑转移到伴侣身上，对伴侣发脾气。当然，这只不过是对自己无力的这部分的一种向外投射。她说，她用极大的毅力来控制自己不要多吃。为了不吃晚饭，晚餐时，她是不上桌的：家人吃晚饭，她就在旁边找个地方啃个苹果。即便这样，“吃”和“不吃”就好像在打游击战一样，在每一个毅力稍稍缺席的地方，“吃”的欲望就会铺天盖地地袭来。吃完之后，又陷入了懊恼、自责和极度的焦虑当中。你也许就要问了，不靠毅力控制，那靠什么？在提出这个问题的时候，你想的还是控制。在回答这个问题之前，我们不妨换个角度，我们为什么对“吃”如此痴迷？那是因为，“吃”给我们带来了很大的快感。我的很多痴迷于“吃”的朋友，曾这么跟我说：在吃的时候，让他们感觉到了无比的满足，就好像在天堂，如果不让他们“吃吃吃”一段时间，他们觉得，人生的意义都没有了。“人生的意义”“生活的乐趣”“活着的快感”都没有了，这是多么严重的问题。在这样的情况下，你可曾看到，控制“吃”的背后，我们在尝试控制什么。控制“吃”，就是在和自己的人性做对，而和人性做对，这几乎是一场必输的游戏。这就是为什么我们这么努力控制，却毫无进展的原因。因为，“吃”，这是一件我们控制不了的事情。一些方法想要减肥，不要节食，先满足吃欲。(少食多餐)别着急，慢慢吃。每一个食物，都是巨大的恩赐，值得好好品味，不可辜负。每天或者每周安排一顿饭，放肆的吃。总有一个时空，我可以“为所欲为”。一些思考这让我想起了《人体的故事：进化、健康与疾病》里面的一个观点：如果他们开始节食或增加运动量，这就意味着他们摄入的热量少于消耗的，那么就会不可避免地变得又饿又累，而这又会激活他们体内的原始冲动：增加食量、减少运动。饥饿和嗜睡是古代的适应机制。失配性疾病，即由于我们旧石器时代的身体不能或不足以适应某些现代行为和条件而导致的疾病。(没有说肥胖是疾病，这是书中解释一些现代社会才会遇到的疾病时提出的名词。)纵观整个人类历史，人类就好像突然从石器时代进入现代。因为我们人类在石器时代停留的时间为99%，现代才1%不到。人类的进化是缓慢的，已经跟不上现代社会的变化。生活越来越好，这点无可否认，可是身体上的那些机能还没有转变过来。所以说，减肥这件事本身就是与人性在作对(还得和社会的审美做抗争)，基本没有胜利的可能。换回的是无尽的纠结、自责、懊恼……这有点像电脑在国内刚起步那几年，家长们怕你沉迷，防这个，防那个。可是现在呢，电脑根本不是什么稀奇物，那些 00 后赶上了好时代，刚出生就接触电脑、智能机、平板…… 而石器时代食物匮乏，能吃到东西就很不错了，所以为了活下去，那种对甜食、脂肪的渴望很强烈，或者说有一种瘾。现代社会能吃饱也是近几十年的事情(感谢袁老)，食物极大丰富对体内的原始冲动来说，就像一夜暴富，开始肆意挥霍。所以我们需要先满足体内的原始冲动，让它慢慢减弱那种食物匮乏的不安全感，然后驯服它，不过这一切都需要时间和耐心，不能一蹴而就，蛮干换回的只能是纠结、自责、懊恼……]]></content>
      <categories>
        <category>减肥</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java异常解析]]></title>
    <url>%2Fposts%2Fd868df11%2F</url>
    <content type="text"><![CDATA[Java 将所有的错误封装为一个对象，其根本父类为 Throwable， Throwable有两个子类：Error 和 Exception。Trowable 类中常用方法如下：12345678// 返回异常发生时的详细信息public string getMessage(); // 返回异常发生时的简要描述public string toString(); // 返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同public string getLocalizedMessage(); // 在控制台上打印Throwable对象封装的异常信息public void printStackTrace();ErrorAn Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions.Error 是 Throwable 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。虽然 ThreadDeath 错误是一个“正规”的条件，但它也是 Error 的子类，因为大多数应用程序都不应该试图捕获它。在执行该方法期间，无需在其 throws 子句中声明可能抛出但是未能捕获的 Error 的任何子类，因为这些错误可能是再也不会发生的异常条件。调用 stop() 方法时会抛出 java.lang.ThreadDeath 错误，但在通常的情况下，此错误不需要显式地捕捉。不过方法 stop() 已经被作废，因为如果强制让线程停止则有可能使一些清理性的工作得不到完成。另外一个情况就是对锁定的对象进行了“解锁”，导致数据得不到同步的处理，出现数据不一致的问题。经典 Error 如下：12OutOfMemoryErrorStackOverflowErrorVirtulMachineError有四种不同类型的 VirtulMachineError：OutOfMemoryErrorStackOverflowErrorInternalErrorUnknownErrorOutOfMemoryErrorOutOfMemoryError 有八种不同类型：java.lang.OutOfMemoryError：Java 堆空间java.lang.OutOfMemoryError：GC 开销超过限制java.lang.OutOfMemoryError：请求的数组大小超过虚拟机限制java.lang.OutOfMemoryError：PermGen 空间java.lang.OutOfMemoryError：Metaspacejava.lang.OutOfMemoryError：无法新建本机线程java.lang.OutOfMemoryError：杀死进程或子进程java.lang.OutOfMemoryError：发生 stack_trace_with_native_method触发每种错误的原因各有不同。类似地，根据 OutOfMemoryError 不同的问题类型，对应的解决方案也不一样。StackOverflowError线程的堆栈存储了执行的方法、基本数据类型值、局部变量、对象指针和返回值信息，所有这些都会消耗内存。当栈深度超过虚拟机分配给线程的栈大小时，那么就会抛出 java.lang.StackOverflowError。通常由于执行程序中有一个错误，在线程重复递归调用同一个函数时会发生这个问题。InternalErrorJVM 抛出 java.lang.InternalError 有三个原因，虚拟机软件出现错误、系统软件底层出现错误或者硬件出现故障。一般极少会遇到 InternalError 这样的错误。要了解哪些特定情况可能导致 InternalError，请在 Oracle 的 Java Bug 数据库 中搜索 InternalError。UnknownError当发生异常或错误，但 Java 虚拟机无法报告确切的异常或错误时，就会抛出 java.lang.UnknownError。UnknownError 很少出现。事实上，在 Oracle Java Bug 数据库 中搜索 UnknownError 时，只找到了2个 Bug。Bug ID: JDK-4023606 AppletViewer generates java.lang.UnknownError when loading inner class.Bug ID: JDK-4054295 UnknownError while loading class with super_class equal to zeroAWTErrorAWT(Abstract Window Toolkit)，中文译为抽象窗口工具包，是 Java 提供的用来建立和设置 Java 的图形用户界面的基本工具。AWTError一般也很少用到。事实上，在 Oracle Java Bug 数据库 中搜索 AWTError 时，只找到了8个 Bug。ExceptionException 类及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。Exception 分为未检查异常(RuntimeException)和已检查异常(非RuntimeException)。 未检查异常是因为程序员没有进行必需要的检查，因为疏忽和错误而引起的错误。几个经典的 RunTimeException 如下：123NullPointerExceptionArithmaticExceptionArrayIndexoutofBoundsException可查异常(编译器要求必须处置的异常)：正确的程序在运行中，很容易出现的、情理可容的异常状况。除了 Exception 中的 RuntimeException 及其子类以外，其他的 Exception 类及其子类(例如：IOException和ClassNotFoundException)都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。RuntimeException表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。RuntimeException运行时异常都是 RuntimeException 类及其子类异常，如 NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是 Java 编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用 try-catch 语句捕获它，也没有用 throws 子句声明抛出它，也会编译通过。非RuntimeException非运行时异常(也称受检查的异常)是 RuntimeException 以外的异常，类型上都属于 Exception 类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException、SQLException 等以及用户自定义的 Exception 异常，一般情况下不自定义检查异常。异常处理的机制抛出异常当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。任何 Java 代码都可以抛出异常，如：自己编写的代码、来自 Java 开发环境包中代码，或者 Java 运行时系统。无论是谁，都可以通过 Java 的 throw 语句抛出异常。从方法中抛出的任何异常都必须使用throws子句。捕获异常在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。捕捉异常通过try-catch语句或者try-catch-finally语句实现。异常的处理123throws //直接往上一层抛出异常；try&#123;&#125;catch // 捕获异常finally // 扫尾工作throw 和 throws 两个关键字有什么不同throw 是用来抛出任意异常的，你可以抛出任意 Throwable，包括自定义的异常类对象；throws 总是出现在一个函数头中，用来标明该成员函数可能抛出的各种异常。如果方法抛出了异常，那么调用这个方法的时候就需要处理这个异常。try-catch-finally-return执行顺序不管是否有异常产生，finally 块中代码都会执行；当 try 和 catch 中有 return 语句时，finally 块仍然会执行；finally 是在 return 后面的表达式运算后执行的，所以函数返回值是在 finally 执行前确定的。无论 finally 中的代码怎么样，返回的值都不会改变，仍然是之前 return 语句中保存的值；finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 按正常顺序执行。try &#123;&#125; catch() &#123;&#125; finally &#123; return;&#125;/** * 1. 程序执行 try 块中 return 之前(包括 return 语句中的表达式运算)代码； * 2. 再执行 finally 块，最后执行 try 中 return; * 3. finally 块后面的 return 语句不再执行。*/try &#123; return; &#125; catch ()&#123;&#125; finally&#123;&#125; return; /** * 1.程序先执行 try，如果遇到异常执行 catch 块， * 有异常则执行 catch 中 return 之前(包括 return 语句中的表达式运算)代码，再执行 finally 语句中全部代码，最后执行 catch 块中 return，finally 块后面的 return 语句不再执行。 * 无异常执行完 try 再 finally 再执行最后的 return 语句。 */try &#123; &#125; catch() &#123; return;&#125; finally &#123;&#125; return; /** * 程序执行 try 块中 return 之前(包括 return 语句中的表达式运算)代码； * 再执行 finally 块，因为 finally 块中有 return 所以提前退出。 */try &#123; return; &#125; catch() &#123;&#125; finally &#123; return;&#125; /** * 程序执行catch块中return之前（包括return语句中的表达式运算）代码； * 再执行finally块，因为finally块中有return所以提前退出。 */try &#123;&#125; catch() &#123; return;&#125;finally &#123; return;&#125;异常链在设计模式中有一个叫做责任链模式，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：异常链。我们有两种方式处理异常，一是 throws 抛出交给上级处理，二是 try…catch 做具体处理。try…catch 的 catch 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 throws 继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。​ 通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。在异常链的使用中，throw 抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在 Throwable 及其子类中的构造器中都可以接受一个 Throwable cause 参数，该参数保存了原有的异常信息，通过 getCause() 就可以获取该原始异常信息。1234567public void test() throws XxxException&#123; try &#123; //do something:可能抛出异常信息的代码块 &#125; catch (Exception e) &#123; throw new XxxException(e); &#125;&#125;注意精确原则尽可能的减小 try 块——try 块不要包含太多的信息，仅包所需。catch 语句应当尽量指定具体的异常类型，不要一个Exception试图处理所有可能出现的异常不要做渣男，负点责既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃。在异常处理模块中提供适量的错误原因信息，使其后续易于理解和阅读。保证所有资源都被正确释放。 ——充分运用finally关键词。或者使用 Java 提供的语法糖 try() catch两不要不要在 finally 块中处理返回值。不要在构造函数中抛出异常。异常使用指南应该在下列情况下使用异常(From 《Think in java》)。在恰当的级别处理问题(在知道该如何处理异常的情况下才捕获异常)。解决问题并且重新调用产生异常的方法。进行少许修补，然后绕过异常发生的地方继续执行。用别的数据进行计算，以代替方法预计会返回的值。把当前运行环境下能做的事情尽量做完。然后把相同(不同)的异常重新抛到更高层。终止程序。进行简化。让类库和程序更加安全。(这既是在为调试做短期投资，也是在为程序的健壮做长期投资)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java的一些基本概念]]></title>
    <url>%2Fposts%2Fd7d0bf4a%2F</url>
    <content type="text"><![CDATA[面向对象与面向过程什么是面向过程？自顶而下的编程模式。占用资源相对低，速度相对快。把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。最典型的用法就是实现一个简单的算法，比如实现冒泡排序。什么是面向对象？将事务高度抽象化的编程模式。占用资源相对高，速度相对慢。将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。面向对象三大特征封装(Encapsulation)所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。继承(Inheritance)继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；多态(Polymorphism)所谓多态就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。重载 &amp; 重写重载简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。重写重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。区别重载是一个编译期概念，重写是一个运行期间概念。重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）构造函数构造函数，是一种特殊的方法。 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。构造器的函数名称必须和它所属的类的名称相同。 它承担着初始化对象数据成员的任务。如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数一般会把成员变量的值初始化为默认值，如int -&gt; 0，Integer -&gt; null。变量Java中共有三种变量，分别是类变量、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。1234567891011121314151617181920212223/** * @author Hollis */public class Variables &#123; /** * 类变量 */ private static int a; /** * 成员变量 */ private int b; /** * 局部变量 * @param c */ public void test(int c)&#123; int d; &#125;&#125;上面定义的三个变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。作用域public表明该成员变量或者方法是对所有类或者对象都是可见的，所有类或者对象都可以直接访问。protected表明成员变量或者方法对类自身以及同在一个包中的其他类可见，其他包下的类不可访问，除非是他的子类。default表明该成员变量或者方法只有自己和其位于同一个包的内可见，其他包内的类不能访问，即便是它的子类。private表明该成员变量或者方法是私有的，只有当前类对其具有访问权限，除此之外其他类或者对象都没有访问权限，子类也没有访问权限。五大基本原则5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”单一职责原则（Single-Resposibility Principle）其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。开放封闭原则（Open-Closed principle）其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。开放封闭原则主要体现在两个方面：对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。里式替换原则（Liskov-Substitution Principle）其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 里式替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了里式替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 里式替换原则是关于继承机制的设计原则，违反了里式替换原则就必然导致违反开放封闭原则。 里式替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。依赖倒置原则（Dependecy-Inversion Principle）其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。接口隔离原则（Interface-Segregation Principle）其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。]]></content>
      <categories>
        <category>Java</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理财杂记]]></title>
    <url>%2Fposts%2F847d5b8e%2F</url>
    <content type="text"><![CDATA[一直很乐观，一直很谨慎。这才是长期生存之道。一盆冷水在很多人的潜意识里：钱是脏的、钱就是性，是羞耻的、钱代表不安全、钱代表攻击、钱代表分离。年轻人收入少，最好的投资是投资自己。什么叫投资自己？什么叫让自己变得值钱？投资是一件带有明确目的性的东西，如果做事情没有目的性，那么不如不做。如果做了没有达到目的，那就说明在浪费时间和金钱。变得值钱这件事情，更要有目的性，要有明确的KPI。回过头来再看，各种让你学习烘焙旅游化妆穿衣的东西，能算是投资自己吗？即使是所谓的考证，健身，读书，也得考虑一个回报率和执行力的问题。大多数人对于长期坚持考证这种事情，是坚持不下来的，人和人就是不一样的。办了健身房年卡，一年能去几次？去闲鱼看看那些便宜出的年卡就知道了。在没有足够数量的有效信息前，各种所谓的投资都是抓瞎。依靠理财实现财务自由如果说投资自己是欺负年轻人的话，那么依靠理财财务自由则是针对职场人士的春秋大梦。那些靠吃利息的人，绝大多数也都是通过其他行业完成了自己的资本积累，例如1000万。理财这件事情说穿了就是把你已有的资金做一个增量，这显然是受限于你的本金的，人家1000万本金一年赚3%都有30万，你5万块钱一年15%也就7千5.很多人的问题不在于3%或者15%，而是在于1000万还是5万。而且投资其实一个技能，这个技能需要大量的时间积累和实战的，就和你做医生，程序员，工程师，老师一样，不是一蹴而就的，你一个普普通通在自己行业冒头都费劲的人，突然就靠理财财务自由了，这东西有点魔幻。一开始就要把目的定下来，让自己舒服一点，但不求大富大贵。大富大贵的东西不要学理财，建议去学刑法。投资一定要跟着高手进行操作认真想想，你和高手的风险承受能力，信息获取能力，资金量级，心态，时间成本都是完全不一样的，你去学高手的操作模式是得有多么想不通。人家高手加杠杆的同时还有另一批资金做风险对冲，你自己傻乎乎地跟着人家加杠杆进场一波就把自己玩儿炸掉。人家高手投资某个标的的时候往往有数据支撑或者内幕消息，你傻乎乎跟着投进去最后就是给高手接盘的。高手的操作模式和普通人的操作根本不是一种东西，二者从目的性上就有本质的区别。开F1和骑自行车都是交通技术，但能一样么？十以内加减法和微积分都是数学，你让小学生学微积分试试？不同的人，要有不同的投资模式，强行并线很容易出事故的。而且吧，专业人士操作的时效性要求很高，哪里有空和你比比？我自己玩高频交易的时候，根本没空和人家废话，各种公式等着我配平，各种市场风险要在指标变化的第一时间做对冲，时刻要盯着自己的平仓线和保证金，哪里有心思还教人怎么玩儿？有的人就是想赚点小钱，学什么杠杆，找死么。有的人心理承受能力就是差，那就去买银行理财，搞什么P2P。有的人天生就是只想投自己懂的公司，那就买股票，死也是个明白鬼。普通人应该是有普通人的玩法。非得跟着高手操作的结果，很有可能是人家车都开到下一站了，你还在天上飘着呢。大钱要谨慎，小钱要自由，抓大放小才是大道，理财也是如此。这话本身没错，但是要看对谁说。对于已经挺有钱的人而言是对的，因为他们的时间本身就挺值钱，没有必要在细节上浪费。但是对于绝大多数时间不能直接变成钱的普通人而言，这句话是最毒的鸡汤。对于普通人而言，买房买车买包买表这种大钱，大家都会本能性的谨慎，去收集信息，去权衡利弊，其实用不着和人讲谨慎，大家都知道要谨慎。反而是打车，是大量奶茶零食，是大量9块9包邮，是各种拼单凑单，才是普通人资金流血的最大问题所在。电子支付的快速发展更加剧了这一问题，过去有一堆堆的现金摆在面前还会让人警醒一点，而现在年轻人手机一刷，感知上就弱了很多。甚至负债类消费已经流行到不需要感知的程度，二维码背后就是信用卡和透支产品，很多人都是一到要还卡的时候才傻了眼，平时根本没什么感觉。而投资理财这件事情，我上面第二点说了，最重要的是先要有本金，哪怕是不多的本金，然后才是收益率。如果不控制住这种弱感知的消费，管理不好自己的资金流，那么永远也没有本金可言，所谓的投资理财在一开始就完犊子了。资金流管理，是我觉得每个人都应该学的第一步。我觉得还会涨出现负利率贷款，金毛大总统接连搞事，不确定因素太多了…… 如果回到一年前，我一定重仓黄金，然后把这件事忘记，一年半之后再卖掉。这个时候我也买了点，看看能不能赶上末班车，喝点汤。希望别打脸~理想情况情况好，赚得多；情况不好，亏的少。基金莫短炒。必须短炒的话，优先买场内基金，或者场外C类基金并持有7天以上。可以省一笔赎回费。利率降低可以拉高所有资产的价格。但2%、3%这种低利率水平，资产没啥机会的，因为价格已经很高了。反倒是利率6%降低到3%的过程中，买资产大有可为，因为仅这一个变化就可以让资产价格翻倍。好品种+好价格=好收益简单、有效、坚持。无论高低贵贱，钱总是钱，能来总比不来好。总之我们自己记得穿上泳装再下水就好。其实不需要太光鲜的成就系统，只要是一个doer，就已经是很了不起的成就了 。交易容易，转手快，中间环节少，税收少。签一个字就可以买卖，房子交易的速度就会越来越快，交易越来越容易，佣金也少，利息也低，大家都愿意买卖，房价才可以上去，就能赚钱。现实情况加盟商的目的不是帮你赚钱，而是从你手上赚钱，这一点非常重要。餐饮业，成本是生命线，一切都和成本有关。投资人也爱割投资人韭菜，大家五五开吧。所谓高收益又能保本保息的并不符合投资常识，和常识对着干早晚要出事的。如果你还年轻，又认可自己的职业前途，那么全力加强自己的工作能力即可，不用过多考虑投资理财的事儿。因为在你们这个年纪，投资自己才是最好的投资，每年涨薪20%比股市赚20%更容易。黄金，是为了对冲人类文明的退步。某种意义上，指数基金是黄金的反面。买指数基金，是为了跟上人类文明的进步。人的本能，会把短期的趋势想象成长期趋势，于是就很容易出现盲目：越涨越看涨，越跌越看跌。万物皆有限，鱼与熊掌不可得兼。世界上最容易的赚钱方式，永远都在别人的故事里。很多人试图模仿牛人，结果碰了一鼻子灰，就这样自暴自弃了，看什么案例？有啥好学习的？都是骗！人！的！你为工作付出24小时，付出你的肉体你的青春，你觉得付出了自己的所有，这些在别人眼里却是最不值钱的东西。因为肉体资源的付出，只要坐着加班就行了。最痛苦的事，往往是你自己以为自己很努力，结果却是瞎忙。理财达到财务自由是一个极小概率事件，理财本身没这个威力，不要迷信理财，理财不是印钞机，理财只是资金的放大器。一些概念攒钱是年轻人改变命运的最低成本方案，没有之一，没有之一，没有之一。省钱+攒钱，只要坚持，路就会越走越宽。酷是生活态度，不是消费态度。向命运宣战，可不是靠透支信用卡。消费主义是什么？简单来说，任何把让你掏钱的事情描绘的别有一番意义的事情，都是消费主义的一种体现。不是说买东西就是消费主义，而是让你通过买东西，去获得一种虚无的快感，这叫做消费主义。典型的消费主义特质，就是把消费与个人社会标签捆绑在一起，让你为个人标签支付更多的金钱。简称你买什么，你就是什么。只要你还在靠出卖自己的劳动力和时间获取收入，哪怕年薪百万是高级职业经理人，你依然是个穷人，别想着给自己贴什么高级标签，更别觉得那些所谓中产必买的东西对你有什么意义。哪有什么中产，中产就是消费主义鼓吹出来的谎言。什么叫有钱人？不需要从事生产，光靠理财和资产的增值收入已经远远可以覆盖掉各种作妖的成本。拥有选择是否出卖时间的自由，想去哪里可以立即头等舱飞过去，不需要凑时间，也不需要找便宜票。银行卡可自由动用资金（注意不是用于生产的资金）余额在8位数以上，不包含用于投资部分。达到这个基础标准的，才叫有钱人。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CodeReview最佳实践]]></title>
    <url>%2Fposts%2Feb547231%2F</url>
    <content type="text"><![CDATA[作者：宝玉原文：https://www.cnblogs.com/dotey/p/11216430.html我一直认为Code Review（代码审查）是软件开发中的最佳实践之一，可以有效提高整体代码质量，及时发现代码中可能存在的问题。包括像Google、微软这些公司，Code Review都是基本要求，代码合并之前必须要有人审查通过才行。然而对于我观察到的大部分软件开发团队来说，认真做Code Review的很少，有的流于形式，有的可能根本就没有Code Review的环节，代码质量只依赖于事后的测试。也有些团队想做好代码审查，但不知道怎么做比较好。网上关于如何做Code Review的文章已经有很多了，这里我结合自己的一些经验，也总结整理了一下Code Review的最佳实践，希望能对大家做好Code Review有所帮助。Code Review有什么好处？很多团队或个人不做Code Review，根源还是不觉得这是一件有意义的事情，不觉得有什么好处。这个问题要从几个角度来看。团队知识共享的角度一个开发团队中，水平有高有低，每个人侧重的领域也有不同。怎么让高水平的帮助新人成长？怎么让大家都对自己侧重领域之外的知识保持了解？怎么能有人离职后其他人能快速接手？这些都是团队管理者关心的问题。而代码审查，就是一个很好的知识共享的方式。通过代码审查，高手可以直接指出新手代码中的问题，新手可以马上从高手的反馈中学习到好的实践，得到更快的成长；通过代码审查，前端也可以去学习后端的代码，做功能模块A的可以去了解功能模块B的。可能有些高手觉得给新手代码审查浪费时间，自己也没收获。其实不然，新人成长了，就可以更多的帮高手分担繁重的任务；代码审查中花时间，就少一些帮新人填坑擦屁股的时间；良好的沟通能力、发现问题的能力、帮助其他人成长，都是技术转管理或技术上更上一层楼必不可少的能力，而通过代码审查可以有效的去练习这些方面的能力。代码质量的角度现实中的项目总是人手缺进度紧，所以被压缩的往往就是自动化测试和代码审查，结果影响代码质量，欠下技术债务，最后还是要加倍偿还。也有人寄希望于开发后的人工测试，然而对于代码质量来说，很多问题通过测试是测试不出来的，只能通过代码审查。比如说代码的可读性可维护性，比如代码的结构，比如一些特定条件才触发的死循环、逻辑算法错误，还有一些安全上的漏洞也更容易通过代码审查发现和预防。也有人觉得自己水平高就不需要代码审查了。对于高手来说，让别人审查自己的代码，可以让其他人学习到好的实践；在让其他人审查的同时，在给别人说明自己代码的时候，也等于自己对自己的代码进行了一次审查。这其实就跟我们上学时做数学题一样，真正能拿高分的往往是那些做完后还会认真检查的。团队规范的角度每个团队都有自己的代码规范，有自己的基于架构设计的开发规范，然而时间一长，就会发现代码中出现很多不遵守代码规范的情况，有很多绕过架构设计的代码。比如难以理解和不规范的命名，比如三层架构里面UI层绕过业务逻辑层直接调用数据访问层代码。如果这些违反规范的代码被纠正的晚了，后面再要修改就成本很高了，而且团队的规范也会慢慢的形同虚设。通过代码审查，就可以及时的去发现和纠正这些问题，保证团队规范的执行。关于代码审查的好处，还有很多，也不一一列举。还是希望能认识到Code Review和写自动化测试一样，都是属于磨刀不误砍柴工的工作，在上面投入一点点时间，未来会收获代码质量，会节约整体的开发时间。该怎么做？现在很多人都已经有意识到Code Review的重要性了，只是苦于不知道如何去实践，不知道怎么样算是好的Code Review实践。把Code Review作为开发流程的必选项而不是可选项在很早以前，我就尝试过将代码审查作为代码流程的一部分，但只是一个可选项，没有Code Review也可以把代码合并到master。这样的结果就是想起来才会去做Code Review，去检查的时候已经有了太多的代码变更，审查起来非常困难，另外就算审查出问题，也很难得以修改。我们现在对代码的审查则是作为开发流程的一个必选项，每次开发新功能或者修复Bug，开一个新的分支，分支要合并到master有两个必要条件：所有的自动化测试通过有至少一个人Code Review通过，如果是新手的PR，还必须有资深程序员Code Review通过。这样把Code Review作为开发流程的一个必选项后，就很好的保证了代码在合并之前有过Code Review。而且这样合并前要求代码审查的流程，好处也很明显：由于每一次合并前都要做代码审查，这样一般一次审查的代码量也不会太大，对于审查者来说压力也不会太大。如果在Code Review时发现问题，被审查者希望代码能尽快合并，也会积极的对审查出来的问题进行修改，不至于对审查结果太过抵触。如果你觉得Code Review难以推行，不妨先尝试着把Code Review变成你开发流程的一个必选项。把Code Review变成一种开发文化而不仅仅是一种制度把Code Review 作为开发流程的必选项后，不代表Code Review这件事就可以执行的很好，因为Code Review 的执行，很大部分程度上依赖于审查者的认真审查，以及被审查者的积极配合，两者缺一不可！如果仅仅只是当作一个流程制度，那么就可能会流于形式。最终结果就是看起来有Code Review，但没有人认真审查，随便看下就通过了，或者发现问题也不愿意修改。真要把Code Review这件事做好，必须让Code Review变成团队的一种文化，开发人员从心底接受这件事，并认真执行这件事。要形成这样的文化，不那么容易，也没有想象的那么难，比如这些方面可以参考：首先，得让开发人员认识到Code Review这件事为自己、为团队带来的好处。然后，得要有几个人做好表率作用，榜样的力量很重要。还有，对于管理者来说，你激励什么，往往就会得到什么。最后，像写自动化测试一样，把Code Review要作为开发任务的一部分，给审查者和被审查者都留出专门的时间去做这件事，不能光想着马儿跑得快又舍不得给马儿吃草。如何形成这样的文化，有心的话，还有很多方法可以尝试。只有真正让大家都认同和践行，才可能去做好Code Review这件事。一些Code Review的经验技巧在做好Code Review这件事上，还有一些经验技巧可以参考。选什么工具辅助做CODE REVIEW？现在很多源代码管理工具都自带Code Review工具，典型的像Github、Gitlab、微软的Azure DevOps，尤其是像Gitlab，还可以自己在本地搭建环境，根据自己的需要灵活配置。配合什么样的开发流程比较好？像Github Flow[1]这样基于分支开发的流程是特别适合搭配Code Review的。其实不管什么样的开发流程，关键点在于代码合并到master（主干）之前，要先做Code Review。真遇到紧急情况，来不及代码审查怎么办？虽然原则上，必须要Code Review才能合并，但有时候确实会存在一些紧急情况，比如说线上故障补丁，而又没有其他人在线，那么这种情况下，最好是在任务管理系统中，创建一个Ticket，用来后续跟踪，确保后续补上Code Review，并对Code Review结果有后续的代码更新。先设计再编码有些新人发现自己的代码提交PR（Pull Request）后，会收到一堆的Code Review意见，必须要做大量的改动。这多半是因为在开始做之前，没有做好设计，做出来后才发现问题很多。建议在做一个新功能之前，写一个简单的设计文档，表达清楚自己的设计思路，找资深的先帮你做一下设计的审查，发现设计上的问题。设计上没问题了，再着手开发，那么到Review的时候，相对问题就会少很多。代码在提交CODE REVIEW之前，作者要自己先REVIEW和测试一遍我在做代码审查的时候，有时候会发现一些非常明显的问题，有些甚至自己都没有测试过，就等着别人Code Review和测试帮助发现问题。这种依赖心理无论是对自己还是对团队都是很不负责任的。一个好的开发人员，代码在提交Code Review之前，肯定是要自己先Review一遍，把该写的自动化测试代码写上，自己把基本的测试用例跑一遍的。我对于团队提交的PR，有个要求就是要在PR的描述中增加截图或者录屏，就是为了通过截图或者录屏，确保提交PR的人自己是先测试过的。这也是一个有效的辅助手段。PR要小在做Code Review的时候，如果有大量的文件修改，那么Review起来是很困难的，但如果PR比较小，相对就比较容易Review，也容易发现代码中可能存在的问题。所以在提交PR时，PR要小，如果是比较大的改动，那么最好分批提交，以减轻审查者的压力。对评论进行分级在做Code Review时，需要针对审查出有问题的代码行添加评论，如果只是评论，有时候对于被审查者比较难甄别评论所代表的含义，是不是必须要修改。建议可以对Review的评论进行分级，不同级别的结果可以打上不同的Tag，比如说：[blocker]: 在评论前面加上一个blocker标记，表示这个代码行的问题必须要修改[optional]：在评论前面加上一个[optional]标记，表示这个代码行的问题可改可不改[question]：在评论前面加上一个[question]标记，表示对这个代码行不理解，有问题需要问，被审查者需要针对问题进行回复澄清类似这样的分级可以帮助被审查者直观了解Review结果，提高Review效率。评论要友好，避免负面词汇；有说不清楚的问题当面沟通总结Code Review是一种非常好的开发实践，如果你还没开始，不妨逐步实践起来；如果已经做了效果不好，不妨对照一下，看有没有把Code Review作为开发流程的必选项而不是可选项？有没有把Code Review变成一种开发文化而不仅仅是一种制度？虽然评论是主要的Code Review沟通方式，但也不要过于依赖，有时候面对面的沟通效率更高，也容易消除误解。另外文明用语，不要用一些负面的词汇。]]></content>
  </entry>
  <entry>
    <title><![CDATA[杂记-数学概念]]></title>
    <url>%2Fposts%2Fa12aac50%2F</url>
    <content type="text"><![CDATA[欧拉常数与圆周率e 是一个不可思议且特别的定数。在这层意义上，欧拉常数 e 与圆周率 π 是两个至关重要的数学定数，就算说成是神赐予人类的数字也不为过。吹爆炸！！！(m+n)(x+y) = mx + my + nx + ny除法的两个意义a÷n=p等分除将a分成n等份，则每份有p个。不同单位的比例为等分除。包含除将a按照每份有n个等分，则可以分成p份（a有p份的n个）。相同单位的比例为包含除。图表的特点柱状图：表示大小折线图：表示变化饼图：表示比例带状图：比较比例频数分布表频数分布表就是将每组中的频数、相对频数、累计相对频数等做成一张表。组：将数据以相同间隔分开的区间。组中值：各组上下限中间的数值。频数：各组中包含数值的数量。相对频数：各组数据频数在总频数中的占比。累计相对频数：逐级相对频数相加的和。分组取组段值分组取组段值时，可以参照下面的JIS（日本工业标准的简称）标准：将包含最大值与最小值在内的数据，分成5～20组时，用最大值与最小值之差（R）除以1、2、5（或者是10、20、50;0.1、0.2、0.5）等各备选范围，选择结果在5～20范围内的数。如果有两个不同的结果，那么，最大值与最小值之差大于100则取小，反之则取大。中位数将数据由大到小排列时，位于最中间的数值。中位数的求法将数据按大小排列。“当数据个数为奇数时”:中位数=正中间的数值。“当数据个数为偶数时”:中位数=正中间两个数值的平均值。众数一组数据中出现次数最多的数值。即频数最高的数据的值。偏差偏差 = 50 + (指定的值-平均值)/标准差 * 10四分位数四分位数是指，将数据从小到大排列并分成4等份后，处于3个分割点上的数。这3个四分位数按照从小到大的顺序分别被称为第一四分位数、第二四分位数和第三四分位数。第二四分位数和数据的中位数是一致的。四分位数的求法找出数据的最大值与最小值。找出数据的中位数→第二四分位数。求出中位数前半部分数据的中位数→第一四分位数。求出中位数后半部分数据的中位数→第三四分位数。倍数的辨别方法2的倍数：尾数为偶数。3的倍数：各位数相加的和为3的倍数。4的倍数：末尾两位数为4的倍数或整百数。5的倍数：尾数为0或5。6的倍数：尾数为偶数，且各位数的和为3的倍数。7的倍数：将个位数字去掉之后的数 - 个位数字的两倍 = 7的倍数。证明判断3的倍数方法首先，拿一个3位数举个栗子，a，b，c 是一个小于10的正整数，则 100a + 10b + c可以表示一个三位数，从而可以得到 100a + 10b + c = 99a + 9b + (a + b + c)，从而只需要各位数相加的和为3的倍数即可。更多位数同理可证。证明判断7的倍数方法如果把一个数记作 10x + y，则10x + y = 7(x + y) + 3x - 6y = 7(x + y) + 3(x - 2y)，即将个位数字去掉之后的数 - 个位数字的两倍=7的倍数。二项分布一般来说，成功概率为p的实验，独立重复n次后的成功次数为X的概率分布，被称为关于发生概率为p、次数为n的二项分布。和事件与积事件一般来说，如果一个试验中有A与B两个事件，“A与B至少有一个事件发生”的事件被称为A与B的和事件，写作A∪B；而“A与B同时发生”的事件被称为积事件，写作A∩B。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>数学概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枚举类型]]></title>
    <url>%2Fposts%2F4502a76f%2F</url>
    <content type="text"><![CDATA[定义枚举类型（enum type）是指由一组固定的常量组成合法的类型。Java 中由关键字 enum 来定义一个枚举类型。123public enum Season &#123; SPRING, SUMMER, AUTUMN, WINER;&#125;语句定义：使用关键字 enum类型名称，比如这里的Season枚举中的属性必须放在最前面，一般使用大写字母表示枚举可以单独定义在一个文件中，也可以嵌在其它Java类中枚举可以实现一个或多个接口（Interface）可以和 java 类一样定义方法 ，枚举中的构造方法必须是私有的。实现使用 javap 进行反编译可以看到 public final class Season extends Enum，也就是说当我们使用 enum 来定义一个枚举类型的时候，编译器会自动帮我们创建一个 final 类型且继承自 Enum 的类。123456789public final class Season extends java.lang.Enum&lt;Season&gt; &#123; public static final com.muhouer.algorithm.Season SPRING; public static final com.muhouer.algorithm.Season SUMMER; public static final com.muhouer.algorithm.Season AUTUMN; public static final com.muhouer.algorithm.Season WINER; public static com.muhouer.algorithm.Season[] values(); public static com.muhouer.algorithm.Season valueOf(java.lang.String); static &#123;&#125;;&#125;枚举类的字段也可以是非 final 类型，即可以在运行期修改，但是不推荐这样做！默认情况下，对枚举常量调用 toString() 会返回和 name() 一样的字符串。但是，toString() 可以被覆写，而 name() 则不行。一些特殊方法Java 枚举值比较用 == 和 equals() 方法效果是一样的。因为枚举 Enum 类的 equals() 方法的实现就是使用 == ；Enum 的 compareTo()方法实际上比较的是 Enum 的 ordinal 顺序大小；Enum 在 switch 中比较的是 Enum 的 ordinal 值；Enum 的 name()方法和 toString() 方法效果一样，返回的都是 Enum 的 name 值。序列化及线程安全为了保证枚举类型像 Java 规范中规定的那样，每一个枚举类型极其定义的枚举变量在 JVM 中都是唯一的，在枚举类型的序列化和反序列化上，Java 做了特殊的规定:Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.大概意思就是说，在序列化的时候 Java 仅仅是将枚举对象的 name 属性输出到结果中，反序列化的时候则是通过java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了 writeObject、readObject、readObjectNoData、writeReplace 和 readResolve 等方法。 我们看一下这个valueOf()方法:12345678910111213141516171819202122232425262728293031public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) &#123; T result = enumType.enumConstantDirectory().get(name); // 获取枚举类型的枚举常量字典 if (result != null) return result; // 找到即返回结果 if (name == null) // 否则抛出异常 throw new NullPointerException("Name is null"); throw new IllegalArgumentException( "No enum constant " + enumType.getCanonicalName() + "." + name);&#125;private volatile transient Map&lt;String, T&gt; enumConstantDirectory = null;/** * Returns a map from simple name to enum constant. This package-private * method is used internally by Enum to implement * &#123;@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)&#125; * efficiently. Note that the map is returned by this method is * created lazily on first use. Typically it won't ever get created. */Map&lt;String, T&gt; enumConstantDirectory() &#123; if (enumConstantDirectory == null) &#123; T[] universe = getEnumConstantsShared(); // 反射的方式调用枚举类型的 values() 静态方法 if (universe == null) throw new IllegalArgumentException( getName() + " is not an enum type"); Map&lt;String, T&gt; m = new HashMap&lt;&gt;(2 * universe.length); for (T constant : universe) m.put(((Enum&lt;?&gt;)constant).name(), constant); // 填充 enumConstantDirectory enumConstantDirectory = m; &#125; return enumConstantDirectory;&#125;从👆可以看出，JVM 对枚举类型序列化有保证。枚举类型是一个 final 类型的继承自 Enum 的类，所以枚举类型不能被继承，而且这个类中的属性和方法都是static 类型的。当一个 Java 类第一次被真正使用到的时候静态资源初始化、Java 类的加载和初始化过程都是线程安全的。所以，创建一个enum类型是线程安全的。单例在StakcOverflow中，有一个关于在 Java 中哪种写单例的方式最好的讨论。Joshua Bloch大神在《Effective Java》中明确表达过的观点：使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。使用枚举实现单例的好处：枚举单例写法简单。12345public enum Singleton &#123; INSTANCE; public Connection getConnection() &#123; &#125; &#125;线程安全：枚举实现的单例是天生线程安全的。反序列化不会破坏单例。普通的 Java 类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。所以，即使单例中构造函数是私有的，也会被反射给破坏掉。由于反序列化后的对象是重新 new 出来的，所以这就破坏了单例。]]></content>
      <categories>
        <category>Java</category>
        <category>源码学习</category>
      </categories>
      <tags>
        <tag>枚举类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记-天秀]]></title>
    <url>%2Fposts%2Fff247979%2F</url>
    <content type="text"><![CDATA[在一个8×8的国际象棋棋盘上, 显然我们可以用32张多米诺骨牌覆盖整个棋盘上的64个方格。问：如果将对角线上的两个方格挖掉, 那剩下来的62个格子还能用31张骨牌覆盖住吗？答：每一张骨牌在棋盘上必是覆盖住两个相邻方格, 一白一黑。挖掉两个角之后只有 32 黑 30 白, 于是就不存在这样一种能用31个骨牌覆盖的方法。问：任意切掉一个一白一黑的格子就一定可以吗？答：可以。粗黑线条将整个棋盘转变为一条首尾相连、黑白格相间的封闭路线。从这棋盘上切掉任何两个颜色不同的方格, 会让这个封闭线路变成两段线路, 当然如果切掉的方格是相连的, 那就是一条线路。显然, 在任何线路中, 两种颜色的格子数量都是偶数，故分别都可以被若干张骨牌覆盖。从而整个棋盘一定可以被31张骨牌完全覆盖。]]></content>
  </entry>
  <entry>
    <title><![CDATA[杂记-科学与方法]]></title>
    <url>%2Fposts%2Fb549d39b%2F</url>
    <content type="text"><![CDATA[假如在那里居住着智者，这些智者毫无好奇心，避免一切过度行为，那么他们不会死于疾病，而确实将死于无聊。法则一经确立，我们首先就要寻找这个法则具有最大失效机遇的情况。我们应该达到的目的主要不在于弄清相似和差异，而是要认出隐藏在表观偏离下的类似性。科学家研究自然，并非因为它有用处；他研究它，是因为他喜欢它，他之所以喜欢它，是因为它是美的。如果自然不美，它就不值得了解；如果自然不值得了解，生命也就不值得活着。假如没有能够在事实中选择、分辨在哪些事实背后隐藏某种东西，以及识别什么正在隐藏着的精神，假如没有在未加工的事实下察觉事实精髓的精神，事实也许是毫无成果的。事实的重要性用它产生的效益来衡量，也就是说，用它容许我们节省的思维数量来衡量。思维经济是我们应该对准的目标，因此提供仿效的模型还是不够的。需要使我们之后的人能够省却这些模型，不去重复已做出的论据，而用几句话概括它。我们应该经常力图去做的，可以说是定性地解决问题；也就是说，力图去了解表示未知函数的曲线的一般形状。依然要寻找问题的定量的解。往往发生这种情况：不完美的解把我们引向比较完美的解。有时，级数收敛过慢，以致计算无法实际进行。我们仅仅得以证明问题的可能性。偶然性仅仅是我们无知的度量。按照定义，偶然发生的现象就是我们不知道其规律的现象。对称性的最小欠缺将使它稍微倾斜到一侧或另一侧，而且如果它倾斜了，不管倾斜得多么小，它必将完全倾向那一侧。我不可能预见我推动的指针将停在何处，这就是我的心紧张地跳动，期望一切都交好运的缘由。原因上的差别是难以觉察的，而结果上的差别对我来说却是至关重要的，由于它就是我的整个赌注。我们忽路了这样一些情况,这些情况乍看起来似乎完全是在我们预见之外发生的，人们从来也没有梦想到把任何影响归咎于它，不过与我们的预期相反，它最终却起着重要的作用。我们不知道偶然误差由什么引起的，而且正因为我们不知道，我们才意识到它们服从高斯定律。不是严格的证明微不足道。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>科学与方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[证明杂记]]></title>
    <url>%2Fposts%2Fc1a19f3f%2F</url>
    <content type="text"><![CDATA[如何证明 0.99999…… = 1方法一1/3 = 0.33333…… ==&gt; 1 = 0.99999……方法二10 * 0.99999…… = 9.9999……两边各减去一个 0.99999…… ==&gt; 9 * 0.99999…… = 9 ==&gt; 0.99999…… = 1方法三0.99999…… = 0.9 + 0.09 + 0.009 + ……采用等比数列求和，然后求极限。从而可以得到 0.99999…… + n = n + 1，例如： 9.99999…… = 10有趣的 PI 和 E1234&gt; Math.pow(Math.PI, 4) + Math.pow(Math.PI, 5)403.4287758192838&gt; Math.pow(Math.E, 6)403.428793492735PI^4 + PI^5 约等于 E^6 可以精确到小数点后四位。紧跟这个精度之后的是 PI^146 + PI^152 约等于 E^1741234&gt; Math.pow(Math.PI, 146) + Math.pow(Math.PI, 152)3.6917488742520865e+75&gt; Math.pow(Math.E, 174)3.6918143295804325e+75神奇！神奇！神奇！有趣！有趣！有趣！时间复利1234&gt; Math.pow((1+1/365), 365)2.714567482021973&gt; Math.pow((1+1/365), 365*10)21727.333146076744]]></content>
      <categories>
        <category>数学</category>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HashSet分析]]></title>
    <url>%2Fposts%2F88817346%2F</url>
    <content type="text"><![CDATA[HashSet 是一个不允许存储重复元素的集合，它的实现比较简单，只要理解了 HashMap，HashSet 基本就没什么问题。成员变量1234private transient HashMap&lt;E,Object&gt; map;// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object();主要就两个变量:map ：用于存放最终数据的。PRESENT ：是所有写入 map 的 value 值。构造函数构造函数也很简单，利用 HashMap 初始化了 map12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;/** * Constructs a new set containing the elements in the specified * collection. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor * (0.75) and an initial capacity sufficient to contain the elements in * the specified collection. * * @param c the collection whose elements are to be placed into this set * @throws NullPointerException if the specified collection is null */public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and default load factor (0.75). * * @param initialCapacity the initial capacity of the hash table * @throws IllegalArgumentException if the initial capacity is less * than zero */public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;重要方法123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;比较关键的就是这个 add() 方法。 可以看出它是将存放的对象当做了 HashMap 的健，value 都是相同的 PRESENT 。由于 HashMap 的 key 是不能重复的，所以每当有重复的值写入到 HashSet 时，value 会被覆盖，但 key 不会受到影响，这样就保证了 HashSet 中只能存放不重复的元素。TreeSet 与 HashSet 的区别1、TreeSet 是二差树实现的，Treesetc中的数据是自动排好序的，不允许放入 null 值 2、HashSet 是哈希表实现的，HashSet 中的数据是无序的，可以放入 null，但只能放入一个 null，两者中的值都不能重复，就如数据库中唯一约束。在 HashSet 中，基本的操作都是由 HashMap 底层实现的，因为 HashSet 底层是用 HashMap 存储数据的。当向HashSet 中添加元素的时候，首先计算元素的hashcode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。TreeSet 的底层是 TreeMap 的 keySet()，而 TreeMap 是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。TreeMap 是按key排序的，元素在插入 TreeSet 时 compareTo() 方法要被调用，所以 TreeSet 中的元素要实现Comparable 接口。TreeSet 作为一种Set，它不允许出现重复元素。TreeSet 是用 compareTo() 来判断重复元素的。总结HashSet 的原理比较简单，几乎全部借助于 HashMap 来实现的。即 HashSet 和 HashMap 是命运共同体，一荣俱荣，一损俱损。]]></content>
      <categories>
        <category>Java</category>
        <category>源码学习</category>
      </categories>
      <tags>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList分析]]></title>
    <url>%2Fposts%2F5c1acfc0%2F</url>
    <content type="text"><![CDATA[LinkedList 底层是基于双向链表 Deque 实现的，也是实现了 List 接口，所以也拥有 List 的一些特点，出场率不高，了解一下。123456789101112131415transient int size = 0;/** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */transient Node&lt;E&gt; first;/** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */transient Node&lt;E&gt; last;即类似如下形式：first.prev == null &amp;&amp; first.next == a &lt;——&gt; a.prev = first&amp;&amp; a.next == last &lt;——&gt; last.prev == a &amp;&amp; last.next == nulladd每次插入都是移动指针，和 ArrayList 的拷贝数组相比效率提升不少。1234567891011121314151617181920212223242526/** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * Links e as last element. */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125;get利用了双向链表的特性，使用空间来换取时间。如果索引值小于链表大小的一半，即 index 离链表头比较近，就从节点头部遍历，否则将从尾结点开始遍历。这就导致效率降低，特别是当 index 越接近 size 的中间值时。12345678910111213141516171819202122232425262728/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;/** * Returns the (non-null) Node at the specified element index. */Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;总结LinkedList 插入，删除都是移动指针效率很高。查找需要进行遍历查询，效率较低。]]></content>
      <categories>
        <category>Java</category>
        <category>源码学习</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap分析]]></title>
    <url>%2Fposts%2F9c86c04c%2F</url>
    <content type="text"><![CDATA[前言Map 这样的 Key Value 在软件开发中是非常经典的结构，常用于在内存中存放数据。Java 中最常用的 Map 有两种，首先是 HashMap ，其次是 ConcurrentHashMap 。HashMap从整个 HashMap 的声明可以看出它内部是基于数组 + 链表实现的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。基于 1.7HashMap 在 jdk1.7 中的数据结构图：首先来看 jdk1.7 中的实现：123456789101112static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //初始化桶大小，因为底层是数组，所以这是数组默认的大小。默认大小16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //桶最大容量static final float DEFAULT_LOAD_FACTOR = 0.75f; //默认的负载因子static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; //真正存放数据的数组transient int size; //存放key-value元素的个数int threshold; //桶容量大小，可在初始化时显式指定，扩容判定threshold = capacity * loadFactor，默认为0.75 * 16 = 12final float loadFactor; //负载因子，可在初始化时显式指定。// 这两个属性是在抽象类AbstractMap中定义的transient volatile Set&lt;K&gt; keySet = null;transient volatile Collection&lt;V&gt; values = null;Map 在使用过程中不断的往里面存放数据，当数量达到了 threshold 就需要将当前容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。根据代码可以看到其实真正存放数据的是1transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;这个数组，那么它又是如何定义的呢？12345678910111213141516171819202122232425// Entry 是 HashMap 中的一个内部类static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; // key，写入时的键 V value; // value，值 Entry&lt;K,V&gt; next; // 用于实现链表结构，当有hash冲突，存储的下一个元素 final int hash; // 当前 key 的 hashcode /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123;return key;&#125; public final V getValue() &#123;return value;&#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125;&#125;以上即为 HashMap 的基本结构，接下来来看写入和获取方法：put 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; // 判断当前数组是否需要初始化。 inflateTable(threshold); &#125; if (key == null) // 如果 key 为空，则 put 一个空值进去 return putForNullKey(value); // int hash = hash(key); // 计算根据 key 计算出 hash 值------ int i = indexFor(hash, table.length); // 根据计算出的 hash 值定位出所在桶 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 如果桶是一个链表则，需要遍历判断 Object k; // hash 值、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 桶是空的，说明当前位置没有数据存入 modCount++; addEntry(hash, key, value, i); // 新增一个 Entry 对象写入当前位置 return null;&#125;static int indexFor(int h, int length) &#123; // 初始容量是一个偶数，当 length-1 的时候，这个数的有效二进制位都是1。 // 只要保证了 h 的分散性就行。&amp;用来取mod运算，效率比%高。 return h &amp; (length-1);&#125;void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; // 判断是否需要扩容 resize(2 * table.length); // 两倍扩充 hash = (null != key) ? hash(key) : 0; // 当前的 key 重新 hash bucketIndex = indexFor(hash, table.length); // 重新定位 &#125; createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表 Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125;get 方法123456789101112131415161718192021public V get(Object key) &#123; if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); // 根据 key 计算出 hash 值 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; // 定位到具体的桶中 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; // key 及 hash 值相等时候就返回对应的值 &#125; return null; // 返回 null &#125;链表死循环HashMap由并发引起的链表死循环基于 1.8HashMap 在 jdk1.7 的实现中有个明显缺点：当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 O(N)。因此 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 O(logn)。话不多说，上🐎：1234567static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;transient Node&lt;K,V&gt;[] table;transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;transient int size;和 1.7 大体上都差不多，还是有几个重要的区别：TREEIFY_THRESHOLD 用于判断是否需要将链表转换为红黑树的阈值。Entry 修改为 Node。Node 的核心组成其实也是和 1.7 中的 Entry 一样，存放的都是 key value hashcode next 等数据。put 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 当前桶为空，进行初始化（resize 中会判断是否进行初始化） if ((p = tab[i = (n - 1) &amp; hash]) == null) // 根据当前 key 的 hash 值定位到具体的桶中 tab[i] = newNode(hash, key, value, null); // 为空表明没有 Hash 冲突就直接在当前位置创建一个新桶 else &#123; // 不为空，有 Hash 冲突 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 比较当前桶中的 key、key 的 hash 值与写入的 key 是否相等，相等就赋值给 e else if (p instanceof TreeNode) // 如果当前桶为红黑树，那就要按照红黑树的方式写入数据 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表） for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 如果在遍历过程中找到 key 相同时直接退出遍历 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // 存在相同的 key ，需要将值覆盖 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) // 判断是否需要进行扩容 resize(); afterNodeInsertion(evict); return null; &#125;get 方法12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 将 key hash 之后取得所定位的桶 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 判断桶的第一个位置的 key 是否为查询的 key，是就直接返回 value。 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) // 红黑树 // 按照树的查找方式返回值 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; // 链表 // 按照链表的方式遍历匹配返回值 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; // 桶为空则直接返回 null &#125;线程不安全HashMap 在并发时可能出现的问题主要有三个方面：如果多个线程同时使用 put 方法添加元素，而且假设正好存在两个 put 的 key 发生了碰撞（根据 hash 值计算的 bucket 一样），那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程 put 的数据被覆盖。如果多个线程同时检测到元素个数超过 threshold，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。遍历方式还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：123456789Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();while (entryIterator.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; next = entryIterator.next();&#125; Iterator&lt;String&gt; iterator = map.keySet().iterator();while (iterator.hasNext())&#123; String key = iterator.next();&#125;强烈建议使用第一种 EntrySet 进行遍历。第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题）。因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 java.util.concurrent 包下，专门用于解决并发问题。]]></content>
      <categories>
        <category>Java</category>
        <category>源码学习</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String分析]]></title>
    <url>%2Fposts%2F4a48cd1d%2F</url>
    <content type="text"><![CDATA[String 这个类是我们在写 Java 代码中用得最多的一个类，没有之一，今天我们就讲讲它。简介String 并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现 String 类为final 型的(当然也不可被继承)，而且通过查看 JDK 文档会发现几乎每一个修改 String 对象的操作，实际上都是创建了一个全新的 String 对象。String 类实现了 Serializable，Comparable，CharSequence接口，被 final 修饰。内部维护了一个字符数组。常用方法字符串比较12345678910111213== // 判断内容与地址是否相同boolean equals(Object anObject) // 判断两个字符串内容是否相同boolean equalsIgnoreCase(String anotherString) // 忽略大小写，判断两个字符串内容是否相同，底层调用了regionMatches方法 boolean contentEquals(CharSequence cs) // 判断字符序列和字符串内容是否相同boolean contentEquals(StringBuffer sb) // 判断StringBuffer和字符串内容是否相同，实际上调用的是contentEquals方法 int compareTo(String anotherString) // 按照字典大小比较两个字符串的大小int compareToIgnoreCase(String str) // 忽略大小写，按照字典大小比较两个字符串的大小，使用忽略大小写比较器 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)// 判断两个字符串部分内容是否相同，ignoreCase:是否忽略大小写，toffset:子字符串的偏移量，ooffset:参数字符串中子字符串的偏移量，len:比较的子字符串的长度字符串查找1234567891011char charAt(int index) // 返回索引上的字符，索引从0开始 int indexOf(int ch) // 从字符串开始检索字符(Unicode 码) ch，并返回第一次出现的位置，未出现返回-1。int indexOf(int ch，int fromIndex) // 从字符串的第fromIndex个字符开始检索字符(Unicode 码) ch，未出现返回-1。int lastIndexOf(int ch) // 从字符串检索字符(Unicode 码) ch最后一次出现的位置。int lastIndexOf(int ch, int fromIndex) //从字符串的第fromIndex个字符检索字符(Unicode 码) ch最后一次出现的位置。boolean startsWith(String prefix, int toffset) // 判断此字符串从指定索引开始的子字符串是否以指定前缀开始boolean startsWith(String prefix) // 判断此字符串是否以指定前缀开始。 boolean endsWith(String suffix) // 判断此字符串是否以指定后缀结尾。字符串截取与替换12345678String substring(int beginIndex) // 返回一个新的字符串，是从beginIndex开始到length-1的串。String subString(int beginIndex，int endIndex)------返回一个新的字符串，是从beginIndex开始到endIndex-1的串。CharSequence subSequence(int beginIndex, int endIndex) // 返回从beginIndex开始到endIndex-1的字符序列String replace(char oldChar, char newChar) // 将字符串中的oldChar字符替换为newCharString replace(CharSequence target, CharSequence replacement) // 将字符串中的target字符序列替换为replacement序列String replaceFirst(String regex, String replacement) // 使用replacement替换第一个通过regex匹配到子串。String replaceAll(String regex, String replacement) // 使用replacement替换所有通过regex匹配到子串。字符串其他常用方法123456789int length() // 获取字符串长度boolean isEmpty() // 判断字符串是否为空boolean contains(CharSequence s) // 判断字符串是否包含字符序列 sString concat(String str) // 字符串拼接String trim() // 字符串去掉首尾空白String toUpperCase(Locale locale) // 字符串转大写String toLowerCase(Locale locale) // 字符串转小写String[] split(String regex) // 字符串分割String[] split(String regex, int limit) // 字符串分割，多了结果阈值参数创建方式第一种方式是在常量池中直接拿对象，第二种是在堆内存空间创建一个新的对象。只要使用new方法，就需要创建新的对象。1String str = new String("Freya"); // 这句话创建了两个对象。首先，字符串“Freya”放入常量池，然后 new 了一个字符串“Freya”放入 Java 堆。字符串常量”Freya”在编译期就已经确定放入常量池，而 Java 堆上的”Freya”是在运行期初始化阶段才确定。然后 Java 栈中的 str 指向了 Java 堆中的 “Freya”。字符串常量池字符串常量池是 JVM 实例全局共享的，全局只有一个。字符串常量池及到一个设计模式，叫“享元模式”，顾名思义 就是共享元素模式。也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素。直接使用双引号声明的 String 对象直接存储在字符串常量池。不是双引号声明的，可以使用 String.intern() 方法，这是一个Native方法。如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。12345678910111213141516public static void main(String[] args) &#123; String a = "Freya"; //常量池中的对象 String b = "Freya"; //常量池中的对象 String c = new String("Freya"); String d = a.intern(); String e = "Freya" + " 17"; //常量池中的对象 String f = " 17"; String g = a + f; //在堆上创建的新的对象 String h = "Freya 17"; //常量池中的对象 System.out.println(a == b); //true System.out.println(a == c); //false System.out.println(a == d); //true System.out.println(e == g); //false System.out.println(e == h); //true System.out.println(g == h); //false&#125;注意：尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变，可以使用StringBuilder或者StringBuffer。String 对象的不可变性打开 String 类源码，可以看到一句话:Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared.意思是 String 是个常量，创建之后就是不可变的。不可变的意思是不能改变对象内的成员变量，包括基本数据类型变量的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。String 对象不可变性是如何实现的？从JDK 9之后，value的类型由 char[] 数组变成了 byte[] 数组。目的是为了节省空间，提高String的性能。123456789101112131415161718192021222324public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123; /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset; /** The count is the number of characters in the String. */ private final int count; /** Cache the hash code for the string */ private int hash; // Default to 0 .... public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length); // deep copy操作 &#125; ... public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result; &#125; ...&#125;从源码可以看出：String 类被 final 修饰，不可继承。String内部所有成员都设置为私有变量。不存在value的setter方法。将value和offset设置为final。当传入可变数组value[]时，进行copy而不是直接将value[]复制给内部变量。获取value时不是直接返回对象引用，而是返回对象的copy。String 对象不可变性的优缺点优点字符串常量池的需要字符串常量池可以将一些字符常量放在常量池中重复使用，避免每次都重新创建相同的对象、节省存储空间。但如果字符串是可变的，此时相同内容的String还指向常量池的同一个内存空间，当某个变量改变了该内存的值时，其他遍历的值也会发生改变。所以不符合常量池设计的初衷。线程安全考虑同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。支持hash映射和缓存因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。缺点如果有对String对象值改变的需求，那么会创建大量的String对象。String对象是否真的不可变虽然 String 对象将 value 设置为 final，并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。例如：1234567891011121314151617181920212223242526public static void main(String[] args) &#123; //创建字符串"Hello World"， 并赋给引用s String s = "Hello World"; System.out.println("s = " + s); //Hello World //获取String类中的value字段 Field valueFieldOfString = null; try &#123; valueFieldOfString = String.class.getDeclaredField("value"); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; //改变value属性的访问权限 valueFieldOfString.setAccessible(true); //获取s对象上的value属性的值 char[] value = new char[0]; try &#123; value = (char[]) valueFieldOfString.get(s); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; //改变value所引用的数组中的第5个字符 value[5] = '_'; System.out.println("s = " + s); //Hello_World&#125;打印结果为：1234s = Hello Worlds = Hello_WorldProcess finished with exit code 0其他相关内容substring 方法在 JDK 1.6中，当调用 substring 方法的时候，会创建一个新的 String 对象，但是这个 String 的值仍然指向堆中的同一个字符数组。这两个对象中只有 count 和offset 的值是不同的。如果你有一个很长很长的字符串，但是当你使用 substring 进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 1.6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。1x = x.substring(x, y) + ""以上问题在jdk 7+中得到解决。在jdk 7+ 中，substring方法会在堆内存中创建一个新的数组。其使用new String创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。String.valueOf和Integer.toString的区别我们有三种方式将一个int类型的变量变成呢过String类型，那么他们有什么区别？1234int i = 5;String i1 = "" + i; //其实是String i1 = (new StringBuilder()).append(i).toString();，首先创建一个StringBuilder对象，然后再调用append方法，再调用toString方法。String i2 = String.valueOf(i); //调用 Integer.toString(i)String i3 = Integer.toString(i);replaceFirst、replaceAll、replace 的区别123456789public static void main(String[] args) &#123; String a = "Hello"; a.replace("e","f"); System.out.println(a); // Hello a = a.replace("e","f"); System.out.println(a); // Hfllo&#125;replace(CharSequence target, CharSequence replacement) ，用 replacement 替换所有的 target ，两个参数都是字符串。replaceAll(String regex, String replacement) ，用 replacement 替换所有的 regex 匹配项，regex 很明显是个正则表达式，replacement 是字符串。replaceFirst(String regex, String replacement) ，基本和 replaceAll 相同，区别是只替换第一个匹配项。注意replace 替换的只能是字符或字符串形式。replaceAll() 和 replaceFirst() 是基于正则表达式的替换。replaceAll() 和 replace() 是替换所有的，而 replaceFirst() 仅替换第一次出现的。如果 replaceAll() 和 replaceFirst() 所用的参数据不是基于正则表达式的，则与 replace() 替换字符串的效果是一样的。执行了替换操作后，源字符串的内容是没有发生改变的。switch 对字符串的支持switch 中只能使用整型，其他数据类型都是转换成整型之后在使用switch的。比如byte、short、char(ASCII码是整型)以及int。字符串进行switch的实际是哈希值，然后通过使用 equals 方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 switch 或者使用纯整数常量，但这也不是很差。因为Java编译器只增加了一个equals方法，如果你比较的是字符串字面量的话会非常快。例如：123456789101112131415public class switchDemoString &#123; public static void main(String[] args) &#123; String str = "world"; switch (str) &#123; case "hello": System.out.println("hello"); break; case "world": System.out.println("world"); break; default: break; &#125; &#125;&#125;对代码进行反编译：123456789101112131415161718192021222324public class switchDemoString&#123; public switchDemoString() &#123; &#125; public static void main(String args[]) &#123; String str = "world"; String s; switch((s = str).hashCode()) &#123; default: break; case 99162322: if(s.equals("hello")) System.out.println("hello"); break; case 113318802: if(s.equals("world")) System.out.println("world"); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>源码学习</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList分析]]></title>
    <url>%2Fposts%2Fb0d3e399%2F</url>
    <content type="text"><![CDATA[ArrayList 实现于 List、RandomAccess 接口。可以插入空数据，也支持随机访问。ArrayList 相当于动态数据，其中最重要的两个属性分别是: elementData 数组，以及 size 大小。成员变量123456789101112131415/** 默认的初始化容量 */private static final int DEFAULT_CAPACITY = 10;/** 空 ArrayList 实例共享的空数组实例 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** 默认大小的空 ArrayList 实例共享的空数组实例，和 EMPTY_ELEMENTDATA 区分开 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * 存储arraylist元素的数组缓冲区。 * 任何使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空 ArrayList 实例， * 在首次添加元素时容量扩展到默认容量 DEFAULT_CAPACITY 。 */transient Object[] elementData; // 非私有以简化嵌套类访问/** ArrayList包含的元素个数 */private int size;构造函数1234567891011121314151617181920212223242526public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 新建 initialCapacity 大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 采用 EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;public ArrayList() &#123; // 采用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，和 EMPTY_ELEMENTDATA 区分开来 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125;c.toArray might (incorrectly) not return Object[] (see 6260652)查看 ArrayList(Collection&lt;? extends E&gt; c) 构造函数时，有个注释 c.toArray might (incorrectly) not return Object[] (see 6260652)，具体什么意思呢？先看个示例：12 List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(Arrays.asList("foo", "bar"));list.set(0, new Object());如果 ArrayList 的构造函数中没有类型检查的代码 elementData.getClass() != Object[].class，会导致其elementData 的实际类型是String[]，而不是 Object[]，所以当你将其中一个元素更换为 Object 元素时会报错，你可以试下如下代码，肯定会报 ArrayStoreException 的错误。123Object[] arr = new String[]&#123;"a","b"&#125;;arr[0]=new Object(); // Causes ArrayStoreException, // because you cannot put arbitrary Object into String[]主要问题出在 Arrays.asList 上面，Arrays.asList 返回的 ArrayList 实际上是内部类 ArrayList ，并不是我们经常使用的 ArrayList。12private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable内部类 ArrayList 的 toArray() 使用的是 clone 方法，而我们经常使用的 ArrayList 的 toArray() 使用的是 Arrays.copyOf() 方法，具体差别如下：1234Object[] arr = new ArrayList&lt;Object&gt;(Arrays.asList("foo", "bar")).toArray();System.out.println(arr.getClass()); // class [Ljava.lang.Object; Object数组Object[] arr1 = Arrays.asList("foo", "bar").toArray();System.out.println(arr1.getClass()); // class [Ljava.lang.String; String 数组，操作不当会引起 ArrayStoreException关于 Arrays.asList 的一个坑 使用Java时的一些坑add在调用 add() 方法的时候：12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;首先进行扩容校验。将插入的值放到尾部，并将 size + 1 。如果是调用 add(index,e) 在指定位置添加的话：12345678910public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //复制，向后移动 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;也是首先扩容校验。接着对数据进行复制，目的是把 index 位置空出来放本次插入的数据，并将后面的数据向后移动一个位置。其实扩容最终调用的代码:1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;也是一个数组复制的过程。由此可见 ArrayList 的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作。序列化由于 ArrayList 是基于动态数组实现的，所以并不是所有的空间都被使用。因此使用了 transient 修饰，可以防止被自动序列化。1transient Object[] elementData;因此 ArrayList 自定义了序列化与反序列化：1234567891011121314151617181920212223242526272829303132333435363738394041private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. //只序列化了被使用的数据 for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125;从实现中可以看出 ArrayList 只序列化了被使用的数据。ArrayList VS VectorVector 也是实现于 List 接口，底层数据结构和 ArrayList 类似，也是一个动态数组存放数据。不过是在 add() 方法的时候使用 synchronized 进行同步写数据，但是开销较大，所以 Vector 是一个同步容器并不是一个并发容器。以下是 add() 方法：123456public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;以及指定位置插入数据:1234567891011121314public void add(int index, E element) &#123; insertElementAt(element, index);&#125;public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt; " + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>源码学习</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式备忘]]></title>
    <url>%2Fposts%2F2c992fa9%2F</url>
    <content type="text"><![CDATA[正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子。元字符正则表达式主要依赖于元字符. 元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:元字符描述.句号匹配任意单个字符除了换行符.[ ]字符种类. 匹配方括号内的任意字符.[^ ]否定的字符种类. 匹配除了方括号里的任意字符*匹配&gt;=0个重复的在*号之前的字符.+匹配&gt;=1个重复的+号前的字符.?标记?之前的字符为可选.{n,m}匹配num个大括号之前的字符 (n &lt;= num &lt;= m).(xyz)字符集, 匹配与 xyz 完全相等的字符串.|或运算符,匹配符号前或后的字符.\转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \^从开始行开始匹配.$从末端开始匹配.简写字符集正则表达式提供一些常用的字符集简写. 如下:简写描述.除换行符外的所有字符\w匹配所有字母数字, 等同于 [a-zA-Z0-9_]\W匹配所有非字母数字, 即符号, 等同于: [^\w]\d匹配数字: [0-9]\D匹配非数字: [^\d]\s匹配所有空格字符, 等同于: [\t\n\f\r\p{Z}]\S匹配所有非空格字符: [^\s]\f匹配一个换页符\n匹配一个换行符\r匹配一个回车符\t匹配一个制表符\v匹配一个垂直制表符\p匹配 CR/LF (等同于 \r\n)，用来匹配 DOS 行终止符零宽度断言(前后预查)先行断言和后发断言都属于非捕获簇(不捕获文本 ，也不针对组合计进行计数). 先行断言用于判断所匹配的格式是否在另一个确定的格式之前, 匹配结果不包含该确定格式(仅作为约束).例如, 我们想要获得所有跟在 $ 符号后的数字, 我们可以使用正后发断言 (?&lt;=\$)[0-9\.]*. 这个表达式匹配 $ 开头, 之后跟着 0,1,2,3,4,5,6,7,8,9,. 这些字符可以出现大于等于 0 次.零宽度断言如下:符号描述?=正先行断言-存在?!负先行断言-排除?&lt;=正后发断言-存在?&lt;!负后发断言-排除?=... 正先行断言?=... 正先行断言, 表示第一部分表达式之后必须跟着 ?=...定义的表达式.返回结果只包含满足匹配条件的第一部分表达式. 定义一个正先行断言要使用 (). 在括号内部使用一个问号和等号: (?=...).正先行断言的内容写在括号中的等号后面. 例如, 表达式 (T|t)he(?=\sfat) 匹配 The 和 the, 在括号中我们又定义了正先行断言 (?=\sfat) ,即 The 和 the 后面紧跟着 (空格)fat.1&quot;(T|t)he(?=\sfat)&quot; =&gt; The fat cat sat on the mat.?!... 负先行断言负先行断言 ?! 用于筛选所有匹配结果, 筛选条件为 其后不跟随着断言中定义的格式. 正先行断言 定义和 负先行断言 一样, 区别就是 = 替换成 ! 也就是 (?!...).表达式 (T|t)he(?!\sfat) 匹配 The 和 the, 且其后不跟着 (空格)fat.1&quot;(T|t)he(?!\sfat)&quot; =&gt; The fat cat sat on the mat.?&lt;= ... 正后发断言正后发断言 记作(?&lt;=...) 用于筛选所有匹配结果, 筛选条件为 其前跟随着断言中定义的格式. 例如, 表达式 (?&lt;=(T|t)he\s)(fat|mat) 匹配 fat 和 mat, 且其前跟着 The 或 the.1&quot;(?&lt;=(T|t)he\s)(fat|mat)&quot; =&gt; The fat cat sat on the mat.?&lt;!... 负后发断言负后发断言 记作 (?&lt;!...) 用于筛选所有匹配结果, 筛选条件为 其前不跟随着断言中定义的格式. 例如, 表达式 (?&lt;!(T|t)he\s)(cat) 匹配 cat, 且其前不跟着 The 或 the.1&quot;(?&lt;!(T|t)he\s)(cat)&quot; =&gt; The cat sat on cat.标志标志也叫模式修正符, 因为它可以用来修改表达式的搜索结果. 这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.标志描述i忽略大小写.g全局搜索.m多行的: 锚点元字符 ^ $ 工作范围在每行的起始.贪婪匹配与惰性匹配 (Greedy vs lazy matching)正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。1&quot;/(.*at)/&quot; =&gt; The fat cat sat on the mat.1&quot;/(.*?at)/&quot; =&gt; The fat cat sat on the mat.来源点击learn-regex即可去查看更详细信息。Regulex是一个JavaScript 正则表达式解析和可视化网站。具体效果参看👇示例。示例邮箱只允许英文字母、数字、下划线、英文句号、以及中划线组成。1^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$汉字1^[\u4e00-\u9fa5]&#123;0,&#125;$浮点数1^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-玩笑]]></title>
    <url>%2Fposts%2F25a3a536%2F</url>
    <content type="text"><![CDATA[墨镜一戴谁都不爱，墨镜一摘数我最乖。我: 昨天不是去剪头发了吗？大鹏: 没剪成！我: 为什么？大鹏: 我跟理发师说剪到下巴。我: 然后呢？大鹏: 他问我剪到哪层下巴！！！女大三抱金砖。女大三十送江山。女大三百送仙丹。上帝是公平的，不是公的就是平的。你能来找东叔帮忙，东叔很高兴，但是你让东叔猜，东叔不喜欢。一货晚上开车回家，让交警拦下，拿出个机器对他说：“麻烦吹下～“。朋友说:好的，我有十五个亿，二十套别墅，四辆兰博基尼，五辆玛莎拉蒂… 交警打断他，指着手上机器说，我让你吹它。奥，好啊，这个机器非常牛逼，美国原装进口，十万美元一台，能测谎，还能拦截导弹… 后来朋友被警察带走了，说妨碍公务…“高！实在是高！”别人一边鼓掌，一边对我的发际线说道。A: 我分手了。 B: 为什么？ A: 她嫌我记性差！ B: 有多差！ A: 什么有多差？为什么要吵架呢？就不能心平气和的坐下来，打对方几巴掌吗？外貌不重要，爱情看的是感觉，可是人家对丑的没感觉。你就算失败了99次，也要再努力一次，凑个整数。你不丑的话，其实还挺漂亮的。完美的男友：不吸烟、不喝酒、不欺骗，也不存在。别看我平时对你总是漠不关心的样子，其实我背地里说了你好多坏话。对你竖起大拇指的人，不一定是在夸你，很可能是用炮在瞄准你。你以为向生活低头就好了？生活是想让你跪下！总有一天你会遇到一个妹子，她不要你的房也不要你的车，她也不要你。只要你成为一个废物，就没有人能利用你。你感情路上不顺吗？顺啊，怎么不顺，一路上都没什么人。不要对我忽冷忽热的，我体质不好，容易感冒。我曾经也有过小鹿乱撞，不过现在好了，它撞死了，现在我只想发财。我的未来不是梦，我的未来是噩梦。生活会让你苦上一阵子，等你适应以后，再让你苦上一辈子。有一种忧伤叫，我回你是秒回，你回我是轮回。如果把我的人生拍成一部电影，那么电影名我已经想好了，就叫穷极一生。今天买了一盆含羞草，回去怎么动也不害羞，回去问老板。老板说：“可能你买的这盆不要脸”。谁说我不会乐器?我退堂鼓打的可好了。我坦白我整过容——我的肚子是隆的。有没有听过“大猪说有，小猪说没有”的故事？年纪轻轻，就知道用脸吓唬人。我终于明白了一个道理：人丑就要多读书。难怪从小到大，大家都说，一看我就是读书的料。我饿了，果然美貌不能当饭吃。我应该漏出点小马脚来，好让你知道我喜欢你呀。我老了可怎么办啊，广场舞好难哦，我一个都学不会。有时候挺讨厌自己的，不会说话，太过善良，没什么心眼，还这么可爱。想问问你现在几点了，也没别的意思，就是提醒你现在不早了，也该喜欢我了。我要好好努力，要不然人家会说我除了长得好看，其他一无是处。小时候我以为全世界都喜欢我，长大后我才发现是全宇宙！同样的好吃懒做，可大熊猫和猪却完全不一样，归根到底是这是个看脸的世界。人还是要多出去走走，不然根本不知道在家里玩手机有多舒服。梦想还是要有的，不然哪天喝多了你跟人聊啥。头发都在为你减负，可你自己不争气。那一刻你懂了什么叫薄如蝉翼。你的发际线在清朝至少是个贝勒。头顶稀疏几棵草，随风飘舞左右摇。荷包蛋，地中海，黑暗中的一盏灯。热闹的马路不长草，聪明的脑袋不长毛。来，喝了这碗黑芝麻！除了人以外的动物胖起来都是可爱的~我可真是个败家子，上亿的家产，我一醒就没了。煎和熬都是变美味的方法，加油也是。越努力，体检报告越刺激。前世因，前世果，以后别找我。喜欢一个人，千万别表白，不然连室友的没得做了。最终钱包空了，脑门绿了，日子黄了，心里空了。这么正，专们帮脑子长歪的人正那么一下。前几天在街上看到了古天乐，我小声的叫了一声：古天乐。然后他也低声回了我一句嗨。我问他我能不能和他拍张照，他说可以。合影完后，他搂着我的肩膀说：最近电子烟卖得怎么样？我惊讶的看着他，然后他也愣了一下，说道：不好意思，我把你认成陈冠希了。形而上学，不行退学。]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>玩笑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记之育儿]]></title>
    <url>%2Fposts%2F1d980d3%2F</url>
    <content type="text"><![CDATA[家长暴露自己越多，孩子暴露自己也会越多，这跟交朋友是一样的，不要总想刺探人家隐私，而是要把自己的秘密和人家分享。温柔而坚定。比如家长要知道一些细节的东西无所谓，比如孩子撒个谎、抄个作业、违反个纪律，我觉得都是小事儿，但是来自生活当中最基本的一些规则，父母一定要坚持，不管你多想和她维持这个关系。孩子是父母的一个宝，但却是别人眼里的一根草。只有这根草有生命力，有价值，别人才会多看一眼，给机会。没有这种角色切换，始终认为自己是宝贝，别人应该溺爱自己，最后处境是被嫌弃而不自知，无价值却很自大，只剩他的父母悲伤地接纳他，共同谱写一出家庭悲剧。真教育，具有破除虚荣的功能，你绝不怕起点低。你有学习能力，你勤奋，终点总是在高处的。]]></content>
      <categories>
        <category>生活杂记</category>
      </categories>
      <tags>
        <tag>育儿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些名词]]></title>
    <url>%2Fposts%2F6bf34d15%2F</url>
    <content type="text"><![CDATA[鞣酸鞣酸系由五倍子中得到的一种鞣质。为黄色或淡棕色轻质无晶性粉末或鳞片；无臭，微有特殊气味，味极涩。溶于水及乙醇，易溶于甘油，几乎不溶于乙醚、氯仿或苯。其水溶液与铁盐溶液相遇变蓝黑色，加亚硫酸钠可延缓变色。在工业上，鞣酸被大量应用于鞣革与制造蓝墨水。鞣酸能使蛋白质凝固。人们把生猪皮、生牛皮用鞣酸进行化学处理，能使生皮中的可溶性蛋白质凝固。于是，本来放上几天就会发臭腐烂的生皮，变成了漂亮、干净、柔韧、经久耐用的皮革。选拔考试与诊断考试选拔考试，类似于中考高考，你考多少分不重要，59分算高还是低无所谓，关键取决于别人考的怎么样，你考59分，别人都在58分以下，你就有机会读名校；你考59分，人家考95分，对不起，你就回家干活，这叫选拔考试。除了中考高考以外，所有的考试都叫诊断考试（测验），即老师教了一个知识点，出一道题看看学生掌握得怎么样了。海姆立克急救法海姆立克教授是美国一位多年从事外科的医生。在临床实践中，他被大量的食物、异物窒息造成呼吸道梗阻致死的病例震惊了。在急救急诊中，医生常常采用拍打病人背部，或将手指伸进口腔咽喉去取的办法排除异物，其结果不仅无效反而使异物更深入呼吸道。他经过反复研究和多次的动物实验，终于发明了利用肺部残留气体，形成气流冲出异物的急救方法。1974年，他作了关于腹部冲击法解除气管异物的首次报告。异物堵塞在呼吸道中的事情在我们的生活中并不少见，前段时间就出现了类似的案列。所以由于异物堵塞在呼吸道中引起的后果还是很严重的。海姆立克急救法也叫海姆里克腹部冲击法（Heimlich Maneuver），是美国医生海姆里克先生发明的，也称为海氏手技。成人如果是成人，救护者站在受害者身后，从背后抱住其腹部，双臂围环其腰腹部，一手握拳，拳心向内按压于受害人的肚脐和肋骨之间的部位；另一手成掌捂按在拳头之上，双手急速用力向里向上挤压，反复实施，直至阻塞物吐出为止。3岁以下孩子如果是3岁以下孩子，应该马上把孩子抱起来，一只手捏住孩子颧骨两侧，手臂贴着孩子的前胸，另一只手托住孩子后颈部，让其脸朝下，趴在救护人膝盖上。在孩子背上拍1-5次，并观察孩子是否将异物吐出。婴儿5次拍背法：将患者的身体扶于救护员的前臂上，头部朝下，救护员用手支撑伤病者头部及颈部；用另一手掌掌根在伤病者背部两肩胛骨之间拍击5次。5次压胸法：如果堵塞物仍未排除，实施5次压胸法。使患儿平卧，面向上，躺在坚硬的地面或床板上，抢救者跪下或立于其足侧,或取坐位，并使患儿骑在抢救者的两大腿上，面朝前。抢救者以两手的中指或食指，放在患儿胸廓下和脐上的腹部，快速向上重击压迫，但要刚中带柔。重复之，直至异物排出。垃圾DNA人类大约有95%的DNA并不编码蛋白质，另外5%的DNA可以分成大约十万个功能单位，它们被称为基因。研究人员从对比结果中得到了一个惊人的模式：生物越复杂，垃圾DNA似乎就越重要。他们将酵母与更为复杂的蠕虫进行了比较，后者是一种多细胞生物，发现有40%的共有DNA没有被编码。随后，研究人员又将脊椎动物与昆虫进行了对比，这些生物比蠕虫更为复杂，结果发现，有超过66%的共有DNA包含有没有编码的DNA。如果这些“垃圾DNA”序列能在电脑屏幕上展现出一个像素数组或一个简单的图像，那么，外星生物曾干预人类DNA的设想就极可能是真的。人类DNA可容纳“外星兴衰史”编码戴维斯称，人类的DNA编码足够容纳一部像样的小说，或者一段外星文明的兴盛和衰落简史。垃圾DNA可以说是基因组的暗面，它将改变生物学的面貌，就像暗物质和暗能量改变宇宙学的面貌那样。它既不能给蛋白质编码、充当基因，也不能给RNA编码，也没有找到明显的与蛋白质等其他分子发生相互作用的迹象。当然，完全有可能它是行使了某种功能的，只不过是在“暗地下”进行，而我们还没有能力看到它行使功能的身影罢了。这些同时存在于不同哺乳动物DNA序列当中的保守非基因序列的相似性，甚至比同源的编码蛋白质、或者是编码RNA的基因还强。对于其中同时在至少12种物种当中发现的保守非基因序列，如果比较它们的核苷酸排列差异的话，还不及它们的蛋白质编码序列的核苷酸排列差异的一半！很多的“垃圾” DNA包含了回文结构，以此维持互补链之间的对称。在果蝇和家蚕里，对这些序列的分析表明，这些转座和散开的重复序列是高度非随机模式。这些模式反映出这些序列是在细胞调控之下，而不是无用或自私的垃圾DNA。 在关系很远的物种之间，例如大型偶蹄类哺乳动物和人，在主要组织相容性复合MHC-DRB基因里都有这些简单重复的(gt)n(ga)m DNA序列。如果这些序列真是垃圾，在数百万年的进化过程中就不可能保存下来。另一个研究表明，DNA包含了大范围的不可解释模式。Eugene Stanley博士报道这些模式不是随机改变的结果。一个基因上的一个位置将影响到100万碱基之外的核苷酸，这真是让人难以置信。因而遗传学家Moran认为，L1在人类进化中扮演着重要角色——增加遗传多样性。在嗜酸粒细胞衍生神经毒素、嗜酸细胞阳离子蛋白、IgM重排基因的可变区域、α-球蛋白基因、微管蛋白基因、4-N-乙酰半乳糖氨基转移酶、醛缩酶B基因、乙醛还原酶基因k轻链基因等等,都有基因內增强作用的描述。另一些研究证实非编码DNA作为沉默基因,对临近基因的转录起抑制作用。在成骨素基因、2-晶体蛋白基因、CD4基因、β-珠蛋白基因、神经胶质细胞粘连分子、神经元-神经胶质细胞粘连分子、血小板衍生的生长因子A链基因、肾素基因等等的研究中对此有描述。冒充者综合征冒充者综合征是指有些人即使获得了一些成绩与成果，但却特别不自信，甚至认为这不是自己应得的，而是冒充那些真正厉害的人而得到的。解决办法大声说出这种 “冒名顶替” 的感受。记下你的努力与成就。设置合理的目标与期望。劳伦斯魔咒1999年，经济学家劳伦斯总结出了一个“摩天大楼指数”。他发现，世界上所有的摩天大楼都与经济周期的波动有着紧密联系。摩天大厦的开工时间通常都是经济发展的鼎盛时期，而一旦大厦建成，经济危机便随之席卷而来。这一规律似乎屡试不爽，因此也被称为“劳伦斯魔咒”。双盲试验在试验过程中，测验者与被测验者都不知道被测者所属的组别（实验组或对照组），分析者在分析资料时，通常也不知道正在分析的资料属于哪一组。旨在消除可能出现在实验者和参与者意识当中的主观偏差和个人偏好。在大多数情况下，双盲实验要求达到非常高的科学严格程度。泡文化中国社会是一个人情社会，中国有一个很出名的词，就是「泡」。泡吧、泡妞，好兄弟「泡」在一起等等。「泡」这个字的偏旁是三滴水，这三滴水分别是时间、金钱和感情。中国人办事喜欢吃饭，需要先跟他们「泡」在一起,而且这仅仅是一个开始，说明你的事情有了可能性。有时候，只是为了见见，就跑很远的路去和对方一起吃一顿饭。没有别的目的，就是为了取悦对方，让他高兴，这样沟通才顺畅。达克效应达克效应（D-Keffect），全称为邓宁-克鲁格效应（Dunning-Krugereffect），指的是能力欠缺的人在自己欠考虑的决定的基础上得出错误结论。 通俗点解释，就是谢博德博士说的：“总有一些人认为自己什么都懂，或者低估自己不懂的事情。”这个效应是由社会心理学家邓宁和克鲁格联合发现的，他们通过对人们阅读、驾驶、下棋或打网球等各种技能的研究发现： 在幽默感、文字能力和逻辑能力上最欠缺的那部分人总是高估自己，当他们实际得分只有12%时，却认为自己的得分在60%以上。认知失调谢博德博士在演讲中说了一个故事：2017年飓风哈维登陆美国得克萨斯州休斯顿市，3天之内降雨50英寸，整个城市都陷入了一片汪洋之中。但在飓风登录前一周，谢博德博士就已经反复提醒休斯顿市民：根据观察，这次飓风到来可能会造成40到50英寸的降雨量。即便如此，市民们依然无所作为，并在一周后迎来了洪灾，造成了重大损失。为什么会这样？休斯顿当地虽然经常下雨，但之前全年的降雨量也才34英寸。谢博德博士所预言的“短时间内降雨40到50英寸”，已经超过了休斯顿市民能够理解的范围——几天之内就下完一整年的雨？这怎么可能！因为和自己过去的经验发生冲突，所以休斯顿市民说得最多的一句话就是：我看到了预警，但没想到真的会这么糟糕。这就是谢博德博士说的“认知失调”：新信息与已有的信念相矛盾，无法理解现有经验外的事物的时候，会让人产生失调的感觉，这种感觉会驱使一个人去寻找合理化的解释，让自己的认知达到一致。休斯顿的市民就是这样，他们面对无法理解的新信息，就去找一个合理化的解释，觉得灾情不会那么糟糕，忽视科学家的警告，最后造成重大损失。博傻理论以虚高的价格购买某样东西，希望能够以更高的价格将其卖给更大的傻瓜。]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>名词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何优化缓存中百万级并发的key]]></title>
    <url>%2Fposts%2F2bc946e8%2F</url>
    <content type="text"><![CDATA[引言这个问题实际上就是热点key问题，其实热点key问题说来也很简单，就是瞬间有几十万上百万，甚至更大的请求去访问redis上某个固定的key，从而压垮缓存服务的情情况。其实生活中也是有不少这样的例子，比如XX明星结婚。那么关于XX明星的Key就会瞬间增大，就会出现热点数据问题。PS:hot key和big key问题，大家一定要有所了解，非常重要。热点Key问题上面提到，所谓热点key问题就是，突然有几十万甚至更大的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到Redis单实例瓶颈（一般是10W OPS级别），或者物理网卡上限，从而导致这台redis的服务器Hold不住。那接下来这个key的请求，就会压垮你的服务。怎么发现热key方法一:凭借业务经验，进行预估哪些是热key其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。方法二:在客户端进行收集这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。方法三:在Proxy层做收集有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。方法四:用redis自带命令(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。方法五:自己抓包评估Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？如何解决目前业内的方案有两种：二级缓存（推荐）比如利用ehcache，或者guava-cache，或者一个HashMap或者List都可以。在你发现热key以后，把热key加载到JVM中（可以是堆内，也可以是堆外）。针对这种热key请求，会直接从JVM中取，而不会走到redis层。假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。现在假设，你的应用层有10台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有10000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。备份热点key这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。假设redis的集群数量为N，步骤如下图所示：说明: 不一定是2N，你想取4N，8N都可以，看要求。伪代码如下:说明：这种方案有一个很明显的缺点，就是缓存的维护代价非常大。假设有100个备份KEY，那么在删除或者更新时，也需要更新100个KEY，所以这种方案不是很推荐。业内方案OK，其实看完上面的内容，大家可能会有一个疑问。自动发信热点key，程序自动处理有办法在项目运行过程中，自动发现热点key，然后程序自动处理么？嗯，好问题，那我们来讲讲业内怎么做的。其实只有两步：监控热点key通知系统做处理正巧，前几天有赞出了一篇《有赞透明多级缓存解决方案（TMC）》，里头也有提到热点key问题，我们刚好借此说明。(1) 监控热点key在监控热点key方面，有赞用的是方式二：在客户端进行收集。在《有赞透明多级缓存解决方案（TMC）》中有一句话提到TMC 对原生jedis包的JedisPool和Jedis类做了改造，在JedisPool初始化过程中集成TMC“热点发现”+“本地缓存”功能Hermes-SDK包的初始化逻辑。也就说人家改写了jedis原生的jar包，加入了Hermes-SDK包。那Hermes-SDK包用来干嘛？OK，就是做热点发现和本地缓存。从监控的角度看，该包对于Jedis-Client的每次key值访问请求，Hermes-SDK 都会通过其通信模块将key访问事件异步上报给Hermes服务端集群，以便其根据上报数据进行“热点探测”。当然，这只是其中一种方式，有的公司在监控方面用的是方式五: 自己抓包评估。具体是这么做的，先利用flink搭建一套流式计算系统。然后自己写一个抓包程序抓redis监听端口的数据，抓到数据后往kafka里丢。接下来，流式计算系统消费kafka里的数据，进行数据统计即可，也能达到监控热key的目的。(2) 通知系统做处理在这个角度，有赞用的是上面的解决方案一:利用二级缓存进行处理。有赞在监控到热key后，Hermes服务端集群会通过各种手段通知各业务系统里的Hermes-SDK，告诉他们:”老弟，这个key是热key，记得做本地缓存。”于是Hermes-SDK就会将该key缓存在本地，对于后面的请求。Hermes-SDK发现这个是一个热key，直接从本地中拿，而不会去访问集群。除了这种通知方式以外。我们也可以这么做，比如你的流式计算系统监控到热key了，往zookeeper里头的某个节点里写。然后你的业务系统监听该节点，发现节点数据变化了，就代表发现热key。最后往本地缓存里写，也是可以的。通知方式各种各样，大家可以自由发挥。本文只是提供一个思路。总结希望通过本文，大家明白如何处理生产上遇到的热key问题。孤独烟如何优化缓存中百万级并发的key]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Java时的一些坑]]></title>
    <url>%2Fposts%2F45d267df%2F</url>
    <content type="text"><![CDATA[Arrays.asList 存在的坑阿里巴巴java开发规范说到使用工具类Arrays.asList()方法把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException。示例123456public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList(&quot;F&quot;, &quot;r&quot;, &quot;e&quot;, &quot;y&quot;, &quot;a&quot;);// list.clear();// list.remove(&quot;a&quot;); list.add(&quot;h&quot;);&#125;执行以上三个方法中任何一个都会报以下异常1234Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.AbstractList.add(AbstractList.java:148) at java.util.AbstractList.add(AbstractList.java:108) ……原因点进去Arrays.asList，实现如下：12345@SafeVarargs@SuppressWarnings(&quot;varargs&quot;)public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125;这个 ArrayList 并不是我们平时用的ArrayList。而是Arrays里面的一个内部类。如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable&#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; @Override public int size() &#123; return a.length; &#125; @Override public Object[] toArray() &#123; return a.clone(); &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) &#123; int size = size(); if (a.length &lt; size) return Arrays.copyOf(this.a, size, (Class&lt;? extends T[]&gt;) a.getClass()); System.arraycopy(this.a, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; @Override public E get(int index) &#123; return a[index]; &#125; @Override public E set(int index, E element) &#123; E oldValue = a[index]; a[index] = element; return oldValue; &#125; @Override public int indexOf(Object o) &#123; E[] a = this.a; if (o == null) &#123; for (int i = 0; i &lt; a.length; i++) if (a[i] == null) return i; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) if (o.equals(a[i])) return i; &#125; return -1; &#125; @Override public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(a, Spliterator.ORDERED); &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); for (E e : a) &#123; action.accept(e); &#125; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); E[] a = this.a; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = operator.apply(a[i]); &#125; &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; Arrays.sort(a, c); &#125;&#125;这个内部类没有add，clear，remove方法，所以抛出的异常其实来自于AbstractList。点进去就会发现抛出异常的地方，clear底层也会调用到remove所以也会抛出异常。如下：1234567public void add(int index, E element) &#123; throw new UnsupportedOperationException();&#125;public E remove(int index) &#123; throw new UnsupportedOperationException();&#125;填坑Arrays.asList()底层其实还是数组。如果使用了Arrays.asList()的话，最好不要使用其集合的操作方法。如果想要使用，List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;F&quot;, &quot;r&quot;, &quot;e&quot;, &quot;y&quot;, &quot;a&quot;))可以在外面这样包一层真正的ArrayList。StringBuilder 存在的坑1234567public static void main(String[] args) &#123; // StringBuffer一样 StringBuilder sb = new StringBuilder(); Object obj = null; sb.append(obj); System.out.println(sb);&#125;上面示例代码最后会打印 “null”，和你想要的可能不一样。123nullProcess finished with exit code 0原因参考 append() 方法，源码如下：123456789101112131415161718192021222324@Overridepublic synchronized StringBuffer append(Object obj) &#123; toStringCache = null; super.append(String.valueOf(obj)); return this;&#125;@Overridepublic StringBuilder append(Object obj) &#123; return append(String.valueOf(obj));&#125;/** * Returns the string representation of the &#123;@code Object&#125; argument. * * @param obj an &#123;@code Object&#125;. * @return if the argument is &#123;@code null&#125;, then a string equal to * &#123;@code "null"&#125;; otherwise, the value of * &#123;@code obj.toString()&#125; is returned. * @see java.lang.Object#toString() */public static String valueOf(Object obj) &#123; return (obj == null) ? "null" : obj.toString();&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些金融概念]]></title>
    <url>%2Fposts%2F6b8c9691%2F</url>
    <content type="text"><![CDATA[Q: 什么是戴维斯双击和戴维斯双杀？戴维斯双击: 在景气周期里，上市公司的业绩和估值同步上升。戴维斯双杀: 在不景气周期里，上市公司的业绩和估值同步下降。Q: 什么是LOF基金？LOF基金（Listed Open-Ended Fund），也称为“上市型开放式基金”。投资者既可以通过一级市场开放式基金账户申购与赎回基金份额，也可以在证券交易所二级市场买卖基金。不过，投资者如果是通过一级市场开放式基金账户申购的基金份额，想要在交易所二级市场卖出，则须办理转托管手续；同样，如果是在交易所二级市场买进的基金份额，想要在一级市场赎回，也要办理转托管手续。Q: 关于熊市大跌“在过去70多年历史上发生的40次股市暴跌中，即使其中39次我提前预测到，而且在暴跌前卖掉了所有的股票，我最后也会后悔万分的。因为即使是跌幅最大的那次股灾，股价最终也涨回来了，而且涨得更高。”——基金经理，彼得林奇Q：ROE与扣非ROEROE（Rate of Return on Common Stockholders’ Equity）即净资产收益率，是净利润与平均股东权益的百分比，反映的是股东权益的收益水平。该指标越高，则说明股东投资的收益越高。ROE=净利润/平均股东权益扣非ROE指的则是扣除非经常性损益后的净资产收益率，它与ROE的区别就在于计算时，剔除了分子里的非经常性损益。扣非ROE=（净利润-非经常性损益）/平均股东权益什么是非经常性损益？主要可以分为两类，一类是与公司经营业务无直接关系的损益，另一类则是虽然与经营业务相关，但是由于其性质、金额或发生频率，无法真实、公允地反映公司正常盈利能力的各项收入、支出。Q：打新打新，就是用资金参与新股申购，如果中签的话，就买到了即将上市的股票。网下的只有机构能申购，网上的申购本人就可以申购。打新分为打新股票和打新基金。打新技巧：联合申购，即几个股民可以把资金集合起来，形成一个小型的申购私募基金。申购冷门股，如果同时遇到2只或2只以上的新股认购，股民应该尽量避免热门股，选择冷门股。间接参与“打新股”，股民可以购买专门“打新股”的基金和其他理财产品。选择申购时间靠后的新股。如果几只新股接连发行，选择申购时间靠后的新股，那么选择时间靠后的新股机会大。有的放矢选新股，在选择新股时不要盲目。固定资产投资固定资产投资是以货币形式表现的、企业在一定时期内建造和购置固定资产的工作量以及与此有关的费用变化情况。包括房产、建筑物、机器、机械、运输工具、以及企业用于基本建设、更新改造、大修理和其他固定资产投资等。]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>金融概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句系列]]></title>
    <url>%2Fposts%2F53e650a7%2F</url>
    <content type="text"><![CDATA[拾句系列1拾句系列主要记录平常生活和工作中遇到的一些句子，当时有点感触，特此记录一下。记录还会继续，不过，随着时间的流逝，可能也会删除一部分或做一些修改。拾句-惊艳拾句-爱拾句-丧拾句-开解自己拾句-乐评拾句-现实拾句-思考拾句-玩笑拾句-念念不忘拾句-甜]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-思考]]></title>
    <url>%2Fposts%2Fef52fadf%2F</url>
    <content type="text"><![CDATA[001相比欧洲几个发达国家，美国在可物理感知的很多细节上都可以用粗砺来形容，但这是由美国的宏大以及持续变化的特性所决定的。相反，美国那不可见的核心是高度精致的， state-of-the-art.——饭否经营一段感情需要付出足够的时间和精力，而把握住一个稍纵即逝的机会，同样需要拿出全力以赴的姿态，否则，我们很有可能因为错失这一步，而错失整个向上发展的机会。和身边的95后聊天，他们不约而同地提到未来希望能实现两点：财务自由、做自己喜欢的事。我问他们，什么是你们喜欢的事？然后就冷场了。——乐鼠老人某先森处于职业艰难时期，压力极大，拼尽全力。但他说，现在我做的工作是我从大一开始就梦寐以求的工作。那就好。——Rena518并不是说鸿蒙OS现在有多强大多完善多牛逼，而是鸿蒙OS的想象空间太大了，是真正的星辰大海。家庭所灌输的理念，将在个体成长过程中不断地重复和强化，以致于成为一种集体信念。被社会所远离的群体/人，露出真实身份时遭遇到的往往是恐慌和排斥。只要不要脸，遍地是金钱。刘邦此人好坏暂且不说，就这份心性，的确少有。厚黑也罢凉薄也罢，舍得二字在他这里解释的再清楚不过。002*Some youngster has signs said “make love, not war”, trouble is they don’t look like they were capable doing either. *——里根Freedom is not free.War is an ugly thing, but not the ugliest of things: the decayed and degraded state of moral and patriotic feeling which thinks that nothing is worth a war, is much worse.——约翰·斯图尔特·密尔问题来了：什么是所谓的“标准密码”呢？人类是地球的“超级病毒”，而地球正在启动对人类的免疫反应。正如《血疫》中所说的那样，大自然有自我平衡的手段，它可能在试图除掉人类这种寄生生物的感染。从长度来看，至少有三种较长的周期，中的是人一辈子可以经历若干轮的，长的是人一辈子大概正好经历一轮，超长的是人一辈子只能经历一个完整周期中的某个片断。当他完成了自己的和解，也就完成了和世人的和解。最牛逼的商业决策不能算小账，考虑投入产出比时不能受限于局部的所谓理性，因为它最后不仅影响你这个公司能赚多少钱，而且影响你这个国家的钱能值多少钱。——饭否格特鲁德·斯泰因（Gertrude Stein）临死前的问题：“答案是什么？”——她没有得到任何回答，然后又问道：“既然这样，问题是什么？”003演化生物学诞生于1859年，以达尔文的《物种起源》发表为标志。但是，为什么长久以来把演化生物学应用到医学和其他与人类有关的科学中的进展如此迟缓？1941年，所有这种细菌都可以被青霉素杀死。到1944年，已经出现了一些突变株能分解青霉素。到今天，95%的葡萄球菌都对青霉素有一定程度的耐药性。对公众进行善意的道德劝诫即便受到欢迎，也很少有人会当真。要使人们为了公众利益合作，必须让不合作者付出代价。——迈特·瑞德利（Matt Ridley）和鲍比·娄（Bobbi Low）医学史反复证明，最容易染上致命性病原体的地方，不是妓院，也不是拥挤的血汗工厂，而是医院。伪装（mimic）种和模型（model）种之间的一场竞赛：伪装种变得更像模型种，而模型种则变得尽可能与伪装种有区别。很少接触毒素，那么一旦遭遇正常剂量的毒素，我们可能会措手不及。在零星的知识岛屿周围，还是茫茫无际的未知海域。我们遵循那些看似没有什么道理可言的文化习俗可能是十分明智的。许多减肥食谱的原理就是：在只有少数几种食物供应时，我们吃得要比品种丰富时少一些。004生活真正残酷的地方，不在于它的正面角色没有故事中那么好，而是它的反派角色并没有故事中那么坏。思想上的完美主义者，大多是思想上的巨人，行动上的矮子，如果你是个完美主义者，至少要先跨出第一步。认识了一个大牌投资公司里蛮不错的年轻人，他说将来如果出来创业，他会同时注册三个实体：第一个拍电影，第二个搞社区，第三个才是做投资。不要阿猫阿狗之类的案子都投，只投那些将来值得拍成电影的公司。——饭否正所谓“尽人事，待天命”。你是否已经用尽了全部力量？一本科幻小说。主要情节是人类可以控制局部时间流速，为了生产更多粮食，在一个封闭的空间里使时间加速来生产粮食，结果里边的生物开始加速进化影响人类。假设一年有365天，每天比前一天进步1/365，一年后就从 1 变成 2.714567482021973，十年后就会从 1 变成21727.333146076744，后者大概是前者的 8004 倍。这大概是我能想到的“你总是高估一年内可以做的事，也总是低估十年内能做到的事。”的数字化解释。——Muhouer“祖国终将选择那些选择了祖国的人”。——《如何在人生的马拉松中跑好清华这一程》，电机系教授于歆杰在清华2019级本科生开学典礼上的发言比「牺牲哪个人」或「牺牲哪个群体」更残酷的问题是「牺牲哪代人」？失利不仅是一个结果，还是一个过程。005机会与灾难总是相伴而生，有人把机会做成了灾难，也有人把灾难做成了机会。生活的进程总是靠两类事件不断积累起来的——可控事件和不可控事件。而所谓规划，就是把精力的大部分聚焦于可控的部分，把这部分做好；而所谓成功，无非就是在这个基础上加上不可控因素的运气。电话，邮件，现场约见，沙雕话术就是四个漏斗，每一层都过滤掉智商正常的人，最后留下的就是欠教育的。人一旦起了贪念，智商就会被按在地上摩擦，不管智商再高也没用，贪心属于降维打击。风险和收益从来就不成正比。时间和时间是不平等的。我认识一个人，他每做一件小事都像抓住最后一根救命稻草，有一天我回头看他，嚯，好家伙，他已经怀抱着一棵让我仰望的苍天大树了！科技行业有一个常识，你无法凭借同样的东西打败对手，取代安卓的也不是另外一个安卓。在汉字里，十是10，廿是20，卅是30。如果“卅”字添上一横，就成了“丗”，表示30年。“丗”字还有另一个写法——“世”，一世就是30年。所以古人说恍如隔世，其实是如隔30年，即便在“车、马、邮件都慢”的从前，30年的变化也足以让人恍然。我非常反对婚姻里，把爱人当亲人。我的亲人只有父母和女儿，而我的妻子，就是我的爱人，这个一直都不会变。——黄磊将爱情变为亲情，是阴险的潜意识诡计。006数据不会骗人，但是看到数据得到的结论会骗人。正确的前提，错误的断言，依然会是无效的推论。当数据涉及人们的选择时（比如当人们选择上大学、结婚或者要孩子时），就会出现“自选择偏差”。在这种情况下，对于做出不同选择的人进行比较的做法是靠不住的。户枢不蠹，流水不腐。户枢流水，不确永生。刷剧时常伴随着：社交孤立、吃垃圾食品、缺乏运动和睡眠，疯狂刷剧对大脑的影响与赌博相似——兰德尔·怀特我们的谦卑、沉默曾助长了偏见和歧视的存在。很多人没有自信，其实是在逃避责任，人生那些该吃的苦，他不想吃，他一定要天地许诺他一个轻松的富足人生，否则就是天地不对，要死给它看。天地会怎么回应？应该是：你爱哭就哭，爱死就死。其实天地不仁，永远按规律运行，连回应都不会给你。——连岳这个世界的大部分地带是灰色的，不存在一个简单答案。不应该有复杂的问题，也不应该有简单的答案。全球廉价服饰每年的流行款式其实都是在抄袭位于顶端的时尚，时尚界的顶端引领着潮流，普通人认为自己的衣着远离这些顶端，但事实上，早被这些顶端所决定。我们的思想观念何尝不是如此呢？——饭否007如果给出具体的值，虽然可以套公式或者用计算器求出结果。不过总是这样，一个人真正的数学能力反而会越来越弱。学好数学的诀窍只有一个，就是放弃死记硬背，与结果相比，更加重视过程。应该爱的意思，就是这是对的，应该的。我应该为你做，所以做。这种爱，是消耗的。越做越累，越累越不想做。而真的爱，则是自发的，情不自禁地想去做。我想为你做，所以做。这种爱，是滋养，越是付出，越是满足。满足家人，其实本来是一件很开心的事。对孩子好，对父母好，对伴侣好，多好的事。好听点说，这叫爱的表达。普通了说，这叫维护关系。往大了说，这叫功德无量。但你会发现，很多时候，我们不愿意满足对方。反而，有时候越是亲密，越是想打击对方。红楼梦说，人生是太虚幻境，真作假时假亦真。海子说，黑夜一无所有，为何给我安慰。梦和醒皆为生命的一部分，只在极少的情形下产生交集，人活一世，却得两生进化或者说演化就是随着时间而发生变化。不一定会更进步，但会更适应。热带雨林最重要的作业不是产氧，而是固碳。狮子与人之间没有信得过的盟约，狼和羊也没有共同的愿望。——荷马《伊利亚特》与其打10个坑，不如打一口井。A/B测试，反复试，找到问题所在，搞定它！008一层层剥开事物的表象，看到里面的本质，然后再从本质一层层往上走。用物理学的角度看待世界。——第一性原理“装备一代、研制一代、预研一代”。说的就是我们国家的军工装备，一贯采用的研发策略就是：生产和装备一代设备，同时研发下一代设备，再同时预先探索和研究下下一代设备。——饭否很多时候，可以为一个枯燥的证明补上一个几何类比，至简至美，以至于定理的真谛几乎一目了然。——马丁·加德纳(1973)Never trouble trouble till trouble troubles you. 麻烦没来找你，就别去自找麻烦。学习的快乐在于求知闻道，而不在进度条。那为什么这么多人执着于进度条呢，因为进度条意味着成就和利益。问题的核心是，即使今天你知道了这一点，却依然无法放下进度条这个执念。人类是唯一一种累积增加无用的知识会感到快感的生物。之前打过一个多月的狼人杀，所得的经验对胜负的帮助，远远不如一粒药物带来记忆力和思考能力的提升带来的帮助大。——饭否天之道，损有余而补不足；人之道则不然，损不足以奉有余。——《老子》凡有的，还要加给他，叫他有余；凡没有的，连他所有的，也要夺去。——马太福音25：29009没有金刚钻，不揽瓷器活。有多的大头，戴多的大帽子。中国的利率不会市场化。他们往往喜欢干货，喜欢文章里的粗体字和下划线，喜欢抓重点。结果以为自己看懂了，甚至觉得自己阅读速度快，然后在这个怪圈里耗费了自己大量的注意力和时间，过几年回头发现啥也没干成还找不到原因，搞不好还觉得自己特别勤奋。他们苦苦寻找的答案往往就在眼前，却总是看不到。结果不是找到了答案，而是找到了一个可以吐槽的地方，往往还沾沾自喜。社会工程学是一种非常高级的诈骗形式。诈骗本身只是操纵信息不对称，我知道你不知道，所以我搞你。而社会工程学在这个过程中加入了对人性的研究，我知道你知道，但是我依然可以搞你。在搞人这种事情上，社会工程学处在诈骗链的顶端。我们对灵魂伴侣的寻找也是同样的道理。每个人都在寻找不同的东西，我们可以称之为“魅力”。在我们见到的几十人、几百人或者几千人之中，少数人会脱颖而出。当我们看到魅力的迹象并鼓起勇气深入了解这个人时，我们通常会失望。坏消息是，这是正常的。好消息是，我们需要继续寻找。值得深思的消息是，对方很可能和我们有着同样的感受。在不确定的世界里，最优决策可遇不可求，最不坏的决策才是现实的追求，善用统计学即可达成最不坏的决策。做出不同选择的人本身可能就是不同的。根本没有可比性。我们渴望使不确定的世界变得更加确定，渴望控制我们无法控制的事物，渴望预测那些无法预测的现象。010复杂系统是由各种较小部件构成的系统，各部分有可能功能不同。随着这些不同的部分以各种方式交互组合，往往会出现更加整合的系统特征。木匠们常说一句话：“两次测量，一次切割。”关于数据，这句话应该改成“两次思考，一次计算”。我们总是能够挤得出时间来干这些“顺人性”的事，甚至做到废寝忘食，而不找任何借口。反人性的事基本上都是要付出很多，而且还要坚持很久。所有的人际关系，实则都是一种束缚——它们使别人变成奴隶，也使自己变成了奴隶。——公路商店一样的努力，不一样的结果。心血来潮和急风骤雨，最终都是没用的，生活奖赏的是木了吧唧一直坚持做，并且做的不错的人。一直很乐观，一直很谨慎。这才是长期生存之道。多年前认识的一个朋友和我讲起她行医的一次手术经历，她无不感慨地说，医生是个良心活。人长大了就觉得自己啥都懂了，小时候看的寓言故事都忘了，最常见的案例是小马过河、刻舟求剑、守株待兔。011财富与机会越来越多，按理抱怨应该变少。实际上，抱怨不会变少，甚至会更多。这就是因为错误的认识模型总有一定的心智市场，如果教育失败，更会普遍败坏人性。财富与机会放大了欲望，物质丰富又让人太容易生存，更容易变懒，欲望与能力的距离越来越大，其中都要靠抱怨填满。人陷入这种状态，世界越好，折磨自己的力量就越大。逃避辛苦，相当于追逐痛苦。软件设计构建有两种方法，一是使其尽可能简单，从而一目了然确定其中不存在缺陷；另一种方法则是使其极为复杂，以至于看不出什么明显的缺陷。——英国计算机专家 Hoare爬上去也许需要几年、几十年、甚至一辈子，放弃却只需要一瞬间。向死而生的意义是:当你无限接近死亡,才能深切体会生的意义。——海德格尔”有些人是渣不起来的，因为他的教养和骨子里的责任感不允许！“我想把”渣“改成”坏“，这个范围就更大了。慈不掌兵，义不守财。半导体之所以厉害就是因为它能变来变去，在某种条件下呈现某种特性，在另一种条件下迅速呈现出另一种特性。咖啡是切入中国市场上最挑剔的那群人的引子。这就像你和女生讨论星座和化妆品总是更容易进入她们的世界一点一样。其实这世界上，人也好，企业也好，基本上是个人都可以说说他不好，找缺点太容易，但是说好，却难。改变是最难的，改变也是最容易的。012法律过于复杂，以至于挫伤积极性。冯仑讲，中国要融入世界，必然会走向职业企业家的道路，需要极细分工的合作，大到法律，小到衣着和用词。当能失去的都失去了，你也就差不多长大了。——《狗十三》科技本应是为了造福人类而存在的，但现在很多公司把技术用在如何让人掏钱上，而且用的无声无息，潜移默化，打着技术无罪的旗号做着榨干人们最后一滴血的事情。荣格说：“人这一生都在整合自童年时候所形成的性格。”大学时候读到这句觉得兴奋，因为说的很有道理。这么多年过去了，猛然发现其实是一个无法挣脱的诅咒！三岁看老，古人诚不欺我在饭店，有几个女人因为皮蛋瘦肉粥里没有看到瘦肉和老板争执了起来。老板解释说，瘦肉都煮化了。其中一个女的越说越激动，竟然哭了起来。老板惊呆了，边给她纸巾边安慰她，说：“一碗粥而已，不至于啦，我再给你们送一个凉菜。”女人边哭边说：“我哭的不是这个，我难过的是，我已经三十几岁了还为一碗粥斤斤计较吵起来，这根本不是我要的人生！我什么时候才能不过这种日子！喜不喜欢，合不合适，在不在一起，能不能走下去，是四码事。没有谁离开谁就活不下去，也没几个人能抛下一切非要和一个人在一起。一个民族，千百万人里面才出一个天才；人世间数百万个闲暇的小时流逝过去，方始出现一个真正的历史性时刻，人类星光璀璨的时辰。——斯蒂芬·茨威格最孤独的人最亲切，最悲伤的人笑得最灿烂。013选择比努力更重要。钱是一切的开始，也是一切的结束。在网红经济时代，漏不漏脸，要不要以个人出镜作为打造 IP 的前提，都是有利有弊的，但王尼玛却是另外一种思路，他打造的 IP 和商业价值全部附属在那个头套而已。一代人终将老去，总有人正年轻。曾经在某一瞬间，我们都以为自己长大了。但是有一天，我们终于发现，长大的含义除了欲望，还有勇气、责任、坚强以及某种必须的牺牲。在生活面前我们还都是孩子，其实我们从未长大，还不懂爱和被爱。2500年前，释迦牟尼用“色即是空”解释他对这个世界的表象与本原之间的看法，现在，这个世界的规则依然没有改变，一切表象皆会回归本原。庄子云：鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。从最初的1公里，到3公里，而后稳定5公里，慢慢进步到6公里，今天一口气跑了8公里，再过一个礼拜挑战人生第一次10公里，加油，越努力，越幸运！你为工作付出24小时，付出你的肉体你的青春，你觉得付出了自己的所有，这些在别人眼里却是最不值钱的东西。因为肉体资源的付出，只要坐着加班就行了。最痛苦的事，往往是你自己以为自己很努力，结果却是瞎忙。014人是自我编织的意义之网的动物。——韦伯人生而自由，却无往不在枷锁之中。不要总想这去个岛上与世隔绝，想与世隔绝关上门就可以，想思考人生躺床上时脑子最清楚。很多人一个人旅行是想要忘记点什么，或者是奖励鼓励自己，证明自己独立，或者就是悲秋伤春了，想遗世而独立。你期待的一个人旅行根本解决不了任何问题，心里有事就去旅行放松不如解决了问题再去放松，因为旅行不会让你放松也不会让你升华。开始学一样东西时，总是想学最佳实践，不想走弯路。这思路当然是好的，只是不太现实。犯错不可怕，可怕的是犯错后没有纠错能力。有两句话，特别有道理。第一句叫：“贫穷限制了我的想象力”。第二句话叫：“我读书少，你别骗我”。最开始，我以为这两句是独立的。后来发现居然互为因果。不知道爱是有限的，这是爱的大风险。世界就像是个巨大的马戏团，它让你兴奋，却让我惶恐，因为我知道散场后永远是——有限温存，无限辛酸。葬礼部分，盖茨比的父亲向尼克展示了盖茨比（当时还叫盖兹）自己制订的每日训练计划表，从早上6点起床，一直到晚上9点睡觉，学习、锻炼、工作，井井有条，其中下午5点至6点，是练习演说、仪态。是的，确认了，他迷人的微笑，也是艰苦训练而来的。如果你生在北京的一个双知识分子家庭，已经战胜了全国95%的人口，绝大部分人终其一生已经不可能反杀你了。015很多时候，纠结一件事什么时候做和怎么做，比做完这件事本身要累得多。人一到群体中，智商就会下降。他们为了获得认同，可以抛弃是非，用智商去换取归属感。——《乌合之众》我们终此一生，就是要摆脱他人的期待，找到真正的自己。——《无声告白》当时的售货员是一份好工作。想拥有一样好东西，最好的办法是让自己配得上它。爱情不是永恒的，痛苦也一样。分手很煎熬，但是可以走出来。你还是可以相信些什么。绕过电线杆，大步往前走好了。其实我脾气超级差，只是害怕伤害到别人，没有去表达我的脾气。其实许多偏见，不是别人的偏见，只是你觉得有偏见。我欣赏文人风骨，但我其实更是丛林杀出来的战士。达成目的需要非常现实的手段，顶住压力光靠情怀是不行的。016人类学会的唯一教训是，人类不会吸取任何教训。很多时候创新不是资源堆出来的，而是因为资源不够被逼出来的。出了事情，新手司机打电话给朋友，老司机换了备胎直接上路。赌就是赌，不要拿结果来美化自己。更不要太当回事，把偶然好运气事件当真了，糟糕的结果也就不远了。一旦我们陷于嫉妒的情绪，我们往往只看到对方的长处，忽略了自己的优势。也无法看到自己拥有的资源。一般来说，越是复杂的方案，越不可靠。有没有著名数学问题被业余爱好者解决过？坦率地讲，没有——这就是对这个问题最简单的回答，也是最不具有误导性的回答。—-Timothy Gowers]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆内存和栈内存]]></title>
    <url>%2Fposts%2Fe896e76f%2F</url>
    <content type="text"><![CDATA[在Java中，您会看到大量关于堆内存和栈内存的引用，Java把内存分成两种，一种叫做栈内存，一种叫做堆内存。Java 堆内存(Heap Memory)Java运行时会在堆内存中将内存分配给对象和子类。每当我们创建任何对象时，它总是在堆空间中创建的。垃圾收集在堆内存上运行，以释放没有任何引用的对象使用的内存。堆空间中创建的任何对象都具有全局访问权限，可以从应用程序的任何位置引用。Java 栈内存(Stack Memory)Java栈内存用于执行线程。它们包含短期存活的方法的特定值，以及堆中方法对其他对象的引用。栈内存总是按后进先出顺序引用。每当调用一个方法时，都会在栈内存中创建一个新块，以便该方法保存本地基元值以及该方法对其他对象的引用。一旦方法结束，该块就不再使用，就可用于下一个方法。与堆内存相比，栈内存非常小。Java 程序中的堆内存和栈内存12345678910111213public class Memory &#123; public static void main(String[] args) &#123; // Line 1 int i = 1; // Line 2 Object obj = new Object(); // Line 3 Memory mem = new Memory(); // Line 4 mem.foo(obj); // Line 5 &#125; // Line 9 private void foo(Object param) &#123; // Line 6 String str = param.toString(); //// Line 7 System.out.println(str); &#125; // Line 8&#125;下图展示了上述程序的堆栈内存的引用程序执行的过程如下：一旦程序开始运行，它将会加载所有运行时类到堆内存，第1行发现了main方法，Java Runtime 创建了栈内存给main方法线程使用。第2行，我们创建了int型本地变量，它被创建并存储在栈内存的main方法里。第3行，我们创建一个对象，它创建在堆内存，栈内存保存它的引用。Memory 对象类似。第5行，我们调用foo方法，在栈内存头部创建一个内存块给foo方法使用，既然Java通过值传递，第6行，对象的新引用将在foo方法的栈内存块内创建。第7行，创建了字符串，它将会进入堆中的字符串常量池，foo方法的栈空间内将创建一个它的引用。foo方法在第8行终止。栈中分配的内存块将会被释放。在第9行，main方法终止，分配给main方法的栈内存将会被销毁。同时，程序也在这一行结束，因此 Java Runtime将会释放所有内存，然后结束程序的执行。堆内存和栈内存的区别应用程序的所有地方都会使用堆内存，而只有线程的执行会使用栈内存。当一个对象创建时，它存放在堆内存中，引用放在栈内存中。栈内存只包含本地原始变量和引用变量。存放在堆内存的对象是全局的，而栈内存中的不能被其他线程获取。栈中的内存管理是以后进先出的方式完成的，而堆内存中的内存管理更复杂，因为它是全局使用的。堆内存分为新生代、老年代等，更多信息可以参考Java 垃圾回收。栈内存是短暂存在的，而堆内存从应用程序执行的开始到结束都是存在的。我们可以使用-Xms和-Xmx来定义堆内存启动时的大小和内存最大值。可以使用-Xss去定义栈内存大小。当栈内存被填满的时候，将会抛出 java.lang.StackOverFlowError，然而，当堆内存被填满的时候，它会抛出 java.lang.OutOfMemoryError: Java Heap Space 错误。和堆内存大小相比，栈内存大小非常小。由于内存分配（LIFO）的简单性，与堆内存相比，栈内存非常快。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>堆栈内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型与内存管理]]></title>
    <url>%2Fposts%2F1f8d140b%2F</url>
    <content type="text"><![CDATA[如果您想弄清楚Java垃圾回收的的工作原理，那么理解JVM内存模型以及Java内存管理非常重要。 今天我们将探讨一下Java中的内存管理、JVM内存的组成以及如何监控和进行垃圾回收调优。Java（JVM）内存模型正如上图所示，JVM内存划分为多个不同部分。 从广义上讲，JVM堆内存内存在物理上分为两部分——新生代(Young Generation)和老年代(Old Generation)。Java 内存管理——年轻代年轻代是创建新对象的地方。 当年轻代被填满时，将会进行垃圾回收，称为Minor GC。 Young Generation分为三个部分——Eden内存空间和两个Survivor内存空间。关于新生代(Young Generation)的要点：大多数新创建的对象都位于Eden内存空间中。当Eden空间填满对象时，执行Minor GC并将所有幸存者对象移动到其中一个Survivor内存空间。Minor GC还会检查幸存者对象并将其移动到其他Survivor内存空间。 所以，在同一时间内，总有一个Survivor内存空间是空的。在多次GC循环后幸存的对象将被移动到老年代(Old Generation)。 通常，新生代(Young Generation)对象达到设定的年龄阈值后才有资格晋升到老年代(Old Generation)。Java 内存管理——老年代老年代(Old Generation)包含在多次Minor GC循环之后长期存在并存活下来的对象。通常，当老年代(Old Generation)被填满后，也会执行垃圾回收，称为Major GC，通常花费时间较长。停顿(Stop the World Event)所有垃圾回收都是“Stop the World”事件，因为所有应用程序线程都会停止，直到操作完成。由于新生代(Young Generation)主要保存短暂存活的对象，因此Minor GC非常快，应用程序不会受此影响。然而，Major GC需要花费很长时间，因为它会检查所有活动对象。 Major GC应该最小化，因为它会使您的应用程序在垃圾回收期间没有响应。 因此，如果您有响应式应用程序而且进行了大量Major GC，您会注意到超时错误。垃圾收集器进行垃圾回收时持续的时间取决于采用的垃圾回收策略。为了避免高响应应用程序中的超时，很有必要去监控、调整垃圾收集器。Java 内存模型——永久代永久代(Permanent Generation或Perm Gen)包含JVM描述应用程序中类和方法所需的应用程序元数据。 请注意，Perm Gen不是Java堆内存的一部分。Perm Gen在运行时，由JVM根据应用程序使用的类填充。 Perm Gen还包含Java SE库中的类和方法。 Perm Gen中的对象在完全垃圾回收(full garbage collection)中将会被回收。Java 内存模型——方法区方法区(Method Area)属于Perm Gen一部分，用于存储类结构(运行时常量和静态变量)以及方法和构造函数的代码。Java 内存模型——内存池内存池(Memory Pool)由JVM内存管理器创建，支持创建不可变对象( immutable object)池。比如 String池。 内存池可以属于Java堆内存或Perm Gen，具体取决于JVM内存管理器实现。Java 内存模型——运行时常量池运行时常量池(Runtime constant pool)是类中常量池的每类运行时表示形式。它包含类运行时常量和静态方法。 运行时常量池是方法区的一部分。Java 内存模型——栈内存Java栈内存(Stack Memory)用于执行线程。 它们包含方法特定的值，这些值是短暂存活的，并且引用了堆内存中被方法引用的其他对象。 堆内存和栈内存Java 内存管理——Java 堆内存开关Java提供了许多内存开关，我们可以用来设置内存大小和它们的比率。一些常用的内存开关是：VM SWITCHVM SWITCH DESCRIPTION-Xms在 JVM 启动时设置初始堆内存大小。-Xmx设置堆内存空间大小的最大值。-Xmn设置新生代内存空间大小，剩下的空间大小就是老年代的内存空间大小。-XX:PermGen设置永久代初始内存空间大小-XX:MaxPermGen设置永久代内存空间大小的最大值。-XX:SurvivorRatio设置Eden内存空间和Survivor内存空间的比例，例如，如果新生代的空间大小是10M，而-XX:SurvivorRatio=2，那么Eden内存空间大小为5M，两个Survivor内存空间大小将分别为2.5M。-XX:SurvivorRatio 默认值为8。-XX:NewRatio设置老年代和新生代空间大小的比例。 默认值为 2.大多数情况下，上面的选项足够使用了，但是如果您想使用其他选项，可以参考JVM 选项。Java 内存管理——垃圾回收Java垃圾收集是从内存中标识、删除未使用对象以及释放空间的过程。 Java编程语言的特色之一是自动垃圾回收，与其他编程语言(如C)不同，它们的内存需要手动分配和释放。垃圾收集器(Garbage Collector)是在后台运行的程序(守护线程)，它检查内存中的所有对象，并找出程序所有未被引用的对象。 然后删除所有未被引用的对象，并释放空间以分配给其他对象。垃圾回收的一个简单实现可以分为三步：标记——这是垃圾回收的第一步，将识别出哪些对象正在使用，哪些对象没有在使用。普通删除——垃圾收集器将删除未被使用的对象，然后回收内存空间分配给其他对象使用。压缩删除——为了获得更好的性能，在删除未被使用的对象后，可以将所有幸存的对象移动到一起。 这会提高给新对象分配内存时的性能。标记-删除方法的缺点它效率不高，因为大多数新创建的对象都将被闲置在多个垃圾收集周期中使用的对象很有可能在未来的垃圾收集周期中继续使用。这是因为堆内存分为新生代(Young Generation)和老年代(Old Generation)，Java垃圾回收是分代的。 上文中已经解释过如何根据Minor GC和Major GC扫描对象并将其从一个空间移动到另一个空间。Java 内存管理——垃圾回收的类型在应用程序中我们可以使用5种垃圾回收类型，我只需要调整JVM开关即可为我们的应用程序选择垃圾回收策略。Serial GC (-XX:+UseSerialGC): Serial GC使用简单的标记 - 清除 - 整理(mark-sweep-compact)方法用于新生代和老年代的垃圾回收，即Minor GC和Major GC。Serial GC在客户端机中非常有用，例如我们的应用程序比较独立，而且CPU比较小。 它适用于内存占用少的小型应用程序。Parallel GC (-XX:+UseParallelGC): Parallel GC与Serial GC相同，不同的是Parallel GC使用N(N是系统中的CPU核心数)个线程进行新生代的垃圾回收。 我们可以使用-XX：ParallelGCThreads = nJVM 选项来控制线程数。并行垃圾收集器也称为吞吐量收集器，因为它使用多个 CPU 来提升 GC 性能。 Parallel GC使用单个线程进行老年代的垃圾回收。Parallel Old GC (-XX:+UseParallelOldGC): 和Parallel GC相同，不同的是它采用多线程进行老年代和新生代的垃圾回收。Concurrent Mark Sweep (CMS) Collector (-XX:+UseConcMarkSweepGC): CMS收集器也称为并发低暂停收集器。 在老年代进行垃圾回收时，CMS收集器尝试通过与应用程序线程同时执行大多数垃圾收集工作来最小化由于垃圾收集而导致的暂停。新生代的CMS收集器与并行收集器使用相同的算法。 此垃圾收集器适用于我们无法忍受暂停时间过长的响应式应用程序。 我们可以使用-XX:ParallelCMSThreads=nJVM选项调整CMS收集器中的线程数 。G1 Garbage Collector (-XX:+UseG1GC): Garbage First 或G1垃圾收集器从 Java 7 开始支持，它的目标是取代CMS收集器。 G1收集器是并行，并发和增量压缩的低暂停垃圾收集器。G1收集器不像其他收集器那样工作，并且没有新生代和老年代的概念。 它将堆空间划分为多个大小相等的堆区域。 当进行垃圾回收时，它首先收集具有较少实时数据的区域，因此称为“Garbage First”。 您可以在Oracle Garbage-First Collector 文档中找到有关它的更多详细信息。Java 内存管理——Java 垃圾回收监控我们可以使用Java命令行以及UI工具来监视应用程序的垃圾收集活动。jstat我们可以使用jstat命令行工具来监控JVM 内存和垃圾收集活动。 它适配标准JDK，因此您无需执行任何其他操作即可使用它。在使用jstat命令之前，你需要知道 Java 应用的进程id。你可以使用ps -ef | grep java命令来获取进程id。假如我的进程id是9582，那么我就可以使用jstat -gc 9582 1000来查看垃圾回收的信息。命令中最后一个参数是每个输出之间的时间间隔，因此它将每1秒打印一次内存和垃圾收集数据。123456789$ jstat -gc 9582 1000 S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT1024.0 1024.0 0.0 0.0 8192.0 7933.3 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8026.5 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8030.0 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8122.2 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8171.2 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 48.7 0.0 8192.0 106.7 42108.0 23401.3 20480.0 19990.9 158 0.275 40 1.381 1.6561024.0 1024.0 48.7 0.0 8192.0 145.8 42108.0 23401.3 20480.0 19990.9 158 0.275 40 1.381 1.656每一列的含义如下：S0C and S1C: Survivor0 和 Survivor1当前的内存大小，以 KB 计。S0U and S1U: Survivor0 和 Survivor1当前已使用的内存大小，以 KB 计。注意其中一个 survivor 一直是空的。EC and EU: Eden 区当前的内存大小和 Eden 区当前已使用的内存大小，以 KB 计。注意 EU 的大小会一直增大直到接近EC的大小，此时会执行Minor GC，然后EU 的大小就降低了。OC and OU: 老年代当前的大小和已使用的大小，以 KB 计。PC and PU: 永久代当前的大小和已使用的大小，以 KB 计。YGC and YGCT: YGC 代表在新生代 GC 发生的次数；YGCT 代表新生代执行GC的累计时间。注意，这两个值都在同一行中增加，因为 Minor GC 会使得 EU 值下降。FGC and FGCT: FGC 代表 Full GC 发生的次数；FGCT Full GC 发生的累计时间。 注意，与新生代 GC 相比， Full GC 花费时间太长。GCT: GC 操作的总累计时间。注意，它是 YGCT 和 FGCT 列值的总和。jstat的优点是它也可以在没有 GUI 的远程服务器上执行。请注意，根据-xmn10mjvm选项的限制，S0C、S1C和EC的总和为10M。可视化的 Java VisualVM如果您想在GUI中看到内存和GC操作，那么可以使用jvisualvm工具。Java VisualVM也是JDK的一部分，不需要单独下载。只需在终端中运行jvisualvm命令即可启动Java VisualVM应用程序。启动后，您需要从tools -&gt; plugins 选项安装VisualGC插件，如下图所示。安装完VisualGC之后，只需打开左侧列中的应用程序，然后转到VisualGC部分。您将得到一个JVM内存和垃圾收集细节的映像，如下图所示。垃圾回收调优Java垃圾回收调优应该是提高应用程序吞吐量的最后选项，只有当GC时间较长导致应用程序超时时，才看到性能下降。假如你在日志中看到java.lang.OutOfMemoryError: PermGen space错误，你可以通过-XX:PermGen和-XX:MaxPermGen来监控和提供永久代内存。你也可以使用-XX:+CMSClassUnloadingEnabled，然后观察在CMS 垃圾收集器的性能。假如你看到很多 Full GC 操作，你可以提高老年代内存大小。总的来说，垃圾回收调优需要花费大量的精力和时间，而且没有硬性和快速的规则。您需要尝试不同的选项并进行比较，从中找出最适合您的选项。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis进阶教程]]></title>
    <url>%2Fposts%2Fc275b75f%2F</url>
    <content type="text"><![CDATA[Redis 数据备份与恢复数据备份Redis save 命令用于创建当前数据库的备份。该命令将在 redis 安装目录中创建dump.rdb文件。创建 redis 备份文件也可以使用命令 bgsave，该命令在后台执行。语法save实例12127.0.0.1:6379&gt; save OK恢复数据如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用config命令，如下所示：123127.0.0.1:6379&gt; config get dir1) &quot;dir&quot;2) &quot;/usr/local/redis-5.0.5/src&quot;Redis 安全我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。语法auth password实例12345678910111213127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;&quot;127.0.0.1:6379&gt; config set requirepass &quot;redis&quot;OK127.0.0.1:6379&gt; config get requirepass(error) NOAUTH Authentication required.127.0.0.1:6379&gt; auth redisOK127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;redis&quot;127.0.0.1:6379&gt;Redis 性能测试Redis 性能测试是通过同时执行多个命令实现的。语法redis-benchmark [option] [option value]注意：该命令是在 redis 的目录下执行的，而不是 redis客户端的内部指令。实例同时执行 10000 个请求来检测性能:12345678910111213141516171819$ ./redis-benchmark -n 10000 -qPING_INLINE: 104166.66 requests per secondPING_BULK: 106382.98 requests per secondSET: 105263.16 requests per secondGET: 105263.16 requests per secondINCR: 103092.78 requests per secondLPUSH: 106382.98 requests per secondRPUSH: 105263.16 requests per secondLPOP: 108695.65 requests per secondRPOP: 102040.82 requests per secondSADD: 106382.98 requests per secondHSET: 107526.88 requests per secondSPOP: 97087.38 requests per secondLPUSH (needed to benchmark LRANGE): 101010.10 requests per secondLRANGE_100 (first 100 elements): 106382.98 requests per secondLRANGE_300 (first 300 elements): 109890.11 requests per secondLRANGE_500 (first 450 elements): 107526.88 requests per secondLRANGE_600 (first 600 elements): 99009.90 requests per secondMSET (10 keys): 101010.10 requests per second序号选项描述默认值1-h指定服务器主机名127.0.0.12-p指定服务器端口63793-s指定服务器 socket4-c指定并发连接数505-n指定请求数100006-d以字节的形式指定 SET/GET 值的数据大小27-k1=keep alive 0=reconnect18-rSET/GET/INCR 使用随机 key, SADD 使用随机值9-P通过管道传输&lt;numreq&gt;请求110-q强制退出 redis。仅显示 query/sec 值11–csv以 CSV 格式输出12-l生成循环，永久执行测试13-t仅运行以逗号分隔的测试命令列表。14-IIdle 模式。仅打开 N 个 idle 连接并等待。123$ ./redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -qSET: 104166.66 requests per secondLPUSH: 105263.16 requests per second以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。Redis 客户端连接Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送Socket编程中，TCP_NODELAY选项是用来控制是否开启Nagle算法，该算法是为了提高较慢的广域网传输效率，减小小分组的报文个数，完整描述：该算法要求一个TCP连接上最多只能有一个未被确认的小分组，在该小分组的确认到来之前，不能发送其他小分组。最大连接数在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。1234127.0.0.1:6379&gt; config get maxclients1) "maxclients"2) "10000"127.0.0.1:6379&gt;1$ ./redis-server --maxclients 100000 # 在服务启动时设置最大连接数为 100000客户端命令序号命令描述可用版本时间复杂度1client list以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据。返回的信息含义参见&gt;=2.4.0O(N)， N 为连接到服务器的客户端数量。2client setname1. 为当前连接分配一个名字。这个名字会显示在client list命令的结果中， 用于识别当前正在与服务器进行连接的客户端。获取通过client setname 命令设置的服务名称。2. 名字使用 Redis 的字符串类型来保存， 最大可以占用 512 MB 。3. 另外， 为了避免和client list命令的输出格式发生冲突， 名字里不允许使用空格。4. 要移除一个连接的名字， 可以将连接的名字设为空字符串 &quot;&quot; 。5. 新创建的连接默认是没有名字的。在 Redis 应用程序发生连接泄漏时，为连接设置名字是一种很好的 debug 手段。&gt;=2.6.9O(1)3client getname返回client getname命令为连接设置的名字。因为新创建的连接默认是没有名字的， 对于没有名字的连接， client getname返回空白回复。&gt;=2.6.9O(1)4client pause挂起客户端连接，指定挂起的时间以毫秒计&gt;=2.9.5O(1)5client kill当指定的客户端存在，且被成功关闭时，返回 OK 。关闭地址为 ip:port 的客户端。ip:port 应该和client-list)命令输出的其中一行匹配。因为 Redis 使用单线程设计，所以当 Redis 正在执行命令的时候，不会有客户端被断开连接。&gt;=2.4.0O(N) ， N 为已连接的客户端数量。6client id返回当前连接的id&gt;=5.0.0O(1)实例123456789127.0.0.1:6379&gt; client getname(nil)127.0.0.1:6379&gt; client setname freya-connectionOK127.0.0.1:6379&gt; client getname"freya-connection"127.0.0.1:6379&gt; client listid=7 addr=127.0.0.1:56661 fd=8 name= age=265815 idle=261969 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribeid=1012 addr=127.0.0.1:51537 fd=9 name=freya-connection age=647 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client12345678910127.0.0.1:6379&gt; client setname # 只用空格是不行的！(error) ERR Unknown subcommand or wrong number of arguments for 'setname'. Try CLIENT HELP127.0.0.1:6379&gt; client setname "" # 必须双引号显示包围OK127.0.0.1:6379&gt; client getname(nil)127.0.0.1:6379&gt; client listid=7 addr=127.0.0.1:56661 fd=8 name= age=265951 idle=262105 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribeid=1012 addr=127.0.0.1:51537 fd=9 name= age=783 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client127.0.0.1:6379&gt;Redis client list 命令返回值命令返回多行字符串，这些字符串按以下形式被格式化：每个已连接客户端对应一行（以 LF 分割）每行字符串由一系列 属性=值 形式的域组成，每个域之间以空格分开以下是域的含义：域含义addr客户端的地址和端口fd套接字所使用的文件描述符age以秒计算的已连接时长idle以秒计算的空闲时长flags客户端flag(见下表)db该客户端正在使用的数据库IDsub已订阅频道的数量psub已订阅模式的数量multi在事务中被执行的命令数量qbuf查询缓存的长度(0 表示没有查询在等待)qbuf-free查询缓存的剩余空间(0 表示没有剩余空间)obl输出缓存的长度oll输出列表的长度(当输出缓存没有剩余空间时，回复被入队到这个队列里)omem输出缓存的内存占用量events文件描述符事件(见下文)cmd最近一次执行的命令客户端 flag 可以由以下部分组成：域含义O客户端是 monitor 模式下的附属节点 (slave)S客户端是一般模式下 (normal) 的附属节点M客户端是主节点 (master)x小写x，客户端正在执行事务b客户端正在等待阻塞事件i客户端正在等待 VM I/O 操作 (已废弃)d一个受监控 (watched) 的键已被修改， exec命令将失败c在将回复完整写出来之后，关闭连接u客户端未被阻塞 (unblocked)A尽可能快地关闭连接N未设置任何 flag文件描述符事件文件描述符事件含义r客户端套接字（在事件 loop 中）是可读的（readable）w客户端套接字（在事件 loop 中）是可写的（writeable）注意为了 debug 的需要，经常会对域进行添加和删除，一个安全的 Redis 客户端应该可以对 CLIENT LIST 的输出进行相应的处理（parse），比如忽略不存在的域，跳过未知域，诸如此类。实例123127.0.0.1:6379&gt; client listid=7 addr=127.0.0.1:56661 fd=8 name= age=150289 idle=146443 flags=P db=0 sub=1 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=subscribeid=10 addr=127.0.0.1:64043 fd=9 name= age=525 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=clientRedis 管道技术Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。实例123456789$ (echo -en &quot;auth pwd\r\n PING\r\n SET freya redis\r\nGET freya\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n&quot;; sleep 10) | nc localhost 6379+OK+PONG+OK$5redis:1:2:3以上命令采用auth pwd授权，采用PING命令查看redis服务是否可用， 之后我们设置了 freya 的值为 redis，然后我们获取 freya 的值并使得 visitor 自增 3 次。管道技术的优势管道技术最显著的优势是提高了 redis 服务的性能。Redis 分区分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。分区的优势通过利用多台计算机内存的和值，允许我们构造更大的数据库。通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。分区的不足涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。涉及多个key的redis事务不能使用。当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。分区类型Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。范围分区最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各种对象的映射表，通常对Redis来说并非是好的方法。哈希分区另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。Java 使用 Redis安装开始在 Java 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 Java redis 驱动，且你的机器上能正常使用 Java。连接到 redis 服务123456789101112import redis.clients.jedis.Jedis;public class RedisTest &#123; public static void main(String[] args) &#123; // 连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;)； //验证密码 jedis.auth(&quot;redis&quot;); // 查看服务是否运行 System.out.println(&quot;服务正在运行: &quot; + jedis.ping()); &#125;&#125;]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>进阶教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis命令5]]></title>
    <url>%2Fposts%2Fe33ec7a3%2F</url>
    <content type="text"><![CDATA[Redis 服务器命令Redis 服务器命令主要是用于管理 redis 服务。实例如何获取 redis 服务器的统计信息：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141127.0.0.1:6379&gt; info# Serverredis_version:5.0.5redis_git_sha1:00000000redis_git_dirty:0redis_build_id:6d3bf9e511543b78redis_mode:standaloneos:Darwin 18.6.0 x86_64arch_bits:64multiplexing_api:kqueueatomicvar_api:atomic-builtingcc_version:4.2.1process_id:65254run_id:3d46ae00173412623b99d81100173246db224357tcp_port:6379uptime_in_seconds:497757uptime_in_days:5hz:10configured_hz:10lru_clock:4627403executable:/Users/asher/Desktop/redis-5.0.5/src/./redis-serverconfig_file:# Clientsconnected_clients:2client_recent_max_input_buffer:2client_recent_max_output_buffer:0blocked_clients:0# Memoryused_memory:1070656used_memory_human:1.02Mused_memory_rss:1712128used_memory_rss_human:1.63Mused_memory_peak:1070656used_memory_peak_human:1.02Mused_memory_peak_perc:100.03%used_memory_overhead:1054744used_memory_startup:987824used_memory_dataset:15912used_memory_dataset_perc:19.21%allocator_allocated:1024592allocator_active:1674240allocator_resident:1674240total_system_memory:8589934592total_system_memory_human:8.00Gused_memory_lua:37888used_memory_lua_human:37.00Kused_memory_scripts:0used_memory_scripts_human:0Bnumber_of_cached_scripts:0maxmemory:0maxmemory_human:0Bmaxmemory_policy:noevictionallocator_frag_ratio:1.63allocator_frag_bytes:649648allocator_rss_ratio:1.00allocator_rss_bytes:0rss_overhead_ratio:1.02rss_overhead_bytes:37888mem_fragmentation_ratio:1.67mem_fragmentation_bytes:687536mem_not_counted_for_evict:0mem_replication_backlog:0mem_clients_slaves:0mem_clients_normal:66616mem_aof_buffer:0mem_allocator:libcactive_defrag_running:0lazyfree_pending_objects:0# Persistenceloading:0rdb_changes_since_last_save:0rdb_bgsave_in_progress:0rdb_last_save_time:1564893311rdb_last_bgsave_status:okrdb_last_bgsave_time_sec:0rdb_current_bgsave_time_sec:-1rdb_last_cow_size:0aof_enabled:0aof_rewrite_in_progress:0aof_rewrite_scheduled:0aof_last_rewrite_time_sec:-1aof_current_rewrite_time_sec:-1aof_last_bgrewrite_status:okaof_last_write_status:okaof_last_cow_size:0# Statstotal_connections_received:8total_commands_processed:214instantaneous_ops_per_sec:0total_net_input_bytes:9198total_net_output_bytes:101508instantaneous_input_kbps:0.00instantaneous_output_kbps:0.00rejected_connections:0sync_full:0sync_partial_ok:0sync_partial_err:0expired_keys:0expired_stale_perc:0.00expired_time_cap_reached_count:0evicted_keys:0keyspace_hits:66keyspace_misses:7pubsub_channels:1pubsub_patterns:0latest_fork_usec:966migrate_cached_sockets:0slave_expires_tracked_keys:0active_defrag_hits:0active_defrag_misses:0active_defrag_key_hits:0active_defrag_key_misses:0# Replicationrole:masterconnected_slaves:0master_replid:b65a8be1272fab6dfd7b73b0c51e75d06e370c79master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0# CPUused_cpu_sys:36.666434used_cpu_user:23.420130used_cpu_sys_children:0.044782used_cpu_user_children:0.009325# Clustercluster_enabled:0# Keyspacedb0:keys=6,expires=0,avg_ttl=0127.0.0.1:6379&gt;Redis time 命令用于返回当前服务器时间。可用版本 &gt;= 2.6.0语法time返回值一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒数。实例123127.0.0.1:6379&gt; time 1) &quot;1564908791&quot;2) &quot;483839&quot;Redis lastsave 命令返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。可用版本 &gt;= 1.0.0语法lastsave返回值一个 UNIX 时间戳。实例12127.0.0.1:6379&gt; lastsave (integer) 1564893311]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇闻异事]]></title>
    <url>%2Fposts%2Fa0f75295%2F</url>
    <content type="text"><![CDATA[为什么饮料瓶上要写「此瓶仅用于灌装本产品，请勿重复使用」？这些都是有人用血泪证明出来的。举个栗子，知道现在为什么沐浴露上面标注:请勿吞食吗？因为以前在美国，有一个人，专门钻法律空子的那种，有一天忽然想到，这个沐浴露上面没有标注不能吞食，发财的机会来了，然后就喝了，送到医院洗了胃，告了卖沐浴露的公司，他们公司赔了几个亿。。。。所以以后的沐浴露标的都有请勿吞食。不过刚才我看了海飞丝没有备注，请勿模仿，因为在我国，食品安全只赔十倍。也就几百块。不要模仿。知乎仙授为什么饮料瓶上要写「此瓶仅用于灌装本产品，请勿重复使用」？为什么录取通知书要用EMS？国内快递只有邮政EMS可以全国范围内无差别覆盖的投送，用顺风的话，你家住在江浙沪好办，你家住在祖国某个边疆偏远山区，顺风就傻眼了。并且邮政可以去一些别的快递送不到的地方（部队等）。知乎夏东为什么录取通知书要用EMS？排位为什么要选不一样的英雄相同的英雄，相同的技能，如果一旦出现经济等级差，那逆转几乎是不可能的。不仅如此，即便是相同水平的玩家，在使用相同英雄博弈的时候也会因为种种原因失误，一旦被单杀，这种耻辱是很难让己方队友接受的，会有种“你看人家的李白”这种冷嘲热讽，被单杀的队友也会很沮丧，甚至怄气，进而产生消极游戏心理。这可能造成初级玩家对游戏的热忱程度大打折扣。佚名排位为什么要选不一样的英雄人间大炮一级准备——出自《恐龙特急克塞号》,是消灭变异怪物的必杀武器。下图是金毛大总统2015年还没当总统时候发的，之后就……玄幻小说里面，为什么主角在得罪大势力之后，大势力明知他是天才，却总是只派出境界比他只高一线的狗腿子去追杀，结果屡屡让他惊险地跨境界反杀呢？对于那些大势力而言，敢动他们的天才见过太多，而事实每次都证明对付这种人，境界仅高一线就足够了，遇上一个就兴师动众一番，非常不值。为什么手机最后 1% 的电量有时很耐用？工程师头发都掉光了也没办法，只好产品和UI的同学上喽。工程师：现在估计还有10%的电了，现在外界挺冷的，我也拿不准电池还有多少电了。产品：让用户赶紧充电去啊UI：我马上让它显示只剩1%用户：我靠，1%了，充电知乎李明阳为什么手机最后 1% 的电量有时很耐用？自行车是怎么保持平衡的？自行车，从一开始就不是依托缜密的物理学、数学理论公式设计出来的。它的诞生，完全依靠人类的生活经验！不过存在即合理，自行车不仅存在了快两个世纪，而且还不断 “ 进化 ”，到现在已经可以不借助人力自己保持平衡了，如此神奇的现象，肯定应该有个能用来解释它的科学依据吧？于是乎，科学家们开始倒回去反推它的设计原理，结果发现，诶？这玩意儿玄学了，居然没法儿用现有的科学理论去解释！差评君自行车是怎么保持平衡的？酒店里的床尾有一块其他颜色的布盖是干什么用的好一点酒店里的床上通常都在床尾有一块其他颜色的布盖着，这块布除了有装饰作用外，还有一个主要的作用就是搭脚用的，因为很多人不脱鞋倚靠在床上休息。关于抗生素的使用目前抗生素的总量大部分是用到了饲养的动物之中，占全世界总用量的 70% 到 80%，其目的不是避免动物感染，仅仅是为了给动物增重，平均增重 10% 到 15% 。所以说我们每天几乎都在吃进抗生素这点是没毛病的，只是其风险可能我们都没有去真正衡量过。关于高铁降速一个长久的错误印象，高铁降速不是因为温州事故。降速是2011年时任铁道部盛部长的决策，到2011年6月底就全面降速了，而温州事故是2011年7.23发生。]]></content>
      <categories>
        <category>记录</category>
        <category>角度</category>
      </categories>
      <tags>
        <tag>另类观点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis命令3]]></title>
    <url>%2Fposts%2Fa5d6296%2F</url>
    <content type="text"><![CDATA[Redis 集合(Set)命令Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)。实例12345678910127.0.0.1:6379&gt; sadd set redis(integer) 1127.0.0.1:6379&gt; sadd set mysql(integer) 1127.0.0.1:6379&gt; sadd redis(error) ERR wrong number of arguments for &apos;sadd&apos; command127.0.0.1:6379&gt; smembers set1) &quot;mysql&quot;2) &quot;redis&quot;127.0.0.1:6379&gt;Redis Sadd 命令将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。可用版本 &gt;= 1.0.0当集合 key 不是集合类型时，返回一个错误。在Redis2.4版本以前， SADD 只接受单个成员值。语法sadd key value1... valuen返回值被添加到集合中的新元素的数量，不包括被忽略的元素。srandmember key [count] 命令如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。该操作和spop相似，但spop将随机元素从集合中移除并返回，而 srandmember则仅仅返回随机元素，而不对集合进行任何改动。可用版本 &gt;= 1.0.0从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。时间复杂度:只提供 key 参数时为 O(1)。如果提供了 count 参数，那么为 O(N)，N 为返回数组的元素个数。返回值只提供 key 参数时，返回一个元素；如果集合为空，返回 nil 。如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。其他命令命令含义可用版本时间复杂度scard key返回集合 key 的基数(集合中元素的数量)。当 key 不存在时，返回 0 。&gt;=1.0.0O(1)sdiff key [key...]返回一个集合的全部成员，该集合是所有给定集合之间的差集。不存在的 key 被视为空集。差集的结果来自前面的 FIRST_KEY ,而不是后面的 OTHER_KEY1，也不是整个 FIRST_KEY OTHER_KEY1..OTHER_KEYN 的差集。&gt;=1.0.0O(N)， N 是所有给定集合的成员数量之和。sdiffstore destination key [key...]这个命令的作用和sdiff类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。&gt;=1.0.0O(N)， N 是所有给定集合的成员数量之和。sinter key [key ...]返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。&gt;=1.0.0O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。sinterstore destination key [key ...]这个命令的作用和sinter类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。&gt;=1.0.0O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。sismember key member判断 member 元素是否集合 key 的成员。如果 member 元素是集合的成员，返回 1 。如果 member 元素不是集合的成员，或 key 不存在，返回 0 。&gt;= 1.0.0O(1)smembers key返回集合 key 中的所有成员。不存在的 key 被视为空集合。&gt;= 1.0.0O(N)，N 为集合的基数smove source destination member将 member 元素从 source 集合移动到 destination 集合。原子性操作。如果 source 集合不存在或不包含指定的 member 元素，则 smove命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。&gt;= 1.0.0O(1)spop key移除并返回集合中的一个随机元素。当 key 不存在或 key 是空集时，返回 nil 。如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 srandmember命令。&gt;= 1.0.0O(1)srem key member [member...]移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。当 key 不是集合类型，返回一个错误。在 Redis 2.4 版本以前，srem只接受单个 member 值。&gt;= 1.0.0O(n)，n为给定member元素的数量sunion key [key ...]返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集。&gt;= 1.0.0O(N)， N 是所有给定集合的成员数量之和。sunionstore dest key [key ...]这个命令的作用和sinter类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。返回结果集中的元素数量。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。&gt;=1.0.0O(N * M)， N 是所有给定集合的成员数量之和。sscan key cursor [MATCH pattern] [COUNT count]和 scan 、hscan、zscan一样，看不太明白。回头用到再看。Redis 有序集合(sorted set)命令Redis 有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。实例12345678910111213141516127.0.0.1:6379&gt; zadd sset 1 redis(integer) 1127.0.0.1:6379&gt; zadd sset 2 mongodb(integer) 1127.0.0.1:6379&gt; zadd sset 3 mysql(integer) 1127.0.0.1:6379&gt; zadd sset 3 mysql(integer) 0127.0.0.1:6379&gt; zadd sset 4 mysql(integer) 0127.0.0.1:6379&gt; zrange sset 0 10 withscores1) &quot;redis&quot;2) &quot;1&quot;3) &quot;mongodb&quot;4) &quot;2&quot;5) &quot;mysql&quot;zadd 命令将一个或多个 member 元素及其 score 值加入到有序集 key 当中。如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。score 值可以是整数值或双精度浮点数。如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。当 key 存在但不是有序集类型时，返回一个错误。语法zadd key score member [[score member] [score member] ...]可用版本：可用版本&gt;= 1.2.0 。在 Redis 2.4 版本以前， zadd每次只能添加一个元素。时间复杂度:O(M*log(N))，N 是有序集的基数，M 为成功添加的新成员的数量。返回值:被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。zrange 命令返回有序集 key 中，指定区间内的成员。可用版本 &gt;= 1.2.0其中成员的位置按 score 值递增(从小到大)来排序。具有相同 score 值的成员按字典序(lexicographical order )来排列。如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE 命令。语法zrange key start stop [WITHSCORES]说明下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。超出范围的下标并不会引起错误。比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。时间复杂度O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。zrangebyscore 命令返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。可用版本 &gt;= 1.0.5语法zrangebyscore key min max [WITHSCORES] [LIMIT offset count]说明具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。该选项自 Redis 2.0 版本起可用。区间及无限min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。举个例子：1zrangebyscore zset (1 5返回所有符合条件 1 &lt; score &lt;= 5 的成员，而zrangebyscore zset (5 (10则返回所有符合条件 5 &lt; score &lt; 10 的成员。时间复杂度O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。zremrangebyrank 命令移除有序集 key 中，指定排名(rank)区间内的所有成员。返回被移除成员的数量。区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。语法zremrangebyrank key start stop时间复杂度O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。zremrangebyscore 命令移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。返回被移除成员的数量。可用版本 &gt;= 1.2.0自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 zrangebyscore 命令。语法zremrangebyscore key min max时间复杂度O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。zrevrange 命令返回有序集 key 中，指定区间内的成员。可用版本 &gt;= 1.2.0其中成员的位置按 score 值递减(从大到小)来排列。具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。除了成员按 score 值递减的次序排列这一点外， zrevrange命令的其他方面和zrange命令一样。语法zrevrange key start stop [WITHSCORES]时间复杂度O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。zunionstore 命令计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。返回保存到 destination 的结果集的基数。可用版本 &gt;= 2.0.0默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和 。语法zunionstore destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]WEIGHTS 选项使用 WEIGHTS 选项，你可以为 每个给定有序集分别指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。AGGREGATE 选项使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之和作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。时间复杂度O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。zinterstore 命令计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。返回保存到 destination 的结果集的基数。可用版本 &gt;= 2.0.0默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.关于 WEIGHTS 和 AGGREGATE 选项的描述，参见zinterstore命令。时间复杂度O(NK)+O(Mlog(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。其他命令命令含义可用版本时间复杂度zcard key返回有序集 key 的基数。当 key 存在且是有序集类型时，返回有序集的基数。当 key 不存在时，返回 0 。&gt;=1.2.0O(1)zcount key min max返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。&gt;=2.0.0O(log(N)+M)， N 为有序集的基数， M 为值在 min 和 max 之间的元素的数量。zincrby key increment member为有序集 key 的成员 member 的 score 值加上增量 increment 。可以通过传递一个负数值 increment ，让 score 减去相应的值。当 key 不存在，或 member 不是 key 的成员时， zincrby key increment member 等同于 zadd key increment member 。当 key 不是有序集类型时，返回一个错误。score 值可以是整数值或双精度浮点数。&gt;=1.2.0O(log(N))zrank key member返回有序集 key 中成员 member 的排名。如果 member 不是有序集 key 的成员，返回 nil 。其中有序集成员按 score 值递增(从小到大)顺序排列。排名以 0 为底，也就是说， score 值最小的成员排名为 0 。&gt;=2.0.0O(log(N))zrem key member [member ...]移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。f返回被成功移除的成员的数量，不包括被忽略的成员。当 key 存在但不是有序集类型时，返回一个错误。在 Redis 2.4 版本以前，zrem每次只能删除一个元素。&gt;=1.2.0O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。zrevrank key member返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。排名以 0 为底，也就是说， score 值最大的成员排名为 0 。&gt;=2.0.0O(log(N))zscore key member返回有序集 key 中，成员 member 的 score 值，以字符串形式表示。如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。&gt;=1.2.0O(1)zrevrangebyscore key max min [withscores] [limit offset count]返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。除了成员按 score 值递减的次序排列这一点外，zrevrangebyscore 命令的其他方面和 zrangebyscore命令一样。&gt;=2.2.0O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis命令4]]></title>
    <url>%2Fposts%2F9439f735%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Redis 发布订阅、事务、脚本、连接四个方面的命令。Redis 发布订阅Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。一个频道也可以被多个客户端订阅。实例创建了订阅频道名为 redisChat12345127.0.0.1:6379&gt; subscribe redisChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;redisChat&quot;3) (integer) 1重新开启个 redis 客户端，然后在同一个频道 redisChat 发布消息，订阅者就能接收到消息。12127.0.0.1:6379&gt; publish redisChat &quot;Redis is a great caching technique&quot;(integer) 112345678127.0.0.1:6379&gt; subscribe redisChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;redisChat&quot;3) (integer) 11) &quot;message&quot;2) &quot;redisChat&quot;3) &quot;Redis is a great caching technique&quot;Redis psubscribe命令订阅一个或多个符合给定模式的频道。可用版本 &gt;= 2.0.0每个模式以 * 作为匹配符，比如 redis* 匹配所有以 redis 开头的频道( redis.news 、 redis.blog等等)。punsubscribe 命令用于退订所有给定模式的频道。与 psubscribe 类似。语法psubscribe pattern [pattern ...]返回值接收到的信息。Redis subscribe命令用于订阅给定的一个或多个频道的信息。可用版本 &gt;= 2.0.0unsubscribe 命令用于退订所有给定模式的频道。与 subscribe 类似。语法subscribe channel [channel ...]返回值接收到的信息Redis publish命令用于将信息发送到指定的频道。可用版本 &gt;= 2.0.0语法publish channel message返回值接收到信息的订阅者数量。Redis pubsub命令pubsub是一个查看订阅与发布系统状态的内省命令，它由数个不同格式的子命令组成。可用版本 &gt;= 2.8.0语法pubsub &lt;subcommand&gt; [argument [argument ...]]channels 子命令列出当前的活跃频道。活跃频道指的是那些至少有一个订阅者的频道，订阅模式的客户端不计算在内。语法pubsub channels [pattern]pattern 参数是可选的，如果不给出 pattern 参数，那么列出订阅与发布系统中的所有活跃频道。如果给出 pattern 参数，那么只列出和给定模式 pattern 相匹配的那些活跃频道。复杂度O(N) ， N 为活跃频道的数量（对于长度较短的频道和模式来说，将进行模式匹配的复杂度视为常数）。返回值一个由活跃频道组成的列表。numsub 子命令返回给定频道的订阅者数量， 订阅模式的客户端不计算在内。语法pubsub numsub [channel-1 ... channel-N]复杂度O(N)， N 为给定频道的数量。返回值一个多条批量回复(Multi-bulk reply)，回复中包含给定的频道，以及频道的订阅者数量。 格式为：频道 channel-1，channel-1 的订阅者数量，频道 channel-2，channel-2 的订阅者数量，诸如此类。 回复中频道的排列顺序和执行命令时给定频道的排列顺序一致。不给定任何频道而直接调用这个命令也是可以的，在这种情况下，命令只返回一个空列表。numpat 子命令返回订阅模式的数量。这个命令返回的不是订阅模式的客户端的数量，而是客户端订阅的所有模式的数量总和。当有多个客户端订阅相同的模式时，相同的订阅也被计算在内语法pubsub numpat复杂度O(1) 。返回值一个整数回复（Integer reply）。Redis 事务Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：批量操作在发送exec命令前被放入队列缓存。收到exec命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。一个事务从开始到执行会经历三个阶段：开始事务-&gt;命令入队。-&gt;执行事务。Redis multi与exec命令用于标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由exec命令原子性(atomic)地执行。可用版本 &gt;= 1.2.0语法multi返回值总是返回 OK 。实例12345678910111213141516127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr user_idQUEUED127.0.0.1:6379&gt; incr user_idQUEUED127.0.0.1:6379&gt; incr user_idQUEUED127.0.0.1:6379&gt; pingQUEUED127.0.0.1:6379&gt; exec1) (integer) 12) (integer) 23) (integer) 34) PONG127.0.0.1:6379&gt;Redis discard命令用于取消事务，放弃执行事务块内的所有命令。可用版本 &gt;= 2.0.0语法discard返回值总是返回 OK 。实例12345678910111213127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr user_idQUEUED127.0.0.1:6379&gt; incr user_idQUEUED127.0.0.1:6379&gt; pingQUEUED127.0.0.1:6379&gt; discardOK127.0.0.1:6379&gt; exec(error) ERR EXEC without MULTI127.0.0.1:6379&gt;Redis watch命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。可用版本 &gt;= 2.2.0语法watch key [key ...]返回值总是返回 OK 。Redis unwatch 命令用于取消watch命令对所有 key 的监视。可用版本 &gt;= 2.2.0语法redis Unwatch 命令基本语法如下：redis 127.0.0.1:6379&gt; UNWATCH返回值总是返回 OK 。Redis 脚本Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。语法EVAL script numkeys key [key ...] arg [arg ...]实例123456127.0.0.1:6379&gt; EVAL &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second1) &quot;key1&quot;2) &quot;key2&quot;3) &quot;first&quot;4) &quot;second&quot;127.0.0.1:6379&gt;Redis eval 命令使用 Lua 解释器执行脚本。可用版本 &gt;= 2.6.0语法EVAL script numkeys key [key ...] arg [arg ...]参数说明：script： 参数是一段 Lua 5.1 脚本程序。脚本不必(也不应该)定义为一个 Lua 函数。numkeys： 用于指定键名参数的个数。key [key …]： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。arg [arg …]： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。Redis evalsha 命令根据给定的 sha1 校验码，执行缓存在服务器中的脚本。可用版本 &gt;= 2.6.0将脚本缓存到服务器的操作可以通过SCRIPT LOAD命令进行。这个命令的其他地方，比如参数的传入方式，都和 EVAL 命令一样。语法EVALSHA sha1 numkeys key [key ...] arg [arg ...]参数说明：sha1 ： 通过SCRIPT LOAD生成的 sha1 校验码。numkeys： 用于指定键名参数的个数。key [key …]： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。arg [arg …]： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。实例12345127.0.0.1:6379&gt; SCRIPT LOAD &quot;return &apos;hello freya&apos;&quot;&quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;127.0.0.1:6379&gt; evalsha &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot; 0&quot;hello freya&quot;127.0.0.1:6379&gt;Redis script exists 命令用于校验指定的脚本是否已经被保存在缓存当中。可用版本 &gt;= 2.6.0语法SCRIPT EXISTS sha1 [sha1 ...]返回值一个列表，包含 0 和 1 ，前者表示脚本不存在于缓存，后者表示脚本已经在缓存里面了。列表中的元素和给定的 SHA1 校验和保持对应关系，比如列表的第三个元素的值就表示第三个 SHA1 校验和所指定的脚本在缓存中的状态。实例123456789127.0.0.1:6379&gt; SCRIPT LOAD &quot;return &apos;hello freya&apos;&quot;&quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;127.0.0.1:6379&gt; script exists &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;1) (integer) 1127.0.0.1:6379&gt; script flushOK127.0.0.1:6379&gt; script exists &quot;bb758a1044e9f9b9e531491d56a9677c432e7216&quot;1) (integer) 0127.0.0.1:6379&gt;Redis script kill 命令用于杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。可用版本 &gt;= 2.6.0这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限循环的脚本。script kill执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从EVAL命令的阻塞当中退出，并收到一个错误作为返回值。语法script kill返回值总是返回 OKRedis 连接Redis 连接命令主要是用于连接 redis 服务。实例1234127.0.0.1:6379&gt; auth &quot;password&quot;OK127.0.0.1:6379&gt; pingPONGRedis auth 命令用于检测给定的密码和配置文件中的密码是否相符。可用版本 &gt;= 1.0.0语法auth pwd返回值密码匹配时返回 OK ，否则返回一个错误。Redis echo 命令用于打印给定的字符串。可用版本 &gt;= 1.0.0语法echo message返回值返回字符串本身。Redis Quit 命令用于关闭与当前客户端与redis服务的连接。可用版本 &gt;= 1.0.0一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。返回值总是返回 OK 。实例12127.0.0.1:6379&gt; quit$Redis select 命令用于切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。可用版本 &gt;= 1.0.0语法select index返回值总是返回 OK 。]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis命令2]]></title>
    <url>%2Fposts%2F7d5a5200%2F</url>
    <content type="text"><![CDATA[Redis 哈希(Hash)相关命令Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。Redis hset命令用于为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，旧值将被覆盖。可用版本&gt;= 2.0.0语法hset key field1 value1 [field2 value2 ]返回值如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 。Redis hsetnx命令用于为哈希表中不存在的的字段赋值。如果哈希表不存在，一个新的哈希表被创建并进行hset操作。如果字段已经存在于哈希表中，操作无效。如果 key 不存在，一个新哈希表被创建并执行hsetnx命令。可用版本 &gt;= 2.0.0语法hsetnx key field value返回值设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0 。Redis hget命令用于返回哈希表中指定字段的值。可用版本&gt;= 2.0.0语法hget key field返回值返回给定字段的值。如果给定的字段或 key 不存在时，返回 nil 。Redis hgetall命令用于返回哈希表中，所有的字段和值。在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍。可用版本 &gt;= 2.0.0语法hgetall key返回值以列表形式返回哈希表的字段及字段值。若 key 不存在，返回空列表。Redis hmget命令用于返回哈希表中，一个或多个给定字段的值。如果指定的字段不存在于哈希表，那么返回一个 nil 值。可用版本 &gt;= 2.0.0语法hmget key field1...fieldn返回值一个包含多个给定字段关联值的表，表值的排列顺序和指定字段的请求顺序一样。如果对应的 field 不存在则返回 nil。Redis hlen命令用于获取哈希表中字段的数量。可用版本 &gt;= 2.0.0语法hlen key返回值哈希表中字段的数量。当 key 不存在时，返回 0 。Redis hkeys命令用于获取哈希表中的所有域（field）。可用版本 &gt;= 2.0.0语法hkeys key返回值包含哈希表中所有域（field）列表。 当 key 不存在时，返回一个空列表。Redis hvals命令返回哈希表所有域(field)的值。可用版本 &gt;= 2.0.0语法hvals key返回值一个包含哈希表中所有域(field)值的列表。 当 key 不存在时，返回一个空表。Redis hexists命令用于查看哈希表的指定字段是否存在。语法hexists key field返回值如果哈希表含有给定字段，返回 1 。 如果哈希表不含有给定字段，或 key 不存在，返回 0 。Redis hdel命令用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略。可用版本 &gt;= 2.0.0语法hdel key field.. fieldn返回值被成功删除字段的数量，不包括被忽略的字段。Redis hincrby命令用于为哈希表中的字段值加上指定增量值 increment。增量也可以为负数，相当于对指定字段进行减法操作。可用版本 &gt;= 2.0.0如果哈希表的 key 不存在，一个新的哈希表被创建并执行hincrby命令。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。对一个储存字符串值的字段执行hincrby命令将造成一个错误。本操作的值被限制在 64 位(bit)有符号数字表示之内。语法hincrby key field increment返回值执行 HINCRBY 命令之后，哈希表中字段的值。实例123456789101112131415127.0.0.1:6379&gt; hset freya age 17(integer) 1127.0.0.1:6379&gt; hincrby freya age 1(integer) 18127.0.0.1:6379&gt; hincrby freya age -1(integer) 17127.0.0.1:6379&gt; exists asher(integer) 0127.0.0.1:6379&gt; hexists asher age(integer) 0127.0.0.1:6379&gt; hincrby asher age 19(integer) 19127.0.0.1:6379&gt; hgetall asher1) &quot;age&quot;2) &quot;19&quot;Redis hincrbyfloat命令用于为哈希表中的字段值加上指定浮点数增量值 increment。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。可用版本 &gt;= 2.6.0语法hincrbyfloat key field increment返回值执行 Hincrbyfloat 命令之后，哈希表中字段的值。Redis hscan命令hscan key cursor [MATCH pattern] [COUNT count]迭代哈希表中的键值对。与scan类似，看不太懂，回头再战。Redis 列表(List)相关命令Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。Redis lpush命令将一个或多个值插入到列表头部。如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误。可用版本&gt;= 1.0.0 。在Redis 2.4版本以前的lpush命令，都只接受单个 value 值。 rpush 与之类似，只不过在列表尾部添加。语法lpush key value1.. valuen返回值执行lpush命令后，列表的长度。Redis lpushx命令将一个值插入到已存在的列表头部，列表不存在时操作无效。可用版本 &gt;= 2.2.0 。rpushx与之类似，只不过在列表尾部添加。语法lpushx key value1.. valuen返回值lpush命令执行之后，列表的长度。Redis lindex命令用于通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。可用版本 &gt;= 1.0.0语法lindex key index返回值列表中下标为指定索引值的元素。如果指定索引值不在列表的区间范围内，返回 nil。Redis llen命令用于返回列表的长度。如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 。 如果 key 不是列表类型，返回一个错误。可用版本 &gt;= 1.0.0语法llen key返回值列表的长度。Redis linsert命令用于在列表的元素前或者后插入元素。当指定元素不存在于列表中时，不执行任何操作。可用版本 &gt;= 1.0.0当列表不存在时，被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。语法linsert key BEFORE|AFTER pivot value将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。返回值如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到指定元素 ，返回 -1 。 如果 key 不存在或为空列表，返回 0 。Redis lpop命令用于移除并返回列表的第一个元素。可用版本 &gt;= 1.0.0语法lpop key返回值列表的第一个元素。当列表 key 不存在时，返回 nil 。Redis rpop命令用于移除列表的最后一个元素，返回值为移除的元素。可用版本 &gt;= 1.0.0语法rpop key返回值被移除的元素。当列表不存在时，返回 nil 。Redis lrange命令返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。可用版本 &gt;= 1.0.0语法lrange key start end返回值一个列表，包含指定区间内的元素。Redis lrem命令根据参数 count 的值，移除列表中与参数 value 相等的元素。可用版本 &gt;= 1.0.0count 的值可以是以下几种：count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。count = 0 : 移除表中所有与 value 相等的值。语法lrem key count value返回值被移除元素的数量。列表不存在时返回 0 。Redis lset命令通过索引来设置元素的值。当索引参数超出范围，或对一个空列表进行lset时，返回一个错误。可用版本 &gt;= 1.0.0语法lset key index value返回值操作成功返回 ok ，否则返回错误信息。Redis ltrim命令对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。可用版本 &gt;= 1.0.0下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。语法ltrim key start end返回值命令执行成功时，返回 ok 。Redis blpop命令移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。可用版本 &gt;= 2.0.0 。brpop与之类似，只不过在列表尾部移除。当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。语法blpop list[list...] timeout返回值如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。可用版本 &gt;= 1.0.0Redis rpoplpush命令用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。在一个原子时间内，执行以下两个动作：将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。语法rpoplpush source_key dest_key返回值被弹出的元素。Redis brpoplpush命令brpoplpush是rpoplpush的阻塞版本，当给定列表 source 不为空时，brpoplpush的表现和rpoplpush一样。可用版本 &gt;= 2.2.0当列表 source 为空时，brpoplpush命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行lpush或rpush命令为止。超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。返回值：假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。]]></content>
  </entry>
  <entry>
    <title><![CDATA[拾句-现实]]></title>
    <url>%2Fposts%2Fa9bf165e%2F</url>
    <content type="text"><![CDATA[001我们现在的现代生活里，在忙碌之后，真正夜半三更的时候，更多的体会还是孤独，所以这个时候就特别渴望有一个相伴，所以爱情在这个地方，跟我们这个部分就有高度的契合。所以孤独本身有时候会让人滑向爱情，好像爱情可以填补这个孤独，但是这是一个特别大的误区，因为两个人真正在一起，它有时候释放出来的孤独，比你原来一个人承担的孤独还要大，因为它伴随着一个特别大的失望，生存生命是要靠自己去承担的，而不是躲到那种所谓的爱情里面去，就像柏拉图讲，人要在洞穴阶段，在一片黑暗里面，获得反思，获得认识，获得沉淀。所以我们人生有时候不要回避，一孤独就觉得为什么我孤独了，就忙着逃避，有的人觉得为什么我还不谈恋爱，我的女朋友、男朋友怎么还不出现，然后我一个人还单着，很多人在恋爱里面，爱人变成对自己的一个弥补，根本的爱的来源是创伤，我们要意识到为什么一个人特别需要，在现代生活里面，需要独立地去成长一段时间，因为在这个过程里面要把自己内心的创伤，要给它认识到，要给它愈合。生命要打开新的叶子，生长出新的枝叶来，来获得一个比较完整的生命，然后去爱人。因为我们今天的社会里面，特别容易有创伤，尤其是我们今天的的独生子女一代，他没有任何经验，也没有任何以前我们传统社会里面的兄弟姐妹，我们的要求太多了，渴望得到的东西也太多了，所以在这种情况下，我们的爱情里面就承担了太多的东西，所以一旦结婚的话，互相的需求度太大了，造成沉重的压力，然后每一个都没有什么输出的能力，互相都是枯竭的，所以就是巨大的失望，所以这些，潜在的需要，我们要有一种自我清理，其实你要珍惜你的这一段孤独，你一旦在这个孤独里面获得了自己的这种独立的生存，获得了自己的内容，获得了自己生命的坚实，这个时候你才真正地变成了一个在这个世界能承担爱情的人，你一生里面如何获得几年的孤独时间，这还真是挺值得去好好地努力的东西，实际上从另外一个意义上说，你的成长就在孤独里面，所以我觉得这个是一个我们原来很容易被扭曲的东西，在天黑以后，往热闹地方躲，可心里头，有定时的闹钟，提醒你有多寂寞。一席|万象|孤独yixi.tv/wanxiang/2/10在我们国家在出轨这件事上，对小三和对出轨丈夫的接受程度简直天差地别。对小三的态度是绝对的零容忍，但对出轨的男人来说会相对宽容。人生最好的三个词——久别重逢、失而复得、虚惊一场。但却没有「和好如初」。只因和好容易，如初太难。打太极——踢皮球曾经那些如胶似漆的，终有一天会因激情燃尽厌弃对方后而渐行渐远。人，总以缘分来作为了却情义的假词。人活着注定是要孤独的，以前不懂的，现在也应该懂了。你觉得电流只走耗电少的那一条。事实上并不是。电流其实走了所有的路。因为电路中电流的产生是要靠电场的。电场会迅速找到阻抗最小的路。期间是一个局部场强不断重新分布的过程，只不过电场很快，你感受不到它的分布。简单地说，电流是由电场建立的，电场的建立依据波动方程，你所看到的现象只是电路达到平衡后的稳态，而稳态建立前的瞬间，电流是向四面八方传播的。其实很多女生都很好，只是少数女生被那些有毒公众号洗脑了。「好人若不团结，必被坏人一一消灭」，这条基本原则不仅适用于以个人为单位，也适用于以国家为单位。——饭否所谓政治，就是老年人谈话、年轻人流血。002你和我玩就不许和我讨厌的人玩，你是我爸妈就是这么多年只想着对我这个小孩付出，你是我朋友不能对我有一丝抱怨和吐槽，你是我的恋人该永远忠贞不能有一丝一毫别的念头。后来发现，绝不是这样的…因为人实在是一种太复杂的生物了太多时候，一些行为并不代表对方不爱你或者不在乎你。如果非要纠结，就会发现世界本就是不纯粹的迈入成年人阶段的过程中，你的三观是无限摧毁建立的。到最后你发现，很多你认定错或者对的事情，到最后只是你以为了而已…你会发现每个人都不是你想象那般好，也不是你想象那般差。你会发现，前一刻的自己的想法如此幼稚，看法过于绝对慢慢宽容一切之后发现，其实是解放了自己。——博主:为什么不去问问神奇的阿UU呢知乎无闻www.zhihu.com/question/328988589/answer/742934290只有观念才能战胜观念，学者的使命是纠正错误观念。——哈耶克战争年代，由于存在战争这种强力的淘汰工具，能够迅速证明一个军官的能力和判断，从而保证这个体系掌握在有能力的人手里。而和平时期，这样一个体系没有了这种最终验证的机制，很容易在内部文化上形成上级对下级的粗暴干涉，层层相压，带有强烈的威权色彩。一旦主官的意志形成绝对，那么天然就是官僚威权体系的温床，甚至比普通的官僚体系还要差。人们总以为在某个特定时刻，一切错误将被纠正，所有伤痕将会痊愈，但这样的时刻并不存在。虽然老话常说，己所不欲，勿施于人。但这就是大道理罢了，很多人都是把自己受的气，又原封不动地撒到比自己更弱小的人身上去。这世界上，越是弱小越是容易遭遇令人讨厌的事情。于荣光在《给爸爸的信》里差点把李连杰打死，论个头块头功夫真打起来，除了职业散打选手谁都打不过他，中国人不爱看体格压制的电影，就喜欢以小博大。给个淘宝链接，加个微信，百度一下，已经成了很正常的语义，品牌代表品类，这才是基础设施最恐怖的地方。——半佛仙人人类文明史就像一场永不退场的牌局，只是出牌的人变了又变。人类是一个进化飞快的民族，很多问题只要被发现，就离解决不远了。——半佛仙人对一部作品解读最差的可能就是作者本人了。——苏格拉底咸吃萝卜淡操心往往不是太闲，是太坏。003有时，我不愿将悲伤诉诸言语。因为，它近乎一种罪过：言语，如同自然，既敞开了灵魂，又将灵魂遮蔽。可是，对于不安的心神呐，适当的表达是有益的；诉苦，如同麻醉剂，足以缓解痛苦。阿佛烈·丁尼生A10攻击机的第一视角。电视剧主角在这样的扫射下一路狂奔是不可能的，炮弹比音速还快，正确的拍法是主角什么都没听到呢，没有任何反应，突然人就没了……100多年前，当大型企业首次出现时，它们能够模仿的唯一组织就是军队。——彼得·德鲁克不要说美团卧虎藏龙？因为是有太多的强者向生活低了头。怀孕的时候，老公说我陪你一起胖，生过孩子我再陪你一起减肥！越伪装越可悲，越伪装越没有机会。年轻时一定要把这点当成纪律遵守。并不是说中年人老年人不要遵守这纪律，只是年轻时违反这纪律，中老年在财务与人格上双重破产，一点也不重要了，随他们去吧。——连叔那种最庞大的金融机器一旦开动起来就几乎不可能平稳停下来，不管是基于战争的金融，还是基于土地的金融。——饭否中国有一句话，徒弟找师傅，师傅也找徒弟，找一个好徒弟很难的。之所以大家觉得天气预报“特别不准”，很大程度上是心理原因，天气预报准的时候，大家并不会惊呼。可一旦不准就立马成为谈资，这才留下“特别不准”的偏见。著名的哲学家阿甘他妈曾说过，生活就像一盒巧克力，你永远不知道下一颗的味道。生活也用一次次无情耳光告诉我们：天有不测风云，人有祸福旦夕。004大脑/比天空更宽广，因为/放在一起，大脑能将天空涵盖。大脑/比海洋更深邃，因为/就像海绵，大脑能将海洋包容。大脑与上帝/难分孰重孰轻，如果/要有差别，只在名分不同。狄更生（Emily Dickinson）斯蒂格勒定律，又名“名字来由法则”，是美国统计学家史蒂芬·斯蒂格勒提出的定律，指出科学发现或定律的命名最终大多归功于后来更有名望的科学家，而非其原发现者或创始人。礼貌最大的作用，就是营造这种距离感。有余力的话还能继续装，没有余力了就会原形毕露。与人深交的成本是很高的。她对你没有好奇，你说的，她就听，没说的，她也不会追着问；你问的，她就答，没问到的，也不多解释。没有特别想要了解你，或被你了解，就不必走太近。待人友善是教养，独来独往是性格。自媒体时代，大家多以吃瓜围观为主。没做什么伤天害理的事，大家多是看个乐子，消遣一把，真没人把你恨到天上去。公众人物真的需要一点自黑的特质，脸皮厚点，不怕别人评论，不怕别人黑你。很多时候，没有那么绝对的，失去了一些东西，可能会因此得到另外一些东西。低级别创业，最重要的技能就是学会算帐。财务，是主导一切的核心，不会有效的算帐。就无法有效的决定一些事。中国历史和区块链的原理有点像，每个朝代给前朝修史，就像生成一个新的区块。要想篡改也并非绝对不可能，但必须掌握超过50%的算力。——饭否005长亭外 古道边 芳草碧连天晚风拂柳笛声残 夕阳山外山天之涯 地之角 知交半零落一壶浊酒尽余欢今宵别梦寒长亭外 古道边 芳草碧连天问君此去几时来 来时莫徘徊天之涯 地之角 知交半零落人生难得是欢聚 惟有别离多天之涯 地之角 知交半零落人生难得是欢聚 惟有别离多送别|李叔同没有神的光环，你我生而平凡。——《只要平凡》在经济高速增长阶段，随便投资什么都很容易获得超过10%稳定回报，自然看不上双汇这种每年分红5%的公司。但一旦经济降速，其他投资困难，自然只能回头来买可口可乐和双汇了。证金公司降低了转融资利率80P，这件事就相当于针对股市定向降息，鼓励大家借钱炒股。股市降息、楼市按揭加息。伴随而来的资本主义和消费社会又极度压缩了普通人成年后的学习寿命。历史长河中的每一段，普通成年人是没有终身学习习惯的。过去二十年，全中国的房地产就像是个比上交所大很多很多倍的证券交易所，每个城市都是一只股票，在某个城市买了一套房就相当于入股了这只股票。那些房地产开发商就相当于大大小小的投行。想起有一次跟老家是西安的朋友吃饭，好像是聊到《妖猫传》，我夸西安城墙保存得真好，身为考古学家之子的他苦笑着说：其实唐代城墙不长这样，现在我们看到的西安城墙是80年代按照类似北京城那样的明清城墙修复的。——饭否其实卡米拉不是真的恨大古，只是恨他走向光明却没有带上她。金融，既是空间上的调动，也是时间上的腾挪。006人各有命，上天注定。有人天生为王，有人落草为寇。脚下的路如果不是你自己选择，那旅程的终点在哪也没人知道。你会走到哪，会碰到谁，都不一定。《镇魂街》开场白因为【爱】的寿命是很短的，【爱】是需要正向反馈的，【爱】是需要持续吸引的，很难有那种纯粹的爱，一直支持两个人走下去。资本不是为了正义，他们只是为了赚钱，什么赚钱，做什么都可以。很多人误以为中国在1980年实行一胎化之前，人口增长过快。但实际上，从1950年到1980年，中国的人口增长在发展中国家中几乎是垫底的。在1950年全球人口最多的30个国家里，中国的人口增长幅度要慢于阿根廷之外的所有发展中国家。一个创业的朋友说，七零后八零后很多人被“ think different and change the world”所激励，但九零后尤其是九五后更主流的态度是「道理我都懂，但 who TM cares?」这让我想起日本相隔不到十年的两代漫画《海贼王》和《银魂》里的价值观天差地别。——饭否别人可以不知道你的斤两，你自己要清楚，有些东西你永远得不到，即便得到也会失去，因为那在你的能力范围之外。世上有两样东西不可直视，一是人心，二是太阳。——东野圭吾无论你做什么，百分百地去做，工作就工作，笑就笑，不忘初心，做你自己。——好是好，可是能有多少人能做到呢？哪有什么承诺？哪有什么山盟海誓？一切全凭自觉！喧闹过后，尽归平静。007正是日常生活的神圣化使得现代公共领域得以产生。——查尔斯·泰勒做了不加分，错了扣分。无论最终结局有多么激动人心，从优秀到卓越的转变从来都不是一蹴而就的。在这一过程中，根本没有单一明确的行动、宏伟的计划、一劳永逸的创新，也绝对不存在侥幸的突破和从天而降的奇迹。——吉姆·柯林斯开完一整天会的感觉不是累，而是乏。当环境音乐节奏加快到每分钟108拍时，顾客成交频率会加快；而降低到每分钟60拍时，顾客在店里的停留时间就会延长。往小了说，这是虚荣；往大了讲，这关系到改革推进的根本，我们（乃至世界）唯成绩论和问责制的文化。因为有问责制，出了问题，要先抓人负责，找人担当。成長，最殘酷的部分就是，女孩永遠比同年齡的男孩成熟，女孩的成熟，沒有一個男孩招架得住。宇宙中每一秒都有上千颗恒星诞生,像银河系一样莫名其妙的事物形成过千亿次。有时一个星体还没走完银河系的一半路程就在太空中爆炸,我们能在这里活着,此刻,这本身就是一个奇迹。君不见，黄河之水天上来，奔流到海不复回。 君不见，高堂明镜悲白发，朝如青丝暮成雪。008]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>现实</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis命令1]]></title>
    <url>%2Fposts%2Fe45303ba%2F</url>
    <content type="text"><![CDATA[Redis命令Redis 命令用于在 redis 服务上执行操作。要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。语法Redis 客户端的基本语法为：1$ redis-cli实例以下实例讲解了如何启动 redis 客户端：启动 redis 客户端，打开终端并输入命令 redis-cli。该命令会连接本地的 redis 服务。连接到本地的 redis 服务并执行 PING 命令，该命令用于检测 redis 服务是否启动。1234$ redis-cli127.0.0.1:6379&gt;127.0.0.1:6379&gt; pingPONG在远程服务上执行命令如果需要在远程 Redis 服务上执行命令，同样我们使用的也是 redis-cli 命令。和上面实例类似，上述命令执行的是默认参数，host 为 127.0.0.1 ，port为 6379， 无需密码1$ redis-cli -h host -p port -a password实例以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。1234$ redis-cli -h 127.0.0.1 -p 6379 -a "mypass"127.0.0.1:6379&gt;127.0.0.1:6379&gt; pingPONG语法1$ redis-cli -h host -p port -a password实例以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。1234$ redis-cli -h 127.0.0.1 -p 6379 -a "mypass"127.0.0.1:6379&gt;127.0.0.1:6379&gt; pingPONGRedis 键(key)相关命令Redis 键命令用于管理 redis 的键。语法Redis 键命令的基本语法如下：1127.0.0.1:6379&gt; COMMAND KEY_NAME实例12345$ # del 是一个命令， name 是一个键。如果键被删除成功，命令执行后输出 (integer) 1，否则将输出 (integer) 0127.0.0.1:6379&gt; set name redisOK127.0.0.1:6379&gt; del name (integer) 1Redis键相关的基本命令命令描述可用版本del key该命令用于在 key 存在时删除 key。返回被删除 key 的数量&gt;= 1.0.0dump key该命令用于序列化给定 key 。如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。&gt;= 2.6.0exists key该命令用于检查给定 key 是否存在。若 key 存在返回 1 ，否则返回 0 。&gt;= 1.0.0expire key seconds1. 该命令用于设置 key 的过期时间，key 过期后将不再可用。单位以秒计。设置成功返回 1 。 当 key 不存在或者不能为 key 设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的过期时间)返回 0 。在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。2. 在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 key 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。&gt;= 1.0.0pexpire key milliseconds该命令和 expire 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间。&gt;= 2.6.0expireat key timestamp该命令用于以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间，单位以秒计。key 过期后将不再可用。设置成功返回 1 。当 key 不存在或者不能为 key 设置过期时间时返回 0 。&gt;= 1.2.0pexpireat key milliseconds-timestamp该命令和expireat命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳。&gt;= 2.6.0keys pattern1. 该命令用于查找所有符合给定模式 pattern 的 key。时间复杂度：O(N)， N 为数据库中 key 的数量。返回符合给定模式的 key 列表。2. keys的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 key ，你最好还是用 Redis 的集合结构(set)来代替。&gt;= 1.0.0move key db1. 该命令用于将当前数据库的 key 移动到给定的数据库 db 当中。时间复杂度：O(1)。移动成功返回 1 ，失败则返回 0 。2. 如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。因此，也可以利用这一特性，将 move当作锁(locking)原语(primitive)。&gt;= 1.0.0persist key该命令用于移除给定 key 的生存时间，将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key )。时间复杂度：O(1)。当生存时间移除成功时，返回 1 .如果 key 不存在或 key 没有设置生存时间，返回 0 。&gt;= 2.2.0ttl key1. 该命令以秒为单位返回 key 的剩余过期时间。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。时间复杂度：O(1)2. 在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。&gt;= 1.0.0pttl key1. 该命令以毫秒为单位返回 key 的剩余过期时间。当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。时间复杂度：O(1)2. 在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。&gt;= 2.6.0randomkey该命令从当前数据库中随机返回(不删除)一个 key 。时间复杂度：O(1)。当数据库不为空时，返回一个 key 。当数据库为空时，返回 nil 。&gt;= 1.0.0rename key newkey将 key 改名为 newkey 。时间复杂度：O(1)。改名成功时提示 OK ，当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。当 newkey 已经存在时， raname命令将覆盖旧值。&gt;= 1.0.0renamenx key newkey将 key 改名为 newkey 。时间复杂度：O(1)。当且仅当 newkey 不存在时，将 key 改名为 newkey 。修改成功时，返回 1 。当 newkey 存在时，返回 0 。当 key 不存在时，返回一个错误。&gt;= 1.0.0type key返回 key 所储存的值的类型。时间复杂度：O(1)。none (key不存在)string (字符串)list (列表)set (集合)zset (有序集)hash (哈希表)&gt;= 1.0.0Redis键相关的其他命令sort语法sort key [by pattern] [limit offset count] [get pattern [get pattern ...]] [asc | desc] [alpha] [store destination]返回或保存给定列表、集合、有序集合 key 中经过排序的元素。排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。一般 SORT 用法最简单的 SORT 使用方法是 SORT key 和 SORT key DESC ：sort key 返回键值从小到大排序的结果。sort key desc 返回键值从大到小排序的结果。1234567891011121314151617127.0.0.1:6379&gt; lpush cost 20 18 35 9.3 18(integer) 5# 排序127.0.0.1:6379&gt; sort cost1) &quot;9.3&quot;2) &quot;18&quot;3) &quot;18&quot;4) &quot;20&quot;5) &quot;35&quot;# 逆序排序127.0.0.1:6379&gt; sort cost desc 1) &quot;35&quot;2) &quot;20&quot;3) &quot;18&quot;4) &quot;18&quot;5) &quot;9.3&quot;127.0.0.1:6379&gt;使用外部 key 进行排序可以使用外部 key 的数据作为权重，代替默认的直接对比键值的方式来进行排序。假设现在有用户数据如下：uiduser_name_{uid}user_level_{uid}1admin99992jack103peter251234567891011121314151617181920212223127.0.0.1:6379&gt; lpush uid 1(integer) 1127.0.0.1:6379&gt; set user_name_1 adminOK127.0.0.1:6379&gt; set user_level_1 9999OK127.0.0.1:6379&gt; lpush uid 2(integer) 2127.0.0.1:6379&gt; set user_name_2 jackOK127.0.0.1:6379&gt; set user_level_2 10OK127.0.0.1:6379&gt; lpush uid 3(integer) 3127.0.0.1:6379&gt; set user_name_3 peterOK127.0.0.1:6379&gt; set user_level_3 25OK127.0.0.1:6379&gt; sort uid by user_level_*1) &quot;2&quot;2) &quot;3&quot;3) &quot;1&quot;127.0.0.1:6379&gt;默认情况下， SORT uid 直接按 uid 中的值排序，通过使用 BY 选项，可以让 uid 按其他键的元素来排序。user_level_* 是一个占位符， 它先取出 uid 中的值， 然后再用这个值来查找相应的键。比如在对 uid 列表进行排序时， 程序就会先取出 uid 的值 1 、 2 、 3 ， 然后使用 user_level_1 、 user_level_2 、 user_level_3的值作为排序 uid 的权重。get 选项使用get选项， 可以根据排序的结果来取出相应的键值。12345127.0.0.1:6379&gt; sort uid get user_name_*1) &quot;admin&quot;2) &quot;jack&quot;3) &quot;peter&quot;127.0.0.1:6379&gt;组合使用 by 和 get通过组合使用by和get， 可以让排序结果以更直观的方式显示出来。比如说， 以下代码先按 user_level_{uid} 来排序 uid 列表， 再取出相应的 user_name_{uid} 的值：1234127.0.0.1:6379&gt; sort uid by user_level_* get user_name_*1) &quot;jack&quot; 2) &quot;peter&quot; 3) &quot;mary&quot;获取多个外部键可以同时使用多个get选项， 获取多个外部键的值。get有一个额外的参数规则——可以用 # 获取被排序键的值。1234567891011127.0.0.1:6379&gt; sort uid get # get user_level_* get user_name_*1) &quot;1&quot;2) &quot;9999&quot;3) &quot;admin&quot;4) &quot;2&quot;5) &quot;10&quot;6) &quot;jack&quot;7) &quot;3&quot;8) &quot;25&quot;9) &quot;peter&quot;127.0.0.1:6379&gt;获取外部键，但不进行排序通过将一个不存在的键作为参数传给by选项， 可以让sort跳过排序操作， 直接返回结果：1234127.0.0.1:6379&gt; sort uid by not-exists-key1) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;这种用法在单独使用时，没什么实际用处。不过，通过将这种用法和get选项配合， 就可以在不排序的情况下， 获取多个外部键， 相当于执行一个整合的获取操作（类似于 SQL 数据库的 join 关键字）。1234567891011127.0.0.1:6379&gt; sort uid by not-exists-key get # get user_level_* get user_name_*1) &quot;3&quot;2) &quot;25&quot;3) &quot;peter&quot;4) &quot;2&quot;5) &quot;10&quot;6) &quot;jack&quot;7) &quot;1&quot;8) &quot;9999&quot;9) &quot;admin&quot;127.0.0.1:6379&gt;保存排序结果默认情况下， sort操作只是简单地返回排序结果，并不进行任何保存操作。通过给store选项指定一个 key 参数，可以将排序结果保存到给定的键上。如果被指定的 key 已存在，那么原有的值将被排序结果覆盖。1234567891011121314151617181920212223242526272829127.0.0.1:6379&gt; rpush numbers 1 3 5 7 9(integer) 5127.0.0.1:6379&gt; rpush numbers 2 4 6 8 10(integer) 10127.0.0.1:6379&gt; lrange numbers 0 -1 1) &quot;1&quot; 2) &quot;3&quot; 3) &quot;5&quot; 4) &quot;7&quot; 5) &quot;9&quot; 6) &quot;2&quot; 7) &quot;4&quot; 8) &quot;6&quot; 9) &quot;8&quot;10) &quot;10&quot;127.0.0.1:6379&gt; sort numbers store sorted-numbers(integer) 10127.0.0.1:6379&gt; lrange sorted-numbers 0 -1 1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 4) &quot;4&quot; 5) &quot;5&quot; 6) &quot;6&quot; 7) &quot;7&quot; 8) &quot;8&quot; 9) &quot;9&quot;10) &quot;10&quot;127.0.0.1:6379&gt;可以通过将sort命令的执行结果保存，并用expire为结果设置生存时间，以此来产生一个sort操作的结果缓存。这样就可以避免对sort操作的频繁调用：只有当结果集过期时，才需要再调用一次sort操作。另外，为了正确实现这一用法，你可能需要加锁以避免多个客户端同时进行缓存重建(也就是多个客户端，同一时间进行sort操作，并保存为结果集)，具体参见setnx命令。objectobject subcommand [arguments [arguments]]object命令允许从内部察看给定key的 Redis 对象。它通常用在除错(debugging)或者了解为了节省空间而对 key 使用特殊编码的情况。当将Redis用作缓存程序时，你也可以通过 OBJECT 命令中的信息，决定 key 的驱逐策略(eviction policies)。可用版本：&gt;= 2.2.3 ，时间复杂度：O(1)。object 命令子命令object refcount key 返回给定 key 引用所储存的值的次数。此命令主要用于除错。object encoding key 返回给定 key 锁储存的值所使用的内部表示(representation)。object idletime key 返回给定 key 自储存以来的空转时间(idle， 没有被读取也没有被写入)，以秒为单位。对象编码方式：字符串可以被编码为raw(一般字符串)、embstr或int(用字符串表示64位数字是为了节约空间)。列表可以被编码为ziplist或linkedlist。 ziplist是为节约大小较小的列表空间而作的特殊表示。集合可以被编码为intset或者hashtable。 intset是只储存数字的小集合的特殊表示。哈希表可以编码为zipmap或者hashtable 。 zipmap是小哈希表的特殊表示。有序集合可以被编码为 ziplist 或者 skiplist 格式。 ziplist 用于表示小的有序集合，而 skiplist 则用于表示任何大小的有序集合。示例12345678910111213141516171819202122232425127.0.0.1:6379&gt; set name &quot;redis&quot;OK127.0.0.1:6379&gt; object refcount name (integer) 1 # 只有一个引用127.0.0.1:6379&gt; 127.0.0.1:6379&gt; object idletime name(integer) 104 # 等待一阵，然后查看空转时间127.0.0.1:6379&gt; get name&quot;redis&quot;127.0.0.1:6379&gt; object idletime name(integer) 1 # get之后立即查空转时间127.0.0.1:6379&gt; object encoding name&quot;embstr&quot; # 对象编码方式127.0.0.1:6379&gt; set phone 17608882643OK127.0.0.1:6379&gt; object encoding phone&quot;int&quot;127.0.0.1:6379&gt; set phone 9223372036854775808OK # 大于或等于2的64次方，被编码为字符串127.0.0.1:6379&gt; object encoding phone&quot;embstr&quot;127.0.0.1:6379&gt; set phone 111111111111111111111111111111111111111111111OK # 超过44位之后以 raw 编码127.0.0.1:6379&gt; object encoding phone&quot;raw&quot;具体为什么是44而不是其他数字，原因可参考为什么redis小等于39字节的字符串是embstr编码，大于39是raw编码？ 44和39只是因为版本支持不同，github修改记录可参考commitrestorerestore key ttl serialized-value反序列化给定的序列化值，并将它和给定的key关联。与dump相对应。可用版本：&gt;= 2.6.0参数ttl以毫秒为单位为key设置生存时间；如果ttl为 0 ，那么不设置生存时间。restore在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么restore会拒绝进行反序列化，并返回一个错误。时间复杂度查找给定键的复杂度为 O(1) ，对键进行反序列化的复杂度为 O(N*M) ，其中 N 是构成 key 的 Redis 对象的数量，而 M 则是这些对象的平均大小。有序集合(sorted set)的反序列化复杂度为 O(NMlog(N)) ，因为有序集合每次插入的复杂度为 O(log(N)) 。如果反序列化的对象是比较小的字符串，那么复杂度为 O(1) 。示例1234567891011121314127.0.0.1:6379&gt; set hi "Hello, World!"OK127.0.0.1:6379&gt; dump hi # 序列化"\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR"127.0.0.1:6379&gt; restore hi 0 "\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR" # 反序列化时key已存在(error) BUSYKEY Target key name already exists.127.0.0.1:6379&gt; restore hi-restore 0 "\x00\rHello, World!\t\x00\xf0\"\x89\x13\xb4\x96\xbeR" # 反序列化OK127.0.0.1:6379&gt; restore fake-hi 0 "hello blablabla" # 使用错误的值进行反序列化(error) ERR DUMP payload version or checksum are wrongmigratemigrate host port key destination-db timeout [copy] [replace]将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。可用版本：&gt;= 2.6.0。迁移成功时返回 OK ，否则返回相应的错误。这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。可选项：copy ：不移除源实例上的 key 。replace ：替换目标实例上已存在的 key 。内部实现它在当前实例对给定 key 执行dump命令 ，将它序列化，然后传送到目标实例，目标实例再使用restore对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到restore命令返回 OK ，它就会调用del删除自己数据库上的 key 。timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。migrate命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。当 IOERR 出现时，有以下两种可能：key 可能存在于两个实例key 可能只存在于当前实例唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）。时间复杂度：这个命令在源实例上实际执行 DUMP 命令和 DEL 命令，在目标实例执行 RESTORE 命令，查看以上命令的文档可以看到详细的复杂度说明。key 数据在两个实例之间传输的复杂度为 O(N) 。实例启动两个Redis实例，一个默认 6379 端口，一个 9999 接口1234567891011121314151617181920212223242526$ ./redis-server --port 999980619:C 01 Aug 2019 23:21:22.685 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo80619:C 01 Aug 2019 23:21:22.686 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=80619, just started80619:C 01 Aug 2019 23:21:22.686 # Configuration loaded80619:M 01 Aug 2019 23:21:22.687 * Increased maximum number of open files to 10032 (it was originally set to 256). _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 5.0.5 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 9999 | `-._ `._ / _.-&apos; | PID: 80619 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 80619:M 01 Aug 2019 23:21:22.691 # Server initialized80619:M 01 Aug 2019 23:21:22.692 * DB loaded from disk: 0.001 seconds80619:M 01 Aug 2019 23:21:22.692 * Ready to accept connections用客户端连上 6379 端口的实例，设置一个键，然后将它迁移到 7777 端口的实例上12345678910$ ./redis-cli127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; set hello "Hello from 6379 instance"OK127.0.0.1:6379&gt; migrate 127.0.0.1 9999 hello 0 1000OK127.0.0.1:6379&gt; exists hello (integer) 0$ # 迁移成功后 key 被删除使用另一个客户端，查看 9999 端口上的实例123$ ./redis-cli -p 9999127.0.0.1:9999&gt; get hello&quot;Hello from 6379 instance&quot;scanscan cursor [MATCH pattern] [COUNT count]scan命令是一个基于游标的迭代器（cursor based iterator）： scan命令每次被调用之后，都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数，以此来延续之前的迭代过程。当scan命令的游标参数被设置为 0 时，服务器将开始一次新的迭代，而当服务器向用户返回值为 0 的游标时，表示迭代已结束。MATCH 选项和keys命令一样，增量式迭代命令也可以通过提供一个 glob 风格的模式参数，让命令只返回和给定模式相匹配的元素，这一点可以通过在执行增量式迭代命令时，通过给定 MATCH参数来实现。TODO 不是很明白，回头继续Redis 字符串(String)相关命令Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：语法1127.0.0.1:6379&gt; COMMAND KEY_NAME实例1234127.0.0.1:6379&gt; set name redisOK127.0.0.1:6379&gt; get name&quot;redis&quot;Redis字符串(String)相关的基本命令命令描述时间复杂度可用版本set key value1. 将字符串值 value 关联到 key 。如果 key 已经持有其他值， set就覆写旧值，无视类型。对于某个原本带有生存时间（TTL）的键来说， 当set命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。2. 在 Redis 2.6.12 以前版本， set 命令总是返回 OK 。从 Redis 2.6.12 版本开始，set 在设置操作成功完成时，才返回 OK 。如果设置了 NX 或者 XX ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。3. 从 Redis 2.6.12 版本开始， set命令的行为可以通过一系列参数来修改：EX、PX、NX、XX 。http://doc.redisfans.com/string/set.htmlO(1)&gt;= 1.0.0get key返回 key 所关联的字符串值。如果 key 不存在那么返回特殊值 nil 。假如 key 储存的值不是字符串类型，返回一个错误，因为get只能用于处理字符串值。O(1)&gt;= 1.0.0getrange key start end返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。getrange通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。O(N)， N 为要返回的字符串的长度。复杂度最终由字符串的返回值长度决定，但因为从已有字符串中取出子字符串的操作非常廉价(cheap)，所以对于长度不大的字符串，该操作的复杂度也可看作O(1)。&gt;= 2.4.0getset key value将给定 key 的值设为 value ，并返回 key 的旧值(old value)。当 key 存在但不是字符串类型时，返回一个错误。key 不存在时，返回 nil。O(1)&gt;= 1.0.0incr key1. 将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行incr操作，返回执行命令之后 key 的值。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。2. 本操作的值限制在 64 位(bit)有符号数字表示之内。这是一个针对字符串的操作，因为 Redis 没有专用的整数类型，所以 key 内储存的字符串被解释为十进制 64 位有符号整数来执行 incr 操作。3. 限速器与计数器的应用。4. incrby key increment、incrbyfloat key increment、decr key、decrby key decrement命令与之类似。http://doc.redisfans.com/string/incrbyfloat.htmlO(1)&gt;= 1.0.0getbit key offset对 key 所储存的字符串值，获取指定偏移量上的位(bit)。当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。O(1)&gt;= 2.2.0setbit key offset value对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。当 key 不存在时，自动生成一个新的字符串值。字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。2. offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。对使用大的 offset 的 setbit操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考setrange命令，warning(警告)部分。O(1)&gt;= 2.2.0strlen key返回 key 所储存的字符串值的长度。当 key 不存在时，返回 0 。当 key 储存的不是字符串值时，返回一个错误。O(1)&gt;= 2.2.0mget key [key ...]返回所有(一个或多个)给定 key 的值。如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败。O(N) , N 为给定 key 的数量。&gt;= 1.0.0mset key value [key value ...]1. 同时设置一个或多个 key-value 对。如果某个给定 key 已经存在，那么mset会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用msetnx命令：它只会在所有给定 key 都不存在的情况下进行设置操作。2. mset是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，某些给定 key 被更新而另一些给定 key 没有改变的情况，不可能发生。总是返回 OK (因为 MSET 不可能失败)O(N)， N 为要设置的 key 数量。&gt;= 1.0.1msetnx key value [key value ...]1. 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。即使只有一个给定 key 已存在， msetnx也会拒绝执行所有给定 key 的设置操作。当所有 key 都成功设置，返回 1 。如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。2. msetnx是原子性的，因此它可以用作设置多个不同 key 表示不同字段(field)的唯一性逻辑对象(unique logic object)，所有字段要么全被设置，要么全不被设置。O(N)， N 为要设置的 key 数量。&gt;= 1.0.1append key value1. 如果 key 已经存在并且是一个字符串， append命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， append就简单地将给定 key 设为 value ，就像执行 set key value 一样。2. 返回追加 value 之后， key 中字符串的长度。平摊O(1)&gt;= 2.0.0Redis字符串(String)相关的其他命令bitcountbitcount key [start] [end]计算给定字符串中，被设置为 1 的比特位的数量。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的start或 end参数，可以让计数只在特定的位上进行。start和end参数的设置和getrange命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推。不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。可用版本：&gt;= 2.6.0，时间复杂度：O(N)示例1234567891011127.0.0.1:6379&gt; bitcount bits(integer) 0127.0.0.1:6379&gt; setbit bits 0 1(integer) 0127.0.0.1:6379&gt; bitcount bits(integer) 1127.0.0.1:6379&gt; setbit bits 3 1(integer) 0127.0.0.1:6379&gt; bitcount bits(integer) 2127.0.0.1:6379&gt;使用 bitmap 实现用户上线次数统计Bitmap 对于一些特定类型的计算非常有效。假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 SETBIT 和 BITCOUNT 来实现。比如说，每当用户在某一天上线的时候，我们就使用 SETBIT ，以用户名作为 key ，将那天所代表的网站的上线日作为 offset 参数，并将这个 offset 上的为设置为 1 。举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 SETBIT peter 100 1 ；如果明天 peter 也继续阅览网站，那么执行命令 SETBIT peter 101 1 ，以此类推。当要计算 peter 总共以来的上线次数时，就使用 BITCOUNT 命令：执行 BITCOUNT peter ，得出的结果就是 peter 上线的总天数。更详细的实现可以参考博文(墙外) Fast, easy, realtime metrics using Redis bitmaps 。性能前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， BITCOUNT 的处理速度就像 GET 和 INCR 这种 O(1) 复杂度的操作一样快。如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。使用 BITCOUNT 的 start 和 end 参数，每次只对所需的部分位进行计算，将位的累积工作(accumulating)放到客户端进行，并且对结果进行缓存 (caching)。更详细的实现可以参考博文 REDIS BITMAPS – FAST, EASY, REALTIME METRICSbitopbitop operation destkey key [key ...]对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：bitop add destkey key [key ...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。bitop or destkey key [key ...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。bitop xor destkey key [key ...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。bitop not destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。处理不同长度的字符串当bitop处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。可用版本：&gt;= 2.6.0，时间复杂度：O(N)，返回值：保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。bitop 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。示例1234567891011121314151617127.0.0.1:6379&gt; setbit bits-1 0 1 # 1001(integer) 1127.0.0.1:6379&gt; setbit bits-1 3 1(integer) 0127.0.0.1:6379&gt; setbit bits-2 0 1 # 1011(integer) 0127.0.0.1:6379&gt; setbit bits-2 1 1(integer) 0127.0.0.1:6379&gt; setbit bits-2 3 1(integer) 1127.0.0.1:6379&gt; bitop and and-result bits-1 bits-2 # 1001(integer) 1127.0.0.1:6379&gt; getbit and-result 2(integer) 0127.0.0.1:6379&gt; getbit and-result 3(integer) 1127.0.0.1:6379&gt;setrangesetrange key offset value用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。可用版本：&gt;= 2.2.0。返回被setrange修改之后，字符串的长度。setrange命令会确保字符串足够长以便将 value 设置在指定的偏移量上，不存在的 key 当作空白字符串处理。如果给定 key 原来储存的字符串长度比偏移量小，那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )来填充。注意你能使用的最大偏移量是 2^29-1(536870911) ，因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内。如果你需要使用比这更大的空间，你可以使用多个 key 。时间复杂度：对小(small)的字符串，平摊复杂度O(1)(关于什么字符串是”小”的，请参考 append命令)。否则为O(M)， M 为 value 参数的长度。实例123456789101112131415$ # 对非空字符串进行 setrange127.0.0.1:6379&gt; set hello &quot;hello world&quot;OK127.0.0.1:6379&gt; setrange hello 6 &quot;Redis&quot;(integer) 11127.0.0.1:6379&gt; get hello&quot;hello Redis&quot;$ # 对空字符串/不存在的 key 进行 setrange127.0.0.1:6379&gt; exists empty_string(integer) 0127.0.0.1:6379&gt; setrange empty_string 5 &quot;Redis!&quot;(integer) 11127.0.0.1:6379&gt; get empty_string &quot;\x00\x00\x00\x00\x00Redis!&quot;模式因为有了setrange和getrange命令，你可以将 Redis 字符串用作具有O(1)随机访问时间的线性数组，这在很多真实用例中都是非常快速且高效的储存方式，具体请参考append命令的『模式：时间序列』部分。appendappend key valueappend key value之后，返回 key 中字符串的长度。如果 key 已经存在并且是一个字符串，append命令将 value 追加到 key 原来的值的末尾。如果 key 不存在，append就简单地将给定 key 设为 value ，就像执行 set key value 一样。可用版本：&gt;= 2.0.0。时间复杂度：平摊O(1)。实例1234567127.0.0.1:6379&gt; exists money(integer) 0127.0.0.1:6379&gt; append money &quot;five cent&quot;(integer) 9127.0.0.1:6379&gt; append money &quot;one dollor&quot;(integer) 19127.0.0.1:6379&gt;时间序列(Time series)append可以为一系列定长(fixed-size)数据(sample)提供一种紧凑的表示方式，通常称之为时间序列。每当一个新数据到达的时候，执行命令：append timeseries &quot;fixed-size sample&quot;然后可以通过以下的方式访问时间序列的各项属性：strlen 给出时间序列中数据的数量getrange 可以用于随机访问。只要有相关的时间信息的话，我们就可以在 Redis 2.6 中使用 Lua 脚本和 GETRANGE 命令实现二分查找。setrange 可以用于覆盖或修改已存在的的时间序列。这个模式的唯一缺陷是我们只能增长时间序列，而不能对时间序列进行缩短，因为 Redis 目前还没有对字符串进行修剪(tirm)的命令，但是，不管怎么说，这个模式的储存方式还是可以节省下大量的空间。可以考虑使用 UNIX 时间戳作为时间序列的键名，这样一来，可以避免单个 key 因为保存过大的时间序列而占用大量内存，另一方面，也可以节省下大量命名空间。setset key value [EX seconds] [PX milliseconds] [NX|XX]将字符串值 value 关联到 key 。如果 key 已经持有其他值， SET 就覆写旧值，无视类型。对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。可选参数从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：EX second ：设置键的过期时间为 second 秒。 set key value EX second 效果等同于 setex key second value 。PX millisecond ：设置键的过期时间为 millisecond 毫秒。 set key value PX millisecond 效果等同于 psetex key millisecond value 。NX ：只在键不存在时，才对键进行设置操作。 set key value NX 效果等同于 setnx key value 。XX ：只在键已经存在时，才对键进行设置操作。返回值在 Redis 2.6.12 版本以前， SET 命令总是返回 OK 。从 Redis 2.6.12 版本开始， SET 在设置操作成功完成时，才返回 OK 。如果设置了 NX 或者 XX ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。使用模式命令 set resource-name anystring NX EX max-lock-time 是一种在 Redis 中实现锁的简单方法。客户端执行以上的命令：如果服务器返回 OK ，那么这个客户端获得锁。如果服务器返回 NIL ，那么客户端获取锁失败，可以在稍后再重试。设置的过期时间到达之后，锁将自动释放。可以通过以下修改，让这个锁实现更健壮：不使用固定的字符串作为键的值，而是设置一个不可猜测（non-guessable）的长随机字符串，作为口令串（token）。不使用 DEL 命令来释放锁，而是发送一个 Lua 脚本，这个脚本只在客户端传入的值和键的口令串相匹配时，才对键进行删除。这两个改动可以防止持有过期锁的客户端误删现有锁的情况出现。123456if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1]then return redis.call(&quot;del&quot;, KEYS[1])else return 0end]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis配置与数据类型]]></title>
    <url>%2Fposts%2F2c68463d%2F</url>
    <content type="text"><![CDATA[Redis配置Redis的配置文件位于Redis安装目录下，文件名为 redis.conf(Windows 名为redis.windows.conf)。你可以通过config命令查看或设置配置项。⚠️不推荐对原始的redis.conf文件进行修改，推荐重新建一个配置文件进行修改，然后运行自己创建的配置文件查看配置语法1127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME示例1234567891011121314151617181920212223242526272829303132127.0.0.1:6379&gt; config get dbfilename #获取某个配置项1) "dbfilename"2) "dump.rdb"127.0.0.1:6379&gt; config get * # 获取所有配置项 1) "dbfilename" 2) "dump.rdb" 3) "requirepass" 4) "" 5) "masterauth" 6) "" 7) "cluster-announce-ip" 8) "" 9) "unixsocket" 10) "" 11) "logfile" 12) "" 13) "pidfile" 14) "" 15) "slave-announce-ip" 16) "" 17) "replica-announce-ip" 18) "" 19) "maxmemory" 20) "0"……208) "0"209) "slaveof"210) ""211) "notify-keyspace-events"212) ""213) "bind"214) ""修改配置你可以通过修改redis.conf文件或使用config set命令来修改配置。语法1127.0.0.1:6379&gt; config set CONFIG_SETTING_NAME NEW_CONFIG_VALUE示例12345127.0.0.1:6379&gt; config set loglevel "notice"OK127.0.0.1:6379&gt; config get loglevel1) "loglevel"2) "notice"参数说明redis.conf 配置项说明如下：类型配置项说明基本daemonize no是否以守护进程的方式运行，默认为 no，使用yes启用守护进程基本databases 16设置数据库的数量，默认数据库为0，可以使用SELECT命令在连接上指定数据库id基本stop-writes-on-bgsave-error yes后台存储错误停止写，默认为 yes基本save &lt;seconds&gt; &lt;changes&gt;指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合。Redis默认配置文件中提供了三个条件：save 900 1 、 save 300 10、save 60 10000基本rdbcompression yes指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大。基本rdbchecksum yes存储和加载rdb文件时校验，默认为 yes基本dbfilename dump.rdb指定本地数据库文件名，默认值为dump.rdb基本dir ./指定本地数据库存放目录，默认为当前安装目录主从slaveof &lt;masterip&gt; &lt;masterport&gt;设置当本机为slave服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步主从masterauth &lt;master-password&gt;当master服务设置了密码保护时，slav服务连接master的密码主从slave-serve-stale-data yes当主从断开或正在复制中，从服务器是否应答，默认为 yes主从repl-disable-tcp-nodelay no主端是否合并数据,大块发送给slave主从slave-priority 100如果master不能再正常工作，那么会在多个slave中，选择优先值最小的一个slave提升为master，优先值为0表示不能提升为master。主从slave-read-only yes从服务器只读，默认为 yes主从repl-ping-slave-period 10从ping主的时间间隔，秒为单位主从repl-timeout 60主从超时时间(超时认为断线了)，要比period大安全requirepass foobared设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH命令提供密码，默认关闭安全rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52如果公共环境，可以重命名部分敏感命令，如config限制maxclients 128设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息限制maxmemory &lt;bytes&gt;指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区限制maxmemory-policy volatile-lru内存到极限后的处理1. volatile-lru -&gt; LRU 算法删除过期key2. allkeys-lru -&gt; LRU算法删除key(不区分过不过期)3. volatile-random -&gt; 随机删除过期key4. allkeys-random -&gt; 随机删除key(不区分过不过期)5. volatile-ttl -&gt; 删除快过期的key6. noeviction -&gt; 不删除,返回错误信息日志模式appendonly no指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no日志模式appendfilename appendonly.aof指定更新日志文件名，默认为appendonly.aof日志模式appendfsync everysec指定更新日志条件，共有3个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折衷，默认值）日志模式no-appendfsync-on-rewrite no为yes，则其他线程的数据放内存里,合并写入(速度快，容易丢失的多)日志模式auto-AOF-rewrite-percentage 100aof文件增长比例，指当前aof文件比上次重写的增长比例大小。aof重写即在aof文件在一定大小之后，重新将整个内存写到aof文件当中，以反映最新的状态(相当于bgsave)。这样就避免了，aof文件过大而实际内存数据小的问题(频繁修改数据问题)。日志模式auto-AOF-rewrite-min-size 64mbaof文件重写最小的文件大小，即最开始aof文件必须要达到这个文件时才触发，后面的每次重写就不会根据这个变量了(根据上一次重写完成之后的大小)，此变量仅初始化启动redis有效。如果是redis恢复时，则lastSize等于初始aof文件大小。日志模式aof-load-truncated yes指redis在恢复时，会忽略最后一条可能存在问题的指令。默认值yes。即在aof写入时，可能存在指令写错的问题(突然断电，写了一半)，这种情况下，yes会log并继续，而no会直接恢复失败。日志loglevel verbose指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose日志logfile stdout日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null连接auth 密码密码登陆(如果有密码)连接ping测试服务器是否可用连接echo &quot;some content&quot;测试服务器是否正常交互连接select 0/1/2…选择数据库连接quit退出连接服务端shutdown [save/nosave]关闭服务器，保存数据，修改AOF(如果设置)服务端flushdb清空当前数据库的所有数据服务端flushall清空所有数据库的所有数据(误用了怎么办?)服务端config get 选项(支持*通配)config set 选项 值config rewriteconfig restart获取配置项修改配置项把值写到配置文件更新info命令的信息服务端timedbsizebgrewriteaofbgsavesavelastsave1. 返回时间戳+微秒2. 返回key的数量3.重写aof4. 在后台异步保存当前数据库的数据到磁盘5. 执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘6.返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示服务端monitor打开控制台,观察命令(调试用)服务端client listclient killclient getnameclient setname &quot;名称&quot;1. 列出所有连接2. 杀死某个连接 CLIENT KILL 127.0.0.1:435013. 获取连接的名称 默认nil4. 设置连接名称,便于调试慢查询slowlog get获取慢查询日志慢查询slowlog len获取慢查询日志条数慢查询slowlog reset清空慢查询慢查询slowlog-log-slower-than 10000记录响应时间大于10000微秒的慢查询。慢查询slowlog-max-len 128最多记录128条Redis数据类型Redis支持五种数据类型：string(字符串)，hash(哈希)，list(列表)，set(集合)及zset(sorted set：有序集合)。Stringstring 是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个 key 对应一个 value。string 类型是二进制安全的。意思是Redis的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是Redis最基本的数据类型，string 类型的值最大能存储 512MB。1234127.0.0.1:6379&gt; set name &quot;redis&quot;OK127.0.0.1:6379&gt; get name&quot;redis&quot;HashRedis hash 是一个键值(key=&gt;value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。每个 hash 可以存储 2^32-1 键值对（40多亿）存储、读取、修改用户属性1234567127.0.0.1:6379&gt; del name # 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value127.0.0.1:6379&gt; hmset name field1 &quot;Hello&quot; field2 &quot;World&quot;&quot;OK&quot;127.0.0.1:6379&gt; hget name field1&quot;Hello&quot;127.0.0.1:6379&gt; hget name field2&quot;World&quot;ListRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。列表最多可存储 2^32-1 元素 (4294967295, 每个列表可存储40多亿)。实例1234567891011127.0.0.1:6379&gt; del name127.0.0.1:6379&gt; lpush name redis(integer) 1127.0.0.1:6379&gt; lpush name mongodb(integer) 2127.0.0.1:6379&gt; lpush name mysql(integer) 3127.0.0.1:6379&gt; lrange name 0 101) &quot;mysql&quot;2) &quot;mongodb&quot;3) &quot;redis&quot;SetRedis的Set是string类型的无序集合，提供了求交集、并集、差集等操作。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为 2^32-1(4294967295, 每个集合可存储40多亿个成员)。sadd 命令:添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。共同好友、利用唯一性，统计访问网站的所有独立ip、好友推荐时，根据tag求交集，大于某个阈值就可以推荐12345678910111213127.0.0.1:6379&gt; del name127.0.0.1:6379&gt; sadd name redis(integer) 1127.0.0.1:6379&gt; sadd name mongodb(integer) 1127.0.0.1:6379&gt; sadd name mongodb(integer) 0127.0.0.1:6379&gt; sadd name mysql(integer) 1127.0.0.1:6379&gt; smembers name1) &quot;redis&quot;2) &quot;rabitmq&quot;3) &quot;mongodb&quot;zsetRedis zset 和 set 一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数(score)却可以重复。zadd 命令：添加元素到集合，元素在集合中存在则更新对应score排行榜、带权重的消息队列格式：zadd key score member12345678910111213127.0.0.1:6379&gt; del name127.0.0.1:6379&gt; zadd name 0 redis(integer) 1127.0.0.1:6379&gt; zadd name 0 mongodb(integer) 1127.0.0.1:6379&gt; zadd name 0 mysql(integer) 1127.0.0.1:6379&gt; zadd name 0 mysql(integer) 0127.0.0.1:6379&gt; &gt; zrangebyscore name 0 10001) &quot;mongodb&quot;2) &quot;mysql&quot;3) &quot;redis&quot;]]></content>
      <categories>
        <category>Redis</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis配置与数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis问题记录]]></title>
    <url>%2Fposts%2F9f25d6e0%2F</url>
    <content type="text"><![CDATA[强制把redis快照关闭了导致不能持久化的问题现象1234567127.0.0.1:6379&gt; ping(error) MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.解决办法通过stop-writes-on-bgsave-error值设置为no即可避免这种问题。有两种修改方法，一种是通过redis命令行修改，另一种是直接修改redis.conf配置文件。redis命令行修改示例：1127.0.0.1:6379&gt; config set stop-writes-on-bgsave-error no使用 redis-cli 过程中出现中文乱码使用redis-cli时后面加上--raw就可以避免中文乱码。1$ redis-cli --raw -h host -p port -a passwordNOAUTH Authentication required.12345678910Exception in thread &quot;main&quot; redis.clients.jedis.exceptions.JedisDataException: NOAUTH Authentication required. at redis.clients.jedis.Protocol.processError(Protocol.java:127) at redis.clients.jedis.Protocol.process(Protocol.java:161) at redis.clients.jedis.Protocol.read(Protocol.java:215) at redis.clients.jedis.Connection.readProtocolWithCheckingBroken(Connection.java:340) at redis.clients.jedis.Connection.getStatusCodeReply(Connection.java:239) at redis.clients.jedis.BinaryJedis.ping(BinaryJedis.java:196) at org.sang.RedisTest.main(RedisTest.java:12)Process finished with exit code 1进行密码验证或者把密码置空。在多线程场景下使用redis时，可能会出现各种类型转换异常：如：B cannot be cast to java.util.List原因在多线程场景下，如果使用jedis连接池获取连接，在各个地方调用，且使用完之后没有释放，则可能在某次使用的时候，拿到的是其他线程的连接，则会出现类型转换异常。解决方案在每次使用完连接后，将其返回连接池。具体操作如下：1234567891011121314/** * return resource to pool * @paran isBroken 是否产生异常 */public void returnResource(Jedis shardedJedis, boolean isBroken) &#123; // starting from Jedis 3.0 this method will not be exposed. Resource cleanup should be done using @see &#123;@link redis.clients.jedis.Jedis#close()&#125; // returnBrokenResource | returnResource 在Jedis 3.0之后已经被废弃，释放shardedJedis调用Jedis的close()方法即可。 if (isBroken) &#123; jedisPool.returnBrokenResource(shardedJedis); &#125; else &#123; jedisPool.returnResource(shardedJedis); &#125;&#125;线上Redis禁止使用Keys正则匹配操作背景redis是单线程的，其所有操作都是原子的，不会因并发产生数据异常使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。案例运维人员进行keys *操作，该操作比较耗时，又因为redis是单线程的，所以redis被锁住。此时QPS比较高，又来了几万个对redis的读写请求，因为redis被锁住，所以全部Hang在那。因为太多线程Hang在那，CPU严重飙升，造成redis所在的服务器宕机。所有的线程在redis那取不到数据，一瞬间全去数据库取数据，数据库就宕机了。其他危险命令但凡发现时间复杂度为O(N)的命令，都要慎重，不要在生产上随便使用。例如hgetall、lrange、smembers、zrange、sinter等命令，它们并非不能使用，但这些命令的时间复杂度都为O(N)，使用这些命令需要明确N的值，否则也会出现缓存宕机。flushdb 命令用于清空当前数据库中的所有 keyflushall 命令用于清空整个 Redis 服务器的数据(删除所有数据库的所有 key )config 客户端连接后可配置服务器如何禁用危险命令在redis.conf中，在SECURITY这一项中，我们新增以下命令：1234rename-command FLUSHALL &quot;&quot;rename-command FLUSHDB &quot;&quot;rename-command CONFIG &quot;&quot;rename-command KEYS &quot;&quot;另外，对于flushall命令，需要设置配置文件中appendonly no，否则服务器是无法启动。请注意，更改[记录到AOF文件或传输到副本的命令]的名称可能会导致问题。改良建议使用scan命令来改良keys和smembers命令redis2.8版本以后有了一个新命令scan，可以用来分批次扫描redis记录，这样肯定会导致整个查询消耗的总时间变大，但不会影响redis服务卡顿，影响服务使用。更多信息可参考redis scan命令Redis Big Key问题数据量大的 key ，由于其数据大小远大于其他key，导致经过分片之后，某个具体存储这个 big key 的实例内存使用量远大于其他实例，造成内存不足，拖累整个集群的使用。big key 在不同业务上，通常体现为不同的数据，比如：论坛中的大型持久盖楼活动；聊天室系统中热门聊天室的消息列表； ……带来的问题bigkey 通常会导致内存空间不平衡，超时阻塞，如果 key 较大，redis 又是单线程，操作 bigkey 比较耗时，那么阻塞 redis 的可能性增大。每次获取 bigKey 的网络流量较大，假设一个 bigkey 为 1MB,每秒访问量为 1000，那么每秒产生 1000MB 的流量，对于普通千兆网卡，按照字节算 128M/S 的服务器来说可能扛不住。而且一般服务器采用单机多实例方式来部署，所以还可能对其他实例造成影响。如果是集群模式下，无法做到负载均衡，导致请求倾斜到某个实例上，而这个实例的QPS会比较大，内存占用也较多；对于Redis单线程模型又容易出现CPU瓶颈，当内存出现瓶颈时，只能进行纵向库容，使用更牛逼的服务器。涉及到大key的操作，尤其是使用hgetall、lrange、get、hmget 等操作时，网卡可能会成为瓶颈，也会到导致堵塞其它操作，qps 就有可能出现突降或者突升的情况，趋势上看起来十分不平滑，严重时会导致应用程序连不上，实例或者集群在某些时间段内不可用的状态。假如这个key需要进行删除操作，如果直接进行DEL 操作，被操作的实例会被Block住，导致无法响应应用的请求，而这个Block的时间会随着key的变大而变长。什么是 big key字符串类型：一般认为超过 10k 的就是 bigkey，但是这个值和具体的 OPS 相关。非字符串类型：体现在哈希，列表，集合类型元素过多。寻找big keyredis-cli自带--bigkeys。12$ redis-cli -p 999 --bigkeys -i 0.1#Scanning the entire keyspace to find biggest keys as well as average sizes per key type. You can use -i 0.1 to sleep 0.1 sec per 100 SCAN commands (not usually needed).获取生产Redis的rdb文件，通过rdbtools分析rdb生成csv文件，再导入MySQL或其他数据库中进行分析统计，根据size_in_bytes统计bigkey1234$ git clone https://github.com/sripathikrishnan/redis-rdb-tools$ cd redis-rdb-tools$ sudo python setup.py install$ rdb -c memory dump-10030.rdb &gt; memory.csv通过python脚本，迭代scan key，每次scan 1000，对扫描出来的key进行类型判断，例如：string长度大于10K，list长度大于10240认为是big bigkeys其他第三方工具，例如：redis-rdb-cli优化big key优化big key的原则就是string减少字符串长度，list、hash、set、zset等减少成员数。string类型的big key，建议不要存入redis，用文档型数据库MongoDB代替或者直接缓存到CDN上等方式优化。有些 key 不只是访问量大，数据量也很大，这个时候就要考虑这个 key 使用的场景，存储在redis集群中是否是合理的，是否使用其他组件来存储更合适；如果坚持要用 redis 来存储，可能考虑迁移出集群，采用一主一备（或1主多备）的架构来存储。单个简单的key存储的value很大该对象需要每次都整存整取: 可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响；该对象每次只需要存取部分数据: 可以像第一种做法一样，分拆成几个key-value，也可以将这个存储在一个hash中，每个field代表一个具体的属性，使用hget,hmget来获取部分的value，使用hset，hmset来更新部分属性。hash， set，zset，list 中存储过多的元素可以将这些元素分拆。以hash为例，原先的正常存取流程是 hget(hashKey, field) ; hset(hashKey, field, value)现在，固定一个桶的数量，比如 10000， 每次存取的时候，先在本地计算field的hash值，模除 10000，确定了该field落在哪个key上。123newHashKey = hashKey + (hash(field) % 10000）; hset(newHashKey, field, value) ; hget(newHashKey, field)set, zset, list 也可以类似上述做法。但有些不适合的场景，比如，要保证 lpop 的数据的确是最早push到list中去的，这个就需要一些附加的属性，或者是在 key的拼接上做一些工作（比如list按照时间来分拆）。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis简单介绍与安装]]></title>
    <url>%2Fposts%2F985fe3fe%2F</url>
    <content type="text"><![CDATA[Redis 简单介绍REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、高性能的key-value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值(value)可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets) 和有序集合(sorted sets)等类型。Redis 特点key-value缓存产品的三个特点：支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。支持简单的key-value类型的数据。支持数据的备份，即master-slave模式的数据备份。Redis的优势：性能极高——Redis能读的速度是110000次/s，写的速度是81000次/s 。丰富的数据类型——Redis支持list、set、zset、hash等数据结构的操作。原子性——Redis的所有操作都是原子性的：单个操作是原子性的，多个操作也支持事务(通过MULTI和EXEC指令包起来)。丰富的特性——Redis还支持publish/subscribe，通知，key 过期等等特性。Redis 安装Window 下安装下载地址：https://github.com/MSOpenTech/redis/releases。Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。如果下载Redis-x64-3.2.100.msi，双击执行安装即可。如果下载Redis-x64-3.2.100.zip，解压到指定目录即可使用。进入安装目录执行以下命令，如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。1&gt; redis-server.exe redis.windows.confLinux 下安装下载地址：http://redis.io/download，下载最新稳定版本。1234$ wget http://download.redis.io/releases/redis-5.0.5.tar.gz$ tar xzf redis-5.0.5.tar.gz$ cd redis-5.0.5$ makemake完后redis-5.0.5目录下会出现编译后的redis服务程序redis-server，还有用于测试的客户端程序redis-cli，两个程序位于安装目录 src 目录下：下面启动redis服务.123$ cd src$ ./redis-server # 使用默认配置$ ./redis-server ../redis.conf # redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务进行交互。Ubuntu 下安装在 Ubuntu 系统安装 Redis 可以使用以下命令:12$sudo apt-get update$sudo apt-get install redis-server启动 Redis1$ redis-serverMac 下安装方法一官网http://redis.io/ 下载最新的稳定版本,这里是5.0.512345$ sudo mv redis-5.0.5.tar.gz /usr/local/ # 移至 /usr/local/$ sudo tar xzf redis-5.0.5.tar.gz # 解压文件$ cd redis-5.0.5 # 进入解压目录$ sudo make test # 测试编译$ sudo make install # 安装方法二使用 homebrew1234$ brew search redis # 查找可用的redis包$ brew install redis #安装redis，可加@版本号安装指定版本，eg: brew install redis@4.0$ # 只能安装可用的redis包，可能不是官网最新版本，比如此次支持最高的是redis@4.0，redis官网是Stable (5.0)$ brew services start redis # 或者直接启动：redis-server /usr/local/etc/redis.conf安装后的简单操作启动Redis server1234567891011121314151617181920212223242526$ cd redis-5.0.5/src$ ./redis-server ../redis.conf60379:C 28 Jul 2019 09:46:36.625 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo60379:C 28 Jul 2019 09:46:36.625 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=60379, just started60379:C 28 Jul 2019 09:46:36.625 # Configuration loaded60379:M 28 Jul 2019 09:46:36.627 * Increased maximum number of open files to 10032 (it was originally set to 256). _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 5.0.5 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 60379 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 60379:M 28 Jul 2019 09:46:36.631 # Server initialized60379:M 28 Jul 2019 09:46:36.631 * Ready to accept connections测试 Redis 是否启动12345$ ./redis-cli # 不知道IP和端口127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; pingPONG# 已经成功安装了redis。Redis 的简单 set 和 get123456$ ./redis-cli -h 127.0.0.1 -p 6379 #指定ip和端口127.0.0.1:6379&gt; set hello worldOK127.0.0.1:6379&gt; get hello"world"127.0.0.1:6379&gt;退出 Redis 客户端1127.0.0.1:6379&gt; exit退出 Redis 服务1$ ./redis-cli shutdown检测 Redis 服务123456#检测后台进程是否存在$ ps -ef |grep redis#检测6379端口是否在监听$ netstat -tln | grep 6379#因为Redis可以妥善处理SIGTERM信号，所以直接 kill -9 进程id 也是可以关闭redis的kill -9 PID卸载 Redis先关闭 Redis 服务，检测以确定关闭。删除 make 的时候产生的几个 redis 文件1234567$ rm -rf /usr/local/bin/redis*# redis-benchmark# redis-check-aof# redis-check-rdb# redis-cli# redis-sentinel# redis-server删除解压后的文件目录和所有文件123$ cd /usr/local/$ rm -rf redis-5.0.5$ rm -rf redis-5.0.5.tar.gz]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源软件协议对比]]></title>
    <url>%2Fposts%2F6821cef2%2F</url>
    <content type="text"><![CDATA[开源不等于免费，开源也不等于没有约束。License就是版权许可证，里面详尽表述了你获得代码后拥有的权利，可以对别人的作品进行何种操作，何种操作又是被禁止的。世界上的开源许可证(Open Source License)大概有上百种，我们常用的开源软件协议大致有GPL、BSD、MIT、Mozilla、Apache和LGPL。协议介绍Apache LicenseApache License（Apache许可证），是Apache软件基金会发布的一个自由软件许可证。Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件：需要给代码的用户一份Apache Licence。如果修改了代码，需要再被修改的文件中说明。在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。Apache Licence也是对商业应用又好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。使用这个协议的好处是:永久权利：一旦被授权，永久拥有。全球范围的权利：在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。授权免费：无版税， 前期、后期均无任何费用。授权无排他性：任何人都可以获得授权。授权不可撤消：一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码。BSDBSD是”Berkeley Software Distribution”的缩写，意思是”伯克利软件发行版”。BSD开源协议：是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。GPLGPL （GNU General Public License） ：GNU通用公共许可协议。Linux 采用了 GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。LGPLLGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。MITMIT是和BSD一样宽范的许可协议,源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。MPL (Mozilla Public License 1.1)MPL协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。EPL (Eclipse Public License 1.0)EPL允许Recipients任意使用、复制、分发、传播、展示、修改以及改后闭源的二次商业发布。使用EPL协议，需要遵守以下规则：当一个Contributors将源码的整体或部分再次开源发布的时候,必须继续遵循EPL开源协议来发布,而不能改用其他协议发布.除非你得到了原”源码”Owner 的授权；EPL协议下,你可以将源码不做任何修改来商业发布.但如果你要发布修改后的源码,或者当你再发布的是Object Code的时候,你必须声明它的Source Code是可以获取的,而且要告知获取方法；当你需要将EPL下的源码作为一部分跟其他私有的源码混和着成为一个Project发布的时候,你可以将整个Project/Product以私人的协议发布,但要声明哪一部分代码是EPL下的,而且声明那部分代码继续遵循EPL；独立的模块(Separate Module),不需要开源。Creative Commons 知识共享协议Creative Commons (CC) 许可协议并不能说是真正的开源协议，它们大多是被使用于设计类的工程上。 CC 协议种类繁多，每一种都授权特定的权利。 一个 CC 许可协议具有四个基本部分，这几个部分可以单独起作用，也可以组合起来。下面是这几部分的简介：署名：作品上必须附有作品的归属。如此之后，作品可以被修改，分发，复制和其它用途。相同方式共享：作品可以被修改、分发或其它操作，但所有的衍生品都要置于CC许可协议下。非商业用途：作品可以被修改、分发等等，但不能用于商业目的。但语言上对什么是”商业”的说明十分含糊不清 (没有提供精确的定义)，所以你可以在你的工程里对其进行说明。例如，有些人简单的解释”非商业”为不能出售这个作品。而另外一些人认为你甚至不能在有广告的网站上使用它们。 还有些人认为”商业”仅仅指你用它获取利益。禁止衍生作品CC 许可协议的这些条款可以自由组合使用。大多数的比较严格的CC协议会声明 “署名权，非商业用途，禁止衍生”条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且必须声明作品的归属。这个许可协议非常的有用，它可以让你的作品传播出去，但又可以对作品的使用保留部分或完全的控制。最少限制的CC协议类型当属 “署名”协议，这意味着只要人们能维护你的名誉，他们对你的作品怎么使用都行。CC 许可协议更多的是在设计类工程中使用，而不是开发类，但没有人或妨碍你将之使用与后者。只是你必须要清楚各部分条款能覆盖到的和不能覆盖到的权利。如何选择简洁版稍微复杂版链接各种开源协议介绍]]></content>
      <categories>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>开源协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-乐评]]></title>
    <url>%2Fposts%2F70b9f430%2F</url>
    <content type="text"><![CDATA[001后来再想，你哪点值得我义无反顾？——《那女孩对我说》你回头看一眼我好不好，我就要放弃你了。——《不找了》写歌的人假正经，听歌的人最无情，人要是矫情起来，听什么都像在说自己。——《不找了》每天都在找饭卡：“我觉得这首歌对我的ID有莫大的恶意。”——《不找了》多年以后一场大雨惊醒沉睡的我。——《星星点灯》嗯，我不会慌张，爱在我心上❤️——《给未来》希望我们冰释前嫌，再也不相见。——《消愁》没有正儿八经谈过恋爱，特别喜欢听情歌😌——《情歌》孤岛——仙人掌——铁树002我仍然认为向人诉苦不过是徒劳，与其如此，不如默默承受。——《标签》我一直都不敢承认自己是个抑郁患者。——《标签》人们真的会因为嘴硬失去很多东西，就像我一样，失去了那个爱我的她——《标签》你爱的人原本也是凡人，是你的注视让他镀上金身。做一个俗人，贪君子之财，好美景之色，一身正气，行正义之事，了前生之怨，爱此生之爱人。——《Skin》有人说：二十年的太子，一天的皇上，十个月的奴才，一辈子的提款机，这就是男人的一生；可有人又说：二十年的公主，一天的皇后，十个月的宠妃，一辈子的保姆，这就是女人的一生。我觉得，应该是：二十年的追寻，一天的仪式，十个月的呵护，换来一辈子的相濡以沫。——《What Makes You Beautiful》沈腾的角色很丧，还要被随时准备打脸，偷车架，卖唱，卖炒饭，做一切不可谓卑微的事情。可是都没忘了，那一千多个弯道。我们会被逗笑，这人真背，可是想想自己，是否用尽过全力去追求热爱的事？全力到，尊严和生命都可以牺牲，就是想，在别人眼里当傻子一样的想。我们有那么多故事，是否欠一个结局？——《奉献》小学时，想和喜欢的人同桌；初中时，想和喜欢的人同班；高中时，想和喜欢的人同校；工作时，想和喜欢的人同城；年老时，想和喜欢的人同一个世界。起初我们揣着糊涂装明白，后来我们揣着明白装糊涂。并不是我们愿意活得不明不白，只是好多事情一用力就会拆穿，拆穿就会失去。长大以后的世界总是这么脆弱！——《那女孩对我说》003人的一生，要死去三次。第一次，当你的心跳停止，呼吸消逝，你在生物学上被宣告了死亡；第二次，当你下葬，人们穿着黑衣出席你的葬礼，他们宣告，你在这个社会上不复存在，你悄然离去；而第三次死亡，是这个世界上最后一个记得你的人，把你忘记，于是，你就真正地死去。整个宇宙都将不再和你有关。——《the sound of silence》人之所以遭受各种各样的伤害大多源于：眼睛看到不该看的东西；嘴巴说出伤人的话语；耳朵听到他人的秘密。——《耳朵》你说一个人自杀，是想通了还是想不通了。——《遗书》看看老电影，听听老调子，对新的人与事物慵懒懈怠。如果那一日的天比较倦，余晖也打着哈欠，我就和一些旧人，谈笑风生。然后等我变老，红酒也够老，就趁着微醺伴着爵士乐沉沉睡去，直到落日的余晖完全融在突如其来的雨里。——《未妨惆怅是清狂》毛不易创作手记：“这个世界上，还有很多不被认可的梦想，不被祝福的感情，不被眷顾的孩子，他们不曾犯错，却只能颤颤巍巍，单薄地行走在路上。这首歌送给他们，借天地万物，不求终将到达某处，只求路上少些阻碍，让他们同样平凡。”——《借》我所有自负都来自我的自卑，所有的英雄气概都来自于我内心的软弱，所有的振振有词都因为心中满是怀疑。我假装无情，其实是痛恨自己的深情。我以为人生的意义在于四处游荡流亡，其实只是掩饰至今没有找到愿意驻足的地方。——《词不达意》我觉得我就像集市上的鱼，水分蒸发得差不多了。我时常觉得自己就要撑不下去，而你总是适时又吝啬地洒点水给我，我便要再提着一口气蹦哒两下，作出生龙活虎的样子给你看。我在前途未卜的痛苦里周而复始，你是不要我死的，又偏不肯温柔豢养我。——《鱼》但凡死缠烂打的人，大都不是真的深爱你，那只是在跟自己赛跑。真正爱你的人，做不到死缠烂打。因为自尊不允许。我们一直深信，爱就是把最好的一切给予对方，包括尊严。多少浅浅淡淡的转身，是旁人看不懂的情深。即使遗憾，那也就遗憾吧。——《献世》任何感情问题都不要冷处理，无论是和家人还是恋人。你有疑惑的时候就要去询问，你有错误的时候就要去承认，你想他就要告诉他。很多事情忍着忍着就变得模糊了，明明不是误会也变成了误会。别以为那些问题会在忍耐的时间中被化解，它只会在日积月累中爆发，给你一个承受不了的结果。——《玩笑》004我觉得这样的距离很好，就隔着一片海互不打扰，谁能够决定谁 怎样最好，我疏离得很舒服 不想治疗，这种距离对大家都好，就隔着一片海互相远眺，懂的人懂得就好，我是座小小岛 心满意足的小岛，我爱的人爱我就好。 ——《离岛》慢慢大家会明白的，无法跟喜欢的人在一起，其实是人生的常态。忘记一个人可以有两种方式一种是时间，另一种是新欢，而你却选择了时间。——《爱了很久的朋友》某天，你无端想起了一个人，他曾让你对明天有所期许，但是却完全没有出现在你的明天里。——《再见金华站》爱与被爱是世界上最重要的事。——《再见金华站》有时候会喜欢听奇奇怪怪的歌 吃奇奇怪怪的东西 做奇奇怪怪的事 爱奇奇怪怪的人——《桂花巷》没有神的光环，你我生而平凡。——《只要平凡》]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>乐评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记]]></title>
    <url>%2Fposts%2F8eda3648%2F</url>
    <content type="text"><![CDATA[理论篇Redis简单介绍与安装Redis问题记录Redis配置与数据类型Redis命令1Redis命令2Redis命令3Redis命令4Redis命令5Redis进阶教程实战篇]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java源码学习笔记]]></title>
    <url>%2Fposts%2F61fedef2%2F</url>
    <content type="text"><![CDATA[String分析ArrayList分析LinkedList分析HashSet分析HashMap分析枚举类型]]></content>
      <categories>
        <category>源码学习</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[拾句-开解自己]]></title>
    <url>%2Fposts%2F4be8e193%2F</url>
    <content type="text"><![CDATA[001尝试着，放下已有的知识，让自己像孩子一样，慢慢的重新认识这个世界。即便暂时没有什么突破也不要紧，保持那个节奏，允许自己暂时没有突破。为什么不要作弊，不是因为“作弊会对别的学生不公平”，也不是因为“作弊会败坏学校的风气”，而是作弊最终会把你困在一个自己不擅长也不喜欢的职业，困住你真正的人生追求…——加州大学伯克利分校的教授 BrianHarvey好人的皮囊穿久了，都快忘记了怎么做坏人。不强求是美德，更是好方法。清汤一定要清。看起来清澈见底，入口却滋味丰富，这才是一碗好清汤。科学是在黑暗中探索，人性就是黑暗中的蜡烛，照亮我们走过的道路以及前方的危险。失去人性，我们将迎来一个可怕的世界。——迪姆·库克赌性更坚强：光拼是不够的，那是体力活；赌才是脑力活。——曾毓群但愿日子清静，抬头遇见的都是柔情。上天很有意思，猫喜欢吃鱼，猫却不能下水，鱼喜欢吃蚯蚓，鱼却不能上岸。人生，就是一边拥有，一边失去，一边选择，一边放弃。人生，哪有事事如意，生活，哪有样样顺心。所以，不和别人较真，因为不值得，不和自己较真，因为伤不起，不和往事较真，因为回不去。002地球这么大，世界这么宽阔，如果找不到相似的灵魂也不要太难过，遇到了也不一定能合拍，合拍也不一定能长久，人生也不过如此。人生天地间，忽如远行客。笑看人间沉浮事，闲坐摇扇一壶茶。春有百花秋有月，夏有凉风冬有雪。三生有幸遇见你，纵然悲凉也是情。我与春分皆过客，你携秋水揽星河。我爱你，不光是因为你的样子；还因为和你在一起时，我的样子。欲买桂花同载酒，终不似，少年游。岂能尽如人意，但求无愧我心。003吾貌虽丑，其心温柔。忙着工作懒得吃饭的时候会想，人为什么要会饿呢？享受美食的时候会想，人为什么要会饱呢？还有，人为什么要会胖呢？没有人愿意成为一个孤岛，也没有人愿意成为被人群淹没的一员。要处理好自己害怕被抛弃的感觉。你们搞心理学的，想法的确跟别人不一样。相信快，是相信奇迹；相信慢，是相信明天。快，意味着更多的荷尔蒙；慢，意味着耐得住寂寞，以及持续的投入。「因为看见，所以相信。」 VS 「因为相信，所以看见。」你看见的未来，你相信的那个未来，你主观上的那个未来，和实际上要发生的未来未必是一样的。错了就是错了，挨打要立正。大(多)和小(少)是最基础的不对称。——饭否004重大决策常常是既显然又困难。——饭否爱情和友情一样，都存在很好的人但不合适，于是就没法产生交集，也没法产生共鸣，即使产生了，最终也会消失，因为不对的人，成不了对的事。不要因为寂寞而去谈感情，这样就会因为错的感情更加寂寞。下了决心要做的事要保持不动声色却满心澎湃。读书多了，容颜自然的改变，他们在气质上，在谈吐上，在胸襟上的无涯。——三毛真正骂人的最高境界是面带微笑，云淡风轻。表面看起来很犀利，却掩盖不住内心的色厉内荏，实际上是无能狂怒。生活一地鸡毛，理想得竖起来。贪财惜命，有所为，有所不为。到底有没人在下一盘很大的棋？这是个世界观问题。——饭否005人获得财富、才能、地位，第一步都是储蓄。你的所得比你的花费多，积攒可使用的能量，雪球由小滚大。人生最大的痛苦莫过于，坚持了不该坚持的，放弃了不该放弃的。毕竟几人真得鹿，不知终日梦为鱼。——黄庭坚《杂诗七首》姚明的思维模式，是用自己的冷静把对方的“火”扑灭；而孙杨的思维模式，则是用更大的“火”去冲击对方的“火”，至于这把“火”会波及到谁，孙杨可能并没想过。相比于「技工贸」，柳传志老先生当年主张的「贸工技」路线并没有错。事实上，华为正是沿着这条路线发展起来的，从早期代理程控交换机到自己造程控交换机再逐步深入各方面的研发乃至于自己做芯片和操作系统。也就是说，关键是从贸到工之后没有停，真的搞了技。当没什么事可做的时候，你在做什么？世界上之所以需要鞋匠，是因为有人需要鞋，而不是因为鞋匠需要钱。无限接近死亡，更能领悟生存的真谛。“平等”等于没有执行力，项目上需要有人说了算，并且承担责任。006等我把脸皮磨厚，再给你想要的温柔！仪式感相当于提醒功能，告诉你时间的流逝。时间是人最宝贵的资源，但一天天地过日子，最容易忘掉的又是时间。任何东西，都有时限。七夕的时限是一天，生日的时限也是一天。孩子只能在童年举高高，他变少年，就不接受你这游戏，再说，你也举不动。只要是人做决定，就得把时间这个维度放进去，看看事物的时限，这样才能分出表象与本质。不纠缠：在坚持原则的基础上，适当做出取舍。适时放开烂人烂事。我认真学习、努力考试，辛辛苦苦打拼事业为的是，当我爱的人出现时，不管他是富甲一方，还是一无所有，我都可以张开双手，坦然拥抱他。——辛夷坞别人的美你总会习惯，但自己的美却百看不腻，千金难换。——姜思达I hated every minute of training, but I said,’Don’t quit. Suffer now and live the rest of your life as a champion.’——拳王阿里我总是滑向冰球要去的地方，而非冰球现在的位置。——冰球之王韦恩 · 格雷茨基 ( Wayne Gretzky )不要抽泣，想哭，就大哭一场。要知道，活得越久，就死得越快！——古老的爱尔兰民歌相比失败，更让人沮丧的是失去向上的力量，一旦失去，就失去了赢一次的机会。007理性的进行消费决策，绝不是喊喊口号就完事了，还是要尊重事实。流行的东西不一定事实，直觉的东西也不一定就是好的。人生失败了也没有机会重来，只能试错中不断改进，要么破罐子破摔，要么缝缝补补又三年。现在，你看，你必须努力奔跑才能保持原地不动。——《爱丽丝梦游仙境》忠于自己，活的认真，笑的放肆。事与冀盼有落差请不必惊怕！我只懂得，再努力每天！不要晚上一躺下就仇富，想着”这个人为什么这么有钱，那个人为什么有个好爹“，早睡早起，锻炼身体，享受生活，首先扎扎实实的做好自己应该做的事，以此为基础，徐图进取，也许一辈子也挣不到多少钱，但是当你老了，把自己的奋斗故事讲个大孙子、大孙女听，他们依然会崇拜你的。君子守其缺，而不敢求全也；小人则时时求全，全者既得，而吝与凶随之矣。——曾国藩家书悲观也罢，乐观也罢，还是种咱们的田地要紧。春困秋乏夏打盹，睡不醒的冬三月。008野路子对野路子，是真正的社会达尔文。搞的太正规，也是一种罪。人生即是如此，你可以努力，却无法拒绝。哪有什么胜利可言，挺住，意味着一切。——里尔克钝感力是渡边淳一提出来的，简而言之就是，我对别人的评价和嘲讽没那么敏感，甚至是有点迟钝，你们对我的评价对我影响不大。任何事情到最后都是好事，如果不是，说明没有到最后。耐心点。低下头，给自己一点时间。人生本质就是辛苦的，想要什么，向自己要，我才是我真正的源头。和熬都是变美味的方法，加油也是。无论是个人工作还是创业进行时，其中一大忌讳就是被外界很多看起来有关的噪音打扰，比如别人做了什么，哪个公司融资了，哪个公司又挣了多少钱，一个创业论坛邀请你来分享点什么，另一个公司找过来要合作点啥……做一个温暖的人，浅浅笑，轻轻爱。009你好也罢，差也罢 。美也罢，挫也行。别人对你的态度，其实不会有多大变化。喜欢你的人，还是喜欢你。不喜欢你的人，还是不喜欢你。如果我不曾见过太阳，我本可以忍受黑暗。——狄金森世间的罪恶几乎总是由愚昧无知造成，如果缺乏理解，好心能造成和恶意同样大的危害。——加缪《鼠疫》人生没有白走的路，每一步都算数。世间行乐亦如此，古来万事东流水。——李白Don’t rush, don’t push, don’t wish. 不要着急，不要勉强，不要幻想。凡事不能主观臆断，凡事不能强求，凡事不能固执，凡事不能以自我为中心。Nothing is true. Every is permitted.Seize The Day. And Get Busy Living. 抓住这一天，忙着生活。010KISS: Keep It Simple and Stupid.Stay hungry. Stay foolish.Ever tried, ever failed. No matter, try again. Fail again, fail better.]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>开解自己</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM是如何执行方法调用的?]]></title>
    <url>%2Fposts%2Ff090e573%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>方法调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机是如何加载Java类的？]]></title>
    <url>%2Fposts%2F2ce44cf1%2F</url>
    <content type="text"><![CDATA[从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。Java 语言的类型分为两大类——基本类型(primitive types)和引用类型(reference types)，其中引用类型分为4种：类、接口、数组类和泛型参数。由于泛型参数会在编译过程中被擦除，因此 Java 虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。字节流最常见的形式要属由 Java 编译器生成的 class 文件。除此之外，我们也可以在程序内部直接生成，或者从网格中获取(例如网页中内嵌的小程序 Java applet)字节流。这些不同形式的字节流，都会被加载到 Java虚拟机中，成为类或接口。为了叙述方便，接下来统一使用“类”来称呼。无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。加载加载，是指查找字节流，并且据此创建类的过程。对于非 Java 虚拟机直接生成的类来说，Java 虚拟机需要借助类加载器来完成查找字节流的过程。类加载器的“祖师爷”叫启动类加载器(bootstrap class loader)，它是由 c++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。除了启动类加载器之外，其他的类加载器都是java.lang.ClassLoader的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父 类加载器。在父 类加载器没有找到所请求的情况下，该类加载器才会尝试去加载。在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包的类以及由虚拟机参数-Xbootclasspath指定的类。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器(extension class loader)和应用类加载器(application class loader)，均由 Java 核心类库提供。扩展类加载器的父 类加载器是启动类加载器。它负责加载相对次要的、但又通用的类，比如存放在 JRE 的 lib/ext目录下 jar 包中的类(以及由系统变量 java.ext.dirs指定的类)。应用类加载器的父 类加载器是扩展类加载器。它负责加载应用程序路径下的类。即虚拟机参数 -cp/-classpath、系统变量java.class.path或环境变量 CLASSPATH所指定的路径。默认情况下，应用程序所包含的类便是应用类加载器加载的。Java 9 引入了模块系统，并且略微更改了上述的类加载。扩展类加载器改名为平台类加载器(platform class loader)。Java SE 中除了少数几个关键模块之外，其他模块均由平台类加载器所加载。除了由 Java 核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊的加载方式。例如：我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其进行解密。除了加载功能外，类加载器还提供了命名空间的作用。在 Java 虚拟机中，类的唯一性是由类加载器实现以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们会借助这一特性，来运行同一个类的不同版本。链接链接，是指将创建的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。准备阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则在稍后的初始化阶段进行。除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。在 class 文件被加载到 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址。甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能无歧义地定位到具体目标上。解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或未被加载类的字段或方法，那么解析将触发这个类的加载(未必触发这个类的链接以及初始化)。Java虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。初始化在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。如果直接赋值的静态字段被final所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值(ConstantValue)，其初始化直接由 Java 虚拟机完成。除此之外，直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为&lt;clinit&gt;，即 class init。类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行&lt;clinit&gt;方法的过程。 Java 虚拟机会通过加锁来确保类的&lt;clinit&gt;方法仅被执行一次。只有初始化完成之后，类才正式成为可执行的状态。类的初始化触发情况：当虚拟机启动时，初始化用户指定的主类；当遇到用以创建模板类实例的 new 指令时，初始化 new 指令的目标类；当遇到调用静态方法的指令时，初始化该静态方法所在的类；当遇到访问静态字段的指令时，初始化该静态字段所在的类；子类的初始化会触发父类的初始化；如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；使用反射 API 对某个类进行反射调用时，初始化这个类；当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。其他Java中所有的非私有实例方法，都算是虚方法。调用这些方法的指令，也区分直接调用和虚调用。被final修饰的静态成员变量，如果不是基本类型或字符串，也会放在clinit来做。链接时取得的不是被加载类的地址，而是被加载类所调用的其他方法的地址。在加载阶段就已经生成了 class 结构，已经写入方法区，只是被标记为未链接而暂时不能使用，如果验证失败会报错退出。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java类加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的基本类型]]></title>
    <url>%2Fposts%2F12a97f14%2F</url>
    <content type="text"><![CDATA[在 Smalltalk 中，所有的值都是对象。因此，许多人认为它是一门纯粹的面向对象语言。Java 则不同，它引进了八个基本类型，用来支撑数值计算。Java 这么做主要是出于工程上的考虑，使用基本类型能够在执行效率以及内存使用两方面提升软件性能。Java 虚拟机的 boolean 类型在 Java 语言规范中，boolean类型的值只有两种可能，分别使用符合true和false来表示。在 Java 虚拟机规范中， boolean类型则被映射成int类型，具体来说，true被映射为整数1，false被映射为整数0。这个编码规则约束了 Java 字节码的具体实现。Java 虚拟机规范同时也要求 Java 编译器遵守这个编码规则，并且使用整数相关的字节码来实现逻辑运算。当然，这个约束很容易绕开，除了汇编工具 AsmTools外，还有许多可以修改字节码的 Java 库，比如ASMJava 的基本类型类型值域默认值虚拟机内部符号boolean{false, true}falseZbyte[-128, 127]0Bshort[-32768, 32767]0Schar[0, 65535]‘\u000’Cint[-2^31, 2^31-1]0Ilong[-2^63, 2^63-1]0LJfloat~[-3.4E38, 3.4E38]+0.0FFdouble~[-1.8E308, 1.8E308]+0.0DDbyte、short、int、long、float以及double的值域依次扩大，而且前面的值被后面的值域所包含。因此从前面的基本类型转换至后面的基本类型，无需强制转换。它们的默认值看起来都不一样，但在内存中都是0。这些基本类型中，boolean和char是唯二的无符号类型。声明为byte、char以及short的局部变量，能够存储它们取值范围的数值，但在正常使用 Java 编译器的情况下，生成的字节码会遵守 Java 虚拟机规范对编译器的约束。Java 浮点数Java 的浮点数采用 IEEE 754 浮点数格式。以 float 为例，浮点数类型通常有两个0，+0.0F以及-0.0F。前者在 Java 里是0，后者是符号位为1、其它位均为0的浮点数，在内存中等同于十六进制整数0x8000000。尽管它们的内存数值不同，但是在 Java 中+0.0F==-0.0F 会返回真。浮点数中的正无穷：任意正浮点数除以 +0.0F 得到的值，在内存中等同于0x7F800000;浮点数中的负无穷：任意正浮点数除以 -0.0F 得到的值，在内存中等同于0xFF800000。标准 NaN(Not-a-Number)：通过+0.0F/+0.0F 计算得到，在内存中为0x7FC00000；非标准 NaN(Not-a-Number)：0x7F800001、0x7FFFFFF、0xFF800001、0xFFFFFFFF等NaN 和其它浮点数相比较，除了!=始终返回true外，所有其它比较结果均会返回false。1234567public static void main(String[] args) &#123; System.out.println(Float.floatToIntBits(0.0F)); //0 System.out.println(Float.floatToIntBits(-0.0F)); //-2147483648 System.out.println(Float.floatToIntBits(0.0F/0.0F)); //2143289344 System.out.println(0x7FC00000); //2143289344 System.out.println(Float.intBitsToFloat(0x7F800001)); //NaN&#125;Java 基本类型的大小Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。为了方便解释，这里只讨论供解释器使用的解释栈帧(Interpreted frame)。该栈帧有两个主要组成部分，分别是局部变量区以及字节码的操作数栈。这里的局部变量是广义的，除了普通意义下的局部变量外，它还包含实例方法的”this指针”以及方法所接收的参数。在 Java 虚拟机规范中，局部变量等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储外，其他基本类型以及引用类型的值均占用一个数组单元。即 boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 一样，和引用类型也一样。因此，在32位的HotSpot 中，这些类型将占用4个字节，而在64位的 HotSpot 中，他们将占用8个字节。(int 所包含的数据是4字节，由于 JVM 栈的实现方式，它们实际使用的内存可能占用得更多)当然这种情况仅仅存在于局部变量，并不会出现在存储于堆上的字段或者数组元素。对于 byte、char以及 short 这三种类型的字段或数组单元，它们在堆上占用的空间分别为1字节、2字节以及2字节。(变长数组不好控制，所以选择浪费一些空间，以便访问时直接通过下标来计算地址)当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把0xFFFFFFFF(-1)存储到一个声明为 char 类型的字段里时，由于该字段仅占用1字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”。boolean 和 boolean 数组比较特殊，在 HotSpot 中，boolean 字段占用一字节，而boolean 数组直接使用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式进行掩码操作，即只取最后一位的值存入 boolean 字段或数组中。加载Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成int类型来运算。对于 boolean、char这两类无符号类型来说，加载伴随着零扩展，例如：在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节会用0来填充。对于byte、short这两个类型来说，加载伴随着符号扩展，例如：在加载时，short 值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为0，那么该 int 类型的值的高二字节会用0来填充，否则用1来填充。其他ASM 是字节码工程包，它提供了字节码抽象的工具，允许用 Java 代码来生成或更改字节码。JDK里也会使用 ASM 来生成一些适配器什么的。Unsafe 就是一些不被虚拟机控制的内存操作的合集，需要根据 API 来了解。CAS 可以理解为原子性的写操作，概念来自于底层 CPU 指令。Unsafe 提供了一些 cas 的 Java 接口，在即时编译器中我们会将对这些接口的调用替换成具体的 CPU 指令测试 NaN1234567891011121314public static void main(String[] args) &#123; float nan1 = 0.0f/0.0f; float f = 0.0f; float nan2 = f/f; double d = 0.0; System.out.println(&quot;nan1 raw: &quot; + Integer.toHexString(Float.floatToRawIntBits(nan1))); System.out.println(&quot;nan1: &quot; + Integer.toHexString(Float.floatToIntBits(nan1))); System.out.println(&quot;nan2 raw: &quot; + Integer.toHexString(Float.floatToRawIntBits(nan2))); System.out.println(&quot;nan2: &quot; + Integer.toHexString(Float.floatToIntBits(nan2))); System.out.println(&quot;nan3 raw: &quot; + Long.toHexString(Double.doubleToRawLongBits(0.0/0.0))); System.out.println(&quot;nan3: &quot; + Long.toHexString(Double.doubleToLongBits(0.0/0.0))); System.out.println(&quot;nan4 raw: &quot; + Long.toHexString(Double.doubleToRawLongBits(d/d))); System.out.println(&quot;nan4: &quot; + Long.toHexString(Double.doubleToLongBits(d/d)));&#125;测试结果12345678910nan1 raw: 7fc00000nan1: 7fc00000nan2 raw: ffc00000nan2: 7fc00000nan3 raw: 7ff8000000000000nan3: 7ff8000000000000nan4 raw: fff8000000000000nan4: 7ff8000000000000Process finished with exit code 0如果不使用 raw 方法进行 NaN 的转换，采用 0.0f/0.0f 或 先定义变量f = 0.0f再进行f/f的计算，最终结果是一样的，但是如果使用 raw 方法进行转换，结果会有所不同，如:nan1 raw: 7fc00000和nan2 raw: ffc00000，原因是前者是 Java编译器给出的，后者是 CPU 用 DIVSS 指令计算出来的，跟具体的 CPU 实现有关系。由于都是 NaN，理论上哪个值都是正确的。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java基本类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java代码是怎么运行的？]]></title>
    <url>%2Fposts%2F6e9f02ed%2F</url>
    <content type="text"><![CDATA[写在前面Java代码有很多种不同的运行方式，比如在开发工具中运行、双击jar文件运行、在命令行中运行、在网页中运行等，不过这些执行方式都离不开JRE，即Java运行时环境(Java Runtime Environment)。实际上，JRE仅包含Java程序的必需组件，包括Java虚拟机以及Java核心类库等。我们通常接触的JDK(Java开发工具包)同样包含了JRE，并且还附带了一系列开发、诊断工具。为什么 Java 要在虚拟机里运行？Java作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此直接在硬件上运行这种复杂的程序不太现实。所以，在运行 Java 程序之前需要对其进行一番转换。（C++ 的策略是直接编译成目标架构的机器码，Java的策略是编译成一个虚拟架构的机器码。）这个转换操作是怎么操作的呢？当前主流思路是这样：设计一个面向Java语言特性的虚拟机，并通过编译器将 Java 程序转换成该虚拟机能识别的指令序列，即 Java 字节码(Java字节码指令的操作码被固定为一个字节)。Java虚拟机可以由硬件(Java procesor)实现，但更为常见的是在各个现有平台(如Windows ——x64、Linux_aarch64)上提供软件实现。这样一来，一旦一个程序被转换成 Java 字节码，它就可以在不同平台实现的虚拟机实现里运行，即“一次编译，到处运行。”除此之外，虚拟机还提供了一个托管环境(Managed Runtime)。这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。比如：自动内存管理与垃圾回收、数据越界、动态类型、安全权限等等动态监测。Java 虚拟机具体怎样运行 Java 字节码的？虚拟机角度执行 Java 代码首先需要将它编译成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区(Method Area)中，实际运行时，虚拟机会执行方法区内的代码。Java虚拟机会将内存划分为堆和栈来存储运行时数据。Java 虚拟机将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法(用C++写的 native 方法)的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。在运行过程中，每当调用进入一个 Java 方法，Java虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。硬件角度Java 字节码无法直接执行，需要 Java 虚拟机将字节码翻译成机器码。在HotSpot中，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时翻译(Just-In-Time compilation, JIT)，即将一个方法中包含的所有字节码翻译成机器码后再执行。前者优势是无需等待编译，后者优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合解释执行和即时编译的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。Java 虚拟机的运行效率是怎么样的？HotSpot 采用了多种技术来提升启动性能以及峰值性能。即时编译建立在程序符合二八定律的假设之上，即百分之二十的代码占用了百分之八十的计算资源。对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。理论上讲，即时编译后的 Java 程序的执行效率是可能超过 C++ 程序的。这是因为与静态编译相比，即时编译拥有程序的运行时信息，并且可以根据这个信息作出相应优化。比如：一个虚方法的调用，尽管它有很多个目标方法，但是在实际运行过程中它可能只调用其中的一个。这个信息就可以被即时编译器所利用，来规避虚方法调用的开销，从而达到比静态编译的 C++ 程序更高的性能。为了满足不同用户场景的需要，HotSpot 内置了多个即时编译器：C1、C2 和 Graal。其中 Graal 是Java 10正式引入的实验性即时编译器。这样以来就可以在编译时间和生成代码的执行效率上进行取舍。C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。从 Java 7 开始，HotSpot 的即时编译是放在额外的编译栈程中进行的。HotSpot 会根据 CPU 的数量设置编译线程的数目，并且按 1:2 的比例配置还给 C1 和 C2编译器。在资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。问题Java 语言和 Java 虚拟机看待boolean类型的方式是否不同？Java 虚拟机将 boolean 类型看成 int 型 0 和 1 进行处理。123456789101112// Foo.javapublic class Foo &#123; public static void main(String[] args) &#123; boolean flag = true; if (flag) &#123; System.out.println(&quot;Hello, Java!&quot;); &#125; if (flag == true) &#123; System.out.println(&quot;Hello, JVM!&quot;); &#125; &#125;&#125;12345678910$ # linux环境$ javac Foo.java$ java Foo$ # 两个都打印$ # 反汇编器与汇编器 将flag对应的值iconst_1改成了iconst_2$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &gt; Foo.jasm.1$ awk &apos;NR==1,/iconst_1/&#123;sub(/iconst_1/, &quot;iconst_2&quot;)&#125; 1&apos; Foo.jasm.1 &gt; Foo.jasm $ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm$ java Foo$ # 第二个不打印其他热点代码探测热点代码探测有两种算法——基于采样的热点探测和基于计数器的热点探测。一般采样的是基于计数器的热点探测，这种算法有两个计数器，方法调用计数器和回边计数器，它们在 C1 和 C2 中有不同的阈值。对于性能要求高的 web 应用为什么不直接使用即时编译器在启动时全部编译成机器码呢？对于长时间运行的程序来说，大部分编译就发生在前几个小时。再之后的即时编译主要是一些非热点代码，以及即时编译器中的 bug 造成的反复去优化重新编译。JVM 这么做主要也是看中字节码的可移植性，从而牺牲了启动性能。JVM 也引入了 AOT 编译，在线下将 Java 代码编译成可链接库。为什么理论上比 C++ 快？实际上会插入一些虚拟机相关的代码。现代编译器一般都分为平台无关的前端和平台相关的后端。如果要生成某个平台的代码，编译器会选择相应的后端。因此，无论是 C 编译器还是 JIT 编译器，都是基于目标 CPU 的指令集来做优化的。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>代码运行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入拆解Java虚拟机]]></title>
    <url>%2Fposts%2Fec055895%2F</url>
    <content type="text"><![CDATA[极客时间《深入拆解Java虚拟机》 | 郑雨迪 | Oracle高级研究员好记性不如烂笔头，做下笔记顺便加强一下记忆，之前了解虚拟机笔记零散，准备借此机会梳理一下。为什么我们要学习Java虚拟机？“知其然”也要“知其所以然”，学习Java虚拟机的本质，更多是了解Java程序是如何被执行且优化的。这样一来，你才可以从内部入手，达到高效编程的目的。与此同时，你也可以为学习更深层级、更为核心的Java技术打好基础。了解Java虚拟机有如下好处：优化：Java虚拟机提供了很多配置参数，用于满足不同应用场景下，对程序性能的需求。学习Java虚拟机，你可以针对自己的应用，最优化匹配运行参数。避险：Java虚拟机本身是一种工程产品，在实现过程中自然存在不少局限性。学习Java虚拟机，可以更好地规避它在使用过程中的bug，也可以更快地识别出Java虚拟机中的错误。触类旁通：Java虚拟机拥有当前最前沿、最成熟的垃圾回收算法，以及即时编译器实现。学习Java虚拟机，我们可以了解其背后的设计决策，今后再遇到其他代码托管技术也能触类旁通。百发齐放：Java虚拟机发展到今天，已经脱离Java语言，形成一套相对独立的、高性能的执行方案。除了Java以外，Scala、Clojure、Groovy，以及时下热门的Kotlin，这些语言都可以运行在Java虚拟机上。学习Java虚拟机，便可以了解这些语言的通用机制，甚至于让这些语言共享生态系统。基本原理剖析Java虚拟机的运行机制，逐一介绍Java虚拟机的设计决策以及工程实现。Java代码是怎么运行的？Java的基本类型Java虚拟机是如何加载Java类的？高效实现探索Java编译器，以及内嵌于Java虚拟机中的即时编译器，帮助你更好地理解Java语言特性，继而写出简洁高效的代码。代码优化介绍如何利用工具定位并解决代码中的问题，以及在已有工具不适用的情况下，打造专属轮子。虚拟机黑科技介绍甲骨文实验室近年来的前沿工作之——GraalVM。包括如何在JVM上高效运行其他语言；如何混搭这些编程语言，实现Polyglot；如何将这些语言事前编译(Ahead-Of-Time, AOT)成机器指令，单独运行甚至嵌入数据库中运行。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-丧]]></title>
    <url>%2Fposts%2F60ae6d78%2F</url>
    <content type="text"><![CDATA[可能会太丧，不建议一次性食用，千万不要贪杯哦~别人都祝你快乐，我只愿你，遍历山河，觉得人间值得。——夫禾《禾叔的杂货铺》001从明天起，做一个幸福的人喂马，劈柴，周游世界从明天起，关心粮食和蔬菜我有一所房子，面朝大海，春暖花开从明天起，和每一个亲人通信告诉他们我的幸福那幸福的闪电告诉我的我将告诉每一个人给每一条河每一座山取一个温暖的名字陌生人，我也为你祝福愿你有一个灿烂的前程愿你有情人终成眷属愿你在尘世获得幸福我也愿面朝大海，春暖花开海子|面朝大海，春暖花开我希望她三十岁没嫁，我也不希望她三十岁没嫁。——网易云音乐《三十岁的女人》热评我从未拥有过你一秒钟，心里却失去过你千万次。——网易云音乐《再见二丁目》热评慢慢大家会明白的，互相喜欢的两个人无法在一起，其实是人生的常态。———网易云《三角题》热评不在一起就不在一起吧，反正一辈子也没多长。——网易云音乐《关于郑州的记忆》热评多数人25岁就死了，但直到75岁才埋。——网易云音乐《杀死那个石家庄人》热评电影太仁慈，总能让错过的人重新相遇，生活不一样，有些人说过再见就再也不见了。——出处不详她的手只有我的手四分之三那么大，可我还是没能抓住。——网易云音乐《一生所爱》热评那时候没有手机没有网络，只能通过书信来往，才会有这样依依不舍，现在的人很难感受到那种离别后再无音讯的难舍了。——网易云音乐《离别的车站》热评希望我是一个让你心动的人，而不是权衡取舍分析利弊后，觉得不错的人。——出处不详——《成全》002你站在桥上看风景看风景的人在楼上看你明月装饰了你的窗子你装饰了别人的梦卞之琳|断章你总想依赖别人，到最后，你会发现人生的每一个最艰难时刻，都是自己挺过来的。这里是我的心，奇迹般万物生长，后来你来这儿走了一遭，这里荒芜寸草不生死亡，仿佛水消失在水中。自杀，也是一种变相的对自我的执着。希望每个感觉在黑暗里往下沉的人，都能找到再浮起来的力量。善良长不出牙齿，就是软弱。我有抑郁症，所以就去死一死，没什么重要的原因，大家不必在意我的离开。——微博用户走饭你没有如期归来，而这正是离别的意义。——北岛《白日梦》生活真的好累，可我又不能去死吧，那些难捱的事情还得咬咬牙挺过去，不管过程怎么艰难，努力点总比碌碌无为要来的好吧。——出处不详003弯弯的月儿小小的船，小小的船儿两头尖。我在小小的船里坐，只看见闪闪的星星蓝蓝的天。叶圣陶|弯弯的月儿小小的船你没有如期归来，而这正是离别的意义。——北岛《白日梦》小时候真傻，居然盼着长大。—— 丰子恺你长大了，就要做好每个人都会离开的准备 。——出处不详张三丰瞧着郭襄的遗书，眼前似乎又看到了那个明慧潇洒的少女，可是，那是一百年前的事了。——金庸或许我的心包有一层硬壳，能破壳而入的东西是极其有限的。所以我才不能对人一往情深。——村上春树《挪威的森林》热闹是他们的，我什么都没有。——朱自清哪里会有人喜欢孤独，不过是不喜欢失望罢了。——村上春树《挪威的森林》现代人的崩溃，是一种很安静的崩溃，看起来特别正常。会说笑，会打闹，会社会，表面很平静，实际心情已经糟到一定程度了。但不会骂人，不会砸东西，更不会哭。就算有那么一刻，达到所能承受的极限了，也只是不说话，不会真的崩溃，就是不太想活，却也不敢去死。——出处不详我以前以为秘密不能说，现在才知道难过也不能说。——出处不详004离离原上草，一岁一枯荣。野火烧不尽，春风吹又生。远芳侵古道，晴翠接荒城。又送王孙去，萋萋满别情。白居易|赋得古原草送别后来我终于知道，它并不是我的花，我只是恰好途径了它的盛放。——出处不详世间所有的爱都指向团聚，唯有父母的爱指向别离。——出处不详我今年十八岁，如果身体健康，没有飞来横祸，我还可以活四十年，五十年，六十年，但我可能再也见不到她了，而我又只有这么一辈子。——出处不详生活从来不会招招手说，“小子过来我们讲讲道理”，生活只会一个大嘴巴把你打在地上后说，“傻逼，学着点。”——出处不详希望你能明白，那些离开了你的人，不管当时是出于什么原因离开，也许彷徨过犹豫过挣扎不舍过。但至少，在他决定要走的那个瞬间，他觉得没有你，他会过得更好。——出处不详生活中尽是瑕疵，大多平淡。——沃梓基天堂和地狱都太过分了，人们的行为不值得那么多。前已无通路，后不见归途。敌视现实，虚构远方。东张西望，一无所长。四体不勤，五谷不分。文不能测字，武不能防身——《十万嬉皮》领导看的是结果，不看过程，这个社会也是。——Muhouer005Twinkle, twinkle, little star,How I wonder what you are! Up above the world so high,Like a diamond in the sky.When the blazing sun is gone,When he nothing shines upon,Then you show your little light,Twinkle, twinkle, all the night.Then the traveller in the darkThanks you for your tiny sparks；He could not see which way to go,If you did not twinkle so.In the dark blue sky you keep,And often through my curtains peep,For you never shut your eyeTill the sun is in the sky.As your bright and tiny sparkLights the traveller in the dark,Though I know not what you are,Twinkle, twinkle, little star.The Star|[英国]珍·泰勒你不愿意种花，你说，我不愿看见它一点点凋落。是的，为了避免结束，你避免了一切开始。——顾城《避免》太年轻了，还没成为想成为的样子，所以也没有时间遇上共度余生的人。从没和你一起坐过飞机，总是一个人坐飞机跑来找你，再一个人坐飞机回去。我一生未做坏事，为何这样？——张国荣那一刻你心里有场海啸，可你静静地，没有让任何人知道。——独木舟葛婉仪我其实刻薄，不擅温言宽慰，惰于交流，说着说着便沉默。往往疏离，孤独执着。我在自己周围筑起高墙，没有哪个人能够入内，也尽量不放自己出去。——村上春树 《海边的卡夫卡》我的不幸，恰恰在于我缺乏拒绝的能力。我害怕一旦拒绝别人，便会在彼此心里留下永远无法愈合的裂痕。——太宰治《人间失格》好想抱一抱每一个因为敏感而变得小心翼翼的人，我懂得他们内心的善良，亦知晓他们的可贵。(优先考虑哪些优先考虑你的人)006爷爷的年龄，写在脸上的皱纹里；马儿的年龄，嚼在嘴巴的牙齿里；树木的年龄，藏在肚子的年轮里。老师！那么池塘的年龄，是不是画在一圈圈的涟漪里？老师！那棒棒糖呢🍭它是不是过期了？老师！月儿是不是不愿别人知道她的年龄？老师！您别皱眉啊！💢我知道小猪的年龄就藏在它的尾巴上!年龄的问题|杜荣琛有的人就是会天生自我厌恶，我非常清楚自己就是那种表面看的过去，各方面普普通通，有点小特长，坐在人群里不至于太扎眼，实际上非常糟糕的人。很多时候做给别人看，有时候甚至卑劣到做给自己看。每次想要对别人说明这一点的时候，大家总是好心安慰:不是的，你很好呀。不是这样的，我一点也不好，你不明白。你走了真好，不然总担心你要走。对于丑人，细看是种残忍。被人指出丑陋之处的滋味并不好受。坦然地剥开自己并不容易。很难过的是，我所认真重视对待的其实并没有人关心，我所渴望被理解的、努力倾诉希望有人愿意懂得的，其实并没有人真正去倾听。我喜爱很多事物，却唯独讨厌自己。哪有什么不合适，无非就是腻了，倦了，权衡利弊之后懒得爱了，想遇见比你更好的人了。以后的以后，多点自知之明，少点自作多情。我最信任的人，教会我不要信任何人。007春天的花香真正醉人，一阵阵温风拂上人身，你瞧日光它移得多慢，你听蜜蜂在窗子外哼：睡呀，宝宝，蜜蜂飞得真轻。天上瞧不见一颗星星，地上瞧不见一盏红灯；什么声音也都听不到，只有蚯蚓在天井里吟：睡呀，宝宝，蚯蚓都停了声。一片白云天空上行，像是些小船漂过湖心，一刻儿起，一刻儿又沉，摇着船舱里安卧的人：睡呀，宝宝，你来跟那些云。不怕它北风树枝上鸣，放下窗子来关起房门；不怕它结冰十分寒冷，炭火生在那白铜的盆：睡呀，宝宝，挨着炭火的温。摇篮歌|朱湘有些事情做不完，就留到明天做吧！運氣好的話，明天死了就不用做了。其实不想丧的，但真的不快乐。生活到底对你们做了什么，不敢再尝试，不敢再用力爱，不敢再探索。你以为那是成熟，我认为那叫死了。人生这么短，我要和像我喜欢你一样喜欢我的人一起过。少吃兩口飯我都做不到，怎麼可能說不喜歡就不喜歡呢？不是所有怪物一开始就是怪物，也不是所有怪物看起来都像怪物。有些人会把怪物的一面藏在心里。——弗雷德里克·巴克曼《外婆的道歉信》死亡最强大的力量不在于它能让人死去，而在于让留下来的人不想再活着。——弗雷德里克·巴克曼《外婆的道歉信》我什么都做不了，只能眼睁睁地看着。一切都消失在迷雾之中了。过去给抹掉了，而抹掉本身又被遗忘了，谎言便变成了真话。——乔治·奥威尔《一九八四》008在我和世界之间你是海湾，是帆是缆绳忠实的两端你是喷泉，是风是童年清脆的呼喊在我和世界之间你是画框，是窗口是开满野花的田园你是呼吸，是床头是陪伴星星的夜晚在我和世界之间你是日历，是罗盘是暗中滑行的光线你是履历，是书签是写在最后的序言在我和世界之间你是纱幕，是雾是映入梦中的灯盏你是口笛，是无言之歌是石雕低垂的眼帘在我和世界之间你是鸿沟，是池沼是正在下陷的深渊你是栅栏，是墙垣是盾牌上永久的图案一束|北岛人在无端微笑时，不是百无聊赖，就是痛苦难当。——王小波《革命时期的爱情》人性本凉薄，又何介，谁比谁更多。——三毛心，若没有栖息的地方，到哪里都是流浪。——三毛一见钟情，明明是见色起意。日久生情，不过是权衡利弊。就连白头到老，都只是习惯使然。——安逸《这咬人的爱》在青春的掩护下，颓废是勇气，懒惰是反抗，空虚是性感。——刘渝任凭怎么解释，世人也只能相信自己愿意相信的事情。越是拼命争扎，我们的处境越是狼狈。——村上春树《挪威的森林》哪里会有人喜欢孤独，不过是不喜欢失望。——村上春树《挪威的森林》我们究竟是活了365天，还是活了一天，重复了364遍。那天，我忍住没哭。——Muhouer009明月别枝惊鹊，清风半夜鸣蝉。稻花香里说丰年，听取蛙声一片。七八个星天外，两三点雨山前。旧时茅店社林边，路转溪桥忽见。西江月·夜行黄沙道中|辛弃疾以前挺理想主义的，一直都认为金钱不是自由生活的前提，精神自由最重要。当我走出校园真正开始接触社会才发现，赚到的钱越多，生活的可选择性越大，也就越不容易受到周遭环境的影响。希望你们可以尽己所能，想方设法给自己挣到足够的钱，好去旅游，去无所事事，去思索世界的未来或过去，去看书、做梦或是在街头闲逛，让思考的鱼线深深沉入这条溪流中去。——伍尔夫在《一间自己的房间》一切正常的生命都会有意识或无意识地对控制感到愤恨。如果这种控制来自能力低下的一方或据说能力低下的一方，这种愤恨就会更加强烈。人类的智力就像是孔雀的羽毛。只不过是种用来吸引配偶的浮夸表演。最让我崩溃的不是贫穷，而是这种看不见希望的生活。有些事情做不完，就留到明天做吧！運氣好的話，明天死了就不用做了！心酸纵有千万种，沉默不语最难过。半身风雨半身伤，半句别恨半身凉。有情皆虐，无人不冤。慧极必伤，情深不寿。得之我幸，失之我命。010我是一个了不起的巨人，坐在枕头山岗的最高处，静静俯视我的平原和峡谷，还有整个床上的大陆。三里清风三里路，步步清风再无你。闻君有两意，故来与君绝。卿本良人，奈何缘浅。你眼里灿若清河，唯独偏偏无我。不喜欢”丧”用在这里，我们只是偶尔不开心从小我就懂得保护自己，我知道，要想不被人拒绝，最好的办法就是先拒绝别人。——王家卫我终于扛不住了，把所有心里话说出来了，却有人说我不懂事。我真的很差劲，真的，我讨厌这样的自己。没有人喜欢孤独。011我们有一份黑夜要忍受我们有一份清晨去享用我们有一份喜乐要填充我们还有一份伤痛这里一颗星，那里一颗星他们迷路了吧这里一团雾，那里一团雾等待光明我们有一份黑夜要忍受|艾米莉·狄金森|益喜(译)这份黑夜，就是荆棘密布的追梦之路吧这份清晨，就是鸟语花香的梦幻之旅吧这份喜乐，就是云淡风轻的生活之意吧而这份伤痛，定是不可缺少的呢。我觉得自己是个内心非常肮脏的人，并为此感到悲伤。如果快乐太难，那再次祝你平安。人间不值得。曾经的梦想天真无邪，后来满脑子都是为了钱，每年生日闭眼许的愿，能有几个可以灵验，人总会变抱歉，都说生命可以不分贵贱，可有人生来就被叫做少爷，有人只能看着地面，抬头都是些肮脏的嘴脸，励志要走社会的前列，可总是败在势力的面前，肺腑之言，抱歉，我想忘了从前的一切，做一个凡事不问的俗人，从今天起远离人群，做一只狡猾的狐狸，那天我双手合十，看着镜子里狼狈的自己，我用了一半的青春，来思考做人的道理，对不起年少的自己。——尚士达的单曲《生而为人》假的就像这个世界一样真实。多少狗屁倒灶的事，都是披着自由的外衣干的。每个人可以做到，每个人又做不到。一切的防范都制止不了人性的阴狠，而这个世界上的坏人是杀不完的。我们唯一能做的，就是在受到侵犯时不再沉默，勇敢面对。]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>丧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字]]></title>
    <url>%2Fposts%2Fce0f712d%2F</url>
    <content type="text"><![CDATA[本文最初来源，在此基础上做了部分修改、调整。liuxiaopengJava 并发编程：volatile的使用及其原理volatile作用在《Java并发编程：核心理论》一文中，我们已经提到过可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchronized原理有了解的话，应该知道Synchronized是一个比较重量级的操作，对系统的性能有比较大的影响，所以，如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。而volatile关键字就是Java中提供的另一种解决可见性和有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。volatile使用场景防止重排序我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁（DCL）的方式来实现。其源码如下：1234567891011121314151617public class Singleton &#123; public static volatile Singleton singleton; /** * 构造函数私有，禁止外部实例化 */ private Singleton() &#123;&#125;; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125;现在我们分析一下为什么要在变量singleton之前加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤： 1. 分配内存空间。 2. 初始化对象。 3. 将内存空间的地址赋值给对应的引用。但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程： 1. 分配内存空间。 2. 将内存空间的地址赋值给对应的引用。 3. 初始化对象 如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。实现可见性可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用：12345678910111213141516171819202122232425262728293031323334353637public class VolatileTest &#123; int a = 1; int b = 2; public void change() &#123; a = 3; b = a; &#125; public void print() &#123; System.out.println(&quot;b=&quot; + b + &quot;;a=&quot; + a); &#125; public static void main(String[] args) &#123; while (true) &#123; final VolatileTest test = new VolatileTest(); new Thread(() -&gt; &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test.change(); &#125;).start(); new Thread(() -&gt; &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test.print(); &#125;).start(); &#125; &#125;&#125;直观上说，这段代码的结果只可能有两种：b=3;a=3 或 b=2;a=1。不过运行上面的代码（可能时间上要长一点），你会发现除了上两种结果之外，还出现了第三种结果：为什么会出现b=3;a=1这种结果呢？正常情况下，如果先执行change方法，再执行print方法，输出结果应该为b=3;a=3。相反，如果先执行的print方法，再执行change方法，结果应该是 b=2;a=1。那b=3;a=1的结果是怎么出来的？原因就是第一个线程将值a=3修改后，但是对第二个线程是不可见的，所以才出现这一结果。如果将a和b都改成volatile类型的变量再执行，则再也不会出现b=3;a=1的结果了。保证原子性volatile只能保证对单次读/写的原子性。这个问题可以看下JLS中的描述：17.7 Non-Atomic Treatment of double and longFor the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.Writes and reads of volatile long and double values are always atomic.Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency’s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。关于volatile变量对原子性保证，有一个问题容易被误解。现在我们就通过下列程序来演示一下这个问题：12345678910111213141516171819202122public class VolatileTest &#123; volatile int i; public void addI() &#123; i++; &#125; public static void main(String[] args) throws InterruptedException &#123; final VolatileTest test01 = new VolatileTest(); for (int n = 0; n &lt; 1000; n++) &#123; new Thread(() -&gt; &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test01.addI(); &#125;).start(); &#125; Thread.sleep(10000);//等待10秒，保证上面程序执行完成 System.out.println(test01.i); &#125;&#125;大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：12993Process finished with exit code 0可能每个人运行的结果不相同。不过应该能看出，volatile是无法保证原子性的（否则结果应该是1000）。原因也很简单，i++其实是一个复合操作，包括三步骤： 1. 读取i的值。 2. 对i加1。 3. 将i的值写回内存。volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者synchronized来保证+1操作的原子性，以下代码为使用AtomicInteger对应的实现。12345678910111213141516171819202122public class VolatileTest &#123; AtomicInteger i = new AtomicInteger(0); public void addI() &#123; i.getAndAdd(1); &#125; public static void main(String[] args) throws InterruptedException &#123; final VolatileTest test01 = new VolatileTest(); for (int n = 0; n &lt; 1000; n++) &#123; new Thread(() -&gt; &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test01.addI(); &#125;).start(); &#125; Thread.sleep(10000);//等待10秒，保证上面程序执行完成 System.out.println(test01.i.intValue()); &#125;&#125;注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。volatile原理通过上面的例子，我们基本应该知道了volatile是什么以及怎么使用。现在我们再来看看volatile的底层是怎么实现的。可见性实现在前文中已经提及过，线程本身并不直接与主内存进行数据的交互，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。因此要实现volatile变量的可见性，直接从这方面入手即可。对volatile变量的写操作与普通变量的主要区别有两点： （1）修改volatile变量时会强制将修改后的值刷新的主内存中。 （2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。 通过这两个操作，就可以解决volatile变量的可见性问题。有序性实现在解释这个问题前，我们先来了解一下Java中的happen-before规则，JSR 133中对Happen-before的定义如下：Two actions can be ordered by a happens-before relationship.If one action happens before another, then the first is visible to and ordered before the second. 通俗一点说就是如果a happen-before b，则a所做的任何操作对b是可见的。（这一点大家务必记住，因为happen-before这个词容易被误解为是时间的前后）。我们再来看看JSR 133中定义了哪些happen-before规则：• Each action in a thread happens before every subsequent action in that thread.• An unlock on a monitor happens before every subsequent lock on that monitor.• A write to a volatile field happens before every subsequent read of that volatile.• A call to start() on a thread happens before any actions in the started thread.• All actions in a thread happen before any other thread successfully returns from a join() on that thread.• If an action a happens before an action b, and b happens before an action c, then a happens before c. 翻译过来为：同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则）对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则）线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则）线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。 这里我们主要看下第三条：volatile变量的保证有序性的规则。《Java并发编程：核心理论》一文中提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会对volatile变量限制这两种类型的重排序。下面是JMM针对volatile变量所规定的重排序规则表：Can Reorder2nd operation1st operationNormal Load Normal StoreVolatile LoadVolatile StoreNormal Load Normal StoreNoVolatile LoadNoNoNoVolatile storeNoNo内存屏障为了实现volatile可见性和happen-befor的语义。JVM底层是通过一个叫做“内存屏障”的东西来完成。内存屏障，也叫做内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。下面是完成上述规则所要求的内存屏障：Required barriers2nd operation1st operationNormal LoadNormal StoreVolatile LoadVolatile StoreNormal LoadLoadStoreNormal StoreStoreStoreVolatile LoadLoadLoadLoadStoreLoadLoadLoadStoreVolatile StoreStoreLoadStoreStore（1）LoadLoad 屏障执行顺序：Load1—&gt;Loadload—&gt;Load2确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。（2）StoreStore 屏障执行顺序：Store1—&gt;StoreStore—&gt;Store2确保Store2以及后续Store指令执行前，Store1操作的数据对其它处理器可见。（3）LoadStore 屏障执行顺序： Load1—&gt;LoadStore—&gt;Store2确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。（4）StoreLoad 屏障执行顺序: Store1—&gt; StoreLoad—&gt;Load2确保Load2和后续的Load指令读取之前，Store1的数据对其他处理器是可见的。最后我可以通过一个实例来说明一下JVM中是如何插入内存屏障的：12345678910111213141516171819202122232425public class MemoryBarrier &#123; int a, b; volatile int v, u; void f() &#123; int i, j; i = a; j = b; i = v; //LoadLoad j = u; //LoadStore a = i; b = j; //StoreStore v = i; //StoreStore u = j; //StoreLoad i = u; //LoadLoad //LoadStore j = b; a = i; &#125;&#125;总结总体上来说volatile的理解还是比较困难的，如果不是特别理解，也不用急，完全理解需要一个过程，在后续的文章中也还会多次看到volatile的使用场景。这里暂且对volatile的基础知识和原来有一个基本的了解。总体来说，volatile是并发编程中的一种优化，在某些场景下可以代替Synchronized。但是，volatile的不能完全取代Synchronized的位置，只有在一些特殊的场景下，才能适用volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全： 1. 对变量的写操作不依赖于当前值。 2. 该变量没有包含在具有其他变量的不变式中。]]></content>
      <categories>
        <category>Java关键字</category>
      </categories>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-爱]]></title>
    <url>%2Fposts%2F497a5083%2F</url>
    <content type="text"><![CDATA[001如果你问我，他会喜欢你很久很久吗？会的，他会的！很久，很久。星河滚烫，你是人间理想。水中月是天上月，眼前人是心上人。你自月中来，星飒云中雾。情不知所起，一往而深。——汤显祖《牡丹亭》不多不多，以后还可以少吃一点。——三毛为你，千千万万遍。——卡勒德·胡赛尼月亮很亮，亮也没用，没用也亮。我喜欢你，喜欢也没用，没用也喜欢。 ——李诞她可以褪色，可以枯萎，怎样都可以，但我只要看她一眼，万般柔情，涌上心头。——《洛丽塔》别惊动我爱的人，等他自己情愿。——《圣经》002记得早先少年时大家诚诚恳恳说一句是一句清早上火车站长街黑暗无行人卖豆浆的小店冒着热气从前的日色变得慢车，马，邮件都慢一生只够爱一个人从前的锁也好看钥匙精美有样子你锁了人家就懂了从前慢|木心斯人如彩虹，遇上方知有。世上本无圣诞老人，所有礼物和惊喜都来自爱你的人。我这个人啊，满身阴暗，还总想着给你一点阳光。我想变得有趣，变得特别，变成你眼里的一点星光。世界没有你想象的那么坏，你过来，来我身边，我抱你。昨天很喜欢你，今天也很喜欢你，而且预感，明天也会很喜欢你。这里荒芜寸草不生，后来你来这儿走了一遭，奇迹般万物生长，这里是我的心。这个世界上有六十几亿人口，但某个瞬间，只这一个人，就能敌过千军万马，四海潮生。喜欢啊，是清风，是朝露，是脸颊红红，是千千万万人里，心里除了你再也装不下其它。003七点的牛奶 三点的茶六点的炊烟叫我回家挤一把大伞 床头滚床尾沙发里聊聊芸芸事非你可以发呆 或是想想晚饭在我牵着你回家的路上我们穿过灯红酒绿的荒芜和欲望趟过车水马龙的市井与城墙迷途未返总有意义马儿也要歇一歇 我们在路边小憩挑出你发丝里的细草拨出你衔在嘴角的发梢你的呼吸何时这样轻过在银河般深邃的夜里一次次将我击落亲爱的晚安你睡你的我看我的哄你睡觉|刘墨闻不奢望永远，所以，爱一天，珍惜一天。深情但不纠缠。人一大，碰到真心喜欢的人，第一感觉是害怕，还有自卑。真心说出的不一定是真话，那是情话。月遇从云，花遇和风，今晚上的夜空很美，我又想你。 ——太宰治就算世界荒芜，总有一个人，他会是你的信徒。 ——独木舟《深海里的星星》朝暮与年岁并往，然后与你一同行至天光。 ——河唐先生《天光》草在结它的种子，风在摇它的叶子，我们站着，不说话，就十分美好。——顾城《门前》余生不用多指教，我都听你的就是了。004天上飘着些微云，地上吹着些微风。啊！微风吹动了我的头发，教我如何不想她？月光恋爱着海洋，海洋恋爱着月光。啊！这般蜜也似的银夜。教我如何不想她？水面落花慢慢流，水底鱼儿慢慢游。啊！燕子你说些什么话？教我如何不想她？枯树在冷风里摇，野火在暮色中烧。啊！西天还有些儿残霞，教我如何不想她？教我如何不想她|刘半农因为你，我愿意成为一个更好的人。纵然，从此一别两宽，各自欢喜，你也曾写进了他的生命里，虽非经久不衰，却最浓墨重彩。藏不住的喜欢，理直气壮就好了。我喜欢你，甚于昨日，略匮明朝。特别喜欢你朝我走过来的样子，不过我很紧张，心砰砰地跳。你要做个可爱的姑娘，不烦世事，满心欢喜。我站在哪都可以，可以站在你前面，保护你；也可以站在你后面，撑起你；也可以站在你旁边，与你并肩(也可以站得远远的，远离你)。世界并不会对你温柔以待，上帝也不会对你特殊照顾，但是，我会呀。一生太短，所以遇到喜欢的人，就要认真喜欢。005微风吹动你的发梢就像风的线条总是在我的眼里颤动微笑挂在你的嘴角荡漾我的情怀总是叫我无法言语每次都想呼喊你的名字每次都想呼喊你的名字|张学友外面风大，我带你回家。想陪你一起无所事事。我这个人超级好的，你可以放心喜欢。你回头。还有我呢！你最可爱！今晚月色真美！上来吧，我背你！哈哈哈，你也是个普通人，和我一样。006我寻了半生的春天，你一笑便是了。我一点也不想你，一点半再想。我想和你在一起，几天也好。在某个地方，某个时辰。 ——杜拉斯陌上开花，可缓缓归矣。玲珑骰子安红豆，入骨相思君知否。此情无计可消除，才下眉头，却上心头。春风十里不如你。愿得一心人，白首莫相离。情不知所起，一往而深。007但愿人长久，千里共婵娟。人生若只如初见。今夕何夕，见此良人。只一眼，便千秋万世。何烦五色药，尊下即丹丘。愿你垂垂老矣，我可明我心。所爱隔山海，山海皆可平。身无彩凤双飞翼，心有灵犀一点通。世间安得双全法，不负如来不负卿008说的是一辈子！差一年，一个月，一天，一个时辰，都不算一辈子！——《霸王别姬》如果再也看不到你，祝你早安，午安，晚安。——《楚门的世界》如果她打你，一定要装得很痛；如果真的很痛，要装得没事。——《我的野蛮女友》到你是我人生的一大收获。我不道别，也不跟你约定，我想我们一定能再见面的。——《东京爱情故事》我这一生都是坚定不移的唯物主义者，唯有你，我希望有来生。–《周恩来家书》醒来觉得甚是爱你。——朱生豪《朱生豪情书》我并没有喜欢哪一种类型的人 。如果我喜欢你，我喜欢的就只是你。——蔡康永答案很长，我准备用一生的时间来回答，你准备要听了吗？——林徽因人间烟火，山河远阔。无一是你，无一不是你。009若逢新雪初霁/满月当空/下面平铺着皓影/上面流转着亮银/而你带笑地向我步来/月色与雪色之间/你是第三种绝色——余光中 《绝色》这黑灯瞎火的，我贼他妈想你。即许一人以偏爱，愿尽余生之慷慨。愿有岁月可回首，且以深情共白头。思君如满月，夜夜减清辉。不知魂已断，空有梦相随；除却天边月，没人知。锦衣雪华玉颜色，回眸一笑天下倾。愿出一家之言，以结两姓之好。人生当苦无妨，良人当归即可。010一生之中一定会遇到某个人，Ta 打破你的原则，改变你的习惯，成为你的例外。结婚办理九块钱，四块五的意思就是你的另一半，那是不是等你攒够了四块五我也攒够了四块五，我们就可以结婚了。——《四块五》评论爱自己是终生浪漫的开始。他不拿手机，他手捧鲜花，将惊喜藏于身后，他翘首以盼，站在原地默默等候。爱是坚持到底的冒险，是最小的共产主义，是一种持之以恒的胜利，不断地跨越空间、时间、世界所造成的障碍。“我爱你”就意味着在这个世界上，你成为我生命的源泉。——阿兰·巴迪欧请记住每一个容易失效的特殊日子，因为你记住的本质是：我在乎你。林深时见鹿，海蓝时见鲸，梦醒时见你。我喜欢你，你感受到了么？还是说不够明显，仍需努力！011如果衰老是一种病，那么，它似乎无药可救。没事，我陪着你！——读《人为什么生病》有感晓看天色暮看云，行也思君，坐也思君。春赏百花冬观雪，醒亦思卿，梦亦思卿。打过疫苗的猪就会戴这个证明自己是安全的猪。在生命的旅程里，遇见你真好！美是初见，燃起爱情火焰。你最可爱，说时来不及思索，但思索之后，还是这样说。——普希金原以为聚散离合才叫美，到头来柴米油盐都是诗。幸得识卿桃花面，自此阡陌多暖春。你喜欢田野，但我愚笨，只能植荒十年，换得一时春生。012愿此间山有木兮卿有意，昨夜星辰恰似你。陌上花开，可缓缓归矣。你可以信任对方，但并不期待什么。安静的生活，平淡的爱情，温柔的你。今晚月色真好，风也温柔，我也是。过去有人曾对我说:“一个人爱上小溪,是因为没有见过大海。”而如今,我终于可以说:“我见过银河,但我仍爱你这一颗星”——七堇年]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>爱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾句-惊艳]]></title>
    <url>%2Fposts%2F922764cc%2F</url>
    <content type="text"><![CDATA[说书唱戏劝人方，三条大路走中央。善恶到头终有报，人间正道是沧桑。—— 单口相声定场诗曾以为走不出的日子，现在都回不去了。——村上春树长大了，总有那么一两次，你会为重视的人奔跑，因为是对的人，走路真的来不及。没事，只不过是恢复原状罢了，我本来就是一无所有的。——濑川初原《食灵零》能够说出的委屈，便不算委屈；能够抢走的爱人，便不算爱人。——亦舒《开到荼蘼》有人一看书就卖弄，多看几本吧，多看几本就不卖弄了。——木心你如果认识从前的我，也许你会原谅现在的我。——张爱玲《倾城之恋》希望你明白，我凡事都看得开，但并不影响我记仇。我们奋力前行，逆水行舟，被不断向后推，直至回到往昔岁月。——《了不起的盖茨比》人生天地之间，若白驹之过隙，忽然而已。——庄周逝者如斯夫，不舍昼夜。——《论语·子罕》贫穷的思维，是造成贫穷的真正原因。每一个不曾起舞的日子，都是对生命的辜负。——尼采敬这大争之世，敬这小酌之时。长大是人必经的溃烂。——塞林格远方除了遥远一无所有。——海子我妈曾经说过一句话：即使你躺倒让别人踩在你身上走，别人还是会抱怨你踩着不够舒服。所以，不用试着让所有人都开心，过好你自己的生活。张华考上了北京大学，李萍进了中等技术学校，我在百货公司当售货员，我们都有光明的前途。——新华字典1998修订本”前途“一词的例句少年的肩膀，就该这样才对嘛，什么家国仇恨，浩然正气的，都不要急，先挑起清风明月、杨柳依依和草长莺飞，少年郎的肩头，本就应当满是美好的事物啊。——烽火戏诸侯《剑来》女孩，晚安，你要早睡，才会有一天找到另一个也喜欢早睡的男孩，拥抱着你入睡，在你耳边呢喃一句晚安。只有孤独的灵魂，才会越晚越清醒。女孩，你听到吗，晚安。——阿句句《全世界失眠》想生个女儿，头发顺长，肉薄心窄，眼神忧郁。用牛奶，豆浆，米汤和可口可乐浇灌，一二十年后长成祸水。——冯唐《北京北京》有朝一日会成为被喜欢的人觉得大吃一惊，被讨厌的人刮目相看的人——网易云热评你对纹身的女人怎么看？你对她有偏见？我喜欢的女性是多元的，拒绝“女人就应该活成女人的样子”“年纪这么大了，还这么有少女感”“女人过了多少岁就没价值了，类似这样的话。我认真对待我自己，认真对待年龄留下的饱满痕迹，我所有的经历构造了现在的我，我无需被其他定义，无需被教导成“女孩应该有的样子”我只是我而已。也没有什么热衷的东西，感觉追不上就悄悄走开了。生活没那么复杂，种豆子和相思或许都得瓜。你敢试，世界就敢答 。有时候你问的问题对方一直在闪躲，那就是在委婉地告诉你，真实的回答很残忍。你必须只有内心丰富，才能摆脱这些生活表面的相似。贪安稳就没有自由，要自由就要历些危险。只有这两条路。鲁迅不能听命于自己者，就要受命于他人。——尼采《查特拉斯如是说》若是看到自己周围一群拙劣的追随者以及同伴，首要的正确反省是：自己做得还不够卓越。幸运的人一生都被童年治愈，不幸的人一生都在治愈童年。她那时候还太年轻，不知道所有命运馈赠的礼物，早已经在暗中标好了价格。——《断头王后》单是聪明还不够，还应有足够的聪明以避免过度聪明。——莫洛瓦我们始终有一种错觉，以为我们的感情源自于我们自己的内心。——古斯塔夫·勒庞 《乌合之众》人一到群体中，智商就严重降低，为了获得认同，个体愿意抛弃是非，用智商去换取那份让人倍感安全的归属感。——古斯塔夫·勒庞 《乌合之众》没有人帮你，说明你一个人可以。我要再和生活死磕几年。要么我就毁灭，要么我就注定铸就辉煌。如果有一天，你发现我在平庸面前低了头，请向我开炮。——杰克·凯鲁亚克《在路上》正因为众人畏惧死亡，死亡这个事件里，意外率先完成的人，往往被迫伟大。与其互为人间，不如自成宇宙。希望每个感觉在黑暗里往下沉的人，都能找到再浮起来的力量。因为拥有过的很少，所以根本学不会断舍离，生活里一切鸡毛蒜皮的温馨 我都想藏起来。人生的意义是什么？是在生命里偶尔感到超出人的一些部分。一无所有来，一无所有走。中间的过程里，说“失去”都是太抬举自己，借来的、还回去，摊开手心，紧握拳心，会心一击。——春夏决定我们是什么人的是：在本可以什么都不做的时候，你在做什么？几时归去，作个闲人。对一张琴，一壶酒，一溪云。 ——苏轼 行香子·述怀人易老，事多妨，梦难长。一点深情，三分浅土，半壁斜阳。 ——汤显祖情不知所起，一往而深，生者可以死，死者可以生。生而不可与死，死而不可复生者，皆非情之至也。 ——汤显祖被酒莫惊春睡重，赌书消得泼茶香。当时只道是寻常。 ——纳兰性德《浣溪沙》十步杀一人，千里不留行。事了拂衣去，深藏身与名。 ——李白《侠客行》从前幽怨应无数。铁马金戈，青冢黄昏路。一往情深深几许？深山夕照深秋雨。 ——纳兰性德《蝶恋花·出塞》一生一代一双人，争教两处销魂。相思相望不相亲，天为谁春? ——纳兰性德《画堂春·一生一代一双人》人生若只如初见，何事秋风悲画扇？等闲变却故人心，却道故人心易变。 ——纳兰性德出了这个门，有人遭遇风雪，有人逢着彩虹；有人看见虎狼，有人逢着羔羊；有人在春天里发抖，有人在冬天里歌唱。浮沉烟云，总归幻象。悲苦是蜜，全凭心酿。 ——迟子建“如果顺利的话，我会买一个公寓，养一只柯基，一只英短，孤身一人，自由且满足地度过余生。” “若是不顺呢？” “结婚生子”。多数的日子平淡无奇，灵光的颜色往往不暖。丑比美更容易散播，因为丑不需要灵魂。为了有趣而有趣，不有趣；辛于平凡的平凡，不平凡。心中萧瑟，世界就成灰色，心怀旷野，哪里都是山河。做你自己，然后去承受你为个性而付出的代价。所有人都在和所有人喝茶吃饭，往往来来，没有尽头。不被爱着并不是你的错 你需要看到这些创伤 然后，试着做你自己。爱自己是终身浪漫的开始。自信的状态是，别人怎么贬低自己都觉得放你妈的狗屁。人人情有可缘，谁也不正确。一个人，欺负最多的，往往是身边的亲人，因为开罪别人可能会让自己失去很多，而得罪这些人，可以没有一点成本。小事要忍，大事要狠，没人扶的时候自己要站稳。路是走出来的，越低谷的时候越要撑起自己，要赢得起也要输得起。一直在学走路，总有一天会站起来。外面的雷雨愈发振作，屋内的桌椅茶杯更是安宁。要是在暮春时节，看满山暴雨打落花，一定很热闹。绿蚁新醅酒，红泥小火炉，晚来天欲雪，能饮一杯无？——白居易《问刘十九》人终究会被其年少不可得之物困扰一生。你要克服懒惰，你要克服游手好闲，你要克服漫长的白日梦，你要克服一蹴而就的妄想，你要克服自以为是浅薄的幽默感。你要独立生长在这世上，不寻找不依靠，因为冷漠寡情的人孤独一生。你要坚强，振作，自立，不能软弱，逃避，害怕。不要沉溺在消极负面得情绪里，要正面阳光得对待生活和爱你的人。永远年轻，永远热泪盈眶。你才25岁，你可以成为任何你想成为的人。——《步履不停》你可以拥有一切，但不能同时。——玛丽莲·梦露每天发生在自己身上99％的事情，于别人而言根本毫无意义。——马克-鲍尔莱恩我用尽了全力，过着平凡的一生 。——《月亮与六便士》人的一切痛苦，本质上都是对自己无能的愤怒。——王小波铁甲依然在。为了逃离孤单，所刻意做的一切，反而会让人更加孤独。孤单是连续的，不孤单是间断的。孤独这两个字拆开来看，有孩童，有瓜果，有小犬，有蝴蝶，足以撑起一个盛夏傍晚间的巷子口，人情味十足。稚儿擎瓜柳棚下，细犬逐蝶窄巷中，人间繁华多笑语，惟我空余两鬓风。——孩童水果猫狗飞蝶当然热闹，可都和你无关，这就叫孤独。——林语堂春困秋乏夏打盹，睡不醒的冬三月。春生，夏糜，秋去，冬烬，春又来。夔怜弦，弦怜蛇，蛇怜风，风怜目，目怜心。恐惧有巨大的力量，甚至大过热情。蹑着猫足而至。愿娘子相离之后，重梳婵鬓美扫峨眉，巧呈窈窕之姿，选聘高官之主，解怨释结更莫相憎，一别两宽各生欢喜。——唐朝的离婚书这些倏忽即逝的梦幻之美只能是不完美的，因为它是模糊的，总是短暂的。]]></content>
      <categories>
        <category>拾句</category>
      </categories>
      <tags>
        <tag>惊艳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记之孕事]]></title>
    <url>%2Fposts%2Fa28039a0%2F</url>
    <content type="text"><![CDATA[记录这个的缘由，也不是为了做什么，而是我自己发觉我的很多观念已经发生了变化，特别是关于婚姻、家庭……目前还处于比较混乱的状态，做此篇记录是为以后做准备，以后梳理起来会方便很多。正如谚语所说，罗马不是一天建成的(Rome was not built in a day)，观念也不是一下子就定型的，是一个不断变化的动态过程，甚至是一个打破重建的过程。我不敢保证我的观念一定正确，但是我会一直保持开放的态度。如果有可能，我很愿意沟通，甚至做出改变。最差的情况：即便我不愿接受，我也会给予足够的尊重。此篇作为杂记记录系列的第一篇，希望能一直做下去。现在的部分女生为什么不想生孩子？ 开始2019-06-07👤 知乎匿名用户 | 对女孩子忠告(34k👍)只是想对那些被外人催生的女孩子说：没有任何事情比你自己更重要如果你觉得生孩子会让你很有压力，那就不要去受这场折磨！他们上下嘴皮子碰了碰，都磨不掉痒劲，你要为了这群看客去怀胎十月，受累二十年？遵从自己的感受，你有什么可怕的？怕流言蜚语？怕被戳脊梁骨？你生了，他们就没有谈资了？？论人是非者，定是是非人！求求你们，勇敢一点！和爱你并且懂得尊重你的人，一起幸福地活下去！如果孩子对你的生活是锦上添花，我为你即将成为一位伟大的母亲而祝福及致敬！但如果不是，那就量力而为，不要生了痛苦/后悔！知乎匿名用户现在的部分女生为什么不想生孩子？2019-06-15👤 知乎北斗师兄 | 职业教育，有趣的小老师 | 对要孩子持保留态度(12k👍)说实话，作为一个男的，我也不想要孩子。因为我太怕自己有了孩子以后会变得跟我爸妈一样，把自己的整个人生全部寄托和希望都放在孩子身上。我爸妈的生活里只有我和我姐，他们的开心，面子，和动力全在我姐和我身上。有了我们俩之后的人生就完全失去了自我的概念，而完全都是为了我们而活。以至于现在他们年纪大了，把所有的期待都压在我身上，他们不觉得生活是自己的，他们认为自己老年最美好的生活是:儿女工作稳定，成了家，生了子，他们能够发挥余热帮忙带孙子。我绝不否认有了孩子依然能精彩的过一生，我也非常尊重很多人认为有了孩子人生才算完整这样的价值观，但我也深知受原生家庭的影响，我的性格和骨子里刻上了太多古板的东西和父母的影子。如果我有了孩子，会带着他们的影子一不小心就失去自我。我也就活这一次，懵懂少年生活里只有父母，成年之后尚未看够这世界的花样，我不想就草草的把自己的人生交给孩子。我也完全不认为自己的精神需要靠一个孩子作为寄托，老了需要依赖一个孩子来养。我希望我能按照自己的意愿体会更多的选择和可能。知乎北斗师兄www.zhihu.com/question/326634942/answer/7064176932019-06-23👤 知乎海螺面包 | 临床医疗，重症医疗学科 | 现场百态(6.2k👍)1.产妇a在床上疼的死去活来，大喊着要剖宫产，我征求了其他家属的意见，婆婆拉着儿子说 剖什么剖啊，剖宫产的小孩哪有顺产的聪明？我内心os：就您那不聪明的基因蛋孵出来也不能聪明了好么…2.产妇b生产后痔疮脱出肛门，主任直接一指禅捅了回去，还让产妇的老公戴着手套接手继续捅2个小时保证回纳成功。3.产妇c刚下手术，一个类婆婆样的中年女性飞奔到床边大喊，有奶了吗！？？？啊？？怎么还没有奶？！！！那我孙子怎么办啊？？？！4.G4P3（怀了4次生了3个）产妇d的老公和她自己都是智力障碍患者，她产后大出血、心力衰竭，住了一天icu老公就不肯积极治疗了。现在9岁的大宝在照顾新生儿和另一个在襁褓里的弟弟。5.剖宫产术后杜冷丁成瘾的产妇e以后该怎么办呢。6.剖宫产前医生是要把男方家属拉来谈话，反复告诉他们子宫只是一个器官，而我们只会优先抢救产妇，希望你们在签字的时候不要犹豫耽误时间。抖音上常看到在产房外捧着花焦急等待的老公，可我看到的全是事不关己在产床旁打王者农药的男人。也许有好的，但是极少吧。有些人玩游戏也就罢了，老婆疼的死去活来的还在说风凉话。“你都当妈了还怕疼？”“谁生孩子不这样，怎么就你娇气？”“那剖宫产多贵啊！”每个人怀了孕躺在那张产床上就不再是一个能把自尊放在首位的人了吧，压力性尿失禁，耻骨分离，再也无法恢复的身材和满肚皮的妊娠纹，真的每个人都能有如此的奉献精神么？20～30岁是生育黄金期，但是人为了什么而孕育新的生命这个问题，年轻人真的能想明白吗?知乎海螺面包现在的部分女生为什么不想生孩子？2019-07-10👤 知乎榛禾木 | 零售 | 丁克亲答(30k👍)1、我们不喜欢小孩，讨厌小孩，嫌小孩麻烦。对待小孩没有耐心，听见婴儿啼哭和小孩尖叫也会很烦躁。出去吃饭遇到奇葩的熊家庭，老婆也会发发朋友圈抱怨，借此也让催生的人看看我们的态度。我们承认的确有教育得出色的孩童，不过就像遇见别人家漂亮的小狗一样，我也许愿意摸，愿意玩，但自己不愿意养。对孩子也是如此。2、不接受目前流行的生育观。生孩子已经变成了“别人家生了，我们家也应该有”，或者“时间到了，应该要生了”的事。如果不生，最多说不生孩子的女人是不完整的女人，左耳进右耳出。在我们当地，如果生了一个，大概率还会被催生二胎。生了以后两边父母很难做到完全不插手，各种神秘不可言说状掏出来“为你好”的民间偏方，油腻的不放盐的汤水，奇葩的月子禁忌和月子餐，育儿观冲突下增加的矛盾。老婆有大量的适龄同学朋友，这样的例子多得已经看到麻木，女性生孩子十个月脱一层皮，养孩子十个月又是脱一层皮，男人能有什么损失，该上班还是上班，最多晚上被起夜喂奶的老婆带醒了。3、不愿意牺牲家人的生活质量。我俩的收入尚可，每年纯消费20万以上在这个包邮区的二线城市已经让自己过得很舒服，自住市区的联排，两边父母还有市郊景区的独栋别墅和市区的公寓，均无贷款，目前的生活水平我们都已满足。父母已经退休，我俩也无非几十年好光景，只想珍惜身边人，照顾父母度过舒适的晚年，不啃老，不让他们带孩子，也不至于生病时自责影响后辈的生活，所有的财产都能用在自己身上，无论养老还是救命。我们也是善良的人，如果有孩子，也会呵护他成长，在他18岁前尽到家长的责任，18岁后提供适当的辅助。但既然选择丁克，自然也没法在一个根本不存在的，虚无的“孩子”上产生感情，为他奉献。就算这是自私吧，我牺牲了一个薛定谔的孩子，只想和在世的家人走完一生。4、害怕生育风险。老婆是个胆小的人，怕疼，怕死，怕变丑，怕很多。她不想生，正好我也不想要，就这么简单，我可做不出逼迫老婆传宗接代的事。不生孩子的老婆还保持少女模样，脸上满满的胶原蛋白。出去吃个烧烤，穿连衣裙扎着双马尾手平放在桌上，扑察扑察眨着大眼睛等吃的，店主说：“老板带女儿出来吃烧烤啊？”把我老婆乐了一天。生育前后未知的变数，我们不想承担。看到朋友带小孩看病，这个发烧那个感冒的，陪床的过程都觉得心累。我自认从小已经是不让家长操心的孩子了，但也是生过病的人。当我肝囊肿住院开刀时，我爸面对手术风险同意书拿着笔呆滞了5分钟，他后来说很怕养了20年的孩子就这么没了，还哭了。我们不想面对无力掌握的伤心事，情愿从源头上断了这个可能。5、不想变成自己讨厌的那种人。老婆说以前某些挺正常的同学，还跟她玩得挺好的，一生完孩子，智商都好像生掉了。有在朋友圈里每天打卡乳头堵不堵的；有辞了教职闲在家里带孩子做“直销”，直播给亲儿子吃她代理的“产品”证明安全有效的；有隔了几百公里咸吃萝卜淡操心教育我们不该养猫，应该生孩子的。老婆亲戚家的女孩，饭桌上用手抓菜，敲碗碟，尖叫，一桌子大人不制止还要笑眯眯地哄，养而不教，养来何用。这是做人太假还是做人太傻。以我俩养猫时百般溺爱，把猫宠上天的情形来看，我们也是失败的父母，也有几率变成那样的人，还是不趟这水了。6、见过太多孩子让人寒心的事，更坚定养老靠自己的信念。仅仅我俩的家族里，就出了好几个例子。有搞直销，让患尿毒症的亲妈每月花6000元问她买产品喝来治病的表姐，我姨妈去世前身上只有2000元了。有参与诈骗，全家还几百万债的远房弟弟，连75岁的老奶奶都要接活计给孙子还债。有考上公务员，傍上小老板家女儿，逼爸妈掏空全部积蓄买房，然后不理睬他们的另一个弟弟。有酒后骑电动车撞了脑袋后瘫痪的堂哥。也有理所应当地女儿一出生就养在爸妈房里，现在大了就占了房子，和妻女住，让爸妈在附近租房的上海弟弟。老婆的外婆要住进养老院，三个舅舅都不愿出钱，还是我岳母出的钱。这样活生生的例子里，中老年的父母半生都勤劳温和，可以说都是好人，在一夜间失去了所有，眼神呆滞好像梦里，恰恰是这些身上掉下的骨肉，从小到大有礼貌的乖孩子，给了他们意想不到的彻底一击。我知道有人急着反驳这条，说大多数子女还是好的，但那是别处的事，并不改变以上已经客观真实发生了的事，对我们选择造成的负面影响。7、我和老婆从大学恋爱走到现在，十年来一直是黏在一块的，也是彼此的初恋。现在一起做生意也是并排坐着，白天夜晚24小时都不分离，与多数各自上班的夫妻真实相处时间来比较，我们算是结婚20多年了。过年也没有各自回家的说法，向来同手同脚行动，每天有说不完的开心话，在家也要亲亲抱抱举高高，出门就是手拉手走。我不烟不酒，她不施粉黛，我俩的脾气性格三观品味都极其相似，彼此爱慕尊重，可以参考我的签名。对我们来说感情已经到了高度，不需要依赖生孩子来维系婚姻，更不需要二人世界里出现一个不稳定因素。我们都不愿意因为培养孩子时难免的心急心切，分歧争执，破坏夫妻感情。8、阶层固化之下，一代胜一代的希望越发渺茫，家家户户都在拼了命送孩子往上爬，但我觉得大多数将来只能依靠父母的遗产留在现有阶层里。因为工作关系我经常接触各类学校，老师和家长，给我的总体感觉就是累，那种被逼着集体忙碌的无力感，为了孩子创造更多有利条件的紧迫感，和一件耗费时间精力巨大的工程开了头不得不继续下去的压力感。像打怪升级一样，25年后感觉到顶级了，系统又给开了新的25年的带孙子关卡。我和老婆都是清高心傲的人，不想同“宝妈宝爸”们一样甘愿付出，不愿屈服于某个设定。9、我俩都是独生子女，并且除了父母对其他亲戚血缘十分淡漠，也没有家族传承的旧观念和传宗接代的使命感，同时也是无神论者。对于什么绝后，断代的言论只会觉得无聊无趣，信则有不信则无，仅仅往上数四代的老祖宗，我不认识他，他不知道我，有了后代又怎样，我只是个普通人，几代以后连名字都湮灭了。我一生奉公守法爱国爱家，灾荒捐过款，街边救过猫，已经对得起家人和自己的良心，又不为别人而活，也无惧别人的妄言。10、我的父母，她的父母，都同意了我们丁克。我爸说他17岁开始当兵，半生为国半生为家，都没有好好为自己过，希望我和老婆怎么开心怎么过。岳父母曾经催生过，老婆态度坚决，我又和她一个鼻孔出气的，慢慢想通了也就作罢。如今家宅安宁，大家欢喜，我爸妈打牌炒股旅游钓鱼，也很疼爱她。她爸妈也很疼我，还养了个胖橘公猫当小儿子养，早上会叫它“去喊姐姐起床”，然后小舅子来挠门。一大家6个人照样开开心心过，老人不用带小孩，60岁的人精神气质都像年轻了十几岁。他们大把的退休金都能花在自己身上，也能有个安定轻松的晚年，还生劳什子孩子。知乎榛禾木现在的部分女生为什么不想生孩子？现在的部分女生为什么不想生孩子？ 结束(这个问题回答摘录至此告一段落，以后可能会有修改更新，更多回答可以参看知乎)2019-07-14👤 一叶舟 | 心理学本硕，国家二级咨询师这周我将正式迈入孕37周+的大门，足月了，要随时准备好发动了。我那个朴实无华的老公，正穿着大裤衩吭哧吭哧地收拾着待产包，有一搭没一搭地跟我聊着天。我笑话他耷拉着的那点肚腩，是二胎爹的幸福肥，要他仔细着别弯腰憋出了屁。他回应我的是老大今天还没拉臭，要不要给喂点西瓜汁。看着他仔细地在大包的侧兜里塞进了两小瓶开塞露，我突然一下涌出了眼泪。也是，只有他收拾待产包，才会知道我要用到什么。生老大时，大夫交代顺产之后必须尽早排尿排便，以免引起尿液滞留，导致类似于子宫移位乃至出血的可怕事情。护士还要求，产后第一次的尿液要接在盆里，等她们来检查。于是我老公就端着尿盆蹲在卫生间里，吹着口哨，放着水龙头，等我排尿。进出卫生间三次之后，终于“哗啦”一声，完成任务，我俩不自觉地捏了下对方的手，相视一笑，像是什么大事成功了一样。那时我想起我们恋爱时第一次一起外出，在宾馆的卫生间里我尴尬地满地转圈，因为我怕尿出来呼啦啦的声音影响了我精心打扮出的女神形象。一叶舟 | 曾奇峰心理工作室穿越了“屎尿屁”之后，我们是什么样的伴侣？]]></content>
      <categories>
        <category>生活杂记</category>
      </categories>
      <tags>
        <tag>孕事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[趣味生活简史]]></title>
    <url>%2Fposts%2F61505f7b%2F</url>
    <content type="text"><![CDATA[行至衣食住行处 坐看世事风云起内容简介本书是《万物简史》作者最新扛鼎之作、其创作灵感源自作者一次石破天惊的发现:房屋不是躲避历史的避难所、而是历史的最终归宿。在作者看来，无论世界上发生了什么，不管人们发现了什么，创造了什么，或激烈争夺了什么，最终都会以这种或那种方式投射到你的家里。战争、饥荒、工业革命、启蒙运动……这些看似与我们相距遥远的历史或许就隐藏在你的沙发里和五斗橱里，在你窗帘的皱褶里，在你松软的枕头里，在你家墙上的油漆里，在你家的自来水管道乃至抽水马桶里。于是，作者拿定主意要在自己的房屋里转转，他要在不出家门的情况下引领我们做一次有关世界历史的美妙远足。在作者的生花妙笔之下，卫生间是一部个人卫生的历史，厨房是一部烹调的历史，卧室则成了一部爱情、死亡和睡觉的历史。作者还梳理了从建筑学到电力学，从考古学到园艺学，从食物贮藏到流行病、从香料贸易到埃菲尔铁塔，从女性时装到室内装潢等方面的演变脉络，撰写了一部包罗万象的人类居家生活简史。作者以饱满的好奇心、绝妙的智慧心，独具一格的叙事腔调将《万物简史》脸炙人口的风格延续至本书的字里行间，成就了这部思想性与趣味性兼具的神奇之书。作者简介👤 比尔·布莱森，享誉世界的作家。1951年出生于美国艾奥瓦州，后定居英国，曾任职于《泰晤士报》与《独立报》，同时也为《纽约时报》、《国家地理杂志》等刊物撰文。2005年，他被任命为英国久负盛名的杜伦大学校长，并且被众多大学授予荣誉学位。2006年12月，为表彰他在文学上的杰出贡献，英国女王伊丽莎白授予他大英帝国官佐勋章（OBE）。布莱森擅长用不同的眼光来看待他所游历的世界，在他的书里，英国式的睿智幽默与美国式的搞笑绝妙地融合在了一起。他的尖刻加上他的博学，让他的文字充满了幽默、机敏和智慧，使他自己成为“目前活在世上的最有趣的旅游文学作家”（《泰晤士报》）。目录第1册前言当你从一个崭新的角度来观察一个你非常熟悉的世界时，你心里总是觉得很兴奋。第一章 | 现代生活的序幕以1851年5月1日在伦敦开幕的“万国工业博览会展览馆”为标志,现代生活的序幕由此拉开,电灯、电话、电报、抽水马桶、麻醉术、室内管道、煤气照明、制冷、汽车、飞机、摩天大楼如雨后春笋般冒出来。突然之间,有史以来第一次,在大多数人的生活当中什么都不缺，到处是一片生机勃勃的景象。戴维·坎那戴恩写到，到世纪之交的时候，“一代精英都不在教堂内而在教堂外”。第二章 | 居家的气息从古罗马人洞穴到普通住宅再到现代豪宅，居家生活的历史就是一部不断追求舒适的历史。你也许会有点吃惊地想到，对于这栋房子或任何其他房子来说，没有哪个部件的出现是必然的。一切都得经过思考——门呀，窗呀，烟囱呀，楼梯呀——其中许多经过了长时间的试验，比你想象的时间还要长得多。在最初99%的历史里，人类没有干多少事，除了繁衍后代，生存下来。从植物中获取食物是一项艰苦的工作。把小麦、稻谷、玉米、大麦和其他草类转变成主食是人类历史上一个伟大的成就，但也是一个意料之外的成就。这一切又使我们想到，我们对古人的生活方式和习惯知道得如此之少，甚至连想象都不敢想象。带着那种想法，我们终于要走进房子，并开始认识到，我们对里面的事情也是知道得如此之少。第三章 | 门厅没有哪间屋子的地位在历史上落得比门厅更靠后。门厅现在是擦鞋底、挂帽子的地方，而曾经却是住宅里最重要的屋子。直到烟囱问世，使得房子一层一层往上发展成了可能，从那之后，人们开始有了隐私和个人空间的概念，而房间的空间拓展正是建立在人们对效用和隐私不断改变的看法之上的。生活很艰难。在整个中世纪，每个人在一生中要把相当多的时间完全用来求生存，饥荒是司空见惯的。中世纪的世界是个没有储备的世界。第四章 | 厨房值得注意的是，维多利亚时代的人的胃口其实还是比较克制的。暴饮暴食的黄金时代，实际上是在18世纪。那是约翰牛时代，是有史以来哪个国家也没有创造出过的面色最红、吃得过多、随时会得冠心病的形象，为的是给别的国家留下个好印象。在18世纪的最初10年里，英国历史上两位最胖的君主花了大量的精力来吃，这也许不是偶然的。这类事情吸引报界的注意力，恰恰说明它们是个别事件，而不是惯常现象。令人感到意外的是，在很长时间里，开罐头仍是个严重的障碍。杰斐逊在食物方面还是个伟大的冒险家。他有许多别的成就，其中，他在美国是把土豆切成长条进行油炸的第一人。无法掌握自己饮食的人也往往确实吃得很差。许多比较穷的人的饮食是相当单调的。第五章 | 洗碟间和食品库在住宅的设计过程中，越来越注意把仆人挡在看不见的地方，与主人家隔开一段距离，除了绝对需要以外。厨房刚够放一张桌子和两把椅子，连在一起的洗碟间和食品库的空间更小，因为很大程度上那里是仆人们的天地。这无疑是个很怪的世界，仆人构成了人类的一个阶级，从根本上说，他们的存在是为了确保人类的另一个阶级在想要什么时，几乎马上就能伸手拿到什么。仆人构成了人类的一个阶级，从根本上说，他们的存在是为了确保人类的另一个阶级在想要什么时，几乎马上就能伸手拿到什么。仆人们做了所有这一切，受到的待遇往往是很可怕的。主人可以摆布仆人，仆人也同样可以摆布主人。第2册第六章 | 保险丝盒我们忘了，在发明电以前，世界上的光线是多么暗淡。一支蜡烛—支好的蜡烛—所提供的照度，勉强相当于一盏100电灯1%的照度。打开你家的冰箱门，里面射出的光比18世纪大多数家庭享有的光的总和还多。在历史的大部分时间里，夜晚的世界确实是个很黑暗的地方。他们开始制造容量为40加仑的专用油桶。直到今天，这种桶仍然是石油的标准计量单位。煤气灯提供极好的总体照明。它使阅读、打牌甚至交谈更加惬意……人们看书看得更多，睡觉睡得更晚。技术进步提高了光的质量，但也增加了火灾的风险。在最初几年里，没有人会想到插头和插座。因此，任何家用电器都必须直接接到系统上。爱迪生的天才并不在于发明了电灯，而在于创造了以商业规模生产和供应电灯的方法。而后者是一项大得多的、更富于挑战性的事业。第七章 | 起居室若要领会舒适的家庭生活的精神，没有哪里比得上个有着奇特名字的地方:起居室(drawing room)这个词是一个古老得多的词 withdrawing room的缩略形式，意思是“一处家人可以离开家里的其他人以享有更多隐私的空间”。这个词根本没有在英语里完全扎根和得到广泛使用，到14世纪中叶，除了在最上流的社会里以外，这个词被sitting room取而代之。第八章 | 餐厅出现餐厅的原因，不是大家突然想要在一个专门的地方吃饭，总的说来是由于家里女主人的一个简单的愿望，她不想让漂亮的装有软垫的新家具沾上油污。我们最近发现，这类家具价钱很贵，得意的主人不愿意看到任何人在上面擦手指。餐厅的到来标志着一种变化，不仅是摆饭地方的变化，而且是吃饭方式和吃饭时间的变化。人体需要维生素和矿物质，这是一门学问，要过相当长的时间才搞明白。即使今天，要是你开始掉头发，或者脚踝肿的厉害，你首先想到的不大可能是最近吃了什么，你更不会想一想你没有吃什么。饮食不当不光是坏血病的原因，也是一系列普通疾病的原因，认识到这一点是个相当缓慢的过程。维生素K跟字母顺序毫无关系。它之所以叫维生素K，是因为发现这种维生素的人、丹麦的亨里克·丹根据它在血液凝结过程中的作用，管它叫”凝血维生素(Koagulations vitamin)“。泛酸和生物素这两种维生素没有数字编号，这很大程度上是因为它们从来没有给我们制造过麻烦。氯化钠是一种很怪的物质，它由两种及其活跃的元素组成：氯、钠。钠和氯是矿物界的地狱天使，然而氯化钠却是一种无毒的食用盐。没有香料死不了人，但为了香料死了好多人。制造商做了实验，增加了齿尖的数量——有时候多大6个——最后在19世纪末确定为4个，因为4个齿尖的叉子人们用起来似乎最自在。过去人们的大部分卡路里都是在早餐时间和中午摄入的，晚餐时间只是补充少量食物，然而现在，那样的摄入方法几乎完全颠倒了过来。第九章 | 地下室原先，地下室主要用作存放煤的地方。今天，里面放着锅炉、不用的衣箱、不合时节的体育器材以及许多贴了封条的纸板箱。那些箱子几乎永远不会再打开，但每次搬家都要小心翼翼地从一栋房子搬到另一栋房子，认为有一天会有人想要一些已经在箱子里放了25年的要儿衣服。它不是个很合意的场所，但也有个补过的优点:让你了解一点房子上层建筑的情况。通过阅读、咨询、凭借灵感进行的实验，他们成功地设计并监督完成了新大陆有史以来最伟大的工程，他们成为历史上第一批通过开掘运河来学会怎么开掘运河的人。第3册第十章 | 过道过道是寓所里最不合意、最阴暗的地方，因为它没有窗户，必须借助从邻近房间开着的门里透进来的任何自然光线。靠近过道中间的地方，有一扇可以关的门——在早先的年代，这门无疑是关着的——把住宅的服务区和对面的私人区分隔开。房子完工的时候，不可能有它。它显然是为了放置在1851年还没有的某种东西才设计的，而那个东西将会改变世界，改变的速度将超出任何人的想象。第十一章 | 书房虽然“书房”这个名字使它听起来像个了不起的地方，但实际上只是个名字好听的贮藏室而已，即使在天气暖和的月份里，里面也是又暗又冷，你都不想在里面久留。如今，书房是旧家具和旧画片的最后避难所—这些东西夫妻的一方十分欢，另一方却乐意看到将其付之一炬。我们现在去那里的理由几乎只有一条，那就是检查一下捕鼠夹。很有可能，历史上爆发的最严重的鼠疫似乎跟大家鼠毫无关系，至少在英国是这样。很少有人喜欢蝙蝠，这确实是很不幸的，因为蝙蝠干的好事要比坏事多得多。世界上的蝙蝠数量，要比大多数人知道的多得多。实际上，全部哺乳动物种类总共大约1100种，其中大约1/4是蝙蝠。从大小方面说，小到熊蜂蝙蝠——名副其实，它们不过熊蜂那么大，因而是最小的哺乳动物，大到澳大利亚和南亚的翼展达6英尺的巨大狐蝠，应有尽有。哪里的事态都有可能变得越来越糟，而且糟得多。第十二章 | 花园对于许多人来说，今天所谓的园艺就是草坪，几乎不指任何别的东西。美国的草坪所占的面积为5万平方英里，超过了任何一种农作物。家庭草坪里的绿草要做的事，和自然界的野草是一样的，那就是长到大约2英尺高，开花，枯黄，死亡。对于我们大多数人来说，养一个漂亮的草坪，几乎是我们所干的最不绿色的事情，这是极具讽刺意味的。任何形式的侵入他人地界，不管多么无辜，多么轻微，势必会被看成是恶意的。对我们大多数人来说，养一个漂亮的草坪，几乎是我们干的最不绿色的事情，这是极具讽刺意味的。第十三章 | 紫色屋把它叫作紫色屋没有别的理由，只因为我们搬进去住的时候，那间屋子的墙壁是漆成那种颜色的。在原先的图纸上，它本来标着“客厅”两个字，但后来在调整的过程中把那个重要房间移到了隔壁。在那次调整中，仆人们没了拟建的“配餐室”，而给了马香先生一间宽敞的餐厅。不管叫什么名字，反正这间屋子是打算用作一种客厅的，很可能是用来接待喜欢的客人。实际情况并不是那样一丝不差的，建筑风格不会仅仅因为一位君主的死去而改变，也不会因为一个朝代很长而保持不变。它是世界的最后一栋房子，它的前面是一块未经探索的大陆，它的背后是整个已知的世界。这栋房子背向那个旧世界，眺望那个空荡荡的未知的新世界。实际上什么东西都得从一个远方的代理商那里订货。什么要求都得说得清清楚楚，但最终你还得依赖一个陌生人的判断力和诚实的服务，让人失望的可能性是很大的。第十四章 | 楼梯现在，我们来到了这栋房子里最危险的部分。实际上，无论在哪里，这都是最可能出现险情的环境之楼梯。谁也不知道楼梯到底有多危险，因为说来也怪，这方面的记录很少。据最保守的统计，在造成偶然死亡的最常见的原因当中，在楼梯上摔倒排在第二位，落在车祸后面，但遥遥领先于溺死、烧死和其他可怕的不幸事故。楼梯的安全问题不是一个而是两个问题：“要避免引发事故的情况出现；要设计这样的楼梯：万一发生事故时，能把伤痛降低到最低程度。”虽然白色在整个19世纪不断地有所改善，但直到20世纪40年代，由于在涂料里添加了氧化钛，才有了真正鲜亮和耐久的白色。……耐久的深黑色颜料是从焦油和沥青中提炼出来的，19世纪末以前还不容易弄得到。现在，我们可以走上楼梯，来到一个房间。它也许从来没有真正毒死过什么人，但它很可能是带来痛苦和绝望的地方。它所带来的痛苦和绝望，要超过家里所有别的房间所带来的痛苦和绝望的总和。第4册第十五章 | 卧室卧室是个古怪的地方，我们在这里待的时间最长，干的事情最少，而且大多数情况下是悄悄地、无意识地干的，家里没有哪个地方能与之相比。然而，生活中许多影响最大、持续最久的不幸之事恰恰发生在卧室里。要是你快要死去或身体不舒服，精疲力竭，性功能不正常，眼泪汪汪，焦虑万分，因情绪低落而不想见人，要不然就心里不大平静和不大高兴，卧室很可能就是能找到你的地方。许多病人没有死在手术台上，却死于一种因感染而更加持久、更加剧烈的痛苦。在现代社会到来之前，即使没有外科医生令人生畏的干预，人也是在以多种方式死亡。第十六章 | 卫生间自从toilet这个词问世以后，它所经历的变化之多，也许是英语里哪个词都比不上的。起初，大约在1540年，它指的是一种布，呈缩略形式toile。现在toile依然用来指一种亚麻织物。然后，它的意思变成了用于梳妆台上的一种布。接着，它的意思变成了梳妆台上的物品。接着，它的意思变成了梳妆台本身，然后变成了穿戴的动作，然后变成了一边穿戴一边接待客人的动作，然后变成了梳妆室，然后变成了靠近卧室的任何隐蔽房间，然后变成了用作厕所的屋子，最后变成了厕所本身。对许多文化来说，讲究清洁和普遍重视个人卫生在很长时间里一直是很重要的，因此很难知道从何谈起。到18世纪，若要洗个澡，最可靠的办法是发神经病。然后，人家会用水把你浇个够。在不讲卫生、没有抗生素的世界里，造成大批人死亡的传染病是经常发生的。在19世纪，各种各样的情况都会让人送了性命。第十七章 | 梳妆室对于任何有理性的人来说，时尚往往是一件几乎无法捉摸的事。在许多历史时期——也许在大多数历史时期——时尚的全部推动力看起来似乎一直是可笑至极的。要是同时还能觉得不舒服至极，那就是更大的成功了。穿着不实用的衣服，是一种表明某人不必干体力活的方式。在整个历史上，在许多文化里，这一般都要比穿着舒服重要得多。穿着不实用的衣服，是一种表明某人不必干体力活的方式。詹妮纺纱机不是像常说的那样是以他女儿的名字命名的，“詹妮”是个北方用于，意思是“机械”。阿克莱特是工业革命早期所有人物中最没有意思、最没有创造能力的人，却又是最成功的人。历史上也许还从来没有哪个人，能像发明轧棉机的伊莱·惠妮特那样，以一项简单、善意的发明产生如此普遍的繁荣、个人的失望，并在无意中给许多人带来苦难。胸罩(brassiere)一词源于法语，意思是“上臂”，由查尔斯·R·德伯瓦公司首次使用。第十八章 | 幼儿房在现代社会之前，儿童不但不受重视，而且实际上还不大讨人喜欢。把爱投资在小孩子身上是如此危险，如此不划算——无论在哪里，爱是不能给的，都把它看成是毫无意义地浪费精力。感情压根儿谈不上。按照她令人寒心的看法，孩子只是“一种产品”而已。事实上，从怀胎十月起，生命里充满了危险。对母婴双方来说，最危险的关口是分娩本身。对孩子来说，出生仅仅是开始。早在1847年，维也纳有一位名叫伊格纳茨·泽梅尔魏斯的医生已经意识到，只要医院的工作人员在稍稍加氯的水里洗洗手，各种死亡便会大幅度下降，但对他的话几乎谁也不加理会。还要再过几十年，才会普遍采取消毒措施。据报道，有的孩子累得连吃饭的力气都没有，有时候嘴里还含着食物就睡着了。第十九章 | 阁楼我们的故事是从这个阁楼讲起的，现在，我们重新来到这个位于房屋顶部的地方，我们的这次足不出户探寻人类居家生活历程的美妙远足，到这里也就将画上一个圆满的句号，有朝一日—别以为这是遥远的一天——在60亿左右不大富裕的人当中，许多人势必会要求拥有我们今天拥有的东西，而且要像我们容易得到那样容易得到它们。那就意味着要求这颗星球能方便地甚至大方地给予更多的资源。最具讽刺意味的可能是，如果为了过得舒适和快乐而无休止地索取，我们会制造出一个既不舒适又无快乐可言的世界。在这一切变化中，具有讽刺意味的是，正当世界对大多数人来说变得更加惬意，如灯光更加明亮、管子更加可靠、休闲机会更多、需求得到更大程度的满足、娱乐活动更加丰富时,对马香先生这样的人来说,世界正在分崩离析。最具讽刺意味的可能是，如果为了过得舒适和快乐而无休止地索取，我们会制造出一个既不舒适又无快乐可言的世界。感悟以前的生活条件是如此的艰苦，人们又是如此的愚蠢，可是人类还是走到了现在，而且越来越好。这是多么得不容易，要学会珍惜，要学会谦虚，难保后来的人们不会像看傻子一样看着你。这本书共计4册，可以当做睡前读物随手翻翻，偶尔还刷新之前在历史课本上看到的故事。讲真，以前皇帝或贵族过得生活肯定没有现在那么方便、那么舒服，历史在不断进步，未来虽然曲折，总会向着好的方面发展。要心怀希望，冲呀！！！🐷]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>趣味生活简史</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[体重记录]]></title>
    <url>%2Fposts%2Fe93199a0%2F</url>
    <content type="text"><![CDATA[var myChart=echarts.init(document.getElementById("echarts3889")),option={tooltip:{trigger:"axis"},title:{show:!0,text:"日常体重记录"},legend:{data:["体重"]},toolbox:{show:!0,orient:"horizontal",x:"right",y:"top",color:["#1e90ff","#22bb22","#4b0082","#d2691e"],backgroundColor:"rgba(0,0,0,0)",borderColor:"#ccc",borderWidth:0,padding:5,showTitle:!0,feature:{mark:{show:!0,title:{mark:"辅助线-开关",markUndo:"辅助线-删除",markClear:"辅助线-清空"},lineStyle:{width:1,color:"#1e90ff",type:"dashed"}},dataZoom:{show:!0,title:{dataZoom:"区域缩放",dataZoomReset:"区域缩放-后退"}},magicType:{show:!0,title:{line:"动态类型切换-折线图",bar:"动态类型切换-柱形图",stack:"动态类型切换-堆积",tiled:"动态类型切换-平铺"},type:["line","bar","stack","tiled"]},restore:{show:!0,title:"还原",color:"black"},saveAsImage:{show:!0,title:"保存为图片",type:"jpeg",lang:["点击本地保存"]},myTool:{show:!0,title:"自定义扩展方法",icon:"image://../asset/ico/favicon.png",onclick:function(){alert("myToolHandler")}}}},calculable:!0,dataZoom:{show:!0,realtime:!0,start:20,end:80},xAxis:{type:"category",boundaryGap:!1},yAxis:{type:"value",min:60,axisLabel:{formatter:"{value} (kg)"}},series:[{name:"体重",type:"line",data:[{name:"2019-02-10",value:["2019-02-10",65]},{name:"2019-03-10",value:["2019-03-10",67.5]},{name:"2019-03-23",value:["2019-03-23",68.75]},{name:"2019-03-24",value:["2019-03-24",68.25]},{name:"2019-03-30",value:["2019-03-30",69.35]},{name:"2019-04-01",value:["2019-04-01",67.8]},{name:"2019-04-02",value:["2019-04-02",67.3]},{name:"2019-04-07",value:["2019-04-07",67.9]},{name:"2019-04-09",value:["2019-04-09",68.9]},{name:"2019-04-11",value:["2019-04-11",69.05]},{name:"2019-04-12",value:["2019-04-12",68.3]},{name:"2019-04-14",value:["2019-04-14",67.2]},{name:"2019-04-15",value:["2019-04-15",69.25]},{name:"2019-04-18",value:["2019-04-18",68.35]},{name:"2019-04-22",value:["2019-04-22",68.4]},{name:"2019-04-23",value:["2019-04-23",67.75]},{name:"2019-04-24",value:["2019-04-24",68.45]},{name:"2019-04-26",value:["2019-04-26",67.5]},{name:"2019-04-27",value:["2019-04-27",67.6]},{name:"2019-04-28",value:["2019-04-28",67.65]},{name:"2019-04-29",value:["2019-04-29",67.1]},{name:"2019-04-30",value:["2019-04-30",66.75]},{name:"2019-05-02",value:["2019-05-02",68.5]},{name:"2019-05-04",value:["2019-05-04",66.4]},{name:"2019-05-07",value:["2019-05-07",68.3]},{name:"2019-05-08",value:["2019-05-08",67.7]},{name:"2019-05-09",value:["2019-05-09",67.35]},{name:"2019-05-11",value:["2019-05-11",66.6]},{name:"2019-05-12",value:["2019-05-12",67.4]},{name:"2019-05-13",value:["2019-05-13",66.95]},{name:"2019-05-14",value:["2019-05-14",67.55]},{name:"2019-05-16",value:["2019-05-16",67]},{name:"2019-05-18",value:["2019-05-18",68.4]},{name:"2019-05-19",value:["2019-05-19",66.4]},{name:"2019-05-20",value:["2019-05-20",67.4]},{name:"2019-05-21",value:["2019-05-21",66.8]},{name:"2019-05-22",value:["2019-05-22",67.65]},{name:"2019-05-23",value:["2019-05-23",67.4]},{name:"2019-05-24",value:["2019-05-24",67.5]},{name:"2019-05-25",value:["2019-05-25",67.4]},{name:"2019-05-26",value:["2019-05-26",67.4]},{name:"2019-05-27",value:["2019-05-27",67.3]},{name:"2019-05-28",value:["2019-05-28",67.4]},{name:"2019-05-30",value:["2019-05-30",65.95]},{name:"2019-06-02",value:["2019-06-02",66.95]},{name:"2019-06-03",value:["2019-06-03",67]},{name:"2019-06-04",value:["2019-06-04",67.5]},{name:"2019-06-05",value:["2019-06-05",68.35]},{name:"2019-06-06",value:["2019-06-06",67.6]},{name:"2019-06-07",value:["2019-06-07",67.9]},{name:"2019-06-09",value:["2019-06-09",67.55]},{name:"2019-06-11",value:["2019-06-11",67.25]},{name:"2019-06-13",value:["2019-06-13",67.6]},{name:"2019-06-14",value:["2019-06-14",67.25]},{name:"2019-06-15",value:["2019-06-15",66.7]},{name:"2019-06-16",value:["2019-06-16",66.15]},{name:"2019-06-18",value:["2019-06-18",67.5]},{name:"2019-06-19",value:["2019-06-19",65.55]},{name:"2019-06-22",value:["2019-06-22",67.5]},{name:"2019-06-23",value:["2019-06-23",66.8]},{name:"2019-06-26",value:["2019-06-26",67.55]},{name:"2019-06-28",value:["2019-06-28",66.75]},{name:"2019-06-29",value:["2019-06-29",66.2]},{name:"2019-07-03",value:["2019-07-03",68.45]},{name:"2019-07-05",value:["2019-07-05",68.35]},{name:"2019-07-07",value:["2019-07-07",67.75]},{name:"2019-07-08",value:["2019-07-08",69.2]},{name:"2019-07-10",value:["2019-07-10",68.75]},{name:"2019-07-11",value:["2019-07-11",68.15]},{name:"2019-07-13",value:["2019-07-13",67.95]},{name:"2019-07-15",value:["2019-07-15",62.3]},{name:"2019-07-16",value:["2019-07-16",68.05]},{name:"2019-07-17",value:["2019-07-17",67.35]},{name:"2019-07-18",value:["2019-07-18",67]},{name:"2019-07-19",value:["2019-07-19",62.35]},{name:"2019-07-21",value:["2019-07-21",66.95]},{name:"2019-07-22",value:["2019-07-22",66.65]},{name:"2019-07-24",value:["2019-07-24",68.45]},{name:"2019-07-25",value:["2019-07-25",67.8]},{name:"2019-07-26",value:["2019-07-26",67.2]},{name:"2019-07-27",value:["2019-07-27",67.35]},{name:"2019-07-29",value:["2019-07-29",67.8]},{name:"2019-07-31",value:["2019-07-31",66.85]},{name:"2019-08-04",value:["2019-08-04",66.95]},{name:"2019-08-06",value:["2019-08-06",67.8]},{name:"2019-08-08",value:["2019-08-08",68.5]},{name:"2019-08-18",value:["2019-08-18",68.35]},{name:"2019-08-21",value:["2019-08-21",67.2]},{name:"2019-08-24",value:["2019-08-24",66.35]},{name:"2019-09-04",value:["2019-09-04",67.3]}]}]};myChart.setOption(option)]]></content>
      <categories>
        <category>日常生活</category>
      </categories>
      <tags>
        <tag>体重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新记录]]></title>
    <url>%2Fposts%2F77b56474%2F</url>
    <content type="text"><![CDATA[时间更新说明2019-07-13内容补充：更新记录2019-07-13功能添加：点击效果2019-07-05功能优化：博客链接2019-07-03内容补充：关于我2019-07-02功能添加：网站运行时间2019-07-01功能添加：文字统计、阅读时间统计2019-06-25功能添加：Hexo博客初始化。]]></content>
      <categories>
        <category>Muhouer&#39;s blog</category>
      </categories>
      <tags>
        <tag>更新记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客SEO优化之链接优化]]></title>
    <url>%2Fposts%2Fa8db5a9b%2F</url>
    <content type="text"><![CDATA[写在前面默认的permalinkpermalink: :year/:month/:day/:title/缺点如下命名方式层次过多，爬虫会嫌麻烦。对于中文命名，如果要引用自己的链接，会重新编码成好长一串，超级麻烦。中文链接在百度Google权重很低。解决办法有没有其他办法呢？实在想不出来了，还是因为我比较懒，喜欢现成的。皇天不负有心人，通过一番搜索，终于找到一个插件hexo-abbrlink。注意之前如果有做评论或访问计数配置的，会全部失效,一切重头开始。hexo-abbrlink实现思路对标题+时间进行md5然后再转base64，保存在front-matter中。如何安装添加插件到hexo:1npm install hexo-abbrlink --save修改config.yml文件中的永久链接：1permalink: posts/:abbrlink/ # “posts/” 可自行更换两种设置：alg - 算法（）rep - Represent（生成的链接可以以十六进制或十六进制值表示）1234# abbrlink configabbrlink: alg: crc32 # 算法(Algorithm):目前支持crc16和crc32，默认为crc16 rep: hex # 表示(Represent):生成的链接可以以十六进制或十进制值表示，默认十进制示例生成的链接如下所示:12345crc16 &amp; hexhttps://post.zz173.com/posts/66c8.htmlcrc16 &amp; dechttps://post.zz173.com/posts/65535.html12345crc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://post.zz173.com/posts/1690090958.html局限性crc16的最大帖子数为65535。(对于个人博客网站，这个数字还算不错)更多信息hexo-abbrlink介绍参考资料https://github.com/Rozbo/hexo-abbrlink#limitation]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>SEO优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub搭建一个自己的hexo博客]]></title>
    <url>%2Fposts%2F9fe43db6%2F</url>
    <content type="text"><![CDATA[写在前面一直想搭建一个个人博客，无奈有拖延症，一直拖到现在。为什么开始做了呢？最近压力很大，为了防止乱花钱，给自己找点事做。于是，兜兜转转又回到搭建博客的事，来来回回看了很多静态博客(纠结症)，比如docsify、VuePress等等，最终还是选择了hexo，毕竟这也算是我静态博客的启蒙，不能忘本，第一个系列当然给Hexo.本地部署过程环境关于node、npm、git等的安装，在这里先不展开，以后抽空补上。安装 hexo 客户端1npm install -g hexo-cli创建hexo的文件夹(文件夹名称hexo可修改为其他)12cd hexo # hexo 改为自己命名的文件夹名称hexo init # hexo 初始化选择主题hexo本身自带 landscape 主题，不过个人觉得比较丑，改为了比较简约的next 主题。接下来主题均基于next主题下载主题1git clone https://github.com/iissnan/hexo-theme-next修改 theme编辑 hexo/_config.yml，找到 theme 那一行配置，修改为 next本地启动看看安装完之后，我们可以在本地启动看看博客初始化的效果。生成静态文件1hexo ghexo 最终运行的是静态文件，包括js，css和html等，这些文件统一放在 public 文件夹。安装 hexo-server1npm install hexo-server --save启动 server1hexo s在浏览器打开 localhost:4000，会看到一个 Hello World的页面。恭喜你，部署成功。添加“分类”，“关于”和“标签”菜单到此已经把博客安装好了，不过要想看起来更好点，还需要做些其他配置。取消 tags、about、categories 注释在主题配置文件next/_config.yml 在menu下去掉tags、about、categories 注释。创建 tags，about，categories在 hexo 文件夹下执行以下shell命令1hexo new page tags会在 source 文件夹生成 tags 文件夹，编辑里面的 index.md ，添加12type: &quot;tags&quot;comments: false安装同样操作即可添加 categories；添加about相对简单，不需要修改 md 文件的 type，因为tags、categories是特殊目录类型，about只是简单的一个 md。为文章添加标签和分类在文章 md 文件开头 title 的下面，增加类似，就可以归类到tag和 category123456789101112131415tags: #文章标签可，空，多标签请用格式[tag1,tag2,tag3]，如下，注意!!&quot;tags:&quot;后面有个空格tags: [tag1, tag2, tag3, ...]# 下面这种方式似乎仅限于hexo 3.0，应该包括以上吧...tags: - tags1- tags2- ...# 这种方式似乎仅限于hexo 3.0，应该包括以上吧...categories: - tags_level_1- tags_level_2- tags_level_3- ...添加头像图片在 hexo/_config.yml 找到配置 avatar，增加图片路径，注意图片类型要对的上。1avatar: /images/avatar.jpeg新建文章1hexo new post new1就会在 source/_post 文件夹下生成 new1.md 文件，编辑 md 文件即可。这里为什么是 post ？这里涉及 hexo 的模版行为，在 scaffolds 目录下初始定义了3个模板，draft、page、post，文章就是用到了 post。部署到Github本地服务起来之后，基本信息无误，可以先尝试部署到 GitHub 上，之后再慢慢迭代，总会变得更好！github上新建一个仓库登录github后，在界面右上角用户信息点击左边的加号，新建一个repository然后给新建的仓库起个名字，注意：这个名字必须跟用户名一致，github才会默认设置成用户的博客。必须选择public，否则即便部署完成访问也会404。将本地搭建好的hexo发布到github下面是在项目中生成静态文件的命令：1$ hexo generate简写，结果是一样的1$ hexo g执行完以上代码，会在项目的根目录下生成public文件夹安装插件1npm install hexo-deployer-git --save修改网站配置文件_config.yml,添加deploy信息1234deploy: type: git repo: git@github.com:muhouer/muhouer.github.io.git branch: master上面的repo的配置信息，替换成自己的项目名字设置SSH Keys先检查机器上是否已经存在id_rsa.pub文件1$ ls -al ~/.ssh不存在的话执行以下命令生成，一路回车即可。1$ ssh-keygen -t rsa -C &quot;xxxxxx@xxx.com&quot; # 改成自己的邮箱复制id_rsa.pub文件内容，在GitHub的 settings 中，点选 SSH keys，添加一个 key，将内容粘贴进去。测试是否添加成功，在刚刚的机器上输入，配置成功会有类似如下提示，至此本地跟远程github的连接已经建立1ssh -T git@github.com在项目中，直接生成静态文件，上传就可以了：123$ hexo clean //清除缓存文件db.json和已生成的静态文件public$ hexo g //生成网站静态文件到默认设置的public文件夹$ hexo d //部署网站到设定的仓库部署完成之后，访问 https://muhouer.github.io/ ,改成你自己的地址即可访问。小结以上就是在GitHub上搭建一个自己的hexo博客的大致过程，目前还是比较简单，接下来几篇将会记录一下next主题的相关配置以及文章美化方面的内容，以防记性不好，最近老是健忘。参考资料http://durant35.github.io/2016/07/16/hexo_hexo%E5%88%86%E7%BA%A7%E7%9B%AE%E5%BD%95%E4%B8%8E%E5%A4%9A%E6%A0%87%E7%AD%BE/https://github.com/hexojs/hexohttps://albenw.github.io/posts/3454819c/https://segmentfault.com/a/1190000018250408?utm_source=tag-newesthttps://www.cnblogs.com/kex1n/p/5229493.html]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
  </entry>
</search>
